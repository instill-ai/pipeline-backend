// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/api/drive/v3"
)

// IDriveServiceMock implements mm_client.IDriveService
type IDriveServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcReadFile          func(fileUID string) (fp1 *drive.File, sp1 *string, err error)
	funcReadFileOrigin    string
	inspectFuncReadFile   func(fileUID string)
	afterReadFileCounter  uint64
	beforeReadFileCounter uint64
	ReadFileMock          mIDriveServiceMockReadFile

	funcReadFolder          func(folderUID string, readContent bool) (fpa1 []*drive.File, spa1 []*string, err error)
	funcReadFolderOrigin    string
	inspectFuncReadFolder   func(folderUID string, readContent bool)
	afterReadFolderCounter  uint64
	beforeReadFolderCounter uint64
	ReadFolderMock          mIDriveServiceMockReadFolder
}

// NewIDriveServiceMock returns a mock for mm_client.IDriveService
func NewIDriveServiceMock(t minimock.Tester) *IDriveServiceMock {
	m := &IDriveServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ReadFileMock = mIDriveServiceMockReadFile{mock: m}
	m.ReadFileMock.callArgs = []*IDriveServiceMockReadFileParams{}

	m.ReadFolderMock = mIDriveServiceMockReadFolder{mock: m}
	m.ReadFolderMock.callArgs = []*IDriveServiceMockReadFolderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIDriveServiceMockReadFile struct {
	optional           bool
	mock               *IDriveServiceMock
	defaultExpectation *IDriveServiceMockReadFileExpectation
	expectations       []*IDriveServiceMockReadFileExpectation

	callArgs []*IDriveServiceMockReadFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IDriveServiceMockReadFileExpectation specifies expectation struct of the IDriveService.ReadFile
type IDriveServiceMockReadFileExpectation struct {
	mock               *IDriveServiceMock
	params             *IDriveServiceMockReadFileParams
	paramPtrs          *IDriveServiceMockReadFileParamPtrs
	expectationOrigins IDriveServiceMockReadFileExpectationOrigins
	results            *IDriveServiceMockReadFileResults
	returnOrigin       string
	Counter            uint64
}

// IDriveServiceMockReadFileParams contains parameters of the IDriveService.ReadFile
type IDriveServiceMockReadFileParams struct {
	fileUID string
}

// IDriveServiceMockReadFileParamPtrs contains pointers to parameters of the IDriveService.ReadFile
type IDriveServiceMockReadFileParamPtrs struct {
	fileUID *string
}

// IDriveServiceMockReadFileResults contains results of the IDriveService.ReadFile
type IDriveServiceMockReadFileResults struct {
	fp1 *drive.File
	sp1 *string
	err error
}

// IDriveServiceMockReadFileOrigins contains origins of expectations of the IDriveService.ReadFile
type IDriveServiceMockReadFileExpectationOrigins struct {
	origin        string
	originFileUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadFile *mIDriveServiceMockReadFile) Optional() *mIDriveServiceMockReadFile {
	mmReadFile.optional = true
	return mmReadFile
}

// Expect sets up expected params for IDriveService.ReadFile
func (mmReadFile *mIDriveServiceMockReadFile) Expect(fileUID string) *mIDriveServiceMockReadFile {
	if mmReadFile.mock.funcReadFile != nil {
		mmReadFile.mock.t.Fatalf("IDriveServiceMock.ReadFile mock is already set by Set")
	}

	if mmReadFile.defaultExpectation == nil {
		mmReadFile.defaultExpectation = &IDriveServiceMockReadFileExpectation{}
	}

	if mmReadFile.defaultExpectation.paramPtrs != nil {
		mmReadFile.mock.t.Fatalf("IDriveServiceMock.ReadFile mock is already set by ExpectParams functions")
	}

	mmReadFile.defaultExpectation.params = &IDriveServiceMockReadFileParams{fileUID}
	mmReadFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadFile.expectations {
		if minimock.Equal(e.params, mmReadFile.defaultExpectation.params) {
			mmReadFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadFile.defaultExpectation.params)
		}
	}

	return mmReadFile
}

// ExpectFileUIDParam1 sets up expected param fileUID for IDriveService.ReadFile
func (mmReadFile *mIDriveServiceMockReadFile) ExpectFileUIDParam1(fileUID string) *mIDriveServiceMockReadFile {
	if mmReadFile.mock.funcReadFile != nil {
		mmReadFile.mock.t.Fatalf("IDriveServiceMock.ReadFile mock is already set by Set")
	}

	if mmReadFile.defaultExpectation == nil {
		mmReadFile.defaultExpectation = &IDriveServiceMockReadFileExpectation{}
	}

	if mmReadFile.defaultExpectation.params != nil {
		mmReadFile.mock.t.Fatalf("IDriveServiceMock.ReadFile mock is already set by Expect")
	}

	if mmReadFile.defaultExpectation.paramPtrs == nil {
		mmReadFile.defaultExpectation.paramPtrs = &IDriveServiceMockReadFileParamPtrs{}
	}
	mmReadFile.defaultExpectation.paramPtrs.fileUID = &fileUID
	mmReadFile.defaultExpectation.expectationOrigins.originFileUID = minimock.CallerInfo(1)

	return mmReadFile
}

// Inspect accepts an inspector function that has same arguments as the IDriveService.ReadFile
func (mmReadFile *mIDriveServiceMockReadFile) Inspect(f func(fileUID string)) *mIDriveServiceMockReadFile {
	if mmReadFile.mock.inspectFuncReadFile != nil {
		mmReadFile.mock.t.Fatalf("Inspect function is already set for IDriveServiceMock.ReadFile")
	}

	mmReadFile.mock.inspectFuncReadFile = f

	return mmReadFile
}

// Return sets up results that will be returned by IDriveService.ReadFile
func (mmReadFile *mIDriveServiceMockReadFile) Return(fp1 *drive.File, sp1 *string, err error) *IDriveServiceMock {
	if mmReadFile.mock.funcReadFile != nil {
		mmReadFile.mock.t.Fatalf("IDriveServiceMock.ReadFile mock is already set by Set")
	}

	if mmReadFile.defaultExpectation == nil {
		mmReadFile.defaultExpectation = &IDriveServiceMockReadFileExpectation{mock: mmReadFile.mock}
	}
	mmReadFile.defaultExpectation.results = &IDriveServiceMockReadFileResults{fp1, sp1, err}
	mmReadFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadFile.mock
}

// Set uses given function f to mock the IDriveService.ReadFile method
func (mmReadFile *mIDriveServiceMockReadFile) Set(f func(fileUID string) (fp1 *drive.File, sp1 *string, err error)) *IDriveServiceMock {
	if mmReadFile.defaultExpectation != nil {
		mmReadFile.mock.t.Fatalf("Default expectation is already set for the IDriveService.ReadFile method")
	}

	if len(mmReadFile.expectations) > 0 {
		mmReadFile.mock.t.Fatalf("Some expectations are already set for the IDriveService.ReadFile method")
	}

	mmReadFile.mock.funcReadFile = f
	mmReadFile.mock.funcReadFileOrigin = minimock.CallerInfo(1)
	return mmReadFile.mock
}

// When sets expectation for the IDriveService.ReadFile which will trigger the result defined by the following
// Then helper
func (mmReadFile *mIDriveServiceMockReadFile) When(fileUID string) *IDriveServiceMockReadFileExpectation {
	if mmReadFile.mock.funcReadFile != nil {
		mmReadFile.mock.t.Fatalf("IDriveServiceMock.ReadFile mock is already set by Set")
	}

	expectation := &IDriveServiceMockReadFileExpectation{
		mock:               mmReadFile.mock,
		params:             &IDriveServiceMockReadFileParams{fileUID},
		expectationOrigins: IDriveServiceMockReadFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadFile.expectations = append(mmReadFile.expectations, expectation)
	return expectation
}

// Then sets up IDriveService.ReadFile return parameters for the expectation previously defined by the When method
func (e *IDriveServiceMockReadFileExpectation) Then(fp1 *drive.File, sp1 *string, err error) *IDriveServiceMock {
	e.results = &IDriveServiceMockReadFileResults{fp1, sp1, err}
	return e.mock
}

// Times sets number of times IDriveService.ReadFile should be invoked
func (mmReadFile *mIDriveServiceMockReadFile) Times(n uint64) *mIDriveServiceMockReadFile {
	if n == 0 {
		mmReadFile.mock.t.Fatalf("Times of IDriveServiceMock.ReadFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadFile.expectedInvocations, n)
	mmReadFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadFile
}

func (mmReadFile *mIDriveServiceMockReadFile) invocationsDone() bool {
	if len(mmReadFile.expectations) == 0 && mmReadFile.defaultExpectation == nil && mmReadFile.mock.funcReadFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadFile.mock.afterReadFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadFile implements mm_client.IDriveService
func (mmReadFile *IDriveServiceMock) ReadFile(fileUID string) (fp1 *drive.File, sp1 *string, err error) {
	mm_atomic.AddUint64(&mmReadFile.beforeReadFileCounter, 1)
	defer mm_atomic.AddUint64(&mmReadFile.afterReadFileCounter, 1)

	mmReadFile.t.Helper()

	if mmReadFile.inspectFuncReadFile != nil {
		mmReadFile.inspectFuncReadFile(fileUID)
	}

	mm_params := IDriveServiceMockReadFileParams{fileUID}

	// Record call args
	mmReadFile.ReadFileMock.mutex.Lock()
	mmReadFile.ReadFileMock.callArgs = append(mmReadFile.ReadFileMock.callArgs, &mm_params)
	mmReadFile.ReadFileMock.mutex.Unlock()

	for _, e := range mmReadFile.ReadFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fp1, e.results.sp1, e.results.err
		}
	}

	if mmReadFile.ReadFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadFile.ReadFileMock.defaultExpectation.Counter, 1)
		mm_want := mmReadFile.ReadFileMock.defaultExpectation.params
		mm_want_ptrs := mmReadFile.ReadFileMock.defaultExpectation.paramPtrs

		mm_got := IDriveServiceMockReadFileParams{fileUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fileUID != nil && !minimock.Equal(*mm_want_ptrs.fileUID, mm_got.fileUID) {
				mmReadFile.t.Errorf("IDriveServiceMock.ReadFile got unexpected parameter fileUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadFile.ReadFileMock.defaultExpectation.expectationOrigins.originFileUID, *mm_want_ptrs.fileUID, mm_got.fileUID, minimock.Diff(*mm_want_ptrs.fileUID, mm_got.fileUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadFile.t.Errorf("IDriveServiceMock.ReadFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadFile.ReadFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadFile.ReadFileMock.defaultExpectation.results
		if mm_results == nil {
			mmReadFile.t.Fatal("No results are set for the IDriveServiceMock.ReadFile")
		}
		return (*mm_results).fp1, (*mm_results).sp1, (*mm_results).err
	}
	if mmReadFile.funcReadFile != nil {
		return mmReadFile.funcReadFile(fileUID)
	}
	mmReadFile.t.Fatalf("Unexpected call to IDriveServiceMock.ReadFile. %v", fileUID)
	return
}

// ReadFileAfterCounter returns a count of finished IDriveServiceMock.ReadFile invocations
func (mmReadFile *IDriveServiceMock) ReadFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFile.afterReadFileCounter)
}

// ReadFileBeforeCounter returns a count of IDriveServiceMock.ReadFile invocations
func (mmReadFile *IDriveServiceMock) ReadFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFile.beforeReadFileCounter)
}

// Calls returns a list of arguments used in each call to IDriveServiceMock.ReadFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadFile *mIDriveServiceMockReadFile) Calls() []*IDriveServiceMockReadFileParams {
	mmReadFile.mutex.RLock()

	argCopy := make([]*IDriveServiceMockReadFileParams, len(mmReadFile.callArgs))
	copy(argCopy, mmReadFile.callArgs)

	mmReadFile.mutex.RUnlock()

	return argCopy
}

// MinimockReadFileDone returns true if the count of the ReadFile invocations corresponds
// the number of defined expectations
func (m *IDriveServiceMock) MinimockReadFileDone() bool {
	if m.ReadFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadFileMock.invocationsDone()
}

// MinimockReadFileInspect logs each unmet expectation
func (m *IDriveServiceMock) MinimockReadFileInspect() {
	for _, e := range m.ReadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDriveServiceMock.ReadFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadFileCounter := mm_atomic.LoadUint64(&m.afterReadFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadFileMock.defaultExpectation != nil && afterReadFileCounter < 1 {
		if m.ReadFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IDriveServiceMock.ReadFile at\n%s", m.ReadFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IDriveServiceMock.ReadFile at\n%s with params: %#v", m.ReadFileMock.defaultExpectation.expectationOrigins.origin, *m.ReadFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadFile != nil && afterReadFileCounter < 1 {
		m.t.Errorf("Expected call to IDriveServiceMock.ReadFile at\n%s", m.funcReadFileOrigin)
	}

	if !m.ReadFileMock.invocationsDone() && afterReadFileCounter > 0 {
		m.t.Errorf("Expected %d calls to IDriveServiceMock.ReadFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadFileMock.expectedInvocations), m.ReadFileMock.expectedInvocationsOrigin, afterReadFileCounter)
	}
}

type mIDriveServiceMockReadFolder struct {
	optional           bool
	mock               *IDriveServiceMock
	defaultExpectation *IDriveServiceMockReadFolderExpectation
	expectations       []*IDriveServiceMockReadFolderExpectation

	callArgs []*IDriveServiceMockReadFolderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IDriveServiceMockReadFolderExpectation specifies expectation struct of the IDriveService.ReadFolder
type IDriveServiceMockReadFolderExpectation struct {
	mock               *IDriveServiceMock
	params             *IDriveServiceMockReadFolderParams
	paramPtrs          *IDriveServiceMockReadFolderParamPtrs
	expectationOrigins IDriveServiceMockReadFolderExpectationOrigins
	results            *IDriveServiceMockReadFolderResults
	returnOrigin       string
	Counter            uint64
}

// IDriveServiceMockReadFolderParams contains parameters of the IDriveService.ReadFolder
type IDriveServiceMockReadFolderParams struct {
	folderUID   string
	readContent bool
}

// IDriveServiceMockReadFolderParamPtrs contains pointers to parameters of the IDriveService.ReadFolder
type IDriveServiceMockReadFolderParamPtrs struct {
	folderUID   *string
	readContent *bool
}

// IDriveServiceMockReadFolderResults contains results of the IDriveService.ReadFolder
type IDriveServiceMockReadFolderResults struct {
	fpa1 []*drive.File
	spa1 []*string
	err  error
}

// IDriveServiceMockReadFolderOrigins contains origins of expectations of the IDriveService.ReadFolder
type IDriveServiceMockReadFolderExpectationOrigins struct {
	origin            string
	originFolderUID   string
	originReadContent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadFolder *mIDriveServiceMockReadFolder) Optional() *mIDriveServiceMockReadFolder {
	mmReadFolder.optional = true
	return mmReadFolder
}

// Expect sets up expected params for IDriveService.ReadFolder
func (mmReadFolder *mIDriveServiceMockReadFolder) Expect(folderUID string, readContent bool) *mIDriveServiceMockReadFolder {
	if mmReadFolder.mock.funcReadFolder != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by Set")
	}

	if mmReadFolder.defaultExpectation == nil {
		mmReadFolder.defaultExpectation = &IDriveServiceMockReadFolderExpectation{}
	}

	if mmReadFolder.defaultExpectation.paramPtrs != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by ExpectParams functions")
	}

	mmReadFolder.defaultExpectation.params = &IDriveServiceMockReadFolderParams{folderUID, readContent}
	mmReadFolder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadFolder.expectations {
		if minimock.Equal(e.params, mmReadFolder.defaultExpectation.params) {
			mmReadFolder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadFolder.defaultExpectation.params)
		}
	}

	return mmReadFolder
}

// ExpectFolderUIDParam1 sets up expected param folderUID for IDriveService.ReadFolder
func (mmReadFolder *mIDriveServiceMockReadFolder) ExpectFolderUIDParam1(folderUID string) *mIDriveServiceMockReadFolder {
	if mmReadFolder.mock.funcReadFolder != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by Set")
	}

	if mmReadFolder.defaultExpectation == nil {
		mmReadFolder.defaultExpectation = &IDriveServiceMockReadFolderExpectation{}
	}

	if mmReadFolder.defaultExpectation.params != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by Expect")
	}

	if mmReadFolder.defaultExpectation.paramPtrs == nil {
		mmReadFolder.defaultExpectation.paramPtrs = &IDriveServiceMockReadFolderParamPtrs{}
	}
	mmReadFolder.defaultExpectation.paramPtrs.folderUID = &folderUID
	mmReadFolder.defaultExpectation.expectationOrigins.originFolderUID = minimock.CallerInfo(1)

	return mmReadFolder
}

// ExpectReadContentParam2 sets up expected param readContent for IDriveService.ReadFolder
func (mmReadFolder *mIDriveServiceMockReadFolder) ExpectReadContentParam2(readContent bool) *mIDriveServiceMockReadFolder {
	if mmReadFolder.mock.funcReadFolder != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by Set")
	}

	if mmReadFolder.defaultExpectation == nil {
		mmReadFolder.defaultExpectation = &IDriveServiceMockReadFolderExpectation{}
	}

	if mmReadFolder.defaultExpectation.params != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by Expect")
	}

	if mmReadFolder.defaultExpectation.paramPtrs == nil {
		mmReadFolder.defaultExpectation.paramPtrs = &IDriveServiceMockReadFolderParamPtrs{}
	}
	mmReadFolder.defaultExpectation.paramPtrs.readContent = &readContent
	mmReadFolder.defaultExpectation.expectationOrigins.originReadContent = minimock.CallerInfo(1)

	return mmReadFolder
}

// Inspect accepts an inspector function that has same arguments as the IDriveService.ReadFolder
func (mmReadFolder *mIDriveServiceMockReadFolder) Inspect(f func(folderUID string, readContent bool)) *mIDriveServiceMockReadFolder {
	if mmReadFolder.mock.inspectFuncReadFolder != nil {
		mmReadFolder.mock.t.Fatalf("Inspect function is already set for IDriveServiceMock.ReadFolder")
	}

	mmReadFolder.mock.inspectFuncReadFolder = f

	return mmReadFolder
}

// Return sets up results that will be returned by IDriveService.ReadFolder
func (mmReadFolder *mIDriveServiceMockReadFolder) Return(fpa1 []*drive.File, spa1 []*string, err error) *IDriveServiceMock {
	if mmReadFolder.mock.funcReadFolder != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by Set")
	}

	if mmReadFolder.defaultExpectation == nil {
		mmReadFolder.defaultExpectation = &IDriveServiceMockReadFolderExpectation{mock: mmReadFolder.mock}
	}
	mmReadFolder.defaultExpectation.results = &IDriveServiceMockReadFolderResults{fpa1, spa1, err}
	mmReadFolder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadFolder.mock
}

// Set uses given function f to mock the IDriveService.ReadFolder method
func (mmReadFolder *mIDriveServiceMockReadFolder) Set(f func(folderUID string, readContent bool) (fpa1 []*drive.File, spa1 []*string, err error)) *IDriveServiceMock {
	if mmReadFolder.defaultExpectation != nil {
		mmReadFolder.mock.t.Fatalf("Default expectation is already set for the IDriveService.ReadFolder method")
	}

	if len(mmReadFolder.expectations) > 0 {
		mmReadFolder.mock.t.Fatalf("Some expectations are already set for the IDriveService.ReadFolder method")
	}

	mmReadFolder.mock.funcReadFolder = f
	mmReadFolder.mock.funcReadFolderOrigin = minimock.CallerInfo(1)
	return mmReadFolder.mock
}

// When sets expectation for the IDriveService.ReadFolder which will trigger the result defined by the following
// Then helper
func (mmReadFolder *mIDriveServiceMockReadFolder) When(folderUID string, readContent bool) *IDriveServiceMockReadFolderExpectation {
	if mmReadFolder.mock.funcReadFolder != nil {
		mmReadFolder.mock.t.Fatalf("IDriveServiceMock.ReadFolder mock is already set by Set")
	}

	expectation := &IDriveServiceMockReadFolderExpectation{
		mock:               mmReadFolder.mock,
		params:             &IDriveServiceMockReadFolderParams{folderUID, readContent},
		expectationOrigins: IDriveServiceMockReadFolderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadFolder.expectations = append(mmReadFolder.expectations, expectation)
	return expectation
}

// Then sets up IDriveService.ReadFolder return parameters for the expectation previously defined by the When method
func (e *IDriveServiceMockReadFolderExpectation) Then(fpa1 []*drive.File, spa1 []*string, err error) *IDriveServiceMock {
	e.results = &IDriveServiceMockReadFolderResults{fpa1, spa1, err}
	return e.mock
}

// Times sets number of times IDriveService.ReadFolder should be invoked
func (mmReadFolder *mIDriveServiceMockReadFolder) Times(n uint64) *mIDriveServiceMockReadFolder {
	if n == 0 {
		mmReadFolder.mock.t.Fatalf("Times of IDriveServiceMock.ReadFolder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadFolder.expectedInvocations, n)
	mmReadFolder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadFolder
}

func (mmReadFolder *mIDriveServiceMockReadFolder) invocationsDone() bool {
	if len(mmReadFolder.expectations) == 0 && mmReadFolder.defaultExpectation == nil && mmReadFolder.mock.funcReadFolder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadFolder.mock.afterReadFolderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadFolder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReadFolder implements mm_client.IDriveService
func (mmReadFolder *IDriveServiceMock) ReadFolder(folderUID string, readContent bool) (fpa1 []*drive.File, spa1 []*string, err error) {
	mm_atomic.AddUint64(&mmReadFolder.beforeReadFolderCounter, 1)
	defer mm_atomic.AddUint64(&mmReadFolder.afterReadFolderCounter, 1)

	mmReadFolder.t.Helper()

	if mmReadFolder.inspectFuncReadFolder != nil {
		mmReadFolder.inspectFuncReadFolder(folderUID, readContent)
	}

	mm_params := IDriveServiceMockReadFolderParams{folderUID, readContent}

	// Record call args
	mmReadFolder.ReadFolderMock.mutex.Lock()
	mmReadFolder.ReadFolderMock.callArgs = append(mmReadFolder.ReadFolderMock.callArgs, &mm_params)
	mmReadFolder.ReadFolderMock.mutex.Unlock()

	for _, e := range mmReadFolder.ReadFolderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fpa1, e.results.spa1, e.results.err
		}
	}

	if mmReadFolder.ReadFolderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadFolder.ReadFolderMock.defaultExpectation.Counter, 1)
		mm_want := mmReadFolder.ReadFolderMock.defaultExpectation.params
		mm_want_ptrs := mmReadFolder.ReadFolderMock.defaultExpectation.paramPtrs

		mm_got := IDriveServiceMockReadFolderParams{folderUID, readContent}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.folderUID != nil && !minimock.Equal(*mm_want_ptrs.folderUID, mm_got.folderUID) {
				mmReadFolder.t.Errorf("IDriveServiceMock.ReadFolder got unexpected parameter folderUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadFolder.ReadFolderMock.defaultExpectation.expectationOrigins.originFolderUID, *mm_want_ptrs.folderUID, mm_got.folderUID, minimock.Diff(*mm_want_ptrs.folderUID, mm_got.folderUID))
			}

			if mm_want_ptrs.readContent != nil && !minimock.Equal(*mm_want_ptrs.readContent, mm_got.readContent) {
				mmReadFolder.t.Errorf("IDriveServiceMock.ReadFolder got unexpected parameter readContent, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadFolder.ReadFolderMock.defaultExpectation.expectationOrigins.originReadContent, *mm_want_ptrs.readContent, mm_got.readContent, minimock.Diff(*mm_want_ptrs.readContent, mm_got.readContent))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadFolder.t.Errorf("IDriveServiceMock.ReadFolder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadFolder.ReadFolderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadFolder.ReadFolderMock.defaultExpectation.results
		if mm_results == nil {
			mmReadFolder.t.Fatal("No results are set for the IDriveServiceMock.ReadFolder")
		}
		return (*mm_results).fpa1, (*mm_results).spa1, (*mm_results).err
	}
	if mmReadFolder.funcReadFolder != nil {
		return mmReadFolder.funcReadFolder(folderUID, readContent)
	}
	mmReadFolder.t.Fatalf("Unexpected call to IDriveServiceMock.ReadFolder. %v %v", folderUID, readContent)
	return
}

// ReadFolderAfterCounter returns a count of finished IDriveServiceMock.ReadFolder invocations
func (mmReadFolder *IDriveServiceMock) ReadFolderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFolder.afterReadFolderCounter)
}

// ReadFolderBeforeCounter returns a count of IDriveServiceMock.ReadFolder invocations
func (mmReadFolder *IDriveServiceMock) ReadFolderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadFolder.beforeReadFolderCounter)
}

// Calls returns a list of arguments used in each call to IDriveServiceMock.ReadFolder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadFolder *mIDriveServiceMockReadFolder) Calls() []*IDriveServiceMockReadFolderParams {
	mmReadFolder.mutex.RLock()

	argCopy := make([]*IDriveServiceMockReadFolderParams, len(mmReadFolder.callArgs))
	copy(argCopy, mmReadFolder.callArgs)

	mmReadFolder.mutex.RUnlock()

	return argCopy
}

// MinimockReadFolderDone returns true if the count of the ReadFolder invocations corresponds
// the number of defined expectations
func (m *IDriveServiceMock) MinimockReadFolderDone() bool {
	if m.ReadFolderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadFolderMock.invocationsDone()
}

// MinimockReadFolderInspect logs each unmet expectation
func (m *IDriveServiceMock) MinimockReadFolderInspect() {
	for _, e := range m.ReadFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IDriveServiceMock.ReadFolder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadFolderCounter := mm_atomic.LoadUint64(&m.afterReadFolderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadFolderMock.defaultExpectation != nil && afterReadFolderCounter < 1 {
		if m.ReadFolderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IDriveServiceMock.ReadFolder at\n%s", m.ReadFolderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IDriveServiceMock.ReadFolder at\n%s with params: %#v", m.ReadFolderMock.defaultExpectation.expectationOrigins.origin, *m.ReadFolderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadFolder != nil && afterReadFolderCounter < 1 {
		m.t.Errorf("Expected call to IDriveServiceMock.ReadFolder at\n%s", m.funcReadFolderOrigin)
	}

	if !m.ReadFolderMock.invocationsDone() && afterReadFolderCounter > 0 {
		m.t.Errorf("Expected %d calls to IDriveServiceMock.ReadFolder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadFolderMock.expectedInvocations), m.ReadFolderMock.expectedInvocationsOrigin, afterReadFolderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IDriveServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockReadFileInspect()

			m.MinimockReadFolderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IDriveServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IDriveServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockReadFileDone() &&
		m.MinimockReadFolderDone()
}
