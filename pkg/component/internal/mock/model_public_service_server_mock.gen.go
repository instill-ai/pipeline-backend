// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_modelv1alpha "github.com/instill-ai/protogen-go/model/model/v1alpha"
)

// ModelPublicServiceServerMock implements mm_modelv1alpha.ModelPublicServiceServer
type ModelPublicServiceServerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateNamespaceModel          func(ctx context.Context, cp1 *mm_modelv1alpha.CreateNamespaceModelRequest) (cp2 *mm_modelv1alpha.CreateNamespaceModelResponse, err error)
	funcCreateNamespaceModelOrigin    string
	inspectFuncCreateNamespaceModel   func(ctx context.Context, cp1 *mm_modelv1alpha.CreateNamespaceModelRequest)
	afterCreateNamespaceModelCounter  uint64
	beforeCreateNamespaceModelCounter uint64
	CreateNamespaceModelMock          mModelPublicServiceServerMockCreateNamespaceModel

	funcCreateOrganizationModel          func(ctx context.Context, cp1 *mm_modelv1alpha.CreateOrganizationModelRequest) (cp2 *mm_modelv1alpha.CreateOrganizationModelResponse, err error)
	funcCreateOrganizationModelOrigin    string
	inspectFuncCreateOrganizationModel   func(ctx context.Context, cp1 *mm_modelv1alpha.CreateOrganizationModelRequest)
	afterCreateOrganizationModelCounter  uint64
	beforeCreateOrganizationModelCounter uint64
	CreateOrganizationModelMock          mModelPublicServiceServerMockCreateOrganizationModel

	funcCreateUserModel          func(ctx context.Context, cp1 *mm_modelv1alpha.CreateUserModelRequest) (cp2 *mm_modelv1alpha.CreateUserModelResponse, err error)
	funcCreateUserModelOrigin    string
	inspectFuncCreateUserModel   func(ctx context.Context, cp1 *mm_modelv1alpha.CreateUserModelRequest)
	afterCreateUserModelCounter  uint64
	beforeCreateUserModelCounter uint64
	CreateUserModelMock          mModelPublicServiceServerMockCreateUserModel

	funcDeleteNamespaceModel          func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest) (dp2 *mm_modelv1alpha.DeleteNamespaceModelResponse, err error)
	funcDeleteNamespaceModelOrigin    string
	inspectFuncDeleteNamespaceModel   func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest)
	afterDeleteNamespaceModelCounter  uint64
	beforeDeleteNamespaceModelCounter uint64
	DeleteNamespaceModelMock          mModelPublicServiceServerMockDeleteNamespaceModel

	funcDeleteNamespaceModelVersion          func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteNamespaceModelVersionResponse, err error)
	funcDeleteNamespaceModelVersionOrigin    string
	inspectFuncDeleteNamespaceModelVersion   func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest)
	afterDeleteNamespaceModelVersionCounter  uint64
	beforeDeleteNamespaceModelVersionCounter uint64
	DeleteNamespaceModelVersionMock          mModelPublicServiceServerMockDeleteNamespaceModelVersion

	funcDeleteOrganizationModel          func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest) (dp2 *mm_modelv1alpha.DeleteOrganizationModelResponse, err error)
	funcDeleteOrganizationModelOrigin    string
	inspectFuncDeleteOrganizationModel   func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest)
	afterDeleteOrganizationModelCounter  uint64
	beforeDeleteOrganizationModelCounter uint64
	DeleteOrganizationModelMock          mModelPublicServiceServerMockDeleteOrganizationModel

	funcDeleteOrganizationModelVersion          func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteOrganizationModelVersionResponse, err error)
	funcDeleteOrganizationModelVersionOrigin    string
	inspectFuncDeleteOrganizationModelVersion   func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest)
	afterDeleteOrganizationModelVersionCounter  uint64
	beforeDeleteOrganizationModelVersionCounter uint64
	DeleteOrganizationModelVersionMock          mModelPublicServiceServerMockDeleteOrganizationModelVersion

	funcDeleteUserModel          func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelRequest) (dp2 *mm_modelv1alpha.DeleteUserModelResponse, err error)
	funcDeleteUserModelOrigin    string
	inspectFuncDeleteUserModel   func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelRequest)
	afterDeleteUserModelCounter  uint64
	beforeDeleteUserModelCounter uint64
	DeleteUserModelMock          mModelPublicServiceServerMockDeleteUserModel

	funcDeleteUserModelVersion          func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteUserModelVersionResponse, err error)
	funcDeleteUserModelVersionOrigin    string
	inspectFuncDeleteUserModelVersion   func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest)
	afterDeleteUserModelVersionCounter  uint64
	beforeDeleteUserModelVersionCounter uint64
	DeleteUserModelVersionMock          mModelPublicServiceServerMockDeleteUserModelVersion

	funcGetModelDefinition          func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelDefinitionRequest) (gp2 *mm_modelv1alpha.GetModelDefinitionResponse, err error)
	funcGetModelDefinitionOrigin    string
	inspectFuncGetModelDefinition   func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelDefinitionRequest)
	afterGetModelDefinitionCounter  uint64
	beforeGetModelDefinitionCounter uint64
	GetModelDefinitionMock          mModelPublicServiceServerMockGetModelDefinition

	funcGetModelOperation          func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelOperationRequest) (gp2 *mm_modelv1alpha.GetModelOperationResponse, err error)
	funcGetModelOperationOrigin    string
	inspectFuncGetModelOperation   func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelOperationRequest)
	afterGetModelOperationCounter  uint64
	beforeGetModelOperationCounter uint64
	GetModelOperationMock          mModelPublicServiceServerMockGetModelOperation

	funcGetNamespaceLatestModelOperation          func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetNamespaceLatestModelOperationResponse, err error)
	funcGetNamespaceLatestModelOperationOrigin    string
	inspectFuncGetNamespaceLatestModelOperation   func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest)
	afterGetNamespaceLatestModelOperationCounter  uint64
	beforeGetNamespaceLatestModelOperationCounter uint64
	GetNamespaceLatestModelOperationMock          mModelPublicServiceServerMockGetNamespaceLatestModelOperation

	funcGetNamespaceModel          func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelRequest) (gp2 *mm_modelv1alpha.GetNamespaceModelResponse, err error)
	funcGetNamespaceModelOrigin    string
	inspectFuncGetNamespaceModel   func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelRequest)
	afterGetNamespaceModelCounter  uint64
	beforeGetNamespaceModelCounter uint64
	GetNamespaceModelMock          mModelPublicServiceServerMockGetNamespaceModel

	funcGetNamespaceModelOperation          func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest) (gp2 *mm_modelv1alpha.GetNamespaceModelOperationResponse, err error)
	funcGetNamespaceModelOperationOrigin    string
	inspectFuncGetNamespaceModelOperation   func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest)
	afterGetNamespaceModelOperationCounter  uint64
	beforeGetNamespaceModelOperationCounter uint64
	GetNamespaceModelOperationMock          mModelPublicServiceServerMockGetNamespaceModelOperation

	funcGetOrganizationLatestModelOperation          func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetOrganizationLatestModelOperationResponse, err error)
	funcGetOrganizationLatestModelOperationOrigin    string
	inspectFuncGetOrganizationLatestModelOperation   func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest)
	afterGetOrganizationLatestModelOperationCounter  uint64
	beforeGetOrganizationLatestModelOperationCounter uint64
	GetOrganizationLatestModelOperationMock          mModelPublicServiceServerMockGetOrganizationLatestModelOperation

	funcGetOrganizationModel          func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationModelRequest) (gp2 *mm_modelv1alpha.GetOrganizationModelResponse, err error)
	funcGetOrganizationModelOrigin    string
	inspectFuncGetOrganizationModel   func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationModelRequest)
	afterGetOrganizationModelCounter  uint64
	beforeGetOrganizationModelCounter uint64
	GetOrganizationModelMock          mModelPublicServiceServerMockGetOrganizationModel

	funcGetUserLatestModelOperation          func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetUserLatestModelOperationResponse, err error)
	funcGetUserLatestModelOperationOrigin    string
	inspectFuncGetUserLatestModelOperation   func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest)
	afterGetUserLatestModelOperationCounter  uint64
	beforeGetUserLatestModelOperationCounter uint64
	GetUserLatestModelOperationMock          mModelPublicServiceServerMockGetUserLatestModelOperation

	funcGetUserModel          func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserModelRequest) (gp2 *mm_modelv1alpha.GetUserModelResponse, err error)
	funcGetUserModelOrigin    string
	inspectFuncGetUserModel   func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserModelRequest)
	afterGetUserModelCounter  uint64
	beforeGetUserModelCounter uint64
	GetUserModelMock          mModelPublicServiceServerMockGetUserModel

	funcListAvailableRegions          func(ctx context.Context, lp1 *mm_modelv1alpha.ListAvailableRegionsRequest) (lp2 *mm_modelv1alpha.ListAvailableRegionsResponse, err error)
	funcListAvailableRegionsOrigin    string
	inspectFuncListAvailableRegions   func(ctx context.Context, lp1 *mm_modelv1alpha.ListAvailableRegionsRequest)
	afterListAvailableRegionsCounter  uint64
	beforeListAvailableRegionsCounter uint64
	ListAvailableRegionsMock          mModelPublicServiceServerMockListAvailableRegions

	funcListModelDefinitions          func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelDefinitionsRequest) (lp2 *mm_modelv1alpha.ListModelDefinitionsResponse, err error)
	funcListModelDefinitionsOrigin    string
	inspectFuncListModelDefinitions   func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelDefinitionsRequest)
	afterListModelDefinitionsCounter  uint64
	beforeListModelDefinitionsCounter uint64
	ListModelDefinitionsMock          mModelPublicServiceServerMockListModelDefinitions

	funcListModelRuns          func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsRequest) (lp2 *mm_modelv1alpha.ListModelRunsResponse, err error)
	funcListModelRunsOrigin    string
	inspectFuncListModelRuns   func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsRequest)
	afterListModelRunsCounter  uint64
	beforeListModelRunsCounter uint64
	ListModelRunsMock          mModelPublicServiceServerMockListModelRuns

	funcListModelRunsByRequester          func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest) (lp2 *mm_modelv1alpha.ListModelRunsByRequesterResponse, err error)
	funcListModelRunsByRequesterOrigin    string
	inspectFuncListModelRunsByRequester   func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest)
	afterListModelRunsByRequesterCounter  uint64
	beforeListModelRunsByRequesterCounter uint64
	ListModelRunsByRequesterMock          mModelPublicServiceServerMockListModelRunsByRequester

	funcListModels          func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelsRequest) (lp2 *mm_modelv1alpha.ListModelsResponse, err error)
	funcListModelsOrigin    string
	inspectFuncListModels   func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelsRequest)
	afterListModelsCounter  uint64
	beforeListModelsCounter uint64
	ListModelsMock          mModelPublicServiceServerMockListModels

	funcListNamespaceModelVersions          func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest) (lp2 *mm_modelv1alpha.ListNamespaceModelVersionsResponse, err error)
	funcListNamespaceModelVersionsOrigin    string
	inspectFuncListNamespaceModelVersions   func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest)
	afterListNamespaceModelVersionsCounter  uint64
	beforeListNamespaceModelVersionsCounter uint64
	ListNamespaceModelVersionsMock          mModelPublicServiceServerMockListNamespaceModelVersions

	funcListNamespaceModels          func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelsRequest) (lp2 *mm_modelv1alpha.ListNamespaceModelsResponse, err error)
	funcListNamespaceModelsOrigin    string
	inspectFuncListNamespaceModels   func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelsRequest)
	afterListNamespaceModelsCounter  uint64
	beforeListNamespaceModelsCounter uint64
	ListNamespaceModelsMock          mModelPublicServiceServerMockListNamespaceModels

	funcListOrganizationModelVersions          func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest) (lp2 *mm_modelv1alpha.ListOrganizationModelVersionsResponse, err error)
	funcListOrganizationModelVersionsOrigin    string
	inspectFuncListOrganizationModelVersions   func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest)
	afterListOrganizationModelVersionsCounter  uint64
	beforeListOrganizationModelVersionsCounter uint64
	ListOrganizationModelVersionsMock          mModelPublicServiceServerMockListOrganizationModelVersions

	funcListOrganizationModels          func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelsRequest) (lp2 *mm_modelv1alpha.ListOrganizationModelsResponse, err error)
	funcListOrganizationModelsOrigin    string
	inspectFuncListOrganizationModels   func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelsRequest)
	afterListOrganizationModelsCounter  uint64
	beforeListOrganizationModelsCounter uint64
	ListOrganizationModelsMock          mModelPublicServiceServerMockListOrganizationModels

	funcListUserModelVersions          func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelVersionsRequest) (lp2 *mm_modelv1alpha.ListUserModelVersionsResponse, err error)
	funcListUserModelVersionsOrigin    string
	inspectFuncListUserModelVersions   func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelVersionsRequest)
	afterListUserModelVersionsCounter  uint64
	beforeListUserModelVersionsCounter uint64
	ListUserModelVersionsMock          mModelPublicServiceServerMockListUserModelVersions

	funcListUserModels          func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelsRequest) (lp2 *mm_modelv1alpha.ListUserModelsResponse, err error)
	funcListUserModelsOrigin    string
	inspectFuncListUserModels   func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelsRequest)
	afterListUserModelsCounter  uint64
	beforeListUserModelsCounter uint64
	ListUserModelsMock          mModelPublicServiceServerMockListUserModels

	funcLiveness          func(ctx context.Context, lp1 *mm_modelv1alpha.LivenessRequest) (lp2 *mm_modelv1alpha.LivenessResponse, err error)
	funcLivenessOrigin    string
	inspectFuncLiveness   func(ctx context.Context, lp1 *mm_modelv1alpha.LivenessRequest)
	afterLivenessCounter  uint64
	beforeLivenessCounter uint64
	LivenessMock          mModelPublicServiceServerMockLiveness

	funcLookUpModel          func(ctx context.Context, lp1 *mm_modelv1alpha.LookUpModelRequest) (lp2 *mm_modelv1alpha.LookUpModelResponse, err error)
	funcLookUpModelOrigin    string
	inspectFuncLookUpModel   func(ctx context.Context, lp1 *mm_modelv1alpha.LookUpModelRequest)
	afterLookUpModelCounter  uint64
	beforeLookUpModelCounter uint64
	LookUpModelMock          mModelPublicServiceServerMockLookUpModel

	funcReadiness          func(ctx context.Context, rp1 *mm_modelv1alpha.ReadinessRequest) (rp2 *mm_modelv1alpha.ReadinessResponse, err error)
	funcReadinessOrigin    string
	inspectFuncReadiness   func(ctx context.Context, rp1 *mm_modelv1alpha.ReadinessRequest)
	afterReadinessCounter  uint64
	beforeReadinessCounter uint64
	ReadinessMock          mModelPublicServiceServerMockReadiness

	funcRenameNamespaceModel          func(ctx context.Context, rp1 *mm_modelv1alpha.RenameNamespaceModelRequest) (rp2 *mm_modelv1alpha.RenameNamespaceModelResponse, err error)
	funcRenameNamespaceModelOrigin    string
	inspectFuncRenameNamespaceModel   func(ctx context.Context, rp1 *mm_modelv1alpha.RenameNamespaceModelRequest)
	afterRenameNamespaceModelCounter  uint64
	beforeRenameNamespaceModelCounter uint64
	RenameNamespaceModelMock          mModelPublicServiceServerMockRenameNamespaceModel

	funcRenameOrganizationModel          func(ctx context.Context, rp1 *mm_modelv1alpha.RenameOrganizationModelRequest) (rp2 *mm_modelv1alpha.RenameOrganizationModelResponse, err error)
	funcRenameOrganizationModelOrigin    string
	inspectFuncRenameOrganizationModel   func(ctx context.Context, rp1 *mm_modelv1alpha.RenameOrganizationModelRequest)
	afterRenameOrganizationModelCounter  uint64
	beforeRenameOrganizationModelCounter uint64
	RenameOrganizationModelMock          mModelPublicServiceServerMockRenameOrganizationModel

	funcRenameUserModel          func(ctx context.Context, rp1 *mm_modelv1alpha.RenameUserModelRequest) (rp2 *mm_modelv1alpha.RenameUserModelResponse, err error)
	funcRenameUserModelOrigin    string
	inspectFuncRenameUserModel   func(ctx context.Context, rp1 *mm_modelv1alpha.RenameUserModelRequest)
	afterRenameUserModelCounter  uint64
	beforeRenameUserModelCounter uint64
	RenameUserModelMock          mModelPublicServiceServerMockRenameUserModel

	funcTriggerAsyncNamespaceLatestModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelResponse, err error)
	funcTriggerAsyncNamespaceLatestModelOrigin    string
	inspectFuncTriggerAsyncNamespaceLatestModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest)
	afterTriggerAsyncNamespaceLatestModelCounter  uint64
	beforeTriggerAsyncNamespaceLatestModelCounter uint64
	TriggerAsyncNamespaceLatestModelMock          mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel

	funcTriggerAsyncNamespaceModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncNamespaceModelResponse, err error)
	funcTriggerAsyncNamespaceModelOrigin    string
	inspectFuncTriggerAsyncNamespaceModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest)
	afterTriggerAsyncNamespaceModelCounter  uint64
	beforeTriggerAsyncNamespaceModelCounter uint64
	TriggerAsyncNamespaceModelMock          mModelPublicServiceServerMockTriggerAsyncNamespaceModel

	funcTriggerAsyncOrganizationLatestModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelResponse, err error)
	funcTriggerAsyncOrganizationLatestModelOrigin    string
	inspectFuncTriggerAsyncOrganizationLatestModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest)
	afterTriggerAsyncOrganizationLatestModelCounter  uint64
	beforeTriggerAsyncOrganizationLatestModelCounter uint64
	TriggerAsyncOrganizationLatestModelMock          mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel

	funcTriggerAsyncOrganizationModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncOrganizationModelResponse, err error)
	funcTriggerAsyncOrganizationModelOrigin    string
	inspectFuncTriggerAsyncOrganizationModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest)
	afterTriggerAsyncOrganizationModelCounter  uint64
	beforeTriggerAsyncOrganizationModelCounter uint64
	TriggerAsyncOrganizationModelMock          mModelPublicServiceServerMockTriggerAsyncOrganizationModel

	funcTriggerAsyncUserLatestModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncUserLatestModelResponse, err error)
	funcTriggerAsyncUserLatestModelOrigin    string
	inspectFuncTriggerAsyncUserLatestModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest)
	afterTriggerAsyncUserLatestModelCounter  uint64
	beforeTriggerAsyncUserLatestModelCounter uint64
	TriggerAsyncUserLatestModelMock          mModelPublicServiceServerMockTriggerAsyncUserLatestModel

	funcTriggerAsyncUserModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncUserModelResponse, err error)
	funcTriggerAsyncUserModelOrigin    string
	inspectFuncTriggerAsyncUserModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest)
	afterTriggerAsyncUserModelCounter  uint64
	beforeTriggerAsyncUserModelCounter uint64
	TriggerAsyncUserModelMock          mModelPublicServiceServerMockTriggerAsyncUserModel

	funcTriggerNamespaceLatestModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerNamespaceLatestModelResponse, err error)
	funcTriggerNamespaceLatestModelOrigin    string
	inspectFuncTriggerNamespaceLatestModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest)
	afterTriggerNamespaceLatestModelCounter  uint64
	beforeTriggerNamespaceLatestModelCounter uint64
	TriggerNamespaceLatestModelMock          mModelPublicServiceServerMockTriggerNamespaceLatestModel

	funcTriggerNamespaceLatestModelBinaryFileUpload          func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer) (err error)
	funcTriggerNamespaceLatestModelBinaryFileUploadOrigin    string
	inspectFuncTriggerNamespaceLatestModelBinaryFileUpload   func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer)
	afterTriggerNamespaceLatestModelBinaryFileUploadCounter  uint64
	beforeTriggerNamespaceLatestModelBinaryFileUploadCounter uint64
	TriggerNamespaceLatestModelBinaryFileUploadMock          mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload

	funcTriggerNamespaceModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest) (tp2 *mm_modelv1alpha.TriggerNamespaceModelResponse, err error)
	funcTriggerNamespaceModelOrigin    string
	inspectFuncTriggerNamespaceModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest)
	afterTriggerNamespaceModelCounter  uint64
	beforeTriggerNamespaceModelCounter uint64
	TriggerNamespaceModelMock          mModelPublicServiceServerMockTriggerNamespaceModel

	funcTriggerNamespaceModelBinaryFileUpload          func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer) (err error)
	funcTriggerNamespaceModelBinaryFileUploadOrigin    string
	inspectFuncTriggerNamespaceModelBinaryFileUpload   func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer)
	afterTriggerNamespaceModelBinaryFileUploadCounter  uint64
	beforeTriggerNamespaceModelBinaryFileUploadCounter uint64
	TriggerNamespaceModelBinaryFileUploadMock          mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload

	funcTriggerOrganizationLatestModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerOrganizationLatestModelResponse, err error)
	funcTriggerOrganizationLatestModelOrigin    string
	inspectFuncTriggerOrganizationLatestModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest)
	afterTriggerOrganizationLatestModelCounter  uint64
	beforeTriggerOrganizationLatestModelCounter uint64
	TriggerOrganizationLatestModelMock          mModelPublicServiceServerMockTriggerOrganizationLatestModel

	funcTriggerOrganizationModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest) (tp2 *mm_modelv1alpha.TriggerOrganizationModelResponse, err error)
	funcTriggerOrganizationModelOrigin    string
	inspectFuncTriggerOrganizationModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest)
	afterTriggerOrganizationModelCounter  uint64
	beforeTriggerOrganizationModelCounter uint64
	TriggerOrganizationModelMock          mModelPublicServiceServerMockTriggerOrganizationModel

	funcTriggerOrganizationModelBinaryFileUpload          func(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer) (err error)
	funcTriggerOrganizationModelBinaryFileUploadOrigin    string
	inspectFuncTriggerOrganizationModelBinaryFileUpload   func(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer)
	afterTriggerOrganizationModelBinaryFileUploadCounter  uint64
	beforeTriggerOrganizationModelBinaryFileUploadCounter uint64
	TriggerOrganizationModelBinaryFileUploadMock          mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload

	funcTriggerUserLatestModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerUserLatestModelResponse, err error)
	funcTriggerUserLatestModelOrigin    string
	inspectFuncTriggerUserLatestModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest)
	afterTriggerUserLatestModelCounter  uint64
	beforeTriggerUserLatestModelCounter uint64
	TriggerUserLatestModelMock          mModelPublicServiceServerMockTriggerUserLatestModel

	funcTriggerUserModel          func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserModelRequest) (tp2 *mm_modelv1alpha.TriggerUserModelResponse, err error)
	funcTriggerUserModelOrigin    string
	inspectFuncTriggerUserModel   func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserModelRequest)
	afterTriggerUserModelCounter  uint64
	beforeTriggerUserModelCounter uint64
	TriggerUserModelMock          mModelPublicServiceServerMockTriggerUserModel

	funcTriggerUserModelBinaryFileUpload          func(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer) (err error)
	funcTriggerUserModelBinaryFileUploadOrigin    string
	inspectFuncTriggerUserModelBinaryFileUpload   func(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer)
	afterTriggerUserModelBinaryFileUploadCounter  uint64
	beforeTriggerUserModelBinaryFileUploadCounter uint64
	TriggerUserModelBinaryFileUploadMock          mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload

	funcUpdateNamespaceModel          func(ctx context.Context, up1 *mm_modelv1alpha.UpdateNamespaceModelRequest) (up2 *mm_modelv1alpha.UpdateNamespaceModelResponse, err error)
	funcUpdateNamespaceModelOrigin    string
	inspectFuncUpdateNamespaceModel   func(ctx context.Context, up1 *mm_modelv1alpha.UpdateNamespaceModelRequest)
	afterUpdateNamespaceModelCounter  uint64
	beforeUpdateNamespaceModelCounter uint64
	UpdateNamespaceModelMock          mModelPublicServiceServerMockUpdateNamespaceModel

	funcUpdateOrganizationModel          func(ctx context.Context, up1 *mm_modelv1alpha.UpdateOrganizationModelRequest) (up2 *mm_modelv1alpha.UpdateOrganizationModelResponse, err error)
	funcUpdateOrganizationModelOrigin    string
	inspectFuncUpdateOrganizationModel   func(ctx context.Context, up1 *mm_modelv1alpha.UpdateOrganizationModelRequest)
	afterUpdateOrganizationModelCounter  uint64
	beforeUpdateOrganizationModelCounter uint64
	UpdateOrganizationModelMock          mModelPublicServiceServerMockUpdateOrganizationModel

	funcUpdateUserModel          func(ctx context.Context, up1 *mm_modelv1alpha.UpdateUserModelRequest) (up2 *mm_modelv1alpha.UpdateUserModelResponse, err error)
	funcUpdateUserModelOrigin    string
	inspectFuncUpdateUserModel   func(ctx context.Context, up1 *mm_modelv1alpha.UpdateUserModelRequest)
	afterUpdateUserModelCounter  uint64
	beforeUpdateUserModelCounter uint64
	UpdateUserModelMock          mModelPublicServiceServerMockUpdateUserModel

	funcWatchNamespaceLatestModel          func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest) (wp2 *mm_modelv1alpha.WatchNamespaceLatestModelResponse, err error)
	funcWatchNamespaceLatestModelOrigin    string
	inspectFuncWatchNamespaceLatestModel   func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest)
	afterWatchNamespaceLatestModelCounter  uint64
	beforeWatchNamespaceLatestModelCounter uint64
	WatchNamespaceLatestModelMock          mModelPublicServiceServerMockWatchNamespaceLatestModel

	funcWatchNamespaceModel          func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceModelRequest) (wp2 *mm_modelv1alpha.WatchNamespaceModelResponse, err error)
	funcWatchNamespaceModelOrigin    string
	inspectFuncWatchNamespaceModel   func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceModelRequest)
	afterWatchNamespaceModelCounter  uint64
	beforeWatchNamespaceModelCounter uint64
	WatchNamespaceModelMock          mModelPublicServiceServerMockWatchNamespaceModel

	funcWatchOrganizationLatestModel          func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest) (wp2 *mm_modelv1alpha.WatchOrganizationLatestModelResponse, err error)
	funcWatchOrganizationLatestModelOrigin    string
	inspectFuncWatchOrganizationLatestModel   func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest)
	afterWatchOrganizationLatestModelCounter  uint64
	beforeWatchOrganizationLatestModelCounter uint64
	WatchOrganizationLatestModelMock          mModelPublicServiceServerMockWatchOrganizationLatestModel

	funcWatchOrganizationModel          func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationModelRequest) (wp2 *mm_modelv1alpha.WatchOrganizationModelResponse, err error)
	funcWatchOrganizationModelOrigin    string
	inspectFuncWatchOrganizationModel   func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationModelRequest)
	afterWatchOrganizationModelCounter  uint64
	beforeWatchOrganizationModelCounter uint64
	WatchOrganizationModelMock          mModelPublicServiceServerMockWatchOrganizationModel

	funcWatchUserLatestModel          func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserLatestModelRequest) (wp2 *mm_modelv1alpha.WatchUserLatestModelResponse, err error)
	funcWatchUserLatestModelOrigin    string
	inspectFuncWatchUserLatestModel   func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserLatestModelRequest)
	afterWatchUserLatestModelCounter  uint64
	beforeWatchUserLatestModelCounter uint64
	WatchUserLatestModelMock          mModelPublicServiceServerMockWatchUserLatestModel

	funcWatchUserModel          func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserModelRequest) (wp2 *mm_modelv1alpha.WatchUserModelResponse, err error)
	funcWatchUserModelOrigin    string
	inspectFuncWatchUserModel   func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserModelRequest)
	afterWatchUserModelCounter  uint64
	beforeWatchUserModelCounter uint64
	WatchUserModelMock          mModelPublicServiceServerMockWatchUserModel
}

// NewModelPublicServiceServerMock returns a mock for mm_modelv1alpha.ModelPublicServiceServer
func NewModelPublicServiceServerMock(t minimock.Tester) *ModelPublicServiceServerMock {
	m := &ModelPublicServiceServerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateNamespaceModelMock = mModelPublicServiceServerMockCreateNamespaceModel{mock: m}
	m.CreateNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockCreateNamespaceModelParams{}

	m.CreateOrganizationModelMock = mModelPublicServiceServerMockCreateOrganizationModel{mock: m}
	m.CreateOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockCreateOrganizationModelParams{}

	m.CreateUserModelMock = mModelPublicServiceServerMockCreateUserModel{mock: m}
	m.CreateUserModelMock.callArgs = []*ModelPublicServiceServerMockCreateUserModelParams{}

	m.DeleteNamespaceModelMock = mModelPublicServiceServerMockDeleteNamespaceModel{mock: m}
	m.DeleteNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockDeleteNamespaceModelParams{}

	m.DeleteNamespaceModelVersionMock = mModelPublicServiceServerMockDeleteNamespaceModelVersion{mock: m}
	m.DeleteNamespaceModelVersionMock.callArgs = []*ModelPublicServiceServerMockDeleteNamespaceModelVersionParams{}

	m.DeleteOrganizationModelMock = mModelPublicServiceServerMockDeleteOrganizationModel{mock: m}
	m.DeleteOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockDeleteOrganizationModelParams{}

	m.DeleteOrganizationModelVersionMock = mModelPublicServiceServerMockDeleteOrganizationModelVersion{mock: m}
	m.DeleteOrganizationModelVersionMock.callArgs = []*ModelPublicServiceServerMockDeleteOrganizationModelVersionParams{}

	m.DeleteUserModelMock = mModelPublicServiceServerMockDeleteUserModel{mock: m}
	m.DeleteUserModelMock.callArgs = []*ModelPublicServiceServerMockDeleteUserModelParams{}

	m.DeleteUserModelVersionMock = mModelPublicServiceServerMockDeleteUserModelVersion{mock: m}
	m.DeleteUserModelVersionMock.callArgs = []*ModelPublicServiceServerMockDeleteUserModelVersionParams{}

	m.GetModelDefinitionMock = mModelPublicServiceServerMockGetModelDefinition{mock: m}
	m.GetModelDefinitionMock.callArgs = []*ModelPublicServiceServerMockGetModelDefinitionParams{}

	m.GetModelOperationMock = mModelPublicServiceServerMockGetModelOperation{mock: m}
	m.GetModelOperationMock.callArgs = []*ModelPublicServiceServerMockGetModelOperationParams{}

	m.GetNamespaceLatestModelOperationMock = mModelPublicServiceServerMockGetNamespaceLatestModelOperation{mock: m}
	m.GetNamespaceLatestModelOperationMock.callArgs = []*ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams{}

	m.GetNamespaceModelMock = mModelPublicServiceServerMockGetNamespaceModel{mock: m}
	m.GetNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockGetNamespaceModelParams{}

	m.GetNamespaceModelOperationMock = mModelPublicServiceServerMockGetNamespaceModelOperation{mock: m}
	m.GetNamespaceModelOperationMock.callArgs = []*ModelPublicServiceServerMockGetNamespaceModelOperationParams{}

	m.GetOrganizationLatestModelOperationMock = mModelPublicServiceServerMockGetOrganizationLatestModelOperation{mock: m}
	m.GetOrganizationLatestModelOperationMock.callArgs = []*ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams{}

	m.GetOrganizationModelMock = mModelPublicServiceServerMockGetOrganizationModel{mock: m}
	m.GetOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockGetOrganizationModelParams{}

	m.GetUserLatestModelOperationMock = mModelPublicServiceServerMockGetUserLatestModelOperation{mock: m}
	m.GetUserLatestModelOperationMock.callArgs = []*ModelPublicServiceServerMockGetUserLatestModelOperationParams{}

	m.GetUserModelMock = mModelPublicServiceServerMockGetUserModel{mock: m}
	m.GetUserModelMock.callArgs = []*ModelPublicServiceServerMockGetUserModelParams{}

	m.ListAvailableRegionsMock = mModelPublicServiceServerMockListAvailableRegions{mock: m}
	m.ListAvailableRegionsMock.callArgs = []*ModelPublicServiceServerMockListAvailableRegionsParams{}

	m.ListModelDefinitionsMock = mModelPublicServiceServerMockListModelDefinitions{mock: m}
	m.ListModelDefinitionsMock.callArgs = []*ModelPublicServiceServerMockListModelDefinitionsParams{}

	m.ListModelRunsMock = mModelPublicServiceServerMockListModelRuns{mock: m}
	m.ListModelRunsMock.callArgs = []*ModelPublicServiceServerMockListModelRunsParams{}

	m.ListModelRunsByRequesterMock = mModelPublicServiceServerMockListModelRunsByRequester{mock: m}
	m.ListModelRunsByRequesterMock.callArgs = []*ModelPublicServiceServerMockListModelRunsByRequesterParams{}

	m.ListModelsMock = mModelPublicServiceServerMockListModels{mock: m}
	m.ListModelsMock.callArgs = []*ModelPublicServiceServerMockListModelsParams{}

	m.ListNamespaceModelVersionsMock = mModelPublicServiceServerMockListNamespaceModelVersions{mock: m}
	m.ListNamespaceModelVersionsMock.callArgs = []*ModelPublicServiceServerMockListNamespaceModelVersionsParams{}

	m.ListNamespaceModelsMock = mModelPublicServiceServerMockListNamespaceModels{mock: m}
	m.ListNamespaceModelsMock.callArgs = []*ModelPublicServiceServerMockListNamespaceModelsParams{}

	m.ListOrganizationModelVersionsMock = mModelPublicServiceServerMockListOrganizationModelVersions{mock: m}
	m.ListOrganizationModelVersionsMock.callArgs = []*ModelPublicServiceServerMockListOrganizationModelVersionsParams{}

	m.ListOrganizationModelsMock = mModelPublicServiceServerMockListOrganizationModels{mock: m}
	m.ListOrganizationModelsMock.callArgs = []*ModelPublicServiceServerMockListOrganizationModelsParams{}

	m.ListUserModelVersionsMock = mModelPublicServiceServerMockListUserModelVersions{mock: m}
	m.ListUserModelVersionsMock.callArgs = []*ModelPublicServiceServerMockListUserModelVersionsParams{}

	m.ListUserModelsMock = mModelPublicServiceServerMockListUserModels{mock: m}
	m.ListUserModelsMock.callArgs = []*ModelPublicServiceServerMockListUserModelsParams{}

	m.LivenessMock = mModelPublicServiceServerMockLiveness{mock: m}
	m.LivenessMock.callArgs = []*ModelPublicServiceServerMockLivenessParams{}

	m.LookUpModelMock = mModelPublicServiceServerMockLookUpModel{mock: m}
	m.LookUpModelMock.callArgs = []*ModelPublicServiceServerMockLookUpModelParams{}

	m.ReadinessMock = mModelPublicServiceServerMockReadiness{mock: m}
	m.ReadinessMock.callArgs = []*ModelPublicServiceServerMockReadinessParams{}

	m.RenameNamespaceModelMock = mModelPublicServiceServerMockRenameNamespaceModel{mock: m}
	m.RenameNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockRenameNamespaceModelParams{}

	m.RenameOrganizationModelMock = mModelPublicServiceServerMockRenameOrganizationModel{mock: m}
	m.RenameOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockRenameOrganizationModelParams{}

	m.RenameUserModelMock = mModelPublicServiceServerMockRenameUserModel{mock: m}
	m.RenameUserModelMock.callArgs = []*ModelPublicServiceServerMockRenameUserModelParams{}

	m.TriggerAsyncNamespaceLatestModelMock = mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel{mock: m}
	m.TriggerAsyncNamespaceLatestModelMock.callArgs = []*ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams{}

	m.TriggerAsyncNamespaceModelMock = mModelPublicServiceServerMockTriggerAsyncNamespaceModel{mock: m}
	m.TriggerAsyncNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams{}

	m.TriggerAsyncOrganizationLatestModelMock = mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel{mock: m}
	m.TriggerAsyncOrganizationLatestModelMock.callArgs = []*ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams{}

	m.TriggerAsyncOrganizationModelMock = mModelPublicServiceServerMockTriggerAsyncOrganizationModel{mock: m}
	m.TriggerAsyncOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams{}

	m.TriggerAsyncUserLatestModelMock = mModelPublicServiceServerMockTriggerAsyncUserLatestModel{mock: m}
	m.TriggerAsyncUserLatestModelMock.callArgs = []*ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams{}

	m.TriggerAsyncUserModelMock = mModelPublicServiceServerMockTriggerAsyncUserModel{mock: m}
	m.TriggerAsyncUserModelMock.callArgs = []*ModelPublicServiceServerMockTriggerAsyncUserModelParams{}

	m.TriggerNamespaceLatestModelMock = mModelPublicServiceServerMockTriggerNamespaceLatestModel{mock: m}
	m.TriggerNamespaceLatestModelMock.callArgs = []*ModelPublicServiceServerMockTriggerNamespaceLatestModelParams{}

	m.TriggerNamespaceLatestModelBinaryFileUploadMock = mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload{mock: m}
	m.TriggerNamespaceLatestModelBinaryFileUploadMock.callArgs = []*ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams{}

	m.TriggerNamespaceModelMock = mModelPublicServiceServerMockTriggerNamespaceModel{mock: m}
	m.TriggerNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockTriggerNamespaceModelParams{}

	m.TriggerNamespaceModelBinaryFileUploadMock = mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload{mock: m}
	m.TriggerNamespaceModelBinaryFileUploadMock.callArgs = []*ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams{}

	m.TriggerOrganizationLatestModelMock = mModelPublicServiceServerMockTriggerOrganizationLatestModel{mock: m}
	m.TriggerOrganizationLatestModelMock.callArgs = []*ModelPublicServiceServerMockTriggerOrganizationLatestModelParams{}

	m.TriggerOrganizationModelMock = mModelPublicServiceServerMockTriggerOrganizationModel{mock: m}
	m.TriggerOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockTriggerOrganizationModelParams{}

	m.TriggerOrganizationModelBinaryFileUploadMock = mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload{mock: m}
	m.TriggerOrganizationModelBinaryFileUploadMock.callArgs = []*ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams{}

	m.TriggerUserLatestModelMock = mModelPublicServiceServerMockTriggerUserLatestModel{mock: m}
	m.TriggerUserLatestModelMock.callArgs = []*ModelPublicServiceServerMockTriggerUserLatestModelParams{}

	m.TriggerUserModelMock = mModelPublicServiceServerMockTriggerUserModel{mock: m}
	m.TriggerUserModelMock.callArgs = []*ModelPublicServiceServerMockTriggerUserModelParams{}

	m.TriggerUserModelBinaryFileUploadMock = mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload{mock: m}
	m.TriggerUserModelBinaryFileUploadMock.callArgs = []*ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams{}

	m.UpdateNamespaceModelMock = mModelPublicServiceServerMockUpdateNamespaceModel{mock: m}
	m.UpdateNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockUpdateNamespaceModelParams{}

	m.UpdateOrganizationModelMock = mModelPublicServiceServerMockUpdateOrganizationModel{mock: m}
	m.UpdateOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockUpdateOrganizationModelParams{}

	m.UpdateUserModelMock = mModelPublicServiceServerMockUpdateUserModel{mock: m}
	m.UpdateUserModelMock.callArgs = []*ModelPublicServiceServerMockUpdateUserModelParams{}

	m.WatchNamespaceLatestModelMock = mModelPublicServiceServerMockWatchNamespaceLatestModel{mock: m}
	m.WatchNamespaceLatestModelMock.callArgs = []*ModelPublicServiceServerMockWatchNamespaceLatestModelParams{}

	m.WatchNamespaceModelMock = mModelPublicServiceServerMockWatchNamespaceModel{mock: m}
	m.WatchNamespaceModelMock.callArgs = []*ModelPublicServiceServerMockWatchNamespaceModelParams{}

	m.WatchOrganizationLatestModelMock = mModelPublicServiceServerMockWatchOrganizationLatestModel{mock: m}
	m.WatchOrganizationLatestModelMock.callArgs = []*ModelPublicServiceServerMockWatchOrganizationLatestModelParams{}

	m.WatchOrganizationModelMock = mModelPublicServiceServerMockWatchOrganizationModel{mock: m}
	m.WatchOrganizationModelMock.callArgs = []*ModelPublicServiceServerMockWatchOrganizationModelParams{}

	m.WatchUserLatestModelMock = mModelPublicServiceServerMockWatchUserLatestModel{mock: m}
	m.WatchUserLatestModelMock.callArgs = []*ModelPublicServiceServerMockWatchUserLatestModelParams{}

	m.WatchUserModelMock = mModelPublicServiceServerMockWatchUserModel{mock: m}
	m.WatchUserModelMock.callArgs = []*ModelPublicServiceServerMockWatchUserModelParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mModelPublicServiceServerMockCreateNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockCreateNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockCreateNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockCreateNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockCreateNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.CreateNamespaceModel
type ModelPublicServiceServerMockCreateNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockCreateNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockCreateNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockCreateNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockCreateNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockCreateNamespaceModelParams contains parameters of the ModelPublicServiceServer.CreateNamespaceModel
type ModelPublicServiceServerMockCreateNamespaceModelParams struct {
	ctx context.Context
	cp1 *mm_modelv1alpha.CreateNamespaceModelRequest
}

// ModelPublicServiceServerMockCreateNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.CreateNamespaceModel
type ModelPublicServiceServerMockCreateNamespaceModelParamPtrs struct {
	ctx *context.Context
	cp1 **mm_modelv1alpha.CreateNamespaceModelRequest
}

// ModelPublicServiceServerMockCreateNamespaceModelResults contains results of the ModelPublicServiceServer.CreateNamespaceModel
type ModelPublicServiceServerMockCreateNamespaceModelResults struct {
	cp2 *mm_modelv1alpha.CreateNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockCreateNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.CreateNamespaceModel
type ModelPublicServiceServerMockCreateNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) Optional() *mModelPublicServiceServerMockCreateNamespaceModel {
	mmCreateNamespaceModel.optional = true
	return mmCreateNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.CreateNamespaceModel
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) Expect(ctx context.Context, cp1 *mm_modelv1alpha.CreateNamespaceModelRequest) *mModelPublicServiceServerMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockCreateNamespaceModelParams{ctx, cp1}
	mmCreateNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespaceModel.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceModel.defaultExpectation.params) {
			mmCreateNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceModel.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.CreateNamespaceModel
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespaceModel
}

// ExpectCp1Param2 sets up expected param cp1 for ModelPublicServiceServer.CreateNamespaceModel
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) ExpectCp1Param2(cp1 *mm_modelv1alpha.CreateNamespaceModelRequest) *mModelPublicServiceServerMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateNamespaceModel.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.CreateNamespaceModel
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) Inspect(f func(ctx context.Context, cp1 *mm_modelv1alpha.CreateNamespaceModelRequest)) *mModelPublicServiceServerMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.inspectFuncCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.CreateNamespaceModel")
	}

	mmCreateNamespaceModel.mock.inspectFuncCreateNamespaceModel = f

	return mmCreateNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.CreateNamespaceModel
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) Return(cp2 *mm_modelv1alpha.CreateNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockCreateNamespaceModelExpectation{mock: mmCreateNamespaceModel.mock}
	}
	mmCreateNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockCreateNamespaceModelResults{cp2, err}
	mmCreateNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.CreateNamespaceModel method
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) Set(f func(ctx context.Context, cp1 *mm_modelv1alpha.CreateNamespaceModelRequest) (cp2 *mm_modelv1alpha.CreateNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmCreateNamespaceModel.defaultExpectation != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.CreateNamespaceModel method")
	}

	if len(mmCreateNamespaceModel.expectations) > 0 {
		mmCreateNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.CreateNamespaceModel method")
	}

	mmCreateNamespaceModel.mock.funcCreateNamespaceModel = f
	mmCreateNamespaceModel.mock.funcCreateNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.CreateNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) When(ctx context.Context, cp1 *mm_modelv1alpha.CreateNamespaceModelRequest) *ModelPublicServiceServerMockCreateNamespaceModelExpectation {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockCreateNamespaceModelExpectation{
		mock:               mmCreateNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockCreateNamespaceModelParams{ctx, cp1},
		expectationOrigins: ModelPublicServiceServerMockCreateNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespaceModel.expectations = append(mmCreateNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.CreateNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockCreateNamespaceModelExpectation) Then(cp2 *mm_modelv1alpha.CreateNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockCreateNamespaceModelResults{cp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.CreateNamespaceModel should be invoked
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockCreateNamespaceModel {
	if n == 0 {
		mmCreateNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.CreateNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceModel.expectedInvocations, n)
	mmCreateNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceModel
}

func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) invocationsDone() bool {
	if len(mmCreateNamespaceModel.expectations) == 0 && mmCreateNamespaceModel.defaultExpectation == nil && mmCreateNamespaceModel.mock.funcCreateNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceModel.mock.afterCreateNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmCreateNamespaceModel *ModelPublicServiceServerMock) CreateNamespaceModel(ctx context.Context, cp1 *mm_modelv1alpha.CreateNamespaceModelRequest) (cp2 *mm_modelv1alpha.CreateNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceModel.beforeCreateNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceModel.afterCreateNamespaceModelCounter, 1)

	mmCreateNamespaceModel.t.Helper()

	if mmCreateNamespaceModel.inspectFuncCreateNamespaceModel != nil {
		mmCreateNamespaceModel.inspectFuncCreateNamespaceModel(ctx, cp1)
	}

	mm_params := ModelPublicServiceServerMockCreateNamespaceModelParams{ctx, cp1}

	// Record call args
	mmCreateNamespaceModel.CreateNamespaceModelMock.mutex.Lock()
	mmCreateNamespaceModel.CreateNamespaceModelMock.callArgs = append(mmCreateNamespaceModel.CreateNamespaceModelMock.callArgs, &mm_params)
	mmCreateNamespaceModel.CreateNamespaceModelMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceModel.CreateNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockCreateNamespaceModelParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceModel.t.Errorf("ModelPublicServiceServerMock.CreateNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateNamespaceModel.t.Errorf("ModelPublicServiceServerMock.CreateNamespaceModel got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceModel.t.Errorf("ModelPublicServiceServerMock.CreateNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.CreateNamespaceModel")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateNamespaceModel.funcCreateNamespaceModel != nil {
		return mmCreateNamespaceModel.funcCreateNamespaceModel(ctx, cp1)
	}
	mmCreateNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.CreateNamespaceModel. %v %v", ctx, cp1)
	return
}

// CreateNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.CreateNamespaceModel invocations
func (mmCreateNamespaceModel *ModelPublicServiceServerMock) CreateNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceModel.afterCreateNamespaceModelCounter)
}

// CreateNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.CreateNamespaceModel invocations
func (mmCreateNamespaceModel *ModelPublicServiceServerMock) CreateNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceModel.beforeCreateNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.CreateNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceModel *mModelPublicServiceServerMockCreateNamespaceModel) Calls() []*ModelPublicServiceServerMockCreateNamespaceModelParams {
	mmCreateNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockCreateNamespaceModelParams, len(mmCreateNamespaceModel.callArgs))
	copy(argCopy, mmCreateNamespaceModel.callArgs)

	mmCreateNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceModelDone returns true if the count of the CreateNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockCreateNamespaceModelDone() bool {
	if m.CreateNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceModelMock.invocationsDone()
}

// MinimockCreateNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockCreateNamespaceModelInspect() {
	for _, e := range m.CreateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceModelMock.defaultExpectation != nil && afterCreateNamespaceModelCounter < 1 {
		if m.CreateNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateNamespaceModel at\n%s", m.CreateNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateNamespaceModel at\n%s with params: %#v", m.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceModel != nil && afterCreateNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateNamespaceModel at\n%s", m.funcCreateNamespaceModelOrigin)
	}

	if !m.CreateNamespaceModelMock.invocationsDone() && afterCreateNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.CreateNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceModelMock.expectedInvocations), m.CreateNamespaceModelMock.expectedInvocationsOrigin, afterCreateNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockCreateOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockCreateOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockCreateOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockCreateOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockCreateOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.CreateOrganizationModel
type ModelPublicServiceServerMockCreateOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockCreateOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockCreateOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockCreateOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockCreateOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockCreateOrganizationModelParams contains parameters of the ModelPublicServiceServer.CreateOrganizationModel
type ModelPublicServiceServerMockCreateOrganizationModelParams struct {
	ctx context.Context
	cp1 *mm_modelv1alpha.CreateOrganizationModelRequest
}

// ModelPublicServiceServerMockCreateOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.CreateOrganizationModel
type ModelPublicServiceServerMockCreateOrganizationModelParamPtrs struct {
	ctx *context.Context
	cp1 **mm_modelv1alpha.CreateOrganizationModelRequest
}

// ModelPublicServiceServerMockCreateOrganizationModelResults contains results of the ModelPublicServiceServer.CreateOrganizationModel
type ModelPublicServiceServerMockCreateOrganizationModelResults struct {
	cp2 *mm_modelv1alpha.CreateOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockCreateOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.CreateOrganizationModel
type ModelPublicServiceServerMockCreateOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) Optional() *mModelPublicServiceServerMockCreateOrganizationModel {
	mmCreateOrganizationModel.optional = true
	return mmCreateOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.CreateOrganizationModel
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) Expect(ctx context.Context, cp1 *mm_modelv1alpha.CreateOrganizationModelRequest) *mModelPublicServiceServerMockCreateOrganizationModel {
	if mmCreateOrganizationModel.mock.funcCreateOrganizationModel != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by Set")
	}

	if mmCreateOrganizationModel.defaultExpectation == nil {
		mmCreateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockCreateOrganizationModelExpectation{}
	}

	if mmCreateOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by ExpectParams functions")
	}

	mmCreateOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockCreateOrganizationModelParams{ctx, cp1}
	mmCreateOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrganizationModel.expectations {
		if minimock.Equal(e.params, mmCreateOrganizationModel.defaultExpectation.params) {
			mmCreateOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrganizationModel.defaultExpectation.params)
		}
	}

	return mmCreateOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.CreateOrganizationModel
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockCreateOrganizationModel {
	if mmCreateOrganizationModel.mock.funcCreateOrganizationModel != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by Set")
	}

	if mmCreateOrganizationModel.defaultExpectation == nil {
		mmCreateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockCreateOrganizationModelExpectation{}
	}

	if mmCreateOrganizationModel.defaultExpectation.params != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by Expect")
	}

	if mmCreateOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmCreateOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockCreateOrganizationModelParamPtrs{}
	}
	mmCreateOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrganizationModel
}

// ExpectCp1Param2 sets up expected param cp1 for ModelPublicServiceServer.CreateOrganizationModel
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) ExpectCp1Param2(cp1 *mm_modelv1alpha.CreateOrganizationModelRequest) *mModelPublicServiceServerMockCreateOrganizationModel {
	if mmCreateOrganizationModel.mock.funcCreateOrganizationModel != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by Set")
	}

	if mmCreateOrganizationModel.defaultExpectation == nil {
		mmCreateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockCreateOrganizationModelExpectation{}
	}

	if mmCreateOrganizationModel.defaultExpectation.params != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by Expect")
	}

	if mmCreateOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmCreateOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockCreateOrganizationModelParamPtrs{}
	}
	mmCreateOrganizationModel.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateOrganizationModel.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.CreateOrganizationModel
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) Inspect(f func(ctx context.Context, cp1 *mm_modelv1alpha.CreateOrganizationModelRequest)) *mModelPublicServiceServerMockCreateOrganizationModel {
	if mmCreateOrganizationModel.mock.inspectFuncCreateOrganizationModel != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.CreateOrganizationModel")
	}

	mmCreateOrganizationModel.mock.inspectFuncCreateOrganizationModel = f

	return mmCreateOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.CreateOrganizationModel
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) Return(cp2 *mm_modelv1alpha.CreateOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmCreateOrganizationModel.mock.funcCreateOrganizationModel != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by Set")
	}

	if mmCreateOrganizationModel.defaultExpectation == nil {
		mmCreateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockCreateOrganizationModelExpectation{mock: mmCreateOrganizationModel.mock}
	}
	mmCreateOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockCreateOrganizationModelResults{cp2, err}
	mmCreateOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.CreateOrganizationModel method
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) Set(f func(ctx context.Context, cp1 *mm_modelv1alpha.CreateOrganizationModelRequest) (cp2 *mm_modelv1alpha.CreateOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmCreateOrganizationModel.defaultExpectation != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.CreateOrganizationModel method")
	}

	if len(mmCreateOrganizationModel.expectations) > 0 {
		mmCreateOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.CreateOrganizationModel method")
	}

	mmCreateOrganizationModel.mock.funcCreateOrganizationModel = f
	mmCreateOrganizationModel.mock.funcCreateOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmCreateOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.CreateOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) When(ctx context.Context, cp1 *mm_modelv1alpha.CreateOrganizationModelRequest) *ModelPublicServiceServerMockCreateOrganizationModelExpectation {
	if mmCreateOrganizationModel.mock.funcCreateOrganizationModel != nil {
		mmCreateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockCreateOrganizationModelExpectation{
		mock:               mmCreateOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockCreateOrganizationModelParams{ctx, cp1},
		expectationOrigins: ModelPublicServiceServerMockCreateOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrganizationModel.expectations = append(mmCreateOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.CreateOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockCreateOrganizationModelExpectation) Then(cp2 *mm_modelv1alpha.CreateOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockCreateOrganizationModelResults{cp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.CreateOrganizationModel should be invoked
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockCreateOrganizationModel {
	if n == 0 {
		mmCreateOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.CreateOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrganizationModel.expectedInvocations, n)
	mmCreateOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrganizationModel
}

func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) invocationsDone() bool {
	if len(mmCreateOrganizationModel.expectations) == 0 && mmCreateOrganizationModel.defaultExpectation == nil && mmCreateOrganizationModel.mock.funcCreateOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrganizationModel.mock.afterCreateOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmCreateOrganizationModel *ModelPublicServiceServerMock) CreateOrganizationModel(ctx context.Context, cp1 *mm_modelv1alpha.CreateOrganizationModelRequest) (cp2 *mm_modelv1alpha.CreateOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmCreateOrganizationModel.beforeCreateOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrganizationModel.afterCreateOrganizationModelCounter, 1)

	mmCreateOrganizationModel.t.Helper()

	if mmCreateOrganizationModel.inspectFuncCreateOrganizationModel != nil {
		mmCreateOrganizationModel.inspectFuncCreateOrganizationModel(ctx, cp1)
	}

	mm_params := ModelPublicServiceServerMockCreateOrganizationModelParams{ctx, cp1}

	// Record call args
	mmCreateOrganizationModel.CreateOrganizationModelMock.mutex.Lock()
	mmCreateOrganizationModel.CreateOrganizationModelMock.callArgs = append(mmCreateOrganizationModel.CreateOrganizationModelMock.callArgs, &mm_params)
	mmCreateOrganizationModel.CreateOrganizationModelMock.mutex.Unlock()

	for _, e := range mmCreateOrganizationModel.CreateOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockCreateOrganizationModelParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrganizationModel.t.Errorf("ModelPublicServiceServerMock.CreateOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateOrganizationModel.t.Errorf("ModelPublicServiceServerMock.CreateOrganizationModel got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrganizationModel.t.Errorf("ModelPublicServiceServerMock.CreateOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrganizationModel.CreateOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.CreateOrganizationModel")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateOrganizationModel.funcCreateOrganizationModel != nil {
		return mmCreateOrganizationModel.funcCreateOrganizationModel(ctx, cp1)
	}
	mmCreateOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.CreateOrganizationModel. %v %v", ctx, cp1)
	return
}

// CreateOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.CreateOrganizationModel invocations
func (mmCreateOrganizationModel *ModelPublicServiceServerMock) CreateOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrganizationModel.afterCreateOrganizationModelCounter)
}

// CreateOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.CreateOrganizationModel invocations
func (mmCreateOrganizationModel *ModelPublicServiceServerMock) CreateOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrganizationModel.beforeCreateOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.CreateOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrganizationModel *mModelPublicServiceServerMockCreateOrganizationModel) Calls() []*ModelPublicServiceServerMockCreateOrganizationModelParams {
	mmCreateOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockCreateOrganizationModelParams, len(mmCreateOrganizationModel.callArgs))
	copy(argCopy, mmCreateOrganizationModel.callArgs)

	mmCreateOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrganizationModelDone returns true if the count of the CreateOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockCreateOrganizationModelDone() bool {
	if m.CreateOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrganizationModelMock.invocationsDone()
}

// MinimockCreateOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockCreateOrganizationModelInspect() {
	for _, e := range m.CreateOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterCreateOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrganizationModelMock.defaultExpectation != nil && afterCreateOrganizationModelCounter < 1 {
		if m.CreateOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateOrganizationModel at\n%s", m.CreateOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateOrganizationModel at\n%s with params: %#v", m.CreateOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrganizationModel != nil && afterCreateOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateOrganizationModel at\n%s", m.funcCreateOrganizationModelOrigin)
	}

	if !m.CreateOrganizationModelMock.invocationsDone() && afterCreateOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.CreateOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrganizationModelMock.expectedInvocations), m.CreateOrganizationModelMock.expectedInvocationsOrigin, afterCreateOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockCreateUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockCreateUserModelExpectation
	expectations       []*ModelPublicServiceServerMockCreateUserModelExpectation

	callArgs []*ModelPublicServiceServerMockCreateUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockCreateUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.CreateUserModel
type ModelPublicServiceServerMockCreateUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockCreateUserModelParams
	paramPtrs          *ModelPublicServiceServerMockCreateUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockCreateUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockCreateUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockCreateUserModelParams contains parameters of the ModelPublicServiceServer.CreateUserModel
type ModelPublicServiceServerMockCreateUserModelParams struct {
	ctx context.Context
	cp1 *mm_modelv1alpha.CreateUserModelRequest
}

// ModelPublicServiceServerMockCreateUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.CreateUserModel
type ModelPublicServiceServerMockCreateUserModelParamPtrs struct {
	ctx *context.Context
	cp1 **mm_modelv1alpha.CreateUserModelRequest
}

// ModelPublicServiceServerMockCreateUserModelResults contains results of the ModelPublicServiceServer.CreateUserModel
type ModelPublicServiceServerMockCreateUserModelResults struct {
	cp2 *mm_modelv1alpha.CreateUserModelResponse
	err error
}

// ModelPublicServiceServerMockCreateUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.CreateUserModel
type ModelPublicServiceServerMockCreateUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) Optional() *mModelPublicServiceServerMockCreateUserModel {
	mmCreateUserModel.optional = true
	return mmCreateUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.CreateUserModel
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) Expect(ctx context.Context, cp1 *mm_modelv1alpha.CreateUserModelRequest) *mModelPublicServiceServerMockCreateUserModel {
	if mmCreateUserModel.mock.funcCreateUserModel != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by Set")
	}

	if mmCreateUserModel.defaultExpectation == nil {
		mmCreateUserModel.defaultExpectation = &ModelPublicServiceServerMockCreateUserModelExpectation{}
	}

	if mmCreateUserModel.defaultExpectation.paramPtrs != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by ExpectParams functions")
	}

	mmCreateUserModel.defaultExpectation.params = &ModelPublicServiceServerMockCreateUserModelParams{ctx, cp1}
	mmCreateUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUserModel.expectations {
		if minimock.Equal(e.params, mmCreateUserModel.defaultExpectation.params) {
			mmCreateUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUserModel.defaultExpectation.params)
		}
	}

	return mmCreateUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.CreateUserModel
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockCreateUserModel {
	if mmCreateUserModel.mock.funcCreateUserModel != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by Set")
	}

	if mmCreateUserModel.defaultExpectation == nil {
		mmCreateUserModel.defaultExpectation = &ModelPublicServiceServerMockCreateUserModelExpectation{}
	}

	if mmCreateUserModel.defaultExpectation.params != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by Expect")
	}

	if mmCreateUserModel.defaultExpectation.paramPtrs == nil {
		mmCreateUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockCreateUserModelParamPtrs{}
	}
	mmCreateUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUserModel
}

// ExpectCp1Param2 sets up expected param cp1 for ModelPublicServiceServer.CreateUserModel
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) ExpectCp1Param2(cp1 *mm_modelv1alpha.CreateUserModelRequest) *mModelPublicServiceServerMockCreateUserModel {
	if mmCreateUserModel.mock.funcCreateUserModel != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by Set")
	}

	if mmCreateUserModel.defaultExpectation == nil {
		mmCreateUserModel.defaultExpectation = &ModelPublicServiceServerMockCreateUserModelExpectation{}
	}

	if mmCreateUserModel.defaultExpectation.params != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by Expect")
	}

	if mmCreateUserModel.defaultExpectation.paramPtrs == nil {
		mmCreateUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockCreateUserModelParamPtrs{}
	}
	mmCreateUserModel.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateUserModel.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.CreateUserModel
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) Inspect(f func(ctx context.Context, cp1 *mm_modelv1alpha.CreateUserModelRequest)) *mModelPublicServiceServerMockCreateUserModel {
	if mmCreateUserModel.mock.inspectFuncCreateUserModel != nil {
		mmCreateUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.CreateUserModel")
	}

	mmCreateUserModel.mock.inspectFuncCreateUserModel = f

	return mmCreateUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.CreateUserModel
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) Return(cp2 *mm_modelv1alpha.CreateUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmCreateUserModel.mock.funcCreateUserModel != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by Set")
	}

	if mmCreateUserModel.defaultExpectation == nil {
		mmCreateUserModel.defaultExpectation = &ModelPublicServiceServerMockCreateUserModelExpectation{mock: mmCreateUserModel.mock}
	}
	mmCreateUserModel.defaultExpectation.results = &ModelPublicServiceServerMockCreateUserModelResults{cp2, err}
	mmCreateUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.CreateUserModel method
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) Set(f func(ctx context.Context, cp1 *mm_modelv1alpha.CreateUserModelRequest) (cp2 *mm_modelv1alpha.CreateUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmCreateUserModel.defaultExpectation != nil {
		mmCreateUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.CreateUserModel method")
	}

	if len(mmCreateUserModel.expectations) > 0 {
		mmCreateUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.CreateUserModel method")
	}

	mmCreateUserModel.mock.funcCreateUserModel = f
	mmCreateUserModel.mock.funcCreateUserModelOrigin = minimock.CallerInfo(1)
	return mmCreateUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.CreateUserModel which will trigger the result defined by the following
// Then helper
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) When(ctx context.Context, cp1 *mm_modelv1alpha.CreateUserModelRequest) *ModelPublicServiceServerMockCreateUserModelExpectation {
	if mmCreateUserModel.mock.funcCreateUserModel != nil {
		mmCreateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.CreateUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockCreateUserModelExpectation{
		mock:               mmCreateUserModel.mock,
		params:             &ModelPublicServiceServerMockCreateUserModelParams{ctx, cp1},
		expectationOrigins: ModelPublicServiceServerMockCreateUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUserModel.expectations = append(mmCreateUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.CreateUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockCreateUserModelExpectation) Then(cp2 *mm_modelv1alpha.CreateUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockCreateUserModelResults{cp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.CreateUserModel should be invoked
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) Times(n uint64) *mModelPublicServiceServerMockCreateUserModel {
	if n == 0 {
		mmCreateUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.CreateUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUserModel.expectedInvocations, n)
	mmCreateUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUserModel
}

func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) invocationsDone() bool {
	if len(mmCreateUserModel.expectations) == 0 && mmCreateUserModel.defaultExpectation == nil && mmCreateUserModel.mock.funcCreateUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUserModel.mock.afterCreateUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmCreateUserModel *ModelPublicServiceServerMock) CreateUserModel(ctx context.Context, cp1 *mm_modelv1alpha.CreateUserModelRequest) (cp2 *mm_modelv1alpha.CreateUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmCreateUserModel.beforeCreateUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUserModel.afterCreateUserModelCounter, 1)

	mmCreateUserModel.t.Helper()

	if mmCreateUserModel.inspectFuncCreateUserModel != nil {
		mmCreateUserModel.inspectFuncCreateUserModel(ctx, cp1)
	}

	mm_params := ModelPublicServiceServerMockCreateUserModelParams{ctx, cp1}

	// Record call args
	mmCreateUserModel.CreateUserModelMock.mutex.Lock()
	mmCreateUserModel.CreateUserModelMock.callArgs = append(mmCreateUserModel.CreateUserModelMock.callArgs, &mm_params)
	mmCreateUserModel.CreateUserModelMock.mutex.Unlock()

	for _, e := range mmCreateUserModel.CreateUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateUserModel.CreateUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUserModel.CreateUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUserModel.CreateUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUserModel.CreateUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockCreateUserModelParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUserModel.t.Errorf("ModelPublicServiceServerMock.CreateUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUserModel.CreateUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateUserModel.t.Errorf("ModelPublicServiceServerMock.CreateUserModel got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUserModel.CreateUserModelMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUserModel.t.Errorf("ModelPublicServiceServerMock.CreateUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUserModel.CreateUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUserModel.CreateUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.CreateUserModel")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateUserModel.funcCreateUserModel != nil {
		return mmCreateUserModel.funcCreateUserModel(ctx, cp1)
	}
	mmCreateUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.CreateUserModel. %v %v", ctx, cp1)
	return
}

// CreateUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.CreateUserModel invocations
func (mmCreateUserModel *ModelPublicServiceServerMock) CreateUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserModel.afterCreateUserModelCounter)
}

// CreateUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.CreateUserModel invocations
func (mmCreateUserModel *ModelPublicServiceServerMock) CreateUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUserModel.beforeCreateUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.CreateUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUserModel *mModelPublicServiceServerMockCreateUserModel) Calls() []*ModelPublicServiceServerMockCreateUserModelParams {
	mmCreateUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockCreateUserModelParams, len(mmCreateUserModel.callArgs))
	copy(argCopy, mmCreateUserModel.callArgs)

	mmCreateUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserModelDone returns true if the count of the CreateUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockCreateUserModelDone() bool {
	if m.CreateUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserModelMock.invocationsDone()
}

// MinimockCreateUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockCreateUserModelInspect() {
	for _, e := range m.CreateUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserModelCounter := mm_atomic.LoadUint64(&m.afterCreateUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserModelMock.defaultExpectation != nil && afterCreateUserModelCounter < 1 {
		if m.CreateUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateUserModel at\n%s", m.CreateUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateUserModel at\n%s with params: %#v", m.CreateUserModelMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUserModel != nil && afterCreateUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.CreateUserModel at\n%s", m.funcCreateUserModelOrigin)
	}

	if !m.CreateUserModelMock.invocationsDone() && afterCreateUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.CreateUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserModelMock.expectedInvocations), m.CreateUserModelMock.expectedInvocationsOrigin, afterCreateUserModelCounter)
	}
}

type mModelPublicServiceServerMockDeleteNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockDeleteNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockDeleteNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockDeleteNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockDeleteNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.DeleteNamespaceModel
type ModelPublicServiceServerMockDeleteNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockDeleteNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockDeleteNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockDeleteNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockDeleteNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockDeleteNamespaceModelParams contains parameters of the ModelPublicServiceServer.DeleteNamespaceModel
type ModelPublicServiceServerMockDeleteNamespaceModelParams struct {
	ctx context.Context
	dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest
}

// ModelPublicServiceServerMockDeleteNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.DeleteNamespaceModel
type ModelPublicServiceServerMockDeleteNamespaceModelParamPtrs struct {
	ctx *context.Context
	dp1 **mm_modelv1alpha.DeleteNamespaceModelRequest
}

// ModelPublicServiceServerMockDeleteNamespaceModelResults contains results of the ModelPublicServiceServer.DeleteNamespaceModel
type ModelPublicServiceServerMockDeleteNamespaceModelResults struct {
	dp2 *mm_modelv1alpha.DeleteNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockDeleteNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.DeleteNamespaceModel
type ModelPublicServiceServerMockDeleteNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) Optional() *mModelPublicServiceServerMockDeleteNamespaceModel {
	mmDeleteNamespaceModel.optional = true
	return mmDeleteNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.DeleteNamespaceModel
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) Expect(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest) *mModelPublicServiceServerMockDeleteNamespaceModel {
	if mmDeleteNamespaceModel.mock.funcDeleteNamespaceModel != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by Set")
	}

	if mmDeleteNamespaceModel.defaultExpectation == nil {
		mmDeleteNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelExpectation{}
	}

	if mmDeleteNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockDeleteNamespaceModelParams{ctx, dp1}
	mmDeleteNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespaceModel.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceModel.defaultExpectation.params) {
			mmDeleteNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceModel.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.DeleteNamespaceModel
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockDeleteNamespaceModel {
	if mmDeleteNamespaceModel.mock.funcDeleteNamespaceModel != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by Set")
	}

	if mmDeleteNamespaceModel.defaultExpectation == nil {
		mmDeleteNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelExpectation{}
	}

	if mmDeleteNamespaceModel.defaultExpectation.params != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by Expect")
	}

	if mmDeleteNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteNamespaceModelParamPtrs{}
	}
	mmDeleteNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespaceModel
}

// ExpectDp1Param2 sets up expected param dp1 for ModelPublicServiceServer.DeleteNamespaceModel
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) ExpectDp1Param2(dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest) *mModelPublicServiceServerMockDeleteNamespaceModel {
	if mmDeleteNamespaceModel.mock.funcDeleteNamespaceModel != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by Set")
	}

	if mmDeleteNamespaceModel.defaultExpectation == nil {
		mmDeleteNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelExpectation{}
	}

	if mmDeleteNamespaceModel.defaultExpectation.params != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by Expect")
	}

	if mmDeleteNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteNamespaceModelParamPtrs{}
	}
	mmDeleteNamespaceModel.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteNamespaceModel.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.DeleteNamespaceModel
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) Inspect(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest)) *mModelPublicServiceServerMockDeleteNamespaceModel {
	if mmDeleteNamespaceModel.mock.inspectFuncDeleteNamespaceModel != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.DeleteNamespaceModel")
	}

	mmDeleteNamespaceModel.mock.inspectFuncDeleteNamespaceModel = f

	return mmDeleteNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.DeleteNamespaceModel
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) Return(dp2 *mm_modelv1alpha.DeleteNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmDeleteNamespaceModel.mock.funcDeleteNamespaceModel != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by Set")
	}

	if mmDeleteNamespaceModel.defaultExpectation == nil {
		mmDeleteNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelExpectation{mock: mmDeleteNamespaceModel.mock}
	}
	mmDeleteNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockDeleteNamespaceModelResults{dp2, err}
	mmDeleteNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.DeleteNamespaceModel method
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) Set(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest) (dp2 *mm_modelv1alpha.DeleteNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmDeleteNamespaceModel.defaultExpectation != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.DeleteNamespaceModel method")
	}

	if len(mmDeleteNamespaceModel.expectations) > 0 {
		mmDeleteNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.DeleteNamespaceModel method")
	}

	mmDeleteNamespaceModel.mock.funcDeleteNamespaceModel = f
	mmDeleteNamespaceModel.mock.funcDeleteNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.DeleteNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) When(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest) *ModelPublicServiceServerMockDeleteNamespaceModelExpectation {
	if mmDeleteNamespaceModel.mock.funcDeleteNamespaceModel != nil {
		mmDeleteNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockDeleteNamespaceModelExpectation{
		mock:               mmDeleteNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockDeleteNamespaceModelParams{ctx, dp1},
		expectationOrigins: ModelPublicServiceServerMockDeleteNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespaceModel.expectations = append(mmDeleteNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.DeleteNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockDeleteNamespaceModelExpectation) Then(dp2 *mm_modelv1alpha.DeleteNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockDeleteNamespaceModelResults{dp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.DeleteNamespaceModel should be invoked
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockDeleteNamespaceModel {
	if n == 0 {
		mmDeleteNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.DeleteNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceModel.expectedInvocations, n)
	mmDeleteNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModel
}

func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) invocationsDone() bool {
	if len(mmDeleteNamespaceModel.expectations) == 0 && mmDeleteNamespaceModel.defaultExpectation == nil && mmDeleteNamespaceModel.mock.funcDeleteNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModel.mock.afterDeleteNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmDeleteNamespaceModel *ModelPublicServiceServerMock) DeleteNamespaceModel(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelRequest) (dp2 *mm_modelv1alpha.DeleteNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceModel.beforeDeleteNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceModel.afterDeleteNamespaceModelCounter, 1)

	mmDeleteNamespaceModel.t.Helper()

	if mmDeleteNamespaceModel.inspectFuncDeleteNamespaceModel != nil {
		mmDeleteNamespaceModel.inspectFuncDeleteNamespaceModel(ctx, dp1)
	}

	mm_params := ModelPublicServiceServerMockDeleteNamespaceModelParams{ctx, dp1}

	// Record call args
	mmDeleteNamespaceModel.DeleteNamespaceModelMock.mutex.Lock()
	mmDeleteNamespaceModel.DeleteNamespaceModelMock.callArgs = append(mmDeleteNamespaceModel.DeleteNamespaceModelMock.callArgs, &mm_params)
	mmDeleteNamespaceModel.DeleteNamespaceModelMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceModel.DeleteNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockDeleteNamespaceModelParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceModel.t.Errorf("ModelPublicServiceServerMock.DeleteNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteNamespaceModel.t.Errorf("ModelPublicServiceServerMock.DeleteNamespaceModel got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceModel.t.Errorf("ModelPublicServiceServerMock.DeleteNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceModel.DeleteNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.DeleteNamespaceModel")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteNamespaceModel.funcDeleteNamespaceModel != nil {
		return mmDeleteNamespaceModel.funcDeleteNamespaceModel(ctx, dp1)
	}
	mmDeleteNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.DeleteNamespaceModel. %v %v", ctx, dp1)
	return
}

// DeleteNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.DeleteNamespaceModel invocations
func (mmDeleteNamespaceModel *ModelPublicServiceServerMock) DeleteNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModel.afterDeleteNamespaceModelCounter)
}

// DeleteNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.DeleteNamespaceModel invocations
func (mmDeleteNamespaceModel *ModelPublicServiceServerMock) DeleteNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModel.beforeDeleteNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.DeleteNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceModel *mModelPublicServiceServerMockDeleteNamespaceModel) Calls() []*ModelPublicServiceServerMockDeleteNamespaceModelParams {
	mmDeleteNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockDeleteNamespaceModelParams, len(mmDeleteNamespaceModel.callArgs))
	copy(argCopy, mmDeleteNamespaceModel.callArgs)

	mmDeleteNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceModelDone returns true if the count of the DeleteNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockDeleteNamespaceModelDone() bool {
	if m.DeleteNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceModelMock.invocationsDone()
}

// MinimockDeleteNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockDeleteNamespaceModelInspect() {
	for _, e := range m.DeleteNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceModelMock.defaultExpectation != nil && afterDeleteNamespaceModelCounter < 1 {
		if m.DeleteNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModel at\n%s", m.DeleteNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModel at\n%s with params: %#v", m.DeleteNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceModel != nil && afterDeleteNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModel at\n%s", m.funcDeleteNamespaceModelOrigin)
	}

	if !m.DeleteNamespaceModelMock.invocationsDone() && afterDeleteNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.DeleteNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceModelMock.expectedInvocations), m.DeleteNamespaceModelMock.expectedInvocationsOrigin, afterDeleteNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockDeleteNamespaceModelVersion struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation
	expectations       []*ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation

	callArgs []*ModelPublicServiceServerMockDeleteNamespaceModelVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation specifies expectation struct of the ModelPublicServiceServer.DeleteNamespaceModelVersion
type ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockDeleteNamespaceModelVersionParams
	paramPtrs          *ModelPublicServiceServerMockDeleteNamespaceModelVersionParamPtrs
	expectationOrigins ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectationOrigins
	results            *ModelPublicServiceServerMockDeleteNamespaceModelVersionResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockDeleteNamespaceModelVersionParams contains parameters of the ModelPublicServiceServer.DeleteNamespaceModelVersion
type ModelPublicServiceServerMockDeleteNamespaceModelVersionParams struct {
	ctx context.Context
	dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest
}

// ModelPublicServiceServerMockDeleteNamespaceModelVersionParamPtrs contains pointers to parameters of the ModelPublicServiceServer.DeleteNamespaceModelVersion
type ModelPublicServiceServerMockDeleteNamespaceModelVersionParamPtrs struct {
	ctx *context.Context
	dp1 **mm_modelv1alpha.DeleteNamespaceModelVersionRequest
}

// ModelPublicServiceServerMockDeleteNamespaceModelVersionResults contains results of the ModelPublicServiceServer.DeleteNamespaceModelVersion
type ModelPublicServiceServerMockDeleteNamespaceModelVersionResults struct {
	dp2 *mm_modelv1alpha.DeleteNamespaceModelVersionResponse
	err error
}

// ModelPublicServiceServerMockDeleteNamespaceModelVersionOrigins contains origins of expectations of the ModelPublicServiceServer.DeleteNamespaceModelVersion
type ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) Optional() *mModelPublicServiceServerMockDeleteNamespaceModelVersion {
	mmDeleteNamespaceModelVersion.optional = true
	return mmDeleteNamespaceModelVersion
}

// Expect sets up expected params for ModelPublicServiceServer.DeleteNamespaceModelVersion
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) Expect(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest) *mModelPublicServiceServerMockDeleteNamespaceModelVersion {
	if mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersion != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by Set")
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation == nil {
		mmDeleteNamespaceModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation{}
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceModelVersion.defaultExpectation.params = &ModelPublicServiceServerMockDeleteNamespaceModelVersionParams{ctx, dp1}
	mmDeleteNamespaceModelVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespaceModelVersion.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceModelVersion.defaultExpectation.params) {
			mmDeleteNamespaceModelVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceModelVersion.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceModelVersion
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.DeleteNamespaceModelVersion
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockDeleteNamespaceModelVersion {
	if mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersion != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by Set")
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation == nil {
		mmDeleteNamespaceModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation{}
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation.params != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by Expect")
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelVersion.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteNamespaceModelVersionParamPtrs{}
	}
	mmDeleteNamespaceModelVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespaceModelVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespaceModelVersion
}

// ExpectDp1Param2 sets up expected param dp1 for ModelPublicServiceServer.DeleteNamespaceModelVersion
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) ExpectDp1Param2(dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest) *mModelPublicServiceServerMockDeleteNamespaceModelVersion {
	if mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersion != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by Set")
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation == nil {
		mmDeleteNamespaceModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation{}
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation.params != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by Expect")
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelVersion.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteNamespaceModelVersionParamPtrs{}
	}
	mmDeleteNamespaceModelVersion.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteNamespaceModelVersion.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteNamespaceModelVersion
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.DeleteNamespaceModelVersion
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) Inspect(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest)) *mModelPublicServiceServerMockDeleteNamespaceModelVersion {
	if mmDeleteNamespaceModelVersion.mock.inspectFuncDeleteNamespaceModelVersion != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.DeleteNamespaceModelVersion")
	}

	mmDeleteNamespaceModelVersion.mock.inspectFuncDeleteNamespaceModelVersion = f

	return mmDeleteNamespaceModelVersion
}

// Return sets up results that will be returned by ModelPublicServiceServer.DeleteNamespaceModelVersion
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) Return(dp2 *mm_modelv1alpha.DeleteNamespaceModelVersionResponse, err error) *ModelPublicServiceServerMock {
	if mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersion != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by Set")
	}

	if mmDeleteNamespaceModelVersion.defaultExpectation == nil {
		mmDeleteNamespaceModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation{mock: mmDeleteNamespaceModelVersion.mock}
	}
	mmDeleteNamespaceModelVersion.defaultExpectation.results = &ModelPublicServiceServerMockDeleteNamespaceModelVersionResults{dp2, err}
	mmDeleteNamespaceModelVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModelVersion.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.DeleteNamespaceModelVersion method
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) Set(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteNamespaceModelVersionResponse, err error)) *ModelPublicServiceServerMock {
	if mmDeleteNamespaceModelVersion.defaultExpectation != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.DeleteNamespaceModelVersion method")
	}

	if len(mmDeleteNamespaceModelVersion.expectations) > 0 {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.DeleteNamespaceModelVersion method")
	}

	mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersion = f
	mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersionOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModelVersion.mock
}

// When sets expectation for the ModelPublicServiceServer.DeleteNamespaceModelVersion which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) When(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest) *ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation {
	if mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersion != nil {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation{
		mock:               mmDeleteNamespaceModelVersion.mock,
		params:             &ModelPublicServiceServerMockDeleteNamespaceModelVersionParams{ctx, dp1},
		expectationOrigins: ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespaceModelVersion.expectations = append(mmDeleteNamespaceModelVersion.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.DeleteNamespaceModelVersion return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockDeleteNamespaceModelVersionExpectation) Then(dp2 *mm_modelv1alpha.DeleteNamespaceModelVersionResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockDeleteNamespaceModelVersionResults{dp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.DeleteNamespaceModelVersion should be invoked
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) Times(n uint64) *mModelPublicServiceServerMockDeleteNamespaceModelVersion {
	if n == 0 {
		mmDeleteNamespaceModelVersion.mock.t.Fatalf("Times of ModelPublicServiceServerMock.DeleteNamespaceModelVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceModelVersion.expectedInvocations, n)
	mmDeleteNamespaceModelVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModelVersion
}

func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) invocationsDone() bool {
	if len(mmDeleteNamespaceModelVersion.expectations) == 0 && mmDeleteNamespaceModelVersion.defaultExpectation == nil && mmDeleteNamespaceModelVersion.mock.funcDeleteNamespaceModelVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModelVersion.mock.afterDeleteNamespaceModelVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModelVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceModelVersion implements mm_modelv1alpha.ModelPublicServiceServer
func (mmDeleteNamespaceModelVersion *ModelPublicServiceServerMock) DeleteNamespaceModelVersion(ctx context.Context, dp1 *mm_modelv1alpha.DeleteNamespaceModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteNamespaceModelVersionResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceModelVersion.beforeDeleteNamespaceModelVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceModelVersion.afterDeleteNamespaceModelVersionCounter, 1)

	mmDeleteNamespaceModelVersion.t.Helper()

	if mmDeleteNamespaceModelVersion.inspectFuncDeleteNamespaceModelVersion != nil {
		mmDeleteNamespaceModelVersion.inspectFuncDeleteNamespaceModelVersion(ctx, dp1)
	}

	mm_params := ModelPublicServiceServerMockDeleteNamespaceModelVersionParams{ctx, dp1}

	// Record call args
	mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.mutex.Lock()
	mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.callArgs = append(mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.callArgs, &mm_params)
	mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockDeleteNamespaceModelVersionParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteNamespaceModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteNamespaceModelVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceModelVersion.DeleteNamespaceModelVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceModelVersion.t.Fatal("No results are set for the ModelPublicServiceServerMock.DeleteNamespaceModelVersion")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteNamespaceModelVersion.funcDeleteNamespaceModelVersion != nil {
		return mmDeleteNamespaceModelVersion.funcDeleteNamespaceModelVersion(ctx, dp1)
	}
	mmDeleteNamespaceModelVersion.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.DeleteNamespaceModelVersion. %v %v", ctx, dp1)
	return
}

// DeleteNamespaceModelVersionAfterCounter returns a count of finished ModelPublicServiceServerMock.DeleteNamespaceModelVersion invocations
func (mmDeleteNamespaceModelVersion *ModelPublicServiceServerMock) DeleteNamespaceModelVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModelVersion.afterDeleteNamespaceModelVersionCounter)
}

// DeleteNamespaceModelVersionBeforeCounter returns a count of ModelPublicServiceServerMock.DeleteNamespaceModelVersion invocations
func (mmDeleteNamespaceModelVersion *ModelPublicServiceServerMock) DeleteNamespaceModelVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModelVersion.beforeDeleteNamespaceModelVersionCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.DeleteNamespaceModelVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceModelVersion *mModelPublicServiceServerMockDeleteNamespaceModelVersion) Calls() []*ModelPublicServiceServerMockDeleteNamespaceModelVersionParams {
	mmDeleteNamespaceModelVersion.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockDeleteNamespaceModelVersionParams, len(mmDeleteNamespaceModelVersion.callArgs))
	copy(argCopy, mmDeleteNamespaceModelVersion.callArgs)

	mmDeleteNamespaceModelVersion.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceModelVersionDone returns true if the count of the DeleteNamespaceModelVersion invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockDeleteNamespaceModelVersionDone() bool {
	if m.DeleteNamespaceModelVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceModelVersionMock.invocationsDone()
}

// MinimockDeleteNamespaceModelVersionInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockDeleteNamespaceModelVersionInspect() {
	for _, e := range m.DeleteNamespaceModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModelVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespaceModelVersionCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceModelVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceModelVersionMock.defaultExpectation != nil && afterDeleteNamespaceModelVersionCounter < 1 {
		if m.DeleteNamespaceModelVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModelVersion at\n%s", m.DeleteNamespaceModelVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModelVersion at\n%s with params: %#v", m.DeleteNamespaceModelVersionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespaceModelVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceModelVersion != nil && afterDeleteNamespaceModelVersionCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteNamespaceModelVersion at\n%s", m.funcDeleteNamespaceModelVersionOrigin)
	}

	if !m.DeleteNamespaceModelVersionMock.invocationsDone() && afterDeleteNamespaceModelVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.DeleteNamespaceModelVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceModelVersionMock.expectedInvocations), m.DeleteNamespaceModelVersionMock.expectedInvocationsOrigin, afterDeleteNamespaceModelVersionCounter)
	}
}

type mModelPublicServiceServerMockDeleteOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockDeleteOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockDeleteOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockDeleteOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockDeleteOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.DeleteOrganizationModel
type ModelPublicServiceServerMockDeleteOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockDeleteOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockDeleteOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockDeleteOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockDeleteOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockDeleteOrganizationModelParams contains parameters of the ModelPublicServiceServer.DeleteOrganizationModel
type ModelPublicServiceServerMockDeleteOrganizationModelParams struct {
	ctx context.Context
	dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest
}

// ModelPublicServiceServerMockDeleteOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.DeleteOrganizationModel
type ModelPublicServiceServerMockDeleteOrganizationModelParamPtrs struct {
	ctx *context.Context
	dp1 **mm_modelv1alpha.DeleteOrganizationModelRequest
}

// ModelPublicServiceServerMockDeleteOrganizationModelResults contains results of the ModelPublicServiceServer.DeleteOrganizationModel
type ModelPublicServiceServerMockDeleteOrganizationModelResults struct {
	dp2 *mm_modelv1alpha.DeleteOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockDeleteOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.DeleteOrganizationModel
type ModelPublicServiceServerMockDeleteOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) Optional() *mModelPublicServiceServerMockDeleteOrganizationModel {
	mmDeleteOrganizationModel.optional = true
	return mmDeleteOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.DeleteOrganizationModel
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) Expect(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest) *mModelPublicServiceServerMockDeleteOrganizationModel {
	if mmDeleteOrganizationModel.mock.funcDeleteOrganizationModel != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by Set")
	}

	if mmDeleteOrganizationModel.defaultExpectation == nil {
		mmDeleteOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelExpectation{}
	}

	if mmDeleteOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by ExpectParams functions")
	}

	mmDeleteOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockDeleteOrganizationModelParams{ctx, dp1}
	mmDeleteOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrganizationModel.expectations {
		if minimock.Equal(e.params, mmDeleteOrganizationModel.defaultExpectation.params) {
			mmDeleteOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrganizationModel.defaultExpectation.params)
		}
	}

	return mmDeleteOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.DeleteOrganizationModel
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockDeleteOrganizationModel {
	if mmDeleteOrganizationModel.mock.funcDeleteOrganizationModel != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by Set")
	}

	if mmDeleteOrganizationModel.defaultExpectation == nil {
		mmDeleteOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelExpectation{}
	}

	if mmDeleteOrganizationModel.defaultExpectation.params != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by Expect")
	}

	if mmDeleteOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmDeleteOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteOrganizationModelParamPtrs{}
	}
	mmDeleteOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOrganizationModel
}

// ExpectDp1Param2 sets up expected param dp1 for ModelPublicServiceServer.DeleteOrganizationModel
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) ExpectDp1Param2(dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest) *mModelPublicServiceServerMockDeleteOrganizationModel {
	if mmDeleteOrganizationModel.mock.funcDeleteOrganizationModel != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by Set")
	}

	if mmDeleteOrganizationModel.defaultExpectation == nil {
		mmDeleteOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelExpectation{}
	}

	if mmDeleteOrganizationModel.defaultExpectation.params != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by Expect")
	}

	if mmDeleteOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmDeleteOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteOrganizationModelParamPtrs{}
	}
	mmDeleteOrganizationModel.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteOrganizationModel.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.DeleteOrganizationModel
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) Inspect(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest)) *mModelPublicServiceServerMockDeleteOrganizationModel {
	if mmDeleteOrganizationModel.mock.inspectFuncDeleteOrganizationModel != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.DeleteOrganizationModel")
	}

	mmDeleteOrganizationModel.mock.inspectFuncDeleteOrganizationModel = f

	return mmDeleteOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.DeleteOrganizationModel
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) Return(dp2 *mm_modelv1alpha.DeleteOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmDeleteOrganizationModel.mock.funcDeleteOrganizationModel != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by Set")
	}

	if mmDeleteOrganizationModel.defaultExpectation == nil {
		mmDeleteOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelExpectation{mock: mmDeleteOrganizationModel.mock}
	}
	mmDeleteOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockDeleteOrganizationModelResults{dp2, err}
	mmDeleteOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.DeleteOrganizationModel method
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) Set(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest) (dp2 *mm_modelv1alpha.DeleteOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmDeleteOrganizationModel.defaultExpectation != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.DeleteOrganizationModel method")
	}

	if len(mmDeleteOrganizationModel.expectations) > 0 {
		mmDeleteOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.DeleteOrganizationModel method")
	}

	mmDeleteOrganizationModel.mock.funcDeleteOrganizationModel = f
	mmDeleteOrganizationModel.mock.funcDeleteOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmDeleteOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.DeleteOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) When(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest) *ModelPublicServiceServerMockDeleteOrganizationModelExpectation {
	if mmDeleteOrganizationModel.mock.funcDeleteOrganizationModel != nil {
		mmDeleteOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockDeleteOrganizationModelExpectation{
		mock:               mmDeleteOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockDeleteOrganizationModelParams{ctx, dp1},
		expectationOrigins: ModelPublicServiceServerMockDeleteOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrganizationModel.expectations = append(mmDeleteOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.DeleteOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockDeleteOrganizationModelExpectation) Then(dp2 *mm_modelv1alpha.DeleteOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockDeleteOrganizationModelResults{dp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.DeleteOrganizationModel should be invoked
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockDeleteOrganizationModel {
	if n == 0 {
		mmDeleteOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.DeleteOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrganizationModel.expectedInvocations, n)
	mmDeleteOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrganizationModel
}

func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) invocationsDone() bool {
	if len(mmDeleteOrganizationModel.expectations) == 0 && mmDeleteOrganizationModel.defaultExpectation == nil && mmDeleteOrganizationModel.mock.funcDeleteOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrganizationModel.mock.afterDeleteOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmDeleteOrganizationModel *ModelPublicServiceServerMock) DeleteOrganizationModel(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelRequest) (dp2 *mm_modelv1alpha.DeleteOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteOrganizationModel.beforeDeleteOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrganizationModel.afterDeleteOrganizationModelCounter, 1)

	mmDeleteOrganizationModel.t.Helper()

	if mmDeleteOrganizationModel.inspectFuncDeleteOrganizationModel != nil {
		mmDeleteOrganizationModel.inspectFuncDeleteOrganizationModel(ctx, dp1)
	}

	mm_params := ModelPublicServiceServerMockDeleteOrganizationModelParams{ctx, dp1}

	// Record call args
	mmDeleteOrganizationModel.DeleteOrganizationModelMock.mutex.Lock()
	mmDeleteOrganizationModel.DeleteOrganizationModelMock.callArgs = append(mmDeleteOrganizationModel.DeleteOrganizationModelMock.callArgs, &mm_params)
	mmDeleteOrganizationModel.DeleteOrganizationModelMock.mutex.Unlock()

	for _, e := range mmDeleteOrganizationModel.DeleteOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockDeleteOrganizationModelParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrganizationModel.t.Errorf("ModelPublicServiceServerMock.DeleteOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteOrganizationModel.t.Errorf("ModelPublicServiceServerMock.DeleteOrganizationModel got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrganizationModel.t.Errorf("ModelPublicServiceServerMock.DeleteOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrganizationModel.DeleteOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.DeleteOrganizationModel")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteOrganizationModel.funcDeleteOrganizationModel != nil {
		return mmDeleteOrganizationModel.funcDeleteOrganizationModel(ctx, dp1)
	}
	mmDeleteOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.DeleteOrganizationModel. %v %v", ctx, dp1)
	return
}

// DeleteOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.DeleteOrganizationModel invocations
func (mmDeleteOrganizationModel *ModelPublicServiceServerMock) DeleteOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrganizationModel.afterDeleteOrganizationModelCounter)
}

// DeleteOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.DeleteOrganizationModel invocations
func (mmDeleteOrganizationModel *ModelPublicServiceServerMock) DeleteOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrganizationModel.beforeDeleteOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.DeleteOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrganizationModel *mModelPublicServiceServerMockDeleteOrganizationModel) Calls() []*ModelPublicServiceServerMockDeleteOrganizationModelParams {
	mmDeleteOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockDeleteOrganizationModelParams, len(mmDeleteOrganizationModel.callArgs))
	copy(argCopy, mmDeleteOrganizationModel.callArgs)

	mmDeleteOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrganizationModelDone returns true if the count of the DeleteOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockDeleteOrganizationModelDone() bool {
	if m.DeleteOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrganizationModelMock.invocationsDone()
}

// MinimockDeleteOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockDeleteOrganizationModelInspect() {
	for _, e := range m.DeleteOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterDeleteOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrganizationModelMock.defaultExpectation != nil && afterDeleteOrganizationModelCounter < 1 {
		if m.DeleteOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModel at\n%s", m.DeleteOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModel at\n%s with params: %#v", m.DeleteOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrganizationModel != nil && afterDeleteOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModel at\n%s", m.funcDeleteOrganizationModelOrigin)
	}

	if !m.DeleteOrganizationModelMock.invocationsDone() && afterDeleteOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.DeleteOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrganizationModelMock.expectedInvocations), m.DeleteOrganizationModelMock.expectedInvocationsOrigin, afterDeleteOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockDeleteOrganizationModelVersion struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation
	expectations       []*ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation

	callArgs []*ModelPublicServiceServerMockDeleteOrganizationModelVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation specifies expectation struct of the ModelPublicServiceServer.DeleteOrganizationModelVersion
type ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockDeleteOrganizationModelVersionParams
	paramPtrs          *ModelPublicServiceServerMockDeleteOrganizationModelVersionParamPtrs
	expectationOrigins ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectationOrigins
	results            *ModelPublicServiceServerMockDeleteOrganizationModelVersionResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockDeleteOrganizationModelVersionParams contains parameters of the ModelPublicServiceServer.DeleteOrganizationModelVersion
type ModelPublicServiceServerMockDeleteOrganizationModelVersionParams struct {
	ctx context.Context
	dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest
}

// ModelPublicServiceServerMockDeleteOrganizationModelVersionParamPtrs contains pointers to parameters of the ModelPublicServiceServer.DeleteOrganizationModelVersion
type ModelPublicServiceServerMockDeleteOrganizationModelVersionParamPtrs struct {
	ctx *context.Context
	dp1 **mm_modelv1alpha.DeleteOrganizationModelVersionRequest
}

// ModelPublicServiceServerMockDeleteOrganizationModelVersionResults contains results of the ModelPublicServiceServer.DeleteOrganizationModelVersion
type ModelPublicServiceServerMockDeleteOrganizationModelVersionResults struct {
	dp2 *mm_modelv1alpha.DeleteOrganizationModelVersionResponse
	err error
}

// ModelPublicServiceServerMockDeleteOrganizationModelVersionOrigins contains origins of expectations of the ModelPublicServiceServer.DeleteOrganizationModelVersion
type ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) Optional() *mModelPublicServiceServerMockDeleteOrganizationModelVersion {
	mmDeleteOrganizationModelVersion.optional = true
	return mmDeleteOrganizationModelVersion
}

// Expect sets up expected params for ModelPublicServiceServer.DeleteOrganizationModelVersion
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) Expect(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest) *mModelPublicServiceServerMockDeleteOrganizationModelVersion {
	if mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersion != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by Set")
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation == nil {
		mmDeleteOrganizationModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation{}
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation.paramPtrs != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by ExpectParams functions")
	}

	mmDeleteOrganizationModelVersion.defaultExpectation.params = &ModelPublicServiceServerMockDeleteOrganizationModelVersionParams{ctx, dp1}
	mmDeleteOrganizationModelVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteOrganizationModelVersion.expectations {
		if minimock.Equal(e.params, mmDeleteOrganizationModelVersion.defaultExpectation.params) {
			mmDeleteOrganizationModelVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrganizationModelVersion.defaultExpectation.params)
		}
	}

	return mmDeleteOrganizationModelVersion
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.DeleteOrganizationModelVersion
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockDeleteOrganizationModelVersion {
	if mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersion != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by Set")
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation == nil {
		mmDeleteOrganizationModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation{}
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation.params != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by Expect")
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation.paramPtrs == nil {
		mmDeleteOrganizationModelVersion.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteOrganizationModelVersionParamPtrs{}
	}
	mmDeleteOrganizationModelVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteOrganizationModelVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteOrganizationModelVersion
}

// ExpectDp1Param2 sets up expected param dp1 for ModelPublicServiceServer.DeleteOrganizationModelVersion
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) ExpectDp1Param2(dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest) *mModelPublicServiceServerMockDeleteOrganizationModelVersion {
	if mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersion != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by Set")
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation == nil {
		mmDeleteOrganizationModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation{}
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation.params != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by Expect")
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation.paramPtrs == nil {
		mmDeleteOrganizationModelVersion.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteOrganizationModelVersionParamPtrs{}
	}
	mmDeleteOrganizationModelVersion.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteOrganizationModelVersion.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteOrganizationModelVersion
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.DeleteOrganizationModelVersion
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) Inspect(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest)) *mModelPublicServiceServerMockDeleteOrganizationModelVersion {
	if mmDeleteOrganizationModelVersion.mock.inspectFuncDeleteOrganizationModelVersion != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.DeleteOrganizationModelVersion")
	}

	mmDeleteOrganizationModelVersion.mock.inspectFuncDeleteOrganizationModelVersion = f

	return mmDeleteOrganizationModelVersion
}

// Return sets up results that will be returned by ModelPublicServiceServer.DeleteOrganizationModelVersion
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) Return(dp2 *mm_modelv1alpha.DeleteOrganizationModelVersionResponse, err error) *ModelPublicServiceServerMock {
	if mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersion != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by Set")
	}

	if mmDeleteOrganizationModelVersion.defaultExpectation == nil {
		mmDeleteOrganizationModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation{mock: mmDeleteOrganizationModelVersion.mock}
	}
	mmDeleteOrganizationModelVersion.defaultExpectation.results = &ModelPublicServiceServerMockDeleteOrganizationModelVersionResults{dp2, err}
	mmDeleteOrganizationModelVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteOrganizationModelVersion.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.DeleteOrganizationModelVersion method
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) Set(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteOrganizationModelVersionResponse, err error)) *ModelPublicServiceServerMock {
	if mmDeleteOrganizationModelVersion.defaultExpectation != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.DeleteOrganizationModelVersion method")
	}

	if len(mmDeleteOrganizationModelVersion.expectations) > 0 {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.DeleteOrganizationModelVersion method")
	}

	mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersion = f
	mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersionOrigin = minimock.CallerInfo(1)
	return mmDeleteOrganizationModelVersion.mock
}

// When sets expectation for the ModelPublicServiceServer.DeleteOrganizationModelVersion which will trigger the result defined by the following
// Then helper
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) When(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest) *ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation {
	if mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersion != nil {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation{
		mock:               mmDeleteOrganizationModelVersion.mock,
		params:             &ModelPublicServiceServerMockDeleteOrganizationModelVersionParams{ctx, dp1},
		expectationOrigins: ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteOrganizationModelVersion.expectations = append(mmDeleteOrganizationModelVersion.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.DeleteOrganizationModelVersion return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockDeleteOrganizationModelVersionExpectation) Then(dp2 *mm_modelv1alpha.DeleteOrganizationModelVersionResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockDeleteOrganizationModelVersionResults{dp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.DeleteOrganizationModelVersion should be invoked
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) Times(n uint64) *mModelPublicServiceServerMockDeleteOrganizationModelVersion {
	if n == 0 {
		mmDeleteOrganizationModelVersion.mock.t.Fatalf("Times of ModelPublicServiceServerMock.DeleteOrganizationModelVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteOrganizationModelVersion.expectedInvocations, n)
	mmDeleteOrganizationModelVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteOrganizationModelVersion
}

func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) invocationsDone() bool {
	if len(mmDeleteOrganizationModelVersion.expectations) == 0 && mmDeleteOrganizationModelVersion.defaultExpectation == nil && mmDeleteOrganizationModelVersion.mock.funcDeleteOrganizationModelVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteOrganizationModelVersion.mock.afterDeleteOrganizationModelVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteOrganizationModelVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteOrganizationModelVersion implements mm_modelv1alpha.ModelPublicServiceServer
func (mmDeleteOrganizationModelVersion *ModelPublicServiceServerMock) DeleteOrganizationModelVersion(ctx context.Context, dp1 *mm_modelv1alpha.DeleteOrganizationModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteOrganizationModelVersionResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteOrganizationModelVersion.beforeDeleteOrganizationModelVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrganizationModelVersion.afterDeleteOrganizationModelVersionCounter, 1)

	mmDeleteOrganizationModelVersion.t.Helper()

	if mmDeleteOrganizationModelVersion.inspectFuncDeleteOrganizationModelVersion != nil {
		mmDeleteOrganizationModelVersion.inspectFuncDeleteOrganizationModelVersion(ctx, dp1)
	}

	mm_params := ModelPublicServiceServerMockDeleteOrganizationModelVersionParams{ctx, dp1}

	// Record call args
	mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.mutex.Lock()
	mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.callArgs = append(mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.callArgs, &mm_params)
	mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.mutex.Unlock()

	for _, e := range mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockDeleteOrganizationModelVersionParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteOrganizationModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteOrganizationModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrganizationModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteOrganizationModelVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrganizationModelVersion.DeleteOrganizationModelVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrganizationModelVersion.t.Fatal("No results are set for the ModelPublicServiceServerMock.DeleteOrganizationModelVersion")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteOrganizationModelVersion.funcDeleteOrganizationModelVersion != nil {
		return mmDeleteOrganizationModelVersion.funcDeleteOrganizationModelVersion(ctx, dp1)
	}
	mmDeleteOrganizationModelVersion.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.DeleteOrganizationModelVersion. %v %v", ctx, dp1)
	return
}

// DeleteOrganizationModelVersionAfterCounter returns a count of finished ModelPublicServiceServerMock.DeleteOrganizationModelVersion invocations
func (mmDeleteOrganizationModelVersion *ModelPublicServiceServerMock) DeleteOrganizationModelVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrganizationModelVersion.afterDeleteOrganizationModelVersionCounter)
}

// DeleteOrganizationModelVersionBeforeCounter returns a count of ModelPublicServiceServerMock.DeleteOrganizationModelVersion invocations
func (mmDeleteOrganizationModelVersion *ModelPublicServiceServerMock) DeleteOrganizationModelVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrganizationModelVersion.beforeDeleteOrganizationModelVersionCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.DeleteOrganizationModelVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrganizationModelVersion *mModelPublicServiceServerMockDeleteOrganizationModelVersion) Calls() []*ModelPublicServiceServerMockDeleteOrganizationModelVersionParams {
	mmDeleteOrganizationModelVersion.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockDeleteOrganizationModelVersionParams, len(mmDeleteOrganizationModelVersion.callArgs))
	copy(argCopy, mmDeleteOrganizationModelVersion.callArgs)

	mmDeleteOrganizationModelVersion.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrganizationModelVersionDone returns true if the count of the DeleteOrganizationModelVersion invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockDeleteOrganizationModelVersionDone() bool {
	if m.DeleteOrganizationModelVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteOrganizationModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteOrganizationModelVersionMock.invocationsDone()
}

// MinimockDeleteOrganizationModelVersionInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockDeleteOrganizationModelVersionInspect() {
	for _, e := range m.DeleteOrganizationModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModelVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteOrganizationModelVersionCounter := mm_atomic.LoadUint64(&m.afterDeleteOrganizationModelVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrganizationModelVersionMock.defaultExpectation != nil && afterDeleteOrganizationModelVersionCounter < 1 {
		if m.DeleteOrganizationModelVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModelVersion at\n%s", m.DeleteOrganizationModelVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModelVersion at\n%s with params: %#v", m.DeleteOrganizationModelVersionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteOrganizationModelVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrganizationModelVersion != nil && afterDeleteOrganizationModelVersionCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteOrganizationModelVersion at\n%s", m.funcDeleteOrganizationModelVersionOrigin)
	}

	if !m.DeleteOrganizationModelVersionMock.invocationsDone() && afterDeleteOrganizationModelVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.DeleteOrganizationModelVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteOrganizationModelVersionMock.expectedInvocations), m.DeleteOrganizationModelVersionMock.expectedInvocationsOrigin, afterDeleteOrganizationModelVersionCounter)
	}
}

type mModelPublicServiceServerMockDeleteUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockDeleteUserModelExpectation
	expectations       []*ModelPublicServiceServerMockDeleteUserModelExpectation

	callArgs []*ModelPublicServiceServerMockDeleteUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockDeleteUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.DeleteUserModel
type ModelPublicServiceServerMockDeleteUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockDeleteUserModelParams
	paramPtrs          *ModelPublicServiceServerMockDeleteUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockDeleteUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockDeleteUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockDeleteUserModelParams contains parameters of the ModelPublicServiceServer.DeleteUserModel
type ModelPublicServiceServerMockDeleteUserModelParams struct {
	ctx context.Context
	dp1 *mm_modelv1alpha.DeleteUserModelRequest
}

// ModelPublicServiceServerMockDeleteUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.DeleteUserModel
type ModelPublicServiceServerMockDeleteUserModelParamPtrs struct {
	ctx *context.Context
	dp1 **mm_modelv1alpha.DeleteUserModelRequest
}

// ModelPublicServiceServerMockDeleteUserModelResults contains results of the ModelPublicServiceServer.DeleteUserModel
type ModelPublicServiceServerMockDeleteUserModelResults struct {
	dp2 *mm_modelv1alpha.DeleteUserModelResponse
	err error
}

// ModelPublicServiceServerMockDeleteUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.DeleteUserModel
type ModelPublicServiceServerMockDeleteUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) Optional() *mModelPublicServiceServerMockDeleteUserModel {
	mmDeleteUserModel.optional = true
	return mmDeleteUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.DeleteUserModel
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) Expect(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelRequest) *mModelPublicServiceServerMockDeleteUserModel {
	if mmDeleteUserModel.mock.funcDeleteUserModel != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by Set")
	}

	if mmDeleteUserModel.defaultExpectation == nil {
		mmDeleteUserModel.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelExpectation{}
	}

	if mmDeleteUserModel.defaultExpectation.paramPtrs != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by ExpectParams functions")
	}

	mmDeleteUserModel.defaultExpectation.params = &ModelPublicServiceServerMockDeleteUserModelParams{ctx, dp1}
	mmDeleteUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUserModel.expectations {
		if minimock.Equal(e.params, mmDeleteUserModel.defaultExpectation.params) {
			mmDeleteUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUserModel.defaultExpectation.params)
		}
	}

	return mmDeleteUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.DeleteUserModel
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockDeleteUserModel {
	if mmDeleteUserModel.mock.funcDeleteUserModel != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by Set")
	}

	if mmDeleteUserModel.defaultExpectation == nil {
		mmDeleteUserModel.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelExpectation{}
	}

	if mmDeleteUserModel.defaultExpectation.params != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by Expect")
	}

	if mmDeleteUserModel.defaultExpectation.paramPtrs == nil {
		mmDeleteUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteUserModelParamPtrs{}
	}
	mmDeleteUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUserModel
}

// ExpectDp1Param2 sets up expected param dp1 for ModelPublicServiceServer.DeleteUserModel
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) ExpectDp1Param2(dp1 *mm_modelv1alpha.DeleteUserModelRequest) *mModelPublicServiceServerMockDeleteUserModel {
	if mmDeleteUserModel.mock.funcDeleteUserModel != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by Set")
	}

	if mmDeleteUserModel.defaultExpectation == nil {
		mmDeleteUserModel.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelExpectation{}
	}

	if mmDeleteUserModel.defaultExpectation.params != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by Expect")
	}

	if mmDeleteUserModel.defaultExpectation.paramPtrs == nil {
		mmDeleteUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteUserModelParamPtrs{}
	}
	mmDeleteUserModel.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteUserModel.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.DeleteUserModel
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) Inspect(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelRequest)) *mModelPublicServiceServerMockDeleteUserModel {
	if mmDeleteUserModel.mock.inspectFuncDeleteUserModel != nil {
		mmDeleteUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.DeleteUserModel")
	}

	mmDeleteUserModel.mock.inspectFuncDeleteUserModel = f

	return mmDeleteUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.DeleteUserModel
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) Return(dp2 *mm_modelv1alpha.DeleteUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmDeleteUserModel.mock.funcDeleteUserModel != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by Set")
	}

	if mmDeleteUserModel.defaultExpectation == nil {
		mmDeleteUserModel.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelExpectation{mock: mmDeleteUserModel.mock}
	}
	mmDeleteUserModel.defaultExpectation.results = &ModelPublicServiceServerMockDeleteUserModelResults{dp2, err}
	mmDeleteUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.DeleteUserModel method
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) Set(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelRequest) (dp2 *mm_modelv1alpha.DeleteUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmDeleteUserModel.defaultExpectation != nil {
		mmDeleteUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.DeleteUserModel method")
	}

	if len(mmDeleteUserModel.expectations) > 0 {
		mmDeleteUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.DeleteUserModel method")
	}

	mmDeleteUserModel.mock.funcDeleteUserModel = f
	mmDeleteUserModel.mock.funcDeleteUserModelOrigin = minimock.CallerInfo(1)
	return mmDeleteUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.DeleteUserModel which will trigger the result defined by the following
// Then helper
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) When(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelRequest) *ModelPublicServiceServerMockDeleteUserModelExpectation {
	if mmDeleteUserModel.mock.funcDeleteUserModel != nil {
		mmDeleteUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockDeleteUserModelExpectation{
		mock:               mmDeleteUserModel.mock,
		params:             &ModelPublicServiceServerMockDeleteUserModelParams{ctx, dp1},
		expectationOrigins: ModelPublicServiceServerMockDeleteUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUserModel.expectations = append(mmDeleteUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.DeleteUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockDeleteUserModelExpectation) Then(dp2 *mm_modelv1alpha.DeleteUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockDeleteUserModelResults{dp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.DeleteUserModel should be invoked
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) Times(n uint64) *mModelPublicServiceServerMockDeleteUserModel {
	if n == 0 {
		mmDeleteUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.DeleteUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUserModel.expectedInvocations, n)
	mmDeleteUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUserModel
}

func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) invocationsDone() bool {
	if len(mmDeleteUserModel.expectations) == 0 && mmDeleteUserModel.defaultExpectation == nil && mmDeleteUserModel.mock.funcDeleteUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUserModel.mock.afterDeleteUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmDeleteUserModel *ModelPublicServiceServerMock) DeleteUserModel(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelRequest) (dp2 *mm_modelv1alpha.DeleteUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteUserModel.beforeDeleteUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUserModel.afterDeleteUserModelCounter, 1)

	mmDeleteUserModel.t.Helper()

	if mmDeleteUserModel.inspectFuncDeleteUserModel != nil {
		mmDeleteUserModel.inspectFuncDeleteUserModel(ctx, dp1)
	}

	mm_params := ModelPublicServiceServerMockDeleteUserModelParams{ctx, dp1}

	// Record call args
	mmDeleteUserModel.DeleteUserModelMock.mutex.Lock()
	mmDeleteUserModel.DeleteUserModelMock.callArgs = append(mmDeleteUserModel.DeleteUserModelMock.callArgs, &mm_params)
	mmDeleteUserModel.DeleteUserModelMock.mutex.Unlock()

	for _, e := range mmDeleteUserModel.DeleteUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteUserModel.DeleteUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUserModel.DeleteUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUserModel.DeleteUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUserModel.DeleteUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockDeleteUserModelParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUserModel.t.Errorf("ModelPublicServiceServerMock.DeleteUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserModel.DeleteUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteUserModel.t.Errorf("ModelPublicServiceServerMock.DeleteUserModel got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserModel.DeleteUserModelMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUserModel.t.Errorf("ModelPublicServiceServerMock.DeleteUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUserModel.DeleteUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUserModel.DeleteUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.DeleteUserModel")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteUserModel.funcDeleteUserModel != nil {
		return mmDeleteUserModel.funcDeleteUserModel(ctx, dp1)
	}
	mmDeleteUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.DeleteUserModel. %v %v", ctx, dp1)
	return
}

// DeleteUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.DeleteUserModel invocations
func (mmDeleteUserModel *ModelPublicServiceServerMock) DeleteUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserModel.afterDeleteUserModelCounter)
}

// DeleteUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.DeleteUserModel invocations
func (mmDeleteUserModel *ModelPublicServiceServerMock) DeleteUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserModel.beforeDeleteUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.DeleteUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUserModel *mModelPublicServiceServerMockDeleteUserModel) Calls() []*ModelPublicServiceServerMockDeleteUserModelParams {
	mmDeleteUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockDeleteUserModelParams, len(mmDeleteUserModel.callArgs))
	copy(argCopy, mmDeleteUserModel.callArgs)

	mmDeleteUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserModelDone returns true if the count of the DeleteUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockDeleteUserModelDone() bool {
	if m.DeleteUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserModelMock.invocationsDone()
}

// MinimockDeleteUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockDeleteUserModelInspect() {
	for _, e := range m.DeleteUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserModelCounter := mm_atomic.LoadUint64(&m.afterDeleteUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserModelMock.defaultExpectation != nil && afterDeleteUserModelCounter < 1 {
		if m.DeleteUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModel at\n%s", m.DeleteUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModel at\n%s with params: %#v", m.DeleteUserModelMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserModel != nil && afterDeleteUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModel at\n%s", m.funcDeleteUserModelOrigin)
	}

	if !m.DeleteUserModelMock.invocationsDone() && afterDeleteUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.DeleteUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserModelMock.expectedInvocations), m.DeleteUserModelMock.expectedInvocationsOrigin, afterDeleteUserModelCounter)
	}
}

type mModelPublicServiceServerMockDeleteUserModelVersion struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockDeleteUserModelVersionExpectation
	expectations       []*ModelPublicServiceServerMockDeleteUserModelVersionExpectation

	callArgs []*ModelPublicServiceServerMockDeleteUserModelVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockDeleteUserModelVersionExpectation specifies expectation struct of the ModelPublicServiceServer.DeleteUserModelVersion
type ModelPublicServiceServerMockDeleteUserModelVersionExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockDeleteUserModelVersionParams
	paramPtrs          *ModelPublicServiceServerMockDeleteUserModelVersionParamPtrs
	expectationOrigins ModelPublicServiceServerMockDeleteUserModelVersionExpectationOrigins
	results            *ModelPublicServiceServerMockDeleteUserModelVersionResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockDeleteUserModelVersionParams contains parameters of the ModelPublicServiceServer.DeleteUserModelVersion
type ModelPublicServiceServerMockDeleteUserModelVersionParams struct {
	ctx context.Context
	dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest
}

// ModelPublicServiceServerMockDeleteUserModelVersionParamPtrs contains pointers to parameters of the ModelPublicServiceServer.DeleteUserModelVersion
type ModelPublicServiceServerMockDeleteUserModelVersionParamPtrs struct {
	ctx *context.Context
	dp1 **mm_modelv1alpha.DeleteUserModelVersionRequest
}

// ModelPublicServiceServerMockDeleteUserModelVersionResults contains results of the ModelPublicServiceServer.DeleteUserModelVersion
type ModelPublicServiceServerMockDeleteUserModelVersionResults struct {
	dp2 *mm_modelv1alpha.DeleteUserModelVersionResponse
	err error
}

// ModelPublicServiceServerMockDeleteUserModelVersionOrigins contains origins of expectations of the ModelPublicServiceServer.DeleteUserModelVersion
type ModelPublicServiceServerMockDeleteUserModelVersionExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) Optional() *mModelPublicServiceServerMockDeleteUserModelVersion {
	mmDeleteUserModelVersion.optional = true
	return mmDeleteUserModelVersion
}

// Expect sets up expected params for ModelPublicServiceServer.DeleteUserModelVersion
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) Expect(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest) *mModelPublicServiceServerMockDeleteUserModelVersion {
	if mmDeleteUserModelVersion.mock.funcDeleteUserModelVersion != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by Set")
	}

	if mmDeleteUserModelVersion.defaultExpectation == nil {
		mmDeleteUserModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelVersionExpectation{}
	}

	if mmDeleteUserModelVersion.defaultExpectation.paramPtrs != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by ExpectParams functions")
	}

	mmDeleteUserModelVersion.defaultExpectation.params = &ModelPublicServiceServerMockDeleteUserModelVersionParams{ctx, dp1}
	mmDeleteUserModelVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUserModelVersion.expectations {
		if minimock.Equal(e.params, mmDeleteUserModelVersion.defaultExpectation.params) {
			mmDeleteUserModelVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUserModelVersion.defaultExpectation.params)
		}
	}

	return mmDeleteUserModelVersion
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.DeleteUserModelVersion
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockDeleteUserModelVersion {
	if mmDeleteUserModelVersion.mock.funcDeleteUserModelVersion != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by Set")
	}

	if mmDeleteUserModelVersion.defaultExpectation == nil {
		mmDeleteUserModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelVersionExpectation{}
	}

	if mmDeleteUserModelVersion.defaultExpectation.params != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by Expect")
	}

	if mmDeleteUserModelVersion.defaultExpectation.paramPtrs == nil {
		mmDeleteUserModelVersion.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteUserModelVersionParamPtrs{}
	}
	mmDeleteUserModelVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUserModelVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUserModelVersion
}

// ExpectDp1Param2 sets up expected param dp1 for ModelPublicServiceServer.DeleteUserModelVersion
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) ExpectDp1Param2(dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest) *mModelPublicServiceServerMockDeleteUserModelVersion {
	if mmDeleteUserModelVersion.mock.funcDeleteUserModelVersion != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by Set")
	}

	if mmDeleteUserModelVersion.defaultExpectation == nil {
		mmDeleteUserModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelVersionExpectation{}
	}

	if mmDeleteUserModelVersion.defaultExpectation.params != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by Expect")
	}

	if mmDeleteUserModelVersion.defaultExpectation.paramPtrs == nil {
		mmDeleteUserModelVersion.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockDeleteUserModelVersionParamPtrs{}
	}
	mmDeleteUserModelVersion.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteUserModelVersion.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteUserModelVersion
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.DeleteUserModelVersion
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) Inspect(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest)) *mModelPublicServiceServerMockDeleteUserModelVersion {
	if mmDeleteUserModelVersion.mock.inspectFuncDeleteUserModelVersion != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.DeleteUserModelVersion")
	}

	mmDeleteUserModelVersion.mock.inspectFuncDeleteUserModelVersion = f

	return mmDeleteUserModelVersion
}

// Return sets up results that will be returned by ModelPublicServiceServer.DeleteUserModelVersion
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) Return(dp2 *mm_modelv1alpha.DeleteUserModelVersionResponse, err error) *ModelPublicServiceServerMock {
	if mmDeleteUserModelVersion.mock.funcDeleteUserModelVersion != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by Set")
	}

	if mmDeleteUserModelVersion.defaultExpectation == nil {
		mmDeleteUserModelVersion.defaultExpectation = &ModelPublicServiceServerMockDeleteUserModelVersionExpectation{mock: mmDeleteUserModelVersion.mock}
	}
	mmDeleteUserModelVersion.defaultExpectation.results = &ModelPublicServiceServerMockDeleteUserModelVersionResults{dp2, err}
	mmDeleteUserModelVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUserModelVersion.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.DeleteUserModelVersion method
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) Set(f func(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteUserModelVersionResponse, err error)) *ModelPublicServiceServerMock {
	if mmDeleteUserModelVersion.defaultExpectation != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.DeleteUserModelVersion method")
	}

	if len(mmDeleteUserModelVersion.expectations) > 0 {
		mmDeleteUserModelVersion.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.DeleteUserModelVersion method")
	}

	mmDeleteUserModelVersion.mock.funcDeleteUserModelVersion = f
	mmDeleteUserModelVersion.mock.funcDeleteUserModelVersionOrigin = minimock.CallerInfo(1)
	return mmDeleteUserModelVersion.mock
}

// When sets expectation for the ModelPublicServiceServer.DeleteUserModelVersion which will trigger the result defined by the following
// Then helper
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) When(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest) *ModelPublicServiceServerMockDeleteUserModelVersionExpectation {
	if mmDeleteUserModelVersion.mock.funcDeleteUserModelVersion != nil {
		mmDeleteUserModelVersion.mock.t.Fatalf("ModelPublicServiceServerMock.DeleteUserModelVersion mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockDeleteUserModelVersionExpectation{
		mock:               mmDeleteUserModelVersion.mock,
		params:             &ModelPublicServiceServerMockDeleteUserModelVersionParams{ctx, dp1},
		expectationOrigins: ModelPublicServiceServerMockDeleteUserModelVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUserModelVersion.expectations = append(mmDeleteUserModelVersion.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.DeleteUserModelVersion return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockDeleteUserModelVersionExpectation) Then(dp2 *mm_modelv1alpha.DeleteUserModelVersionResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockDeleteUserModelVersionResults{dp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.DeleteUserModelVersion should be invoked
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) Times(n uint64) *mModelPublicServiceServerMockDeleteUserModelVersion {
	if n == 0 {
		mmDeleteUserModelVersion.mock.t.Fatalf("Times of ModelPublicServiceServerMock.DeleteUserModelVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUserModelVersion.expectedInvocations, n)
	mmDeleteUserModelVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUserModelVersion
}

func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) invocationsDone() bool {
	if len(mmDeleteUserModelVersion.expectations) == 0 && mmDeleteUserModelVersion.defaultExpectation == nil && mmDeleteUserModelVersion.mock.funcDeleteUserModelVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUserModelVersion.mock.afterDeleteUserModelVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUserModelVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUserModelVersion implements mm_modelv1alpha.ModelPublicServiceServer
func (mmDeleteUserModelVersion *ModelPublicServiceServerMock) DeleteUserModelVersion(ctx context.Context, dp1 *mm_modelv1alpha.DeleteUserModelVersionRequest) (dp2 *mm_modelv1alpha.DeleteUserModelVersionResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteUserModelVersion.beforeDeleteUserModelVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUserModelVersion.afterDeleteUserModelVersionCounter, 1)

	mmDeleteUserModelVersion.t.Helper()

	if mmDeleteUserModelVersion.inspectFuncDeleteUserModelVersion != nil {
		mmDeleteUserModelVersion.inspectFuncDeleteUserModelVersion(ctx, dp1)
	}

	mm_params := ModelPublicServiceServerMockDeleteUserModelVersionParams{ctx, dp1}

	// Record call args
	mmDeleteUserModelVersion.DeleteUserModelVersionMock.mutex.Lock()
	mmDeleteUserModelVersion.DeleteUserModelVersionMock.callArgs = append(mmDeleteUserModelVersion.DeleteUserModelVersionMock.callArgs, &mm_params)
	mmDeleteUserModelVersion.DeleteUserModelVersionMock.mutex.Unlock()

	for _, e := range mmDeleteUserModelVersion.DeleteUserModelVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockDeleteUserModelVersionParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUserModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteUserModelVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteUserModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteUserModelVersion got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUserModelVersion.t.Errorf("ModelPublicServiceServerMock.DeleteUserModelVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUserModelVersion.DeleteUserModelVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUserModelVersion.t.Fatal("No results are set for the ModelPublicServiceServerMock.DeleteUserModelVersion")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteUserModelVersion.funcDeleteUserModelVersion != nil {
		return mmDeleteUserModelVersion.funcDeleteUserModelVersion(ctx, dp1)
	}
	mmDeleteUserModelVersion.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.DeleteUserModelVersion. %v %v", ctx, dp1)
	return
}

// DeleteUserModelVersionAfterCounter returns a count of finished ModelPublicServiceServerMock.DeleteUserModelVersion invocations
func (mmDeleteUserModelVersion *ModelPublicServiceServerMock) DeleteUserModelVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserModelVersion.afterDeleteUserModelVersionCounter)
}

// DeleteUserModelVersionBeforeCounter returns a count of ModelPublicServiceServerMock.DeleteUserModelVersion invocations
func (mmDeleteUserModelVersion *ModelPublicServiceServerMock) DeleteUserModelVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserModelVersion.beforeDeleteUserModelVersionCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.DeleteUserModelVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUserModelVersion *mModelPublicServiceServerMockDeleteUserModelVersion) Calls() []*ModelPublicServiceServerMockDeleteUserModelVersionParams {
	mmDeleteUserModelVersion.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockDeleteUserModelVersionParams, len(mmDeleteUserModelVersion.callArgs))
	copy(argCopy, mmDeleteUserModelVersion.callArgs)

	mmDeleteUserModelVersion.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserModelVersionDone returns true if the count of the DeleteUserModelVersion invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockDeleteUserModelVersionDone() bool {
	if m.DeleteUserModelVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserModelVersionMock.invocationsDone()
}

// MinimockDeleteUserModelVersionInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockDeleteUserModelVersionInspect() {
	for _, e := range m.DeleteUserModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModelVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserModelVersionCounter := mm_atomic.LoadUint64(&m.afterDeleteUserModelVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserModelVersionMock.defaultExpectation != nil && afterDeleteUserModelVersionCounter < 1 {
		if m.DeleteUserModelVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModelVersion at\n%s", m.DeleteUserModelVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModelVersion at\n%s with params: %#v", m.DeleteUserModelVersionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserModelVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserModelVersion != nil && afterDeleteUserModelVersionCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.DeleteUserModelVersion at\n%s", m.funcDeleteUserModelVersionOrigin)
	}

	if !m.DeleteUserModelVersionMock.invocationsDone() && afterDeleteUserModelVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.DeleteUserModelVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserModelVersionMock.expectedInvocations), m.DeleteUserModelVersionMock.expectedInvocationsOrigin, afterDeleteUserModelVersionCounter)
	}
}

type mModelPublicServiceServerMockGetModelDefinition struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetModelDefinitionExpectation
	expectations       []*ModelPublicServiceServerMockGetModelDefinitionExpectation

	callArgs []*ModelPublicServiceServerMockGetModelDefinitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetModelDefinitionExpectation specifies expectation struct of the ModelPublicServiceServer.GetModelDefinition
type ModelPublicServiceServerMockGetModelDefinitionExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetModelDefinitionParams
	paramPtrs          *ModelPublicServiceServerMockGetModelDefinitionParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetModelDefinitionExpectationOrigins
	results            *ModelPublicServiceServerMockGetModelDefinitionResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetModelDefinitionParams contains parameters of the ModelPublicServiceServer.GetModelDefinition
type ModelPublicServiceServerMockGetModelDefinitionParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetModelDefinitionRequest
}

// ModelPublicServiceServerMockGetModelDefinitionParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetModelDefinition
type ModelPublicServiceServerMockGetModelDefinitionParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetModelDefinitionRequest
}

// ModelPublicServiceServerMockGetModelDefinitionResults contains results of the ModelPublicServiceServer.GetModelDefinition
type ModelPublicServiceServerMockGetModelDefinitionResults struct {
	gp2 *mm_modelv1alpha.GetModelDefinitionResponse
	err error
}

// ModelPublicServiceServerMockGetModelDefinitionOrigins contains origins of expectations of the ModelPublicServiceServer.GetModelDefinition
type ModelPublicServiceServerMockGetModelDefinitionExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) Optional() *mModelPublicServiceServerMockGetModelDefinition {
	mmGetModelDefinition.optional = true
	return mmGetModelDefinition
}

// Expect sets up expected params for ModelPublicServiceServer.GetModelDefinition
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetModelDefinitionRequest) *mModelPublicServiceServerMockGetModelDefinition {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &ModelPublicServiceServerMockGetModelDefinitionExpectation{}
	}

	if mmGetModelDefinition.defaultExpectation.paramPtrs != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by ExpectParams functions")
	}

	mmGetModelDefinition.defaultExpectation.params = &ModelPublicServiceServerMockGetModelDefinitionParams{ctx, gp1}
	mmGetModelDefinition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelDefinition.expectations {
		if minimock.Equal(e.params, mmGetModelDefinition.defaultExpectation.params) {
			mmGetModelDefinition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelDefinition.defaultExpectation.params)
		}
	}

	return mmGetModelDefinition
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetModelDefinition
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetModelDefinition {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &ModelPublicServiceServerMockGetModelDefinitionExpectation{}
	}

	if mmGetModelDefinition.defaultExpectation.params != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by Expect")
	}

	if mmGetModelDefinition.defaultExpectation.paramPtrs == nil {
		mmGetModelDefinition.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetModelDefinitionParamPtrs{}
	}
	mmGetModelDefinition.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetModelDefinition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetModelDefinition
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetModelDefinition
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetModelDefinitionRequest) *mModelPublicServiceServerMockGetModelDefinition {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &ModelPublicServiceServerMockGetModelDefinitionExpectation{}
	}

	if mmGetModelDefinition.defaultExpectation.params != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by Expect")
	}

	if mmGetModelDefinition.defaultExpectation.paramPtrs == nil {
		mmGetModelDefinition.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetModelDefinitionParamPtrs{}
	}
	mmGetModelDefinition.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetModelDefinition.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetModelDefinition
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetModelDefinition
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelDefinitionRequest)) *mModelPublicServiceServerMockGetModelDefinition {
	if mmGetModelDefinition.mock.inspectFuncGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetModelDefinition")
	}

	mmGetModelDefinition.mock.inspectFuncGetModelDefinition = f

	return mmGetModelDefinition
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetModelDefinition
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) Return(gp2 *mm_modelv1alpha.GetModelDefinitionResponse, err error) *ModelPublicServiceServerMock {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &ModelPublicServiceServerMockGetModelDefinitionExpectation{mock: mmGetModelDefinition.mock}
	}
	mmGetModelDefinition.defaultExpectation.results = &ModelPublicServiceServerMockGetModelDefinitionResults{gp2, err}
	mmGetModelDefinition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinition.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetModelDefinition method
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelDefinitionRequest) (gp2 *mm_modelv1alpha.GetModelDefinitionResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetModelDefinition.defaultExpectation != nil {
		mmGetModelDefinition.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetModelDefinition method")
	}

	if len(mmGetModelDefinition.expectations) > 0 {
		mmGetModelDefinition.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetModelDefinition method")
	}

	mmGetModelDefinition.mock.funcGetModelDefinition = f
	mmGetModelDefinition.mock.funcGetModelDefinitionOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinition.mock
}

// When sets expectation for the ModelPublicServiceServer.GetModelDefinition which will trigger the result defined by the following
// Then helper
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) When(ctx context.Context, gp1 *mm_modelv1alpha.GetModelDefinitionRequest) *ModelPublicServiceServerMockGetModelDefinitionExpectation {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelDefinition mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetModelDefinitionExpectation{
		mock:               mmGetModelDefinition.mock,
		params:             &ModelPublicServiceServerMockGetModelDefinitionParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetModelDefinitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelDefinition.expectations = append(mmGetModelDefinition.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetModelDefinition return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetModelDefinitionExpectation) Then(gp2 *mm_modelv1alpha.GetModelDefinitionResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetModelDefinitionResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetModelDefinition should be invoked
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) Times(n uint64) *mModelPublicServiceServerMockGetModelDefinition {
	if n == 0 {
		mmGetModelDefinition.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetModelDefinition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelDefinition.expectedInvocations, n)
	mmGetModelDefinition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinition
}

func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) invocationsDone() bool {
	if len(mmGetModelDefinition.expectations) == 0 && mmGetModelDefinition.defaultExpectation == nil && mmGetModelDefinition.mock.funcGetModelDefinition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelDefinition.mock.afterGetModelDefinitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelDefinition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelDefinition implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetModelDefinition *ModelPublicServiceServerMock) GetModelDefinition(ctx context.Context, gp1 *mm_modelv1alpha.GetModelDefinitionRequest) (gp2 *mm_modelv1alpha.GetModelDefinitionResponse, err error) {
	mm_atomic.AddUint64(&mmGetModelDefinition.beforeGetModelDefinitionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelDefinition.afterGetModelDefinitionCounter, 1)

	mmGetModelDefinition.t.Helper()

	if mmGetModelDefinition.inspectFuncGetModelDefinition != nil {
		mmGetModelDefinition.inspectFuncGetModelDefinition(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetModelDefinitionParams{ctx, gp1}

	// Record call args
	mmGetModelDefinition.GetModelDefinitionMock.mutex.Lock()
	mmGetModelDefinition.GetModelDefinitionMock.callArgs = append(mmGetModelDefinition.GetModelDefinitionMock.callArgs, &mm_params)
	mmGetModelDefinition.GetModelDefinitionMock.mutex.Unlock()

	for _, e := range mmGetModelDefinition.GetModelDefinitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetModelDefinitionParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelDefinition.t.Errorf("ModelPublicServiceServerMock.GetModelDefinition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetModelDefinition.t.Errorf("ModelPublicServiceServerMock.GetModelDefinition got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelDefinition.t.Errorf("ModelPublicServiceServerMock.GetModelDefinition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelDefinition.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetModelDefinition")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetModelDefinition.funcGetModelDefinition != nil {
		return mmGetModelDefinition.funcGetModelDefinition(ctx, gp1)
	}
	mmGetModelDefinition.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetModelDefinition. %v %v", ctx, gp1)
	return
}

// GetModelDefinitionAfterCounter returns a count of finished ModelPublicServiceServerMock.GetModelDefinition invocations
func (mmGetModelDefinition *ModelPublicServiceServerMock) GetModelDefinitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinition.afterGetModelDefinitionCounter)
}

// GetModelDefinitionBeforeCounter returns a count of ModelPublicServiceServerMock.GetModelDefinition invocations
func (mmGetModelDefinition *ModelPublicServiceServerMock) GetModelDefinitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinition.beforeGetModelDefinitionCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetModelDefinition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelDefinition *mModelPublicServiceServerMockGetModelDefinition) Calls() []*ModelPublicServiceServerMockGetModelDefinitionParams {
	mmGetModelDefinition.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetModelDefinitionParams, len(mmGetModelDefinition.callArgs))
	copy(argCopy, mmGetModelDefinition.callArgs)

	mmGetModelDefinition.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelDefinitionDone returns true if the count of the GetModelDefinition invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetModelDefinitionDone() bool {
	if m.GetModelDefinitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelDefinitionMock.invocationsDone()
}

// MinimockGetModelDefinitionInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetModelDefinitionInspect() {
	for _, e := range m.GetModelDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelDefinition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelDefinitionCounter := mm_atomic.LoadUint64(&m.afterGetModelDefinitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelDefinitionMock.defaultExpectation != nil && afterGetModelDefinitionCounter < 1 {
		if m.GetModelDefinitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelDefinition at\n%s", m.GetModelDefinitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelDefinition at\n%s with params: %#v", m.GetModelDefinitionMock.defaultExpectation.expectationOrigins.origin, *m.GetModelDefinitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelDefinition != nil && afterGetModelDefinitionCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelDefinition at\n%s", m.funcGetModelDefinitionOrigin)
	}

	if !m.GetModelDefinitionMock.invocationsDone() && afterGetModelDefinitionCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetModelDefinition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelDefinitionMock.expectedInvocations), m.GetModelDefinitionMock.expectedInvocationsOrigin, afterGetModelDefinitionCounter)
	}
}

type mModelPublicServiceServerMockGetModelOperation struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetModelOperationExpectation
	expectations       []*ModelPublicServiceServerMockGetModelOperationExpectation

	callArgs []*ModelPublicServiceServerMockGetModelOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetModelOperationExpectation specifies expectation struct of the ModelPublicServiceServer.GetModelOperation
type ModelPublicServiceServerMockGetModelOperationExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetModelOperationParams
	paramPtrs          *ModelPublicServiceServerMockGetModelOperationParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetModelOperationExpectationOrigins
	results            *ModelPublicServiceServerMockGetModelOperationResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetModelOperationParams contains parameters of the ModelPublicServiceServer.GetModelOperation
type ModelPublicServiceServerMockGetModelOperationParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetModelOperationRequest
}

// ModelPublicServiceServerMockGetModelOperationParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetModelOperation
type ModelPublicServiceServerMockGetModelOperationParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetModelOperationRequest
}

// ModelPublicServiceServerMockGetModelOperationResults contains results of the ModelPublicServiceServer.GetModelOperation
type ModelPublicServiceServerMockGetModelOperationResults struct {
	gp2 *mm_modelv1alpha.GetModelOperationResponse
	err error
}

// ModelPublicServiceServerMockGetModelOperationOrigins contains origins of expectations of the ModelPublicServiceServer.GetModelOperation
type ModelPublicServiceServerMockGetModelOperationExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) Optional() *mModelPublicServiceServerMockGetModelOperation {
	mmGetModelOperation.optional = true
	return mmGetModelOperation
}

// Expect sets up expected params for ModelPublicServiceServer.GetModelOperation
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetModelOperationRequest) *mModelPublicServiceServerMockGetModelOperation {
	if mmGetModelOperation.mock.funcGetModelOperation != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by Set")
	}

	if mmGetModelOperation.defaultExpectation == nil {
		mmGetModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetModelOperationExpectation{}
	}

	if mmGetModelOperation.defaultExpectation.paramPtrs != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by ExpectParams functions")
	}

	mmGetModelOperation.defaultExpectation.params = &ModelPublicServiceServerMockGetModelOperationParams{ctx, gp1}
	mmGetModelOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelOperation.expectations {
		if minimock.Equal(e.params, mmGetModelOperation.defaultExpectation.params) {
			mmGetModelOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelOperation.defaultExpectation.params)
		}
	}

	return mmGetModelOperation
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetModelOperation
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetModelOperation {
	if mmGetModelOperation.mock.funcGetModelOperation != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by Set")
	}

	if mmGetModelOperation.defaultExpectation == nil {
		mmGetModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetModelOperationExpectation{}
	}

	if mmGetModelOperation.defaultExpectation.params != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by Expect")
	}

	if mmGetModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetModelOperationParamPtrs{}
	}
	mmGetModelOperation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetModelOperation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetModelOperation
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetModelOperation
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetModelOperationRequest) *mModelPublicServiceServerMockGetModelOperation {
	if mmGetModelOperation.mock.funcGetModelOperation != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by Set")
	}

	if mmGetModelOperation.defaultExpectation == nil {
		mmGetModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetModelOperationExpectation{}
	}

	if mmGetModelOperation.defaultExpectation.params != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by Expect")
	}

	if mmGetModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetModelOperationParamPtrs{}
	}
	mmGetModelOperation.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetModelOperation.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetModelOperation
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetModelOperation
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelOperationRequest)) *mModelPublicServiceServerMockGetModelOperation {
	if mmGetModelOperation.mock.inspectFuncGetModelOperation != nil {
		mmGetModelOperation.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetModelOperation")
	}

	mmGetModelOperation.mock.inspectFuncGetModelOperation = f

	return mmGetModelOperation
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetModelOperation
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) Return(gp2 *mm_modelv1alpha.GetModelOperationResponse, err error) *ModelPublicServiceServerMock {
	if mmGetModelOperation.mock.funcGetModelOperation != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by Set")
	}

	if mmGetModelOperation.defaultExpectation == nil {
		mmGetModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetModelOperationExpectation{mock: mmGetModelOperation.mock}
	}
	mmGetModelOperation.defaultExpectation.results = &ModelPublicServiceServerMockGetModelOperationResults{gp2, err}
	mmGetModelOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelOperation.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetModelOperation method
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetModelOperationRequest) (gp2 *mm_modelv1alpha.GetModelOperationResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetModelOperation.defaultExpectation != nil {
		mmGetModelOperation.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetModelOperation method")
	}

	if len(mmGetModelOperation.expectations) > 0 {
		mmGetModelOperation.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetModelOperation method")
	}

	mmGetModelOperation.mock.funcGetModelOperation = f
	mmGetModelOperation.mock.funcGetModelOperationOrigin = minimock.CallerInfo(1)
	return mmGetModelOperation.mock
}

// When sets expectation for the ModelPublicServiceServer.GetModelOperation which will trigger the result defined by the following
// Then helper
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) When(ctx context.Context, gp1 *mm_modelv1alpha.GetModelOperationRequest) *ModelPublicServiceServerMockGetModelOperationExpectation {
	if mmGetModelOperation.mock.funcGetModelOperation != nil {
		mmGetModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetModelOperation mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetModelOperationExpectation{
		mock:               mmGetModelOperation.mock,
		params:             &ModelPublicServiceServerMockGetModelOperationParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetModelOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelOperation.expectations = append(mmGetModelOperation.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetModelOperation return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetModelOperationExpectation) Then(gp2 *mm_modelv1alpha.GetModelOperationResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetModelOperationResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetModelOperation should be invoked
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) Times(n uint64) *mModelPublicServiceServerMockGetModelOperation {
	if n == 0 {
		mmGetModelOperation.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetModelOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelOperation.expectedInvocations, n)
	mmGetModelOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelOperation
}

func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) invocationsDone() bool {
	if len(mmGetModelOperation.expectations) == 0 && mmGetModelOperation.defaultExpectation == nil && mmGetModelOperation.mock.funcGetModelOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelOperation.mock.afterGetModelOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelOperation implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetModelOperation *ModelPublicServiceServerMock) GetModelOperation(ctx context.Context, gp1 *mm_modelv1alpha.GetModelOperationRequest) (gp2 *mm_modelv1alpha.GetModelOperationResponse, err error) {
	mm_atomic.AddUint64(&mmGetModelOperation.beforeGetModelOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelOperation.afterGetModelOperationCounter, 1)

	mmGetModelOperation.t.Helper()

	if mmGetModelOperation.inspectFuncGetModelOperation != nil {
		mmGetModelOperation.inspectFuncGetModelOperation(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetModelOperationParams{ctx, gp1}

	// Record call args
	mmGetModelOperation.GetModelOperationMock.mutex.Lock()
	mmGetModelOperation.GetModelOperationMock.callArgs = append(mmGetModelOperation.GetModelOperationMock.callArgs, &mm_params)
	mmGetModelOperation.GetModelOperationMock.mutex.Unlock()

	for _, e := range mmGetModelOperation.GetModelOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetModelOperation.GetModelOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelOperation.GetModelOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelOperation.GetModelOperationMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelOperation.GetModelOperationMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetModelOperationParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelOperation.t.Errorf("ModelPublicServiceServerMock.GetModelOperation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelOperation.GetModelOperationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetModelOperation.t.Errorf("ModelPublicServiceServerMock.GetModelOperation got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelOperation.GetModelOperationMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelOperation.t.Errorf("ModelPublicServiceServerMock.GetModelOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelOperation.GetModelOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelOperation.GetModelOperationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelOperation.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetModelOperation")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetModelOperation.funcGetModelOperation != nil {
		return mmGetModelOperation.funcGetModelOperation(ctx, gp1)
	}
	mmGetModelOperation.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetModelOperation. %v %v", ctx, gp1)
	return
}

// GetModelOperationAfterCounter returns a count of finished ModelPublicServiceServerMock.GetModelOperation invocations
func (mmGetModelOperation *ModelPublicServiceServerMock) GetModelOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelOperation.afterGetModelOperationCounter)
}

// GetModelOperationBeforeCounter returns a count of ModelPublicServiceServerMock.GetModelOperation invocations
func (mmGetModelOperation *ModelPublicServiceServerMock) GetModelOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelOperation.beforeGetModelOperationCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetModelOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelOperation *mModelPublicServiceServerMockGetModelOperation) Calls() []*ModelPublicServiceServerMockGetModelOperationParams {
	mmGetModelOperation.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetModelOperationParams, len(mmGetModelOperation.callArgs))
	copy(argCopy, mmGetModelOperation.callArgs)

	mmGetModelOperation.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelOperationDone returns true if the count of the GetModelOperation invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetModelOperationDone() bool {
	if m.GetModelOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelOperationMock.invocationsDone()
}

// MinimockGetModelOperationInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetModelOperationInspect() {
	for _, e := range m.GetModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelOperationCounter := mm_atomic.LoadUint64(&m.afterGetModelOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelOperationMock.defaultExpectation != nil && afterGetModelOperationCounter < 1 {
		if m.GetModelOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelOperation at\n%s", m.GetModelOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelOperation at\n%s with params: %#v", m.GetModelOperationMock.defaultExpectation.expectationOrigins.origin, *m.GetModelOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelOperation != nil && afterGetModelOperationCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetModelOperation at\n%s", m.funcGetModelOperationOrigin)
	}

	if !m.GetModelOperationMock.invocationsDone() && afterGetModelOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetModelOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelOperationMock.expectedInvocations), m.GetModelOperationMock.expectedInvocationsOrigin, afterGetModelOperationCounter)
	}
}

type mModelPublicServiceServerMockGetNamespaceLatestModelOperation struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation
	expectations       []*ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation

	callArgs []*ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation specifies expectation struct of the ModelPublicServiceServer.GetNamespaceLatestModelOperation
type ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams
	paramPtrs          *ModelPublicServiceServerMockGetNamespaceLatestModelOperationParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectationOrigins
	results            *ModelPublicServiceServerMockGetNamespaceLatestModelOperationResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams contains parameters of the ModelPublicServiceServer.GetNamespaceLatestModelOperation
type ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest
}

// ModelPublicServiceServerMockGetNamespaceLatestModelOperationParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetNamespaceLatestModelOperation
type ModelPublicServiceServerMockGetNamespaceLatestModelOperationParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetNamespaceLatestModelOperationRequest
}

// ModelPublicServiceServerMockGetNamespaceLatestModelOperationResults contains results of the ModelPublicServiceServer.GetNamespaceLatestModelOperation
type ModelPublicServiceServerMockGetNamespaceLatestModelOperationResults struct {
	gp2 *mm_modelv1alpha.GetNamespaceLatestModelOperationResponse
	err error
}

// ModelPublicServiceServerMockGetNamespaceLatestModelOperationOrigins contains origins of expectations of the ModelPublicServiceServer.GetNamespaceLatestModelOperation
type ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) Optional() *mModelPublicServiceServerMockGetNamespaceLatestModelOperation {
	mmGetNamespaceLatestModelOperation.optional = true
	return mmGetNamespaceLatestModelOperation
}

// Expect sets up expected params for ModelPublicServiceServer.GetNamespaceLatestModelOperation
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest) *mModelPublicServiceServerMockGetNamespaceLatestModelOperation {
	if mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperation != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by Set")
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation == nil {
		mmGetNamespaceLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation{}
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by ExpectParams functions")
	}

	mmGetNamespaceLatestModelOperation.defaultExpectation.params = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams{ctx, gp1}
	mmGetNamespaceLatestModelOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceLatestModelOperation.expectations {
		if minimock.Equal(e.params, mmGetNamespaceLatestModelOperation.defaultExpectation.params) {
			mmGetNamespaceLatestModelOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceLatestModelOperation.defaultExpectation.params)
		}
	}

	return mmGetNamespaceLatestModelOperation
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetNamespaceLatestModelOperation
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetNamespaceLatestModelOperation {
	if mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperation != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by Set")
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation == nil {
		mmGetNamespaceLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation{}
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation.params != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by Expect")
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceLatestModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationParamPtrs{}
	}
	mmGetNamespaceLatestModelOperation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceLatestModelOperation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceLatestModelOperation
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetNamespaceLatestModelOperation
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest) *mModelPublicServiceServerMockGetNamespaceLatestModelOperation {
	if mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperation != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by Set")
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation == nil {
		mmGetNamespaceLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation{}
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation.params != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by Expect")
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceLatestModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationParamPtrs{}
	}
	mmGetNamespaceLatestModelOperation.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetNamespaceLatestModelOperation.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetNamespaceLatestModelOperation
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetNamespaceLatestModelOperation
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest)) *mModelPublicServiceServerMockGetNamespaceLatestModelOperation {
	if mmGetNamespaceLatestModelOperation.mock.inspectFuncGetNamespaceLatestModelOperation != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetNamespaceLatestModelOperation")
	}

	mmGetNamespaceLatestModelOperation.mock.inspectFuncGetNamespaceLatestModelOperation = f

	return mmGetNamespaceLatestModelOperation
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetNamespaceLatestModelOperation
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) Return(gp2 *mm_modelv1alpha.GetNamespaceLatestModelOperationResponse, err error) *ModelPublicServiceServerMock {
	if mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperation != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by Set")
	}

	if mmGetNamespaceLatestModelOperation.defaultExpectation == nil {
		mmGetNamespaceLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation{mock: mmGetNamespaceLatestModelOperation.mock}
	}
	mmGetNamespaceLatestModelOperation.defaultExpectation.results = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationResults{gp2, err}
	mmGetNamespaceLatestModelOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceLatestModelOperation.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetNamespaceLatestModelOperation method
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetNamespaceLatestModelOperationResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetNamespaceLatestModelOperation.defaultExpectation != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetNamespaceLatestModelOperation method")
	}

	if len(mmGetNamespaceLatestModelOperation.expectations) > 0 {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetNamespaceLatestModelOperation method")
	}

	mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperation = f
	mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperationOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceLatestModelOperation.mock
}

// When sets expectation for the ModelPublicServiceServer.GetNamespaceLatestModelOperation which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) When(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest) *ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation {
	if mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperation != nil {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation{
		mock:               mmGetNamespaceLatestModelOperation.mock,
		params:             &ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceLatestModelOperation.expectations = append(mmGetNamespaceLatestModelOperation.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetNamespaceLatestModelOperation return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetNamespaceLatestModelOperationExpectation) Then(gp2 *mm_modelv1alpha.GetNamespaceLatestModelOperationResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetNamespaceLatestModelOperationResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetNamespaceLatestModelOperation should be invoked
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) Times(n uint64) *mModelPublicServiceServerMockGetNamespaceLatestModelOperation {
	if n == 0 {
		mmGetNamespaceLatestModelOperation.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetNamespaceLatestModelOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceLatestModelOperation.expectedInvocations, n)
	mmGetNamespaceLatestModelOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceLatestModelOperation
}

func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) invocationsDone() bool {
	if len(mmGetNamespaceLatestModelOperation.expectations) == 0 && mmGetNamespaceLatestModelOperation.defaultExpectation == nil && mmGetNamespaceLatestModelOperation.mock.funcGetNamespaceLatestModelOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceLatestModelOperation.mock.afterGetNamespaceLatestModelOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceLatestModelOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceLatestModelOperation implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetNamespaceLatestModelOperation *ModelPublicServiceServerMock) GetNamespaceLatestModelOperation(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetNamespaceLatestModelOperationResponse, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceLatestModelOperation.beforeGetNamespaceLatestModelOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceLatestModelOperation.afterGetNamespaceLatestModelOperationCounter, 1)

	mmGetNamespaceLatestModelOperation.t.Helper()

	if mmGetNamespaceLatestModelOperation.inspectFuncGetNamespaceLatestModelOperation != nil {
		mmGetNamespaceLatestModelOperation.inspectFuncGetNamespaceLatestModelOperation(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams{ctx, gp1}

	// Record call args
	mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.mutex.Lock()
	mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.callArgs = append(mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.callArgs, &mm_params)
	mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.mutex.Unlock()

	for _, e := range mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetNamespaceLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetNamespaceLatestModelOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceLatestModelOperation.GetNamespaceLatestModelOperationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceLatestModelOperation.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetNamespaceLatestModelOperation")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetNamespaceLatestModelOperation.funcGetNamespaceLatestModelOperation != nil {
		return mmGetNamespaceLatestModelOperation.funcGetNamespaceLatestModelOperation(ctx, gp1)
	}
	mmGetNamespaceLatestModelOperation.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetNamespaceLatestModelOperation. %v %v", ctx, gp1)
	return
}

// GetNamespaceLatestModelOperationAfterCounter returns a count of finished ModelPublicServiceServerMock.GetNamespaceLatestModelOperation invocations
func (mmGetNamespaceLatestModelOperation *ModelPublicServiceServerMock) GetNamespaceLatestModelOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceLatestModelOperation.afterGetNamespaceLatestModelOperationCounter)
}

// GetNamespaceLatestModelOperationBeforeCounter returns a count of ModelPublicServiceServerMock.GetNamespaceLatestModelOperation invocations
func (mmGetNamespaceLatestModelOperation *ModelPublicServiceServerMock) GetNamespaceLatestModelOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceLatestModelOperation.beforeGetNamespaceLatestModelOperationCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetNamespaceLatestModelOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceLatestModelOperation *mModelPublicServiceServerMockGetNamespaceLatestModelOperation) Calls() []*ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams {
	mmGetNamespaceLatestModelOperation.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetNamespaceLatestModelOperationParams, len(mmGetNamespaceLatestModelOperation.callArgs))
	copy(argCopy, mmGetNamespaceLatestModelOperation.callArgs)

	mmGetNamespaceLatestModelOperation.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceLatestModelOperationDone returns true if the count of the GetNamespaceLatestModelOperation invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetNamespaceLatestModelOperationDone() bool {
	if m.GetNamespaceLatestModelOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceLatestModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceLatestModelOperationMock.invocationsDone()
}

// MinimockGetNamespaceLatestModelOperationInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetNamespaceLatestModelOperationInspect() {
	for _, e := range m.GetNamespaceLatestModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceLatestModelOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceLatestModelOperationCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceLatestModelOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceLatestModelOperationMock.defaultExpectation != nil && afterGetNamespaceLatestModelOperationCounter < 1 {
		if m.GetNamespaceLatestModelOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceLatestModelOperation at\n%s", m.GetNamespaceLatestModelOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceLatestModelOperation at\n%s with params: %#v", m.GetNamespaceLatestModelOperationMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceLatestModelOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceLatestModelOperation != nil && afterGetNamespaceLatestModelOperationCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceLatestModelOperation at\n%s", m.funcGetNamespaceLatestModelOperationOrigin)
	}

	if !m.GetNamespaceLatestModelOperationMock.invocationsDone() && afterGetNamespaceLatestModelOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetNamespaceLatestModelOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceLatestModelOperationMock.expectedInvocations), m.GetNamespaceLatestModelOperationMock.expectedInvocationsOrigin, afterGetNamespaceLatestModelOperationCounter)
	}
}

type mModelPublicServiceServerMockGetNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockGetNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockGetNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.GetNamespaceModel
type ModelPublicServiceServerMockGetNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockGetNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockGetNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetNamespaceModelParams contains parameters of the ModelPublicServiceServer.GetNamespaceModel
type ModelPublicServiceServerMockGetNamespaceModelParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetNamespaceModelRequest
}

// ModelPublicServiceServerMockGetNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetNamespaceModel
type ModelPublicServiceServerMockGetNamespaceModelParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetNamespaceModelRequest
}

// ModelPublicServiceServerMockGetNamespaceModelResults contains results of the ModelPublicServiceServer.GetNamespaceModel
type ModelPublicServiceServerMockGetNamespaceModelResults struct {
	gp2 *mm_modelv1alpha.GetNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockGetNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.GetNamespaceModel
type ModelPublicServiceServerMockGetNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) Optional() *mModelPublicServiceServerMockGetNamespaceModel {
	mmGetNamespaceModel.optional = true
	return mmGetNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.GetNamespaceModel
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelRequest) *mModelPublicServiceServerMockGetNamespaceModel {
	if mmGetNamespaceModel.mock.funcGetNamespaceModel != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by Set")
	}

	if mmGetNamespaceModel.defaultExpectation == nil {
		mmGetNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelExpectation{}
	}

	if mmGetNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by ExpectParams functions")
	}

	mmGetNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockGetNamespaceModelParams{ctx, gp1}
	mmGetNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceModel.expectations {
		if minimock.Equal(e.params, mmGetNamespaceModel.defaultExpectation.params) {
			mmGetNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceModel.defaultExpectation.params)
		}
	}

	return mmGetNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetNamespaceModel
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetNamespaceModel {
	if mmGetNamespaceModel.mock.funcGetNamespaceModel != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by Set")
	}

	if mmGetNamespaceModel.defaultExpectation == nil {
		mmGetNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelExpectation{}
	}

	if mmGetNamespaceModel.defaultExpectation.params != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by Expect")
	}

	if mmGetNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetNamespaceModelParamPtrs{}
	}
	mmGetNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceModel
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetNamespaceModel
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetNamespaceModelRequest) *mModelPublicServiceServerMockGetNamespaceModel {
	if mmGetNamespaceModel.mock.funcGetNamespaceModel != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by Set")
	}

	if mmGetNamespaceModel.defaultExpectation == nil {
		mmGetNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelExpectation{}
	}

	if mmGetNamespaceModel.defaultExpectation.params != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by Expect")
	}

	if mmGetNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetNamespaceModelParamPtrs{}
	}
	mmGetNamespaceModel.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetNamespaceModel.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetNamespaceModel
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelRequest)) *mModelPublicServiceServerMockGetNamespaceModel {
	if mmGetNamespaceModel.mock.inspectFuncGetNamespaceModel != nil {
		mmGetNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetNamespaceModel")
	}

	mmGetNamespaceModel.mock.inspectFuncGetNamespaceModel = f

	return mmGetNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetNamespaceModel
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) Return(gp2 *mm_modelv1alpha.GetNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmGetNamespaceModel.mock.funcGetNamespaceModel != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by Set")
	}

	if mmGetNamespaceModel.defaultExpectation == nil {
		mmGetNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelExpectation{mock: mmGetNamespaceModel.mock}
	}
	mmGetNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockGetNamespaceModelResults{gp2, err}
	mmGetNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetNamespaceModel method
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelRequest) (gp2 *mm_modelv1alpha.GetNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetNamespaceModel.defaultExpectation != nil {
		mmGetNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetNamespaceModel method")
	}

	if len(mmGetNamespaceModel.expectations) > 0 {
		mmGetNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetNamespaceModel method")
	}

	mmGetNamespaceModel.mock.funcGetNamespaceModel = f
	mmGetNamespaceModel.mock.funcGetNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.GetNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) When(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelRequest) *ModelPublicServiceServerMockGetNamespaceModelExpectation {
	if mmGetNamespaceModel.mock.funcGetNamespaceModel != nil {
		mmGetNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetNamespaceModelExpectation{
		mock:               mmGetNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockGetNamespaceModelParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceModel.expectations = append(mmGetNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetNamespaceModelExpectation) Then(gp2 *mm_modelv1alpha.GetNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetNamespaceModelResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetNamespaceModel should be invoked
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockGetNamespaceModel {
	if n == 0 {
		mmGetNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceModel.expectedInvocations, n)
	mmGetNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModel
}

func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) invocationsDone() bool {
	if len(mmGetNamespaceModel.expectations) == 0 && mmGetNamespaceModel.defaultExpectation == nil && mmGetNamespaceModel.mock.funcGetNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModel.mock.afterGetNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetNamespaceModel *ModelPublicServiceServerMock) GetNamespaceModel(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelRequest) (gp2 *mm_modelv1alpha.GetNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceModel.beforeGetNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceModel.afterGetNamespaceModelCounter, 1)

	mmGetNamespaceModel.t.Helper()

	if mmGetNamespaceModel.inspectFuncGetNamespaceModel != nil {
		mmGetNamespaceModel.inspectFuncGetNamespaceModel(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetNamespaceModelParams{ctx, gp1}

	// Record call args
	mmGetNamespaceModel.GetNamespaceModelMock.mutex.Lock()
	mmGetNamespaceModel.GetNamespaceModelMock.callArgs = append(mmGetNamespaceModel.GetNamespaceModelMock.callArgs, &mm_params)
	mmGetNamespaceModel.GetNamespaceModelMock.mutex.Unlock()

	for _, e := range mmGetNamespaceModel.GetNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetNamespaceModelParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceModel.t.Errorf("ModelPublicServiceServerMock.GetNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetNamespaceModel.t.Errorf("ModelPublicServiceServerMock.GetNamespaceModel got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceModel.t.Errorf("ModelPublicServiceServerMock.GetNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceModel.GetNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetNamespaceModel")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetNamespaceModel.funcGetNamespaceModel != nil {
		return mmGetNamespaceModel.funcGetNamespaceModel(ctx, gp1)
	}
	mmGetNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetNamespaceModel. %v %v", ctx, gp1)
	return
}

// GetNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.GetNamespaceModel invocations
func (mmGetNamespaceModel *ModelPublicServiceServerMock) GetNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModel.afterGetNamespaceModelCounter)
}

// GetNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.GetNamespaceModel invocations
func (mmGetNamespaceModel *ModelPublicServiceServerMock) GetNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModel.beforeGetNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceModel *mModelPublicServiceServerMockGetNamespaceModel) Calls() []*ModelPublicServiceServerMockGetNamespaceModelParams {
	mmGetNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetNamespaceModelParams, len(mmGetNamespaceModel.callArgs))
	copy(argCopy, mmGetNamespaceModel.callArgs)

	mmGetNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceModelDone returns true if the count of the GetNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetNamespaceModelDone() bool {
	if m.GetNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceModelMock.invocationsDone()
}

// MinimockGetNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetNamespaceModelInspect() {
	for _, e := range m.GetNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceModelMock.defaultExpectation != nil && afterGetNamespaceModelCounter < 1 {
		if m.GetNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModel at\n%s", m.GetNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModel at\n%s with params: %#v", m.GetNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceModel != nil && afterGetNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModel at\n%s", m.funcGetNamespaceModelOrigin)
	}

	if !m.GetNamespaceModelMock.invocationsDone() && afterGetNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceModelMock.expectedInvocations), m.GetNamespaceModelMock.expectedInvocationsOrigin, afterGetNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockGetNamespaceModelOperation struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetNamespaceModelOperationExpectation
	expectations       []*ModelPublicServiceServerMockGetNamespaceModelOperationExpectation

	callArgs []*ModelPublicServiceServerMockGetNamespaceModelOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetNamespaceModelOperationExpectation specifies expectation struct of the ModelPublicServiceServer.GetNamespaceModelOperation
type ModelPublicServiceServerMockGetNamespaceModelOperationExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetNamespaceModelOperationParams
	paramPtrs          *ModelPublicServiceServerMockGetNamespaceModelOperationParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetNamespaceModelOperationExpectationOrigins
	results            *ModelPublicServiceServerMockGetNamespaceModelOperationResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetNamespaceModelOperationParams contains parameters of the ModelPublicServiceServer.GetNamespaceModelOperation
type ModelPublicServiceServerMockGetNamespaceModelOperationParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest
}

// ModelPublicServiceServerMockGetNamespaceModelOperationParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetNamespaceModelOperation
type ModelPublicServiceServerMockGetNamespaceModelOperationParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetNamespaceModelOperationRequest
}

// ModelPublicServiceServerMockGetNamespaceModelOperationResults contains results of the ModelPublicServiceServer.GetNamespaceModelOperation
type ModelPublicServiceServerMockGetNamespaceModelOperationResults struct {
	gp2 *mm_modelv1alpha.GetNamespaceModelOperationResponse
	err error
}

// ModelPublicServiceServerMockGetNamespaceModelOperationOrigins contains origins of expectations of the ModelPublicServiceServer.GetNamespaceModelOperation
type ModelPublicServiceServerMockGetNamespaceModelOperationExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) Optional() *mModelPublicServiceServerMockGetNamespaceModelOperation {
	mmGetNamespaceModelOperation.optional = true
	return mmGetNamespaceModelOperation
}

// Expect sets up expected params for ModelPublicServiceServer.GetNamespaceModelOperation
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest) *mModelPublicServiceServerMockGetNamespaceModelOperation {
	if mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperation != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by Set")
	}

	if mmGetNamespaceModelOperation.defaultExpectation == nil {
		mmGetNamespaceModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelOperationExpectation{}
	}

	if mmGetNamespaceModelOperation.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by ExpectParams functions")
	}

	mmGetNamespaceModelOperation.defaultExpectation.params = &ModelPublicServiceServerMockGetNamespaceModelOperationParams{ctx, gp1}
	mmGetNamespaceModelOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceModelOperation.expectations {
		if minimock.Equal(e.params, mmGetNamespaceModelOperation.defaultExpectation.params) {
			mmGetNamespaceModelOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceModelOperation.defaultExpectation.params)
		}
	}

	return mmGetNamespaceModelOperation
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetNamespaceModelOperation
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetNamespaceModelOperation {
	if mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperation != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by Set")
	}

	if mmGetNamespaceModelOperation.defaultExpectation == nil {
		mmGetNamespaceModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelOperationExpectation{}
	}

	if mmGetNamespaceModelOperation.defaultExpectation.params != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by Expect")
	}

	if mmGetNamespaceModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetNamespaceModelOperationParamPtrs{}
	}
	mmGetNamespaceModelOperation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceModelOperation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceModelOperation
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetNamespaceModelOperation
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest) *mModelPublicServiceServerMockGetNamespaceModelOperation {
	if mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperation != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by Set")
	}

	if mmGetNamespaceModelOperation.defaultExpectation == nil {
		mmGetNamespaceModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelOperationExpectation{}
	}

	if mmGetNamespaceModelOperation.defaultExpectation.params != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by Expect")
	}

	if mmGetNamespaceModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetNamespaceModelOperationParamPtrs{}
	}
	mmGetNamespaceModelOperation.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetNamespaceModelOperation.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetNamespaceModelOperation
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetNamespaceModelOperation
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest)) *mModelPublicServiceServerMockGetNamespaceModelOperation {
	if mmGetNamespaceModelOperation.mock.inspectFuncGetNamespaceModelOperation != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetNamespaceModelOperation")
	}

	mmGetNamespaceModelOperation.mock.inspectFuncGetNamespaceModelOperation = f

	return mmGetNamespaceModelOperation
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetNamespaceModelOperation
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) Return(gp2 *mm_modelv1alpha.GetNamespaceModelOperationResponse, err error) *ModelPublicServiceServerMock {
	if mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperation != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by Set")
	}

	if mmGetNamespaceModelOperation.defaultExpectation == nil {
		mmGetNamespaceModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetNamespaceModelOperationExpectation{mock: mmGetNamespaceModelOperation.mock}
	}
	mmGetNamespaceModelOperation.defaultExpectation.results = &ModelPublicServiceServerMockGetNamespaceModelOperationResults{gp2, err}
	mmGetNamespaceModelOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModelOperation.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetNamespaceModelOperation method
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest) (gp2 *mm_modelv1alpha.GetNamespaceModelOperationResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetNamespaceModelOperation.defaultExpectation != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetNamespaceModelOperation method")
	}

	if len(mmGetNamespaceModelOperation.expectations) > 0 {
		mmGetNamespaceModelOperation.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetNamespaceModelOperation method")
	}

	mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperation = f
	mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperationOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModelOperation.mock
}

// When sets expectation for the ModelPublicServiceServer.GetNamespaceModelOperation which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) When(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest) *ModelPublicServiceServerMockGetNamespaceModelOperationExpectation {
	if mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperation != nil {
		mmGetNamespaceModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetNamespaceModelOperation mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetNamespaceModelOperationExpectation{
		mock:               mmGetNamespaceModelOperation.mock,
		params:             &ModelPublicServiceServerMockGetNamespaceModelOperationParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetNamespaceModelOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceModelOperation.expectations = append(mmGetNamespaceModelOperation.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetNamespaceModelOperation return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetNamespaceModelOperationExpectation) Then(gp2 *mm_modelv1alpha.GetNamespaceModelOperationResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetNamespaceModelOperationResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetNamespaceModelOperation should be invoked
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) Times(n uint64) *mModelPublicServiceServerMockGetNamespaceModelOperation {
	if n == 0 {
		mmGetNamespaceModelOperation.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetNamespaceModelOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceModelOperation.expectedInvocations, n)
	mmGetNamespaceModelOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModelOperation
}

func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) invocationsDone() bool {
	if len(mmGetNamespaceModelOperation.expectations) == 0 && mmGetNamespaceModelOperation.defaultExpectation == nil && mmGetNamespaceModelOperation.mock.funcGetNamespaceModelOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModelOperation.mock.afterGetNamespaceModelOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModelOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceModelOperation implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetNamespaceModelOperation *ModelPublicServiceServerMock) GetNamespaceModelOperation(ctx context.Context, gp1 *mm_modelv1alpha.GetNamespaceModelOperationRequest) (gp2 *mm_modelv1alpha.GetNamespaceModelOperationResponse, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceModelOperation.beforeGetNamespaceModelOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceModelOperation.afterGetNamespaceModelOperationCounter, 1)

	mmGetNamespaceModelOperation.t.Helper()

	if mmGetNamespaceModelOperation.inspectFuncGetNamespaceModelOperation != nil {
		mmGetNamespaceModelOperation.inspectFuncGetNamespaceModelOperation(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetNamespaceModelOperationParams{ctx, gp1}

	// Record call args
	mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.mutex.Lock()
	mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.callArgs = append(mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.callArgs, &mm_params)
	mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.mutex.Unlock()

	for _, e := range mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetNamespaceModelOperationParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceModelOperation.t.Errorf("ModelPublicServiceServerMock.GetNamespaceModelOperation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetNamespaceModelOperation.t.Errorf("ModelPublicServiceServerMock.GetNamespaceModelOperation got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceModelOperation.t.Errorf("ModelPublicServiceServerMock.GetNamespaceModelOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceModelOperation.GetNamespaceModelOperationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceModelOperation.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetNamespaceModelOperation")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetNamespaceModelOperation.funcGetNamespaceModelOperation != nil {
		return mmGetNamespaceModelOperation.funcGetNamespaceModelOperation(ctx, gp1)
	}
	mmGetNamespaceModelOperation.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetNamespaceModelOperation. %v %v", ctx, gp1)
	return
}

// GetNamespaceModelOperationAfterCounter returns a count of finished ModelPublicServiceServerMock.GetNamespaceModelOperation invocations
func (mmGetNamespaceModelOperation *ModelPublicServiceServerMock) GetNamespaceModelOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModelOperation.afterGetNamespaceModelOperationCounter)
}

// GetNamespaceModelOperationBeforeCounter returns a count of ModelPublicServiceServerMock.GetNamespaceModelOperation invocations
func (mmGetNamespaceModelOperation *ModelPublicServiceServerMock) GetNamespaceModelOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModelOperation.beforeGetNamespaceModelOperationCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetNamespaceModelOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceModelOperation *mModelPublicServiceServerMockGetNamespaceModelOperation) Calls() []*ModelPublicServiceServerMockGetNamespaceModelOperationParams {
	mmGetNamespaceModelOperation.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetNamespaceModelOperationParams, len(mmGetNamespaceModelOperation.callArgs))
	copy(argCopy, mmGetNamespaceModelOperation.callArgs)

	mmGetNamespaceModelOperation.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceModelOperationDone returns true if the count of the GetNamespaceModelOperation invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetNamespaceModelOperationDone() bool {
	if m.GetNamespaceModelOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceModelOperationMock.invocationsDone()
}

// MinimockGetNamespaceModelOperationInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetNamespaceModelOperationInspect() {
	for _, e := range m.GetNamespaceModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModelOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceModelOperationCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceModelOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceModelOperationMock.defaultExpectation != nil && afterGetNamespaceModelOperationCounter < 1 {
		if m.GetNamespaceModelOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModelOperation at\n%s", m.GetNamespaceModelOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModelOperation at\n%s with params: %#v", m.GetNamespaceModelOperationMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceModelOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceModelOperation != nil && afterGetNamespaceModelOperationCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetNamespaceModelOperation at\n%s", m.funcGetNamespaceModelOperationOrigin)
	}

	if !m.GetNamespaceModelOperationMock.invocationsDone() && afterGetNamespaceModelOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetNamespaceModelOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceModelOperationMock.expectedInvocations), m.GetNamespaceModelOperationMock.expectedInvocationsOrigin, afterGetNamespaceModelOperationCounter)
	}
}

type mModelPublicServiceServerMockGetOrganizationLatestModelOperation struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation
	expectations       []*ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation

	callArgs []*ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation specifies expectation struct of the ModelPublicServiceServer.GetOrganizationLatestModelOperation
type ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams
	paramPtrs          *ModelPublicServiceServerMockGetOrganizationLatestModelOperationParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectationOrigins
	results            *ModelPublicServiceServerMockGetOrganizationLatestModelOperationResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams contains parameters of the ModelPublicServiceServer.GetOrganizationLatestModelOperation
type ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest
}

// ModelPublicServiceServerMockGetOrganizationLatestModelOperationParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetOrganizationLatestModelOperation
type ModelPublicServiceServerMockGetOrganizationLatestModelOperationParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetOrganizationLatestModelOperationRequest
}

// ModelPublicServiceServerMockGetOrganizationLatestModelOperationResults contains results of the ModelPublicServiceServer.GetOrganizationLatestModelOperation
type ModelPublicServiceServerMockGetOrganizationLatestModelOperationResults struct {
	gp2 *mm_modelv1alpha.GetOrganizationLatestModelOperationResponse
	err error
}

// ModelPublicServiceServerMockGetOrganizationLatestModelOperationOrigins contains origins of expectations of the ModelPublicServiceServer.GetOrganizationLatestModelOperation
type ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) Optional() *mModelPublicServiceServerMockGetOrganizationLatestModelOperation {
	mmGetOrganizationLatestModelOperation.optional = true
	return mmGetOrganizationLatestModelOperation
}

// Expect sets up expected params for ModelPublicServiceServer.GetOrganizationLatestModelOperation
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest) *mModelPublicServiceServerMockGetOrganizationLatestModelOperation {
	if mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperation != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by Set")
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation == nil {
		mmGetOrganizationLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation{}
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation.paramPtrs != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by ExpectParams functions")
	}

	mmGetOrganizationLatestModelOperation.defaultExpectation.params = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams{ctx, gp1}
	mmGetOrganizationLatestModelOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrganizationLatestModelOperation.expectations {
		if minimock.Equal(e.params, mmGetOrganizationLatestModelOperation.defaultExpectation.params) {
			mmGetOrganizationLatestModelOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrganizationLatestModelOperation.defaultExpectation.params)
		}
	}

	return mmGetOrganizationLatestModelOperation
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetOrganizationLatestModelOperation
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetOrganizationLatestModelOperation {
	if mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperation != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by Set")
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation == nil {
		mmGetOrganizationLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation{}
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation.params != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by Expect")
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationLatestModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationParamPtrs{}
	}
	mmGetOrganizationLatestModelOperation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrganizationLatestModelOperation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrganizationLatestModelOperation
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetOrganizationLatestModelOperation
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest) *mModelPublicServiceServerMockGetOrganizationLatestModelOperation {
	if mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperation != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by Set")
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation == nil {
		mmGetOrganizationLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation{}
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation.params != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by Expect")
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationLatestModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationParamPtrs{}
	}
	mmGetOrganizationLatestModelOperation.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetOrganizationLatestModelOperation.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetOrganizationLatestModelOperation
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetOrganizationLatestModelOperation
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest)) *mModelPublicServiceServerMockGetOrganizationLatestModelOperation {
	if mmGetOrganizationLatestModelOperation.mock.inspectFuncGetOrganizationLatestModelOperation != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetOrganizationLatestModelOperation")
	}

	mmGetOrganizationLatestModelOperation.mock.inspectFuncGetOrganizationLatestModelOperation = f

	return mmGetOrganizationLatestModelOperation
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetOrganizationLatestModelOperation
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) Return(gp2 *mm_modelv1alpha.GetOrganizationLatestModelOperationResponse, err error) *ModelPublicServiceServerMock {
	if mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperation != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by Set")
	}

	if mmGetOrganizationLatestModelOperation.defaultExpectation == nil {
		mmGetOrganizationLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation{mock: mmGetOrganizationLatestModelOperation.mock}
	}
	mmGetOrganizationLatestModelOperation.defaultExpectation.results = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationResults{gp2, err}
	mmGetOrganizationLatestModelOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationLatestModelOperation.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetOrganizationLatestModelOperation method
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetOrganizationLatestModelOperationResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetOrganizationLatestModelOperation.defaultExpectation != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetOrganizationLatestModelOperation method")
	}

	if len(mmGetOrganizationLatestModelOperation.expectations) > 0 {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetOrganizationLatestModelOperation method")
	}

	mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperation = f
	mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperationOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationLatestModelOperation.mock
}

// When sets expectation for the ModelPublicServiceServer.GetOrganizationLatestModelOperation which will trigger the result defined by the following
// Then helper
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) When(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest) *ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation {
	if mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperation != nil {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation{
		mock:               mmGetOrganizationLatestModelOperation.mock,
		params:             &ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrganizationLatestModelOperation.expectations = append(mmGetOrganizationLatestModelOperation.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetOrganizationLatestModelOperation return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetOrganizationLatestModelOperationExpectation) Then(gp2 *mm_modelv1alpha.GetOrganizationLatestModelOperationResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetOrganizationLatestModelOperationResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetOrganizationLatestModelOperation should be invoked
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) Times(n uint64) *mModelPublicServiceServerMockGetOrganizationLatestModelOperation {
	if n == 0 {
		mmGetOrganizationLatestModelOperation.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetOrganizationLatestModelOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrganizationLatestModelOperation.expectedInvocations, n)
	mmGetOrganizationLatestModelOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationLatestModelOperation
}

func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) invocationsDone() bool {
	if len(mmGetOrganizationLatestModelOperation.expectations) == 0 && mmGetOrganizationLatestModelOperation.defaultExpectation == nil && mmGetOrganizationLatestModelOperation.mock.funcGetOrganizationLatestModelOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrganizationLatestModelOperation.mock.afterGetOrganizationLatestModelOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrganizationLatestModelOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrganizationLatestModelOperation implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetOrganizationLatestModelOperation *ModelPublicServiceServerMock) GetOrganizationLatestModelOperation(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetOrganizationLatestModelOperationResponse, err error) {
	mm_atomic.AddUint64(&mmGetOrganizationLatestModelOperation.beforeGetOrganizationLatestModelOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrganizationLatestModelOperation.afterGetOrganizationLatestModelOperationCounter, 1)

	mmGetOrganizationLatestModelOperation.t.Helper()

	if mmGetOrganizationLatestModelOperation.inspectFuncGetOrganizationLatestModelOperation != nil {
		mmGetOrganizationLatestModelOperation.inspectFuncGetOrganizationLatestModelOperation(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams{ctx, gp1}

	// Record call args
	mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.mutex.Lock()
	mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.callArgs = append(mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.callArgs, &mm_params)
	mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.mutex.Unlock()

	for _, e := range mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrganizationLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetOrganizationLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrganizationLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetOrganizationLatestModelOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrganizationLatestModelOperation.GetOrganizationLatestModelOperationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrganizationLatestModelOperation.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetOrganizationLatestModelOperation")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetOrganizationLatestModelOperation.funcGetOrganizationLatestModelOperation != nil {
		return mmGetOrganizationLatestModelOperation.funcGetOrganizationLatestModelOperation(ctx, gp1)
	}
	mmGetOrganizationLatestModelOperation.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetOrganizationLatestModelOperation. %v %v", ctx, gp1)
	return
}

// GetOrganizationLatestModelOperationAfterCounter returns a count of finished ModelPublicServiceServerMock.GetOrganizationLatestModelOperation invocations
func (mmGetOrganizationLatestModelOperation *ModelPublicServiceServerMock) GetOrganizationLatestModelOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationLatestModelOperation.afterGetOrganizationLatestModelOperationCounter)
}

// GetOrganizationLatestModelOperationBeforeCounter returns a count of ModelPublicServiceServerMock.GetOrganizationLatestModelOperation invocations
func (mmGetOrganizationLatestModelOperation *ModelPublicServiceServerMock) GetOrganizationLatestModelOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationLatestModelOperation.beforeGetOrganizationLatestModelOperationCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetOrganizationLatestModelOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrganizationLatestModelOperation *mModelPublicServiceServerMockGetOrganizationLatestModelOperation) Calls() []*ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams {
	mmGetOrganizationLatestModelOperation.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetOrganizationLatestModelOperationParams, len(mmGetOrganizationLatestModelOperation.callArgs))
	copy(argCopy, mmGetOrganizationLatestModelOperation.callArgs)

	mmGetOrganizationLatestModelOperation.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrganizationLatestModelOperationDone returns true if the count of the GetOrganizationLatestModelOperation invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetOrganizationLatestModelOperationDone() bool {
	if m.GetOrganizationLatestModelOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrganizationLatestModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrganizationLatestModelOperationMock.invocationsDone()
}

// MinimockGetOrganizationLatestModelOperationInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetOrganizationLatestModelOperationInspect() {
	for _, e := range m.GetOrganizationLatestModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationLatestModelOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrganizationLatestModelOperationCounter := mm_atomic.LoadUint64(&m.afterGetOrganizationLatestModelOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrganizationLatestModelOperationMock.defaultExpectation != nil && afterGetOrganizationLatestModelOperationCounter < 1 {
		if m.GetOrganizationLatestModelOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationLatestModelOperation at\n%s", m.GetOrganizationLatestModelOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationLatestModelOperation at\n%s with params: %#v", m.GetOrganizationLatestModelOperationMock.defaultExpectation.expectationOrigins.origin, *m.GetOrganizationLatestModelOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrganizationLatestModelOperation != nil && afterGetOrganizationLatestModelOperationCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationLatestModelOperation at\n%s", m.funcGetOrganizationLatestModelOperationOrigin)
	}

	if !m.GetOrganizationLatestModelOperationMock.invocationsDone() && afterGetOrganizationLatestModelOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetOrganizationLatestModelOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrganizationLatestModelOperationMock.expectedInvocations), m.GetOrganizationLatestModelOperationMock.expectedInvocationsOrigin, afterGetOrganizationLatestModelOperationCounter)
	}
}

type mModelPublicServiceServerMockGetOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockGetOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockGetOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.GetOrganizationModel
type ModelPublicServiceServerMockGetOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockGetOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockGetOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetOrganizationModelParams contains parameters of the ModelPublicServiceServer.GetOrganizationModel
type ModelPublicServiceServerMockGetOrganizationModelParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetOrganizationModelRequest
}

// ModelPublicServiceServerMockGetOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetOrganizationModel
type ModelPublicServiceServerMockGetOrganizationModelParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetOrganizationModelRequest
}

// ModelPublicServiceServerMockGetOrganizationModelResults contains results of the ModelPublicServiceServer.GetOrganizationModel
type ModelPublicServiceServerMockGetOrganizationModelResults struct {
	gp2 *mm_modelv1alpha.GetOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockGetOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.GetOrganizationModel
type ModelPublicServiceServerMockGetOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) Optional() *mModelPublicServiceServerMockGetOrganizationModel {
	mmGetOrganizationModel.optional = true
	return mmGetOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.GetOrganizationModel
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationModelRequest) *mModelPublicServiceServerMockGetOrganizationModel {
	if mmGetOrganizationModel.mock.funcGetOrganizationModel != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by Set")
	}

	if mmGetOrganizationModel.defaultExpectation == nil {
		mmGetOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationModelExpectation{}
	}

	if mmGetOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by ExpectParams functions")
	}

	mmGetOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockGetOrganizationModelParams{ctx, gp1}
	mmGetOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrganizationModel.expectations {
		if minimock.Equal(e.params, mmGetOrganizationModel.defaultExpectation.params) {
			mmGetOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrganizationModel.defaultExpectation.params)
		}
	}

	return mmGetOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetOrganizationModel
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetOrganizationModel {
	if mmGetOrganizationModel.mock.funcGetOrganizationModel != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by Set")
	}

	if mmGetOrganizationModel.defaultExpectation == nil {
		mmGetOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationModelExpectation{}
	}

	if mmGetOrganizationModel.defaultExpectation.params != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by Expect")
	}

	if mmGetOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetOrganizationModelParamPtrs{}
	}
	mmGetOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrganizationModel
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetOrganizationModel
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetOrganizationModelRequest) *mModelPublicServiceServerMockGetOrganizationModel {
	if mmGetOrganizationModel.mock.funcGetOrganizationModel != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by Set")
	}

	if mmGetOrganizationModel.defaultExpectation == nil {
		mmGetOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationModelExpectation{}
	}

	if mmGetOrganizationModel.defaultExpectation.params != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by Expect")
	}

	if mmGetOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmGetOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetOrganizationModelParamPtrs{}
	}
	mmGetOrganizationModel.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetOrganizationModel.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetOrganizationModel
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationModelRequest)) *mModelPublicServiceServerMockGetOrganizationModel {
	if mmGetOrganizationModel.mock.inspectFuncGetOrganizationModel != nil {
		mmGetOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetOrganizationModel")
	}

	mmGetOrganizationModel.mock.inspectFuncGetOrganizationModel = f

	return mmGetOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetOrganizationModel
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) Return(gp2 *mm_modelv1alpha.GetOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmGetOrganizationModel.mock.funcGetOrganizationModel != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by Set")
	}

	if mmGetOrganizationModel.defaultExpectation == nil {
		mmGetOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockGetOrganizationModelExpectation{mock: mmGetOrganizationModel.mock}
	}
	mmGetOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockGetOrganizationModelResults{gp2, err}
	mmGetOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetOrganizationModel method
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationModelRequest) (gp2 *mm_modelv1alpha.GetOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetOrganizationModel.defaultExpectation != nil {
		mmGetOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetOrganizationModel method")
	}

	if len(mmGetOrganizationModel.expectations) > 0 {
		mmGetOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetOrganizationModel method")
	}

	mmGetOrganizationModel.mock.funcGetOrganizationModel = f
	mmGetOrganizationModel.mock.funcGetOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.GetOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) When(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationModelRequest) *ModelPublicServiceServerMockGetOrganizationModelExpectation {
	if mmGetOrganizationModel.mock.funcGetOrganizationModel != nil {
		mmGetOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetOrganizationModelExpectation{
		mock:               mmGetOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockGetOrganizationModelParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrganizationModel.expectations = append(mmGetOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetOrganizationModelExpectation) Then(gp2 *mm_modelv1alpha.GetOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetOrganizationModelResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetOrganizationModel should be invoked
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockGetOrganizationModel {
	if n == 0 {
		mmGetOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrganizationModel.expectedInvocations, n)
	mmGetOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrganizationModel
}

func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) invocationsDone() bool {
	if len(mmGetOrganizationModel.expectations) == 0 && mmGetOrganizationModel.defaultExpectation == nil && mmGetOrganizationModel.mock.funcGetOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrganizationModel.mock.afterGetOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetOrganizationModel *ModelPublicServiceServerMock) GetOrganizationModel(ctx context.Context, gp1 *mm_modelv1alpha.GetOrganizationModelRequest) (gp2 *mm_modelv1alpha.GetOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmGetOrganizationModel.beforeGetOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrganizationModel.afterGetOrganizationModelCounter, 1)

	mmGetOrganizationModel.t.Helper()

	if mmGetOrganizationModel.inspectFuncGetOrganizationModel != nil {
		mmGetOrganizationModel.inspectFuncGetOrganizationModel(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetOrganizationModelParams{ctx, gp1}

	// Record call args
	mmGetOrganizationModel.GetOrganizationModelMock.mutex.Lock()
	mmGetOrganizationModel.GetOrganizationModelMock.callArgs = append(mmGetOrganizationModel.GetOrganizationModelMock.callArgs, &mm_params)
	mmGetOrganizationModel.GetOrganizationModelMock.mutex.Unlock()

	for _, e := range mmGetOrganizationModel.GetOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetOrganizationModelParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrganizationModel.t.Errorf("ModelPublicServiceServerMock.GetOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetOrganizationModel.t.Errorf("ModelPublicServiceServerMock.GetOrganizationModel got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrganizationModel.t.Errorf("ModelPublicServiceServerMock.GetOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrganizationModel.GetOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetOrganizationModel")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetOrganizationModel.funcGetOrganizationModel != nil {
		return mmGetOrganizationModel.funcGetOrganizationModel(ctx, gp1)
	}
	mmGetOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetOrganizationModel. %v %v", ctx, gp1)
	return
}

// GetOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.GetOrganizationModel invocations
func (mmGetOrganizationModel *ModelPublicServiceServerMock) GetOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationModel.afterGetOrganizationModelCounter)
}

// GetOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.GetOrganizationModel invocations
func (mmGetOrganizationModel *ModelPublicServiceServerMock) GetOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrganizationModel.beforeGetOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrganizationModel *mModelPublicServiceServerMockGetOrganizationModel) Calls() []*ModelPublicServiceServerMockGetOrganizationModelParams {
	mmGetOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetOrganizationModelParams, len(mmGetOrganizationModel.callArgs))
	copy(argCopy, mmGetOrganizationModel.callArgs)

	mmGetOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrganizationModelDone returns true if the count of the GetOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetOrganizationModelDone() bool {
	if m.GetOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrganizationModelMock.invocationsDone()
}

// MinimockGetOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetOrganizationModelInspect() {
	for _, e := range m.GetOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterGetOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrganizationModelMock.defaultExpectation != nil && afterGetOrganizationModelCounter < 1 {
		if m.GetOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationModel at\n%s", m.GetOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationModel at\n%s with params: %#v", m.GetOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.GetOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrganizationModel != nil && afterGetOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetOrganizationModel at\n%s", m.funcGetOrganizationModelOrigin)
	}

	if !m.GetOrganizationModelMock.invocationsDone() && afterGetOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrganizationModelMock.expectedInvocations), m.GetOrganizationModelMock.expectedInvocationsOrigin, afterGetOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockGetUserLatestModelOperation struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetUserLatestModelOperationExpectation
	expectations       []*ModelPublicServiceServerMockGetUserLatestModelOperationExpectation

	callArgs []*ModelPublicServiceServerMockGetUserLatestModelOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetUserLatestModelOperationExpectation specifies expectation struct of the ModelPublicServiceServer.GetUserLatestModelOperation
type ModelPublicServiceServerMockGetUserLatestModelOperationExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetUserLatestModelOperationParams
	paramPtrs          *ModelPublicServiceServerMockGetUserLatestModelOperationParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetUserLatestModelOperationExpectationOrigins
	results            *ModelPublicServiceServerMockGetUserLatestModelOperationResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetUserLatestModelOperationParams contains parameters of the ModelPublicServiceServer.GetUserLatestModelOperation
type ModelPublicServiceServerMockGetUserLatestModelOperationParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest
}

// ModelPublicServiceServerMockGetUserLatestModelOperationParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetUserLatestModelOperation
type ModelPublicServiceServerMockGetUserLatestModelOperationParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetUserLatestModelOperationRequest
}

// ModelPublicServiceServerMockGetUserLatestModelOperationResults contains results of the ModelPublicServiceServer.GetUserLatestModelOperation
type ModelPublicServiceServerMockGetUserLatestModelOperationResults struct {
	gp2 *mm_modelv1alpha.GetUserLatestModelOperationResponse
	err error
}

// ModelPublicServiceServerMockGetUserLatestModelOperationOrigins contains origins of expectations of the ModelPublicServiceServer.GetUserLatestModelOperation
type ModelPublicServiceServerMockGetUserLatestModelOperationExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) Optional() *mModelPublicServiceServerMockGetUserLatestModelOperation {
	mmGetUserLatestModelOperation.optional = true
	return mmGetUserLatestModelOperation
}

// Expect sets up expected params for ModelPublicServiceServer.GetUserLatestModelOperation
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest) *mModelPublicServiceServerMockGetUserLatestModelOperation {
	if mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperation != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by Set")
	}

	if mmGetUserLatestModelOperation.defaultExpectation == nil {
		mmGetUserLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetUserLatestModelOperationExpectation{}
	}

	if mmGetUserLatestModelOperation.defaultExpectation.paramPtrs != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by ExpectParams functions")
	}

	mmGetUserLatestModelOperation.defaultExpectation.params = &ModelPublicServiceServerMockGetUserLatestModelOperationParams{ctx, gp1}
	mmGetUserLatestModelOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserLatestModelOperation.expectations {
		if minimock.Equal(e.params, mmGetUserLatestModelOperation.defaultExpectation.params) {
			mmGetUserLatestModelOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserLatestModelOperation.defaultExpectation.params)
		}
	}

	return mmGetUserLatestModelOperation
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetUserLatestModelOperation
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetUserLatestModelOperation {
	if mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperation != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by Set")
	}

	if mmGetUserLatestModelOperation.defaultExpectation == nil {
		mmGetUserLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetUserLatestModelOperationExpectation{}
	}

	if mmGetUserLatestModelOperation.defaultExpectation.params != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by Expect")
	}

	if mmGetUserLatestModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetUserLatestModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetUserLatestModelOperationParamPtrs{}
	}
	mmGetUserLatestModelOperation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserLatestModelOperation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserLatestModelOperation
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetUserLatestModelOperation
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest) *mModelPublicServiceServerMockGetUserLatestModelOperation {
	if mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperation != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by Set")
	}

	if mmGetUserLatestModelOperation.defaultExpectation == nil {
		mmGetUserLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetUserLatestModelOperationExpectation{}
	}

	if mmGetUserLatestModelOperation.defaultExpectation.params != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by Expect")
	}

	if mmGetUserLatestModelOperation.defaultExpectation.paramPtrs == nil {
		mmGetUserLatestModelOperation.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetUserLatestModelOperationParamPtrs{}
	}
	mmGetUserLatestModelOperation.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetUserLatestModelOperation.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetUserLatestModelOperation
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetUserLatestModelOperation
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest)) *mModelPublicServiceServerMockGetUserLatestModelOperation {
	if mmGetUserLatestModelOperation.mock.inspectFuncGetUserLatestModelOperation != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetUserLatestModelOperation")
	}

	mmGetUserLatestModelOperation.mock.inspectFuncGetUserLatestModelOperation = f

	return mmGetUserLatestModelOperation
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetUserLatestModelOperation
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) Return(gp2 *mm_modelv1alpha.GetUserLatestModelOperationResponse, err error) *ModelPublicServiceServerMock {
	if mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperation != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by Set")
	}

	if mmGetUserLatestModelOperation.defaultExpectation == nil {
		mmGetUserLatestModelOperation.defaultExpectation = &ModelPublicServiceServerMockGetUserLatestModelOperationExpectation{mock: mmGetUserLatestModelOperation.mock}
	}
	mmGetUserLatestModelOperation.defaultExpectation.results = &ModelPublicServiceServerMockGetUserLatestModelOperationResults{gp2, err}
	mmGetUserLatestModelOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserLatestModelOperation.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetUserLatestModelOperation method
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetUserLatestModelOperationResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetUserLatestModelOperation.defaultExpectation != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetUserLatestModelOperation method")
	}

	if len(mmGetUserLatestModelOperation.expectations) > 0 {
		mmGetUserLatestModelOperation.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetUserLatestModelOperation method")
	}

	mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperation = f
	mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperationOrigin = minimock.CallerInfo(1)
	return mmGetUserLatestModelOperation.mock
}

// When sets expectation for the ModelPublicServiceServer.GetUserLatestModelOperation which will trigger the result defined by the following
// Then helper
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) When(ctx context.Context, gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest) *ModelPublicServiceServerMockGetUserLatestModelOperationExpectation {
	if mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperation != nil {
		mmGetUserLatestModelOperation.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserLatestModelOperation mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetUserLatestModelOperationExpectation{
		mock:               mmGetUserLatestModelOperation.mock,
		params:             &ModelPublicServiceServerMockGetUserLatestModelOperationParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetUserLatestModelOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserLatestModelOperation.expectations = append(mmGetUserLatestModelOperation.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetUserLatestModelOperation return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetUserLatestModelOperationExpectation) Then(gp2 *mm_modelv1alpha.GetUserLatestModelOperationResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetUserLatestModelOperationResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetUserLatestModelOperation should be invoked
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) Times(n uint64) *mModelPublicServiceServerMockGetUserLatestModelOperation {
	if n == 0 {
		mmGetUserLatestModelOperation.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetUserLatestModelOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserLatestModelOperation.expectedInvocations, n)
	mmGetUserLatestModelOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserLatestModelOperation
}

func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) invocationsDone() bool {
	if len(mmGetUserLatestModelOperation.expectations) == 0 && mmGetUserLatestModelOperation.defaultExpectation == nil && mmGetUserLatestModelOperation.mock.funcGetUserLatestModelOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserLatestModelOperation.mock.afterGetUserLatestModelOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserLatestModelOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserLatestModelOperation implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetUserLatestModelOperation *ModelPublicServiceServerMock) GetUserLatestModelOperation(ctx context.Context, gp1 *mm_modelv1alpha.GetUserLatestModelOperationRequest) (gp2 *mm_modelv1alpha.GetUserLatestModelOperationResponse, err error) {
	mm_atomic.AddUint64(&mmGetUserLatestModelOperation.beforeGetUserLatestModelOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserLatestModelOperation.afterGetUserLatestModelOperationCounter, 1)

	mmGetUserLatestModelOperation.t.Helper()

	if mmGetUserLatestModelOperation.inspectFuncGetUserLatestModelOperation != nil {
		mmGetUserLatestModelOperation.inspectFuncGetUserLatestModelOperation(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetUserLatestModelOperationParams{ctx, gp1}

	// Record call args
	mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.mutex.Lock()
	mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.callArgs = append(mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.callArgs, &mm_params)
	mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.mutex.Unlock()

	for _, e := range mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetUserLatestModelOperationParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetUserLatestModelOperation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetUserLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetUserLatestModelOperation got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserLatestModelOperation.t.Errorf("ModelPublicServiceServerMock.GetUserLatestModelOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserLatestModelOperation.GetUserLatestModelOperationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserLatestModelOperation.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetUserLatestModelOperation")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetUserLatestModelOperation.funcGetUserLatestModelOperation != nil {
		return mmGetUserLatestModelOperation.funcGetUserLatestModelOperation(ctx, gp1)
	}
	mmGetUserLatestModelOperation.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetUserLatestModelOperation. %v %v", ctx, gp1)
	return
}

// GetUserLatestModelOperationAfterCounter returns a count of finished ModelPublicServiceServerMock.GetUserLatestModelOperation invocations
func (mmGetUserLatestModelOperation *ModelPublicServiceServerMock) GetUserLatestModelOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserLatestModelOperation.afterGetUserLatestModelOperationCounter)
}

// GetUserLatestModelOperationBeforeCounter returns a count of ModelPublicServiceServerMock.GetUserLatestModelOperation invocations
func (mmGetUserLatestModelOperation *ModelPublicServiceServerMock) GetUserLatestModelOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserLatestModelOperation.beforeGetUserLatestModelOperationCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetUserLatestModelOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserLatestModelOperation *mModelPublicServiceServerMockGetUserLatestModelOperation) Calls() []*ModelPublicServiceServerMockGetUserLatestModelOperationParams {
	mmGetUserLatestModelOperation.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetUserLatestModelOperationParams, len(mmGetUserLatestModelOperation.callArgs))
	copy(argCopy, mmGetUserLatestModelOperation.callArgs)

	mmGetUserLatestModelOperation.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserLatestModelOperationDone returns true if the count of the GetUserLatestModelOperation invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetUserLatestModelOperationDone() bool {
	if m.GetUserLatestModelOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserLatestModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserLatestModelOperationMock.invocationsDone()
}

// MinimockGetUserLatestModelOperationInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetUserLatestModelOperationInspect() {
	for _, e := range m.GetUserLatestModelOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserLatestModelOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserLatestModelOperationCounter := mm_atomic.LoadUint64(&m.afterGetUserLatestModelOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserLatestModelOperationMock.defaultExpectation != nil && afterGetUserLatestModelOperationCounter < 1 {
		if m.GetUserLatestModelOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserLatestModelOperation at\n%s", m.GetUserLatestModelOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserLatestModelOperation at\n%s with params: %#v", m.GetUserLatestModelOperationMock.defaultExpectation.expectationOrigins.origin, *m.GetUserLatestModelOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserLatestModelOperation != nil && afterGetUserLatestModelOperationCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserLatestModelOperation at\n%s", m.funcGetUserLatestModelOperationOrigin)
	}

	if !m.GetUserLatestModelOperationMock.invocationsDone() && afterGetUserLatestModelOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetUserLatestModelOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserLatestModelOperationMock.expectedInvocations), m.GetUserLatestModelOperationMock.expectedInvocationsOrigin, afterGetUserLatestModelOperationCounter)
	}
}

type mModelPublicServiceServerMockGetUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockGetUserModelExpectation
	expectations       []*ModelPublicServiceServerMockGetUserModelExpectation

	callArgs []*ModelPublicServiceServerMockGetUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockGetUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.GetUserModel
type ModelPublicServiceServerMockGetUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockGetUserModelParams
	paramPtrs          *ModelPublicServiceServerMockGetUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockGetUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockGetUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockGetUserModelParams contains parameters of the ModelPublicServiceServer.GetUserModel
type ModelPublicServiceServerMockGetUserModelParams struct {
	ctx context.Context
	gp1 *mm_modelv1alpha.GetUserModelRequest
}

// ModelPublicServiceServerMockGetUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.GetUserModel
type ModelPublicServiceServerMockGetUserModelParamPtrs struct {
	ctx *context.Context
	gp1 **mm_modelv1alpha.GetUserModelRequest
}

// ModelPublicServiceServerMockGetUserModelResults contains results of the ModelPublicServiceServer.GetUserModel
type ModelPublicServiceServerMockGetUserModelResults struct {
	gp2 *mm_modelv1alpha.GetUserModelResponse
	err error
}

// ModelPublicServiceServerMockGetUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.GetUserModel
type ModelPublicServiceServerMockGetUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) Optional() *mModelPublicServiceServerMockGetUserModel {
	mmGetUserModel.optional = true
	return mmGetUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.GetUserModel
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) Expect(ctx context.Context, gp1 *mm_modelv1alpha.GetUserModelRequest) *mModelPublicServiceServerMockGetUserModel {
	if mmGetUserModel.mock.funcGetUserModel != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by Set")
	}

	if mmGetUserModel.defaultExpectation == nil {
		mmGetUserModel.defaultExpectation = &ModelPublicServiceServerMockGetUserModelExpectation{}
	}

	if mmGetUserModel.defaultExpectation.paramPtrs != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by ExpectParams functions")
	}

	mmGetUserModel.defaultExpectation.params = &ModelPublicServiceServerMockGetUserModelParams{ctx, gp1}
	mmGetUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserModel.expectations {
		if minimock.Equal(e.params, mmGetUserModel.defaultExpectation.params) {
			mmGetUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserModel.defaultExpectation.params)
		}
	}

	return mmGetUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.GetUserModel
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockGetUserModel {
	if mmGetUserModel.mock.funcGetUserModel != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by Set")
	}

	if mmGetUserModel.defaultExpectation == nil {
		mmGetUserModel.defaultExpectation = &ModelPublicServiceServerMockGetUserModelExpectation{}
	}

	if mmGetUserModel.defaultExpectation.params != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by Expect")
	}

	if mmGetUserModel.defaultExpectation.paramPtrs == nil {
		mmGetUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetUserModelParamPtrs{}
	}
	mmGetUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserModel
}

// ExpectGp1Param2 sets up expected param gp1 for ModelPublicServiceServer.GetUserModel
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) ExpectGp1Param2(gp1 *mm_modelv1alpha.GetUserModelRequest) *mModelPublicServiceServerMockGetUserModel {
	if mmGetUserModel.mock.funcGetUserModel != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by Set")
	}

	if mmGetUserModel.defaultExpectation == nil {
		mmGetUserModel.defaultExpectation = &ModelPublicServiceServerMockGetUserModelExpectation{}
	}

	if mmGetUserModel.defaultExpectation.params != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by Expect")
	}

	if mmGetUserModel.defaultExpectation.paramPtrs == nil {
		mmGetUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockGetUserModelParamPtrs{}
	}
	mmGetUserModel.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetUserModel.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.GetUserModel
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) Inspect(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserModelRequest)) *mModelPublicServiceServerMockGetUserModel {
	if mmGetUserModel.mock.inspectFuncGetUserModel != nil {
		mmGetUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.GetUserModel")
	}

	mmGetUserModel.mock.inspectFuncGetUserModel = f

	return mmGetUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.GetUserModel
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) Return(gp2 *mm_modelv1alpha.GetUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmGetUserModel.mock.funcGetUserModel != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by Set")
	}

	if mmGetUserModel.defaultExpectation == nil {
		mmGetUserModel.defaultExpectation = &ModelPublicServiceServerMockGetUserModelExpectation{mock: mmGetUserModel.mock}
	}
	mmGetUserModel.defaultExpectation.results = &ModelPublicServiceServerMockGetUserModelResults{gp2, err}
	mmGetUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.GetUserModel method
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) Set(f func(ctx context.Context, gp1 *mm_modelv1alpha.GetUserModelRequest) (gp2 *mm_modelv1alpha.GetUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmGetUserModel.defaultExpectation != nil {
		mmGetUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.GetUserModel method")
	}

	if len(mmGetUserModel.expectations) > 0 {
		mmGetUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.GetUserModel method")
	}

	mmGetUserModel.mock.funcGetUserModel = f
	mmGetUserModel.mock.funcGetUserModelOrigin = minimock.CallerInfo(1)
	return mmGetUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.GetUserModel which will trigger the result defined by the following
// Then helper
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) When(ctx context.Context, gp1 *mm_modelv1alpha.GetUserModelRequest) *ModelPublicServiceServerMockGetUserModelExpectation {
	if mmGetUserModel.mock.funcGetUserModel != nil {
		mmGetUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.GetUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockGetUserModelExpectation{
		mock:               mmGetUserModel.mock,
		params:             &ModelPublicServiceServerMockGetUserModelParams{ctx, gp1},
		expectationOrigins: ModelPublicServiceServerMockGetUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserModel.expectations = append(mmGetUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.GetUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockGetUserModelExpectation) Then(gp2 *mm_modelv1alpha.GetUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockGetUserModelResults{gp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.GetUserModel should be invoked
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) Times(n uint64) *mModelPublicServiceServerMockGetUserModel {
	if n == 0 {
		mmGetUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.GetUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserModel.expectedInvocations, n)
	mmGetUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserModel
}

func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) invocationsDone() bool {
	if len(mmGetUserModel.expectations) == 0 && mmGetUserModel.defaultExpectation == nil && mmGetUserModel.mock.funcGetUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserModel.mock.afterGetUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmGetUserModel *ModelPublicServiceServerMock) GetUserModel(ctx context.Context, gp1 *mm_modelv1alpha.GetUserModelRequest) (gp2 *mm_modelv1alpha.GetUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmGetUserModel.beforeGetUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserModel.afterGetUserModelCounter, 1)

	mmGetUserModel.t.Helper()

	if mmGetUserModel.inspectFuncGetUserModel != nil {
		mmGetUserModel.inspectFuncGetUserModel(ctx, gp1)
	}

	mm_params := ModelPublicServiceServerMockGetUserModelParams{ctx, gp1}

	// Record call args
	mmGetUserModel.GetUserModelMock.mutex.Lock()
	mmGetUserModel.GetUserModelMock.callArgs = append(mmGetUserModel.GetUserModelMock.callArgs, &mm_params)
	mmGetUserModel.GetUserModelMock.mutex.Unlock()

	for _, e := range mmGetUserModel.GetUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetUserModel.GetUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserModel.GetUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserModel.GetUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserModel.GetUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockGetUserModelParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserModel.t.Errorf("ModelPublicServiceServerMock.GetUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserModel.GetUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetUserModel.t.Errorf("ModelPublicServiceServerMock.GetUserModel got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserModel.GetUserModelMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserModel.t.Errorf("ModelPublicServiceServerMock.GetUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserModel.GetUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserModel.GetUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.GetUserModel")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetUserModel.funcGetUserModel != nil {
		return mmGetUserModel.funcGetUserModel(ctx, gp1)
	}
	mmGetUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.GetUserModel. %v %v", ctx, gp1)
	return
}

// GetUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.GetUserModel invocations
func (mmGetUserModel *ModelPublicServiceServerMock) GetUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserModel.afterGetUserModelCounter)
}

// GetUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.GetUserModel invocations
func (mmGetUserModel *ModelPublicServiceServerMock) GetUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserModel.beforeGetUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.GetUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserModel *mModelPublicServiceServerMockGetUserModel) Calls() []*ModelPublicServiceServerMockGetUserModelParams {
	mmGetUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockGetUserModelParams, len(mmGetUserModel.callArgs))
	copy(argCopy, mmGetUserModel.callArgs)

	mmGetUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserModelDone returns true if the count of the GetUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockGetUserModelDone() bool {
	if m.GetUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserModelMock.invocationsDone()
}

// MinimockGetUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockGetUserModelInspect() {
	for _, e := range m.GetUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserModelCounter := mm_atomic.LoadUint64(&m.afterGetUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserModelMock.defaultExpectation != nil && afterGetUserModelCounter < 1 {
		if m.GetUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserModel at\n%s", m.GetUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserModel at\n%s with params: %#v", m.GetUserModelMock.defaultExpectation.expectationOrigins.origin, *m.GetUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserModel != nil && afterGetUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.GetUserModel at\n%s", m.funcGetUserModelOrigin)
	}

	if !m.GetUserModelMock.invocationsDone() && afterGetUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.GetUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserModelMock.expectedInvocations), m.GetUserModelMock.expectedInvocationsOrigin, afterGetUserModelCounter)
	}
}

type mModelPublicServiceServerMockListAvailableRegions struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListAvailableRegionsExpectation
	expectations       []*ModelPublicServiceServerMockListAvailableRegionsExpectation

	callArgs []*ModelPublicServiceServerMockListAvailableRegionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListAvailableRegionsExpectation specifies expectation struct of the ModelPublicServiceServer.ListAvailableRegions
type ModelPublicServiceServerMockListAvailableRegionsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListAvailableRegionsParams
	paramPtrs          *ModelPublicServiceServerMockListAvailableRegionsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListAvailableRegionsExpectationOrigins
	results            *ModelPublicServiceServerMockListAvailableRegionsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListAvailableRegionsParams contains parameters of the ModelPublicServiceServer.ListAvailableRegions
type ModelPublicServiceServerMockListAvailableRegionsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListAvailableRegionsRequest
}

// ModelPublicServiceServerMockListAvailableRegionsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListAvailableRegions
type ModelPublicServiceServerMockListAvailableRegionsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListAvailableRegionsRequest
}

// ModelPublicServiceServerMockListAvailableRegionsResults contains results of the ModelPublicServiceServer.ListAvailableRegions
type ModelPublicServiceServerMockListAvailableRegionsResults struct {
	lp2 *mm_modelv1alpha.ListAvailableRegionsResponse
	err error
}

// ModelPublicServiceServerMockListAvailableRegionsOrigins contains origins of expectations of the ModelPublicServiceServer.ListAvailableRegions
type ModelPublicServiceServerMockListAvailableRegionsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) Optional() *mModelPublicServiceServerMockListAvailableRegions {
	mmListAvailableRegions.optional = true
	return mmListAvailableRegions
}

// Expect sets up expected params for ModelPublicServiceServer.ListAvailableRegions
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListAvailableRegionsRequest) *mModelPublicServiceServerMockListAvailableRegions {
	if mmListAvailableRegions.mock.funcListAvailableRegions != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by Set")
	}

	if mmListAvailableRegions.defaultExpectation == nil {
		mmListAvailableRegions.defaultExpectation = &ModelPublicServiceServerMockListAvailableRegionsExpectation{}
	}

	if mmListAvailableRegions.defaultExpectation.paramPtrs != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by ExpectParams functions")
	}

	mmListAvailableRegions.defaultExpectation.params = &ModelPublicServiceServerMockListAvailableRegionsParams{ctx, lp1}
	mmListAvailableRegions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAvailableRegions.expectations {
		if minimock.Equal(e.params, mmListAvailableRegions.defaultExpectation.params) {
			mmListAvailableRegions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAvailableRegions.defaultExpectation.params)
		}
	}

	return mmListAvailableRegions
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListAvailableRegions
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListAvailableRegions {
	if mmListAvailableRegions.mock.funcListAvailableRegions != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by Set")
	}

	if mmListAvailableRegions.defaultExpectation == nil {
		mmListAvailableRegions.defaultExpectation = &ModelPublicServiceServerMockListAvailableRegionsExpectation{}
	}

	if mmListAvailableRegions.defaultExpectation.params != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by Expect")
	}

	if mmListAvailableRegions.defaultExpectation.paramPtrs == nil {
		mmListAvailableRegions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListAvailableRegionsParamPtrs{}
	}
	mmListAvailableRegions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAvailableRegions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAvailableRegions
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListAvailableRegions
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListAvailableRegionsRequest) *mModelPublicServiceServerMockListAvailableRegions {
	if mmListAvailableRegions.mock.funcListAvailableRegions != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by Set")
	}

	if mmListAvailableRegions.defaultExpectation == nil {
		mmListAvailableRegions.defaultExpectation = &ModelPublicServiceServerMockListAvailableRegionsExpectation{}
	}

	if mmListAvailableRegions.defaultExpectation.params != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by Expect")
	}

	if mmListAvailableRegions.defaultExpectation.paramPtrs == nil {
		mmListAvailableRegions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListAvailableRegionsParamPtrs{}
	}
	mmListAvailableRegions.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListAvailableRegions.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListAvailableRegions
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListAvailableRegions
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListAvailableRegionsRequest)) *mModelPublicServiceServerMockListAvailableRegions {
	if mmListAvailableRegions.mock.inspectFuncListAvailableRegions != nil {
		mmListAvailableRegions.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListAvailableRegions")
	}

	mmListAvailableRegions.mock.inspectFuncListAvailableRegions = f

	return mmListAvailableRegions
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListAvailableRegions
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) Return(lp2 *mm_modelv1alpha.ListAvailableRegionsResponse, err error) *ModelPublicServiceServerMock {
	if mmListAvailableRegions.mock.funcListAvailableRegions != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by Set")
	}

	if mmListAvailableRegions.defaultExpectation == nil {
		mmListAvailableRegions.defaultExpectation = &ModelPublicServiceServerMockListAvailableRegionsExpectation{mock: mmListAvailableRegions.mock}
	}
	mmListAvailableRegions.defaultExpectation.results = &ModelPublicServiceServerMockListAvailableRegionsResults{lp2, err}
	mmListAvailableRegions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAvailableRegions.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListAvailableRegions method
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListAvailableRegionsRequest) (lp2 *mm_modelv1alpha.ListAvailableRegionsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListAvailableRegions.defaultExpectation != nil {
		mmListAvailableRegions.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListAvailableRegions method")
	}

	if len(mmListAvailableRegions.expectations) > 0 {
		mmListAvailableRegions.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListAvailableRegions method")
	}

	mmListAvailableRegions.mock.funcListAvailableRegions = f
	mmListAvailableRegions.mock.funcListAvailableRegionsOrigin = minimock.CallerInfo(1)
	return mmListAvailableRegions.mock
}

// When sets expectation for the ModelPublicServiceServer.ListAvailableRegions which will trigger the result defined by the following
// Then helper
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) When(ctx context.Context, lp1 *mm_modelv1alpha.ListAvailableRegionsRequest) *ModelPublicServiceServerMockListAvailableRegionsExpectation {
	if mmListAvailableRegions.mock.funcListAvailableRegions != nil {
		mmListAvailableRegions.mock.t.Fatalf("ModelPublicServiceServerMock.ListAvailableRegions mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListAvailableRegionsExpectation{
		mock:               mmListAvailableRegions.mock,
		params:             &ModelPublicServiceServerMockListAvailableRegionsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListAvailableRegionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAvailableRegions.expectations = append(mmListAvailableRegions.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListAvailableRegions return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListAvailableRegionsExpectation) Then(lp2 *mm_modelv1alpha.ListAvailableRegionsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListAvailableRegionsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListAvailableRegions should be invoked
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) Times(n uint64) *mModelPublicServiceServerMockListAvailableRegions {
	if n == 0 {
		mmListAvailableRegions.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListAvailableRegions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAvailableRegions.expectedInvocations, n)
	mmListAvailableRegions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAvailableRegions
}

func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) invocationsDone() bool {
	if len(mmListAvailableRegions.expectations) == 0 && mmListAvailableRegions.defaultExpectation == nil && mmListAvailableRegions.mock.funcListAvailableRegions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAvailableRegions.mock.afterListAvailableRegionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAvailableRegions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAvailableRegions implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListAvailableRegions *ModelPublicServiceServerMock) ListAvailableRegions(ctx context.Context, lp1 *mm_modelv1alpha.ListAvailableRegionsRequest) (lp2 *mm_modelv1alpha.ListAvailableRegionsResponse, err error) {
	mm_atomic.AddUint64(&mmListAvailableRegions.beforeListAvailableRegionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAvailableRegions.afterListAvailableRegionsCounter, 1)

	mmListAvailableRegions.t.Helper()

	if mmListAvailableRegions.inspectFuncListAvailableRegions != nil {
		mmListAvailableRegions.inspectFuncListAvailableRegions(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListAvailableRegionsParams{ctx, lp1}

	// Record call args
	mmListAvailableRegions.ListAvailableRegionsMock.mutex.Lock()
	mmListAvailableRegions.ListAvailableRegionsMock.callArgs = append(mmListAvailableRegions.ListAvailableRegionsMock.callArgs, &mm_params)
	mmListAvailableRegions.ListAvailableRegionsMock.mutex.Unlock()

	for _, e := range mmListAvailableRegions.ListAvailableRegionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation.params
		mm_want_ptrs := mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListAvailableRegionsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAvailableRegions.t.Errorf("ModelPublicServiceServerMock.ListAvailableRegions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListAvailableRegions.t.Errorf("ModelPublicServiceServerMock.ListAvailableRegions got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAvailableRegions.t.Errorf("ModelPublicServiceServerMock.ListAvailableRegions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAvailableRegions.ListAvailableRegionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAvailableRegions.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListAvailableRegions")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListAvailableRegions.funcListAvailableRegions != nil {
		return mmListAvailableRegions.funcListAvailableRegions(ctx, lp1)
	}
	mmListAvailableRegions.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListAvailableRegions. %v %v", ctx, lp1)
	return
}

// ListAvailableRegionsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListAvailableRegions invocations
func (mmListAvailableRegions *ModelPublicServiceServerMock) ListAvailableRegionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAvailableRegions.afterListAvailableRegionsCounter)
}

// ListAvailableRegionsBeforeCounter returns a count of ModelPublicServiceServerMock.ListAvailableRegions invocations
func (mmListAvailableRegions *ModelPublicServiceServerMock) ListAvailableRegionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAvailableRegions.beforeListAvailableRegionsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListAvailableRegions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAvailableRegions *mModelPublicServiceServerMockListAvailableRegions) Calls() []*ModelPublicServiceServerMockListAvailableRegionsParams {
	mmListAvailableRegions.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListAvailableRegionsParams, len(mmListAvailableRegions.callArgs))
	copy(argCopy, mmListAvailableRegions.callArgs)

	mmListAvailableRegions.mutex.RUnlock()

	return argCopy
}

// MinimockListAvailableRegionsDone returns true if the count of the ListAvailableRegions invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListAvailableRegionsDone() bool {
	if m.ListAvailableRegionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAvailableRegionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAvailableRegionsMock.invocationsDone()
}

// MinimockListAvailableRegionsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListAvailableRegionsInspect() {
	for _, e := range m.ListAvailableRegionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListAvailableRegions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAvailableRegionsCounter := mm_atomic.LoadUint64(&m.afterListAvailableRegionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAvailableRegionsMock.defaultExpectation != nil && afterListAvailableRegionsCounter < 1 {
		if m.ListAvailableRegionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListAvailableRegions at\n%s", m.ListAvailableRegionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListAvailableRegions at\n%s with params: %#v", m.ListAvailableRegionsMock.defaultExpectation.expectationOrigins.origin, *m.ListAvailableRegionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAvailableRegions != nil && afterListAvailableRegionsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListAvailableRegions at\n%s", m.funcListAvailableRegionsOrigin)
	}

	if !m.ListAvailableRegionsMock.invocationsDone() && afterListAvailableRegionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListAvailableRegions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAvailableRegionsMock.expectedInvocations), m.ListAvailableRegionsMock.expectedInvocationsOrigin, afterListAvailableRegionsCounter)
	}
}

type mModelPublicServiceServerMockListModelDefinitions struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListModelDefinitionsExpectation
	expectations       []*ModelPublicServiceServerMockListModelDefinitionsExpectation

	callArgs []*ModelPublicServiceServerMockListModelDefinitionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListModelDefinitionsExpectation specifies expectation struct of the ModelPublicServiceServer.ListModelDefinitions
type ModelPublicServiceServerMockListModelDefinitionsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListModelDefinitionsParams
	paramPtrs          *ModelPublicServiceServerMockListModelDefinitionsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListModelDefinitionsExpectationOrigins
	results            *ModelPublicServiceServerMockListModelDefinitionsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListModelDefinitionsParams contains parameters of the ModelPublicServiceServer.ListModelDefinitions
type ModelPublicServiceServerMockListModelDefinitionsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListModelDefinitionsRequest
}

// ModelPublicServiceServerMockListModelDefinitionsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListModelDefinitions
type ModelPublicServiceServerMockListModelDefinitionsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListModelDefinitionsRequest
}

// ModelPublicServiceServerMockListModelDefinitionsResults contains results of the ModelPublicServiceServer.ListModelDefinitions
type ModelPublicServiceServerMockListModelDefinitionsResults struct {
	lp2 *mm_modelv1alpha.ListModelDefinitionsResponse
	err error
}

// ModelPublicServiceServerMockListModelDefinitionsOrigins contains origins of expectations of the ModelPublicServiceServer.ListModelDefinitions
type ModelPublicServiceServerMockListModelDefinitionsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) Optional() *mModelPublicServiceServerMockListModelDefinitions {
	mmListModelDefinitions.optional = true
	return mmListModelDefinitions
}

// Expect sets up expected params for ModelPublicServiceServer.ListModelDefinitions
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListModelDefinitionsRequest) *mModelPublicServiceServerMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &ModelPublicServiceServerMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by ExpectParams functions")
	}

	mmListModelDefinitions.defaultExpectation.params = &ModelPublicServiceServerMockListModelDefinitionsParams{ctx, lp1}
	mmListModelDefinitions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelDefinitions.expectations {
		if minimock.Equal(e.params, mmListModelDefinitions.defaultExpectation.params) {
			mmListModelDefinitions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelDefinitions.defaultExpectation.params)
		}
	}

	return mmListModelDefinitions
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListModelDefinitions
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &ModelPublicServiceServerMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelDefinitions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelDefinitions
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListModelDefinitions
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListModelDefinitionsRequest) *mModelPublicServiceServerMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &ModelPublicServiceServerMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListModelDefinitions.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListModelDefinitions
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListModelDefinitions
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelDefinitionsRequest)) *mModelPublicServiceServerMockListModelDefinitions {
	if mmListModelDefinitions.mock.inspectFuncListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListModelDefinitions")
	}

	mmListModelDefinitions.mock.inspectFuncListModelDefinitions = f

	return mmListModelDefinitions
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListModelDefinitions
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) Return(lp2 *mm_modelv1alpha.ListModelDefinitionsResponse, err error) *ModelPublicServiceServerMock {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &ModelPublicServiceServerMockListModelDefinitionsExpectation{mock: mmListModelDefinitions.mock}
	}
	mmListModelDefinitions.defaultExpectation.results = &ModelPublicServiceServerMockListModelDefinitionsResults{lp2, err}
	mmListModelDefinitions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelDefinitions.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListModelDefinitions method
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelDefinitionsRequest) (lp2 *mm_modelv1alpha.ListModelDefinitionsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListModelDefinitions.defaultExpectation != nil {
		mmListModelDefinitions.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListModelDefinitions method")
	}

	if len(mmListModelDefinitions.expectations) > 0 {
		mmListModelDefinitions.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListModelDefinitions method")
	}

	mmListModelDefinitions.mock.funcListModelDefinitions = f
	mmListModelDefinitions.mock.funcListModelDefinitionsOrigin = minimock.CallerInfo(1)
	return mmListModelDefinitions.mock
}

// When sets expectation for the ModelPublicServiceServer.ListModelDefinitions which will trigger the result defined by the following
// Then helper
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) When(ctx context.Context, lp1 *mm_modelv1alpha.ListModelDefinitionsRequest) *ModelPublicServiceServerMockListModelDefinitionsExpectation {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelDefinitions mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListModelDefinitionsExpectation{
		mock:               mmListModelDefinitions.mock,
		params:             &ModelPublicServiceServerMockListModelDefinitionsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListModelDefinitionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelDefinitions.expectations = append(mmListModelDefinitions.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListModelDefinitions return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListModelDefinitionsExpectation) Then(lp2 *mm_modelv1alpha.ListModelDefinitionsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListModelDefinitionsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListModelDefinitions should be invoked
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) Times(n uint64) *mModelPublicServiceServerMockListModelDefinitions {
	if n == 0 {
		mmListModelDefinitions.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListModelDefinitions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelDefinitions.expectedInvocations, n)
	mmListModelDefinitions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelDefinitions
}

func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) invocationsDone() bool {
	if len(mmListModelDefinitions.expectations) == 0 && mmListModelDefinitions.defaultExpectation == nil && mmListModelDefinitions.mock.funcListModelDefinitions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelDefinitions.mock.afterListModelDefinitionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelDefinitions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelDefinitions implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListModelDefinitions *ModelPublicServiceServerMock) ListModelDefinitions(ctx context.Context, lp1 *mm_modelv1alpha.ListModelDefinitionsRequest) (lp2 *mm_modelv1alpha.ListModelDefinitionsResponse, err error) {
	mm_atomic.AddUint64(&mmListModelDefinitions.beforeListModelDefinitionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelDefinitions.afterListModelDefinitionsCounter, 1)

	mmListModelDefinitions.t.Helper()

	if mmListModelDefinitions.inspectFuncListModelDefinitions != nil {
		mmListModelDefinitions.inspectFuncListModelDefinitions(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListModelDefinitionsParams{ctx, lp1}

	// Record call args
	mmListModelDefinitions.ListModelDefinitionsMock.mutex.Lock()
	mmListModelDefinitions.ListModelDefinitionsMock.callArgs = append(mmListModelDefinitions.ListModelDefinitionsMock.callArgs, &mm_params)
	mmListModelDefinitions.ListModelDefinitionsMock.mutex.Unlock()

	for _, e := range mmListModelDefinitions.ListModelDefinitionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListModelDefinitionsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelDefinitions.t.Errorf("ModelPublicServiceServerMock.ListModelDefinitions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListModelDefinitions.t.Errorf("ModelPublicServiceServerMock.ListModelDefinitions got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelDefinitions.t.Errorf("ModelPublicServiceServerMock.ListModelDefinitions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelDefinitions.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListModelDefinitions")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListModelDefinitions.funcListModelDefinitions != nil {
		return mmListModelDefinitions.funcListModelDefinitions(ctx, lp1)
	}
	mmListModelDefinitions.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListModelDefinitions. %v %v", ctx, lp1)
	return
}

// ListModelDefinitionsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListModelDefinitions invocations
func (mmListModelDefinitions *ModelPublicServiceServerMock) ListModelDefinitionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelDefinitions.afterListModelDefinitionsCounter)
}

// ListModelDefinitionsBeforeCounter returns a count of ModelPublicServiceServerMock.ListModelDefinitions invocations
func (mmListModelDefinitions *ModelPublicServiceServerMock) ListModelDefinitionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelDefinitions.beforeListModelDefinitionsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListModelDefinitions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelDefinitions *mModelPublicServiceServerMockListModelDefinitions) Calls() []*ModelPublicServiceServerMockListModelDefinitionsParams {
	mmListModelDefinitions.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListModelDefinitionsParams, len(mmListModelDefinitions.callArgs))
	copy(argCopy, mmListModelDefinitions.callArgs)

	mmListModelDefinitions.mutex.RUnlock()

	return argCopy
}

// MinimockListModelDefinitionsDone returns true if the count of the ListModelDefinitions invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListModelDefinitionsDone() bool {
	if m.ListModelDefinitionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelDefinitionsMock.invocationsDone()
}

// MinimockListModelDefinitionsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListModelDefinitionsInspect() {
	for _, e := range m.ListModelDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelDefinitions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelDefinitionsCounter := mm_atomic.LoadUint64(&m.afterListModelDefinitionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelDefinitionsMock.defaultExpectation != nil && afterListModelDefinitionsCounter < 1 {
		if m.ListModelDefinitionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelDefinitions at\n%s", m.ListModelDefinitionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelDefinitions at\n%s with params: %#v", m.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelDefinitionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelDefinitions != nil && afterListModelDefinitionsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelDefinitions at\n%s", m.funcListModelDefinitionsOrigin)
	}

	if !m.ListModelDefinitionsMock.invocationsDone() && afterListModelDefinitionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListModelDefinitions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelDefinitionsMock.expectedInvocations), m.ListModelDefinitionsMock.expectedInvocationsOrigin, afterListModelDefinitionsCounter)
	}
}

type mModelPublicServiceServerMockListModelRuns struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListModelRunsExpectation
	expectations       []*ModelPublicServiceServerMockListModelRunsExpectation

	callArgs []*ModelPublicServiceServerMockListModelRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListModelRunsExpectation specifies expectation struct of the ModelPublicServiceServer.ListModelRuns
type ModelPublicServiceServerMockListModelRunsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListModelRunsParams
	paramPtrs          *ModelPublicServiceServerMockListModelRunsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListModelRunsExpectationOrigins
	results            *ModelPublicServiceServerMockListModelRunsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListModelRunsParams contains parameters of the ModelPublicServiceServer.ListModelRuns
type ModelPublicServiceServerMockListModelRunsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListModelRunsRequest
}

// ModelPublicServiceServerMockListModelRunsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListModelRuns
type ModelPublicServiceServerMockListModelRunsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListModelRunsRequest
}

// ModelPublicServiceServerMockListModelRunsResults contains results of the ModelPublicServiceServer.ListModelRuns
type ModelPublicServiceServerMockListModelRunsResults struct {
	lp2 *mm_modelv1alpha.ListModelRunsResponse
	err error
}

// ModelPublicServiceServerMockListModelRunsOrigins contains origins of expectations of the ModelPublicServiceServer.ListModelRuns
type ModelPublicServiceServerMockListModelRunsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) Optional() *mModelPublicServiceServerMockListModelRuns {
	mmListModelRuns.optional = true
	return mmListModelRuns
}

// Expect sets up expected params for ModelPublicServiceServer.ListModelRuns
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsRequest) *mModelPublicServiceServerMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &ModelPublicServiceServerMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.paramPtrs != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by ExpectParams functions")
	}

	mmListModelRuns.defaultExpectation.params = &ModelPublicServiceServerMockListModelRunsParams{ctx, lp1}
	mmListModelRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelRuns.expectations {
		if minimock.Equal(e.params, mmListModelRuns.defaultExpectation.params) {
			mmListModelRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelRuns.defaultExpectation.params)
		}
	}

	return mmListModelRuns
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListModelRuns
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &ModelPublicServiceServerMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListModelRuns
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListModelRunsRequest) *mModelPublicServiceServerMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &ModelPublicServiceServerMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListModelRuns.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListModelRuns
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListModelRuns
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsRequest)) *mModelPublicServiceServerMockListModelRuns {
	if mmListModelRuns.mock.inspectFuncListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListModelRuns")
	}

	mmListModelRuns.mock.inspectFuncListModelRuns = f

	return mmListModelRuns
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListModelRuns
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) Return(lp2 *mm_modelv1alpha.ListModelRunsResponse, err error) *ModelPublicServiceServerMock {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &ModelPublicServiceServerMockListModelRunsExpectation{mock: mmListModelRuns.mock}
	}
	mmListModelRuns.defaultExpectation.results = &ModelPublicServiceServerMockListModelRunsResults{lp2, err}
	mmListModelRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelRuns.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListModelRuns method
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsRequest) (lp2 *mm_modelv1alpha.ListModelRunsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListModelRuns.defaultExpectation != nil {
		mmListModelRuns.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListModelRuns method")
	}

	if len(mmListModelRuns.expectations) > 0 {
		mmListModelRuns.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListModelRuns method")
	}

	mmListModelRuns.mock.funcListModelRuns = f
	mmListModelRuns.mock.funcListModelRunsOrigin = minimock.CallerInfo(1)
	return mmListModelRuns.mock
}

// When sets expectation for the ModelPublicServiceServer.ListModelRuns which will trigger the result defined by the following
// Then helper
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) When(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsRequest) *ModelPublicServiceServerMockListModelRunsExpectation {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRuns mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListModelRunsExpectation{
		mock:               mmListModelRuns.mock,
		params:             &ModelPublicServiceServerMockListModelRunsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListModelRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelRuns.expectations = append(mmListModelRuns.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListModelRuns return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListModelRunsExpectation) Then(lp2 *mm_modelv1alpha.ListModelRunsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListModelRunsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListModelRuns should be invoked
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) Times(n uint64) *mModelPublicServiceServerMockListModelRuns {
	if n == 0 {
		mmListModelRuns.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListModelRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelRuns.expectedInvocations, n)
	mmListModelRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelRuns
}

func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) invocationsDone() bool {
	if len(mmListModelRuns.expectations) == 0 && mmListModelRuns.defaultExpectation == nil && mmListModelRuns.mock.funcListModelRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelRuns.mock.afterListModelRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelRuns implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListModelRuns *ModelPublicServiceServerMock) ListModelRuns(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsRequest) (lp2 *mm_modelv1alpha.ListModelRunsResponse, err error) {
	mm_atomic.AddUint64(&mmListModelRuns.beforeListModelRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelRuns.afterListModelRunsCounter, 1)

	mmListModelRuns.t.Helper()

	if mmListModelRuns.inspectFuncListModelRuns != nil {
		mmListModelRuns.inspectFuncListModelRuns(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListModelRunsParams{ctx, lp1}

	// Record call args
	mmListModelRuns.ListModelRunsMock.mutex.Lock()
	mmListModelRuns.ListModelRunsMock.callArgs = append(mmListModelRuns.ListModelRunsMock.callArgs, &mm_params)
	mmListModelRuns.ListModelRunsMock.mutex.Unlock()

	for _, e := range mmListModelRuns.ListModelRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListModelRuns.ListModelRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelRuns.ListModelRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelRuns.ListModelRunsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelRuns.ListModelRunsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListModelRunsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelRuns.t.Errorf("ModelPublicServiceServerMock.ListModelRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListModelRuns.t.Errorf("ModelPublicServiceServerMock.ListModelRuns got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelRuns.t.Errorf("ModelPublicServiceServerMock.ListModelRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelRuns.ListModelRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelRuns.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListModelRuns")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListModelRuns.funcListModelRuns != nil {
		return mmListModelRuns.funcListModelRuns(ctx, lp1)
	}
	mmListModelRuns.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListModelRuns. %v %v", ctx, lp1)
	return
}

// ListModelRunsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListModelRuns invocations
func (mmListModelRuns *ModelPublicServiceServerMock) ListModelRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRuns.afterListModelRunsCounter)
}

// ListModelRunsBeforeCounter returns a count of ModelPublicServiceServerMock.ListModelRuns invocations
func (mmListModelRuns *ModelPublicServiceServerMock) ListModelRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRuns.beforeListModelRunsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListModelRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelRuns *mModelPublicServiceServerMockListModelRuns) Calls() []*ModelPublicServiceServerMockListModelRunsParams {
	mmListModelRuns.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListModelRunsParams, len(mmListModelRuns.callArgs))
	copy(argCopy, mmListModelRuns.callArgs)

	mmListModelRuns.mutex.RUnlock()

	return argCopy
}

// MinimockListModelRunsDone returns true if the count of the ListModelRuns invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListModelRunsDone() bool {
	if m.ListModelRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelRunsMock.invocationsDone()
}

// MinimockListModelRunsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListModelRunsInspect() {
	for _, e := range m.ListModelRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelRunsCounter := mm_atomic.LoadUint64(&m.afterListModelRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelRunsMock.defaultExpectation != nil && afterListModelRunsCounter < 1 {
		if m.ListModelRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRuns at\n%s", m.ListModelRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRuns at\n%s with params: %#v", m.ListModelRunsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelRuns != nil && afterListModelRunsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRuns at\n%s", m.funcListModelRunsOrigin)
	}

	if !m.ListModelRunsMock.invocationsDone() && afterListModelRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListModelRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelRunsMock.expectedInvocations), m.ListModelRunsMock.expectedInvocationsOrigin, afterListModelRunsCounter)
	}
}

type mModelPublicServiceServerMockListModelRunsByRequester struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListModelRunsByRequesterExpectation
	expectations       []*ModelPublicServiceServerMockListModelRunsByRequesterExpectation

	callArgs []*ModelPublicServiceServerMockListModelRunsByRequesterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListModelRunsByRequesterExpectation specifies expectation struct of the ModelPublicServiceServer.ListModelRunsByRequester
type ModelPublicServiceServerMockListModelRunsByRequesterExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListModelRunsByRequesterParams
	paramPtrs          *ModelPublicServiceServerMockListModelRunsByRequesterParamPtrs
	expectationOrigins ModelPublicServiceServerMockListModelRunsByRequesterExpectationOrigins
	results            *ModelPublicServiceServerMockListModelRunsByRequesterResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListModelRunsByRequesterParams contains parameters of the ModelPublicServiceServer.ListModelRunsByRequester
type ModelPublicServiceServerMockListModelRunsByRequesterParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest
}

// ModelPublicServiceServerMockListModelRunsByRequesterParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListModelRunsByRequester
type ModelPublicServiceServerMockListModelRunsByRequesterParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListModelRunsByRequesterRequest
}

// ModelPublicServiceServerMockListModelRunsByRequesterResults contains results of the ModelPublicServiceServer.ListModelRunsByRequester
type ModelPublicServiceServerMockListModelRunsByRequesterResults struct {
	lp2 *mm_modelv1alpha.ListModelRunsByRequesterResponse
	err error
}

// ModelPublicServiceServerMockListModelRunsByRequesterOrigins contains origins of expectations of the ModelPublicServiceServer.ListModelRunsByRequester
type ModelPublicServiceServerMockListModelRunsByRequesterExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) Optional() *mModelPublicServiceServerMockListModelRunsByRequester {
	mmListModelRunsByRequester.optional = true
	return mmListModelRunsByRequester
}

// Expect sets up expected params for ModelPublicServiceServer.ListModelRunsByRequester
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest) *mModelPublicServiceServerMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &ModelPublicServiceServerMockListModelRunsByRequesterExpectation{}
	}

	if mmListModelRunsByRequester.defaultExpectation.paramPtrs != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by ExpectParams functions")
	}

	mmListModelRunsByRequester.defaultExpectation.params = &ModelPublicServiceServerMockListModelRunsByRequesterParams{ctx, lp1}
	mmListModelRunsByRequester.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelRunsByRequester.expectations {
		if minimock.Equal(e.params, mmListModelRunsByRequester.defaultExpectation.params) {
			mmListModelRunsByRequester.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelRunsByRequester.defaultExpectation.params)
		}
	}

	return mmListModelRunsByRequester
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListModelRunsByRequester
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &ModelPublicServiceServerMockListModelRunsByRequesterExpectation{}
	}

	if mmListModelRunsByRequester.defaultExpectation.params != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by Expect")
	}

	if mmListModelRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmListModelRunsByRequester.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelRunsByRequesterParamPtrs{}
	}
	mmListModelRunsByRequester.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelRunsByRequester.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelRunsByRequester
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListModelRunsByRequester
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest) *mModelPublicServiceServerMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &ModelPublicServiceServerMockListModelRunsByRequesterExpectation{}
	}

	if mmListModelRunsByRequester.defaultExpectation.params != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by Expect")
	}

	if mmListModelRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmListModelRunsByRequester.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelRunsByRequesterParamPtrs{}
	}
	mmListModelRunsByRequester.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListModelRunsByRequester.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListModelRunsByRequester
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListModelRunsByRequester
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest)) *mModelPublicServiceServerMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.inspectFuncListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListModelRunsByRequester")
	}

	mmListModelRunsByRequester.mock.inspectFuncListModelRunsByRequester = f

	return mmListModelRunsByRequester
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListModelRunsByRequester
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) Return(lp2 *mm_modelv1alpha.ListModelRunsByRequesterResponse, err error) *ModelPublicServiceServerMock {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &ModelPublicServiceServerMockListModelRunsByRequesterExpectation{mock: mmListModelRunsByRequester.mock}
	}
	mmListModelRunsByRequester.defaultExpectation.results = &ModelPublicServiceServerMockListModelRunsByRequesterResults{lp2, err}
	mmListModelRunsByRequester.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelRunsByRequester.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListModelRunsByRequester method
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest) (lp2 *mm_modelv1alpha.ListModelRunsByRequesterResponse, err error)) *ModelPublicServiceServerMock {
	if mmListModelRunsByRequester.defaultExpectation != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListModelRunsByRequester method")
	}

	if len(mmListModelRunsByRequester.expectations) > 0 {
		mmListModelRunsByRequester.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListModelRunsByRequester method")
	}

	mmListModelRunsByRequester.mock.funcListModelRunsByRequester = f
	mmListModelRunsByRequester.mock.funcListModelRunsByRequesterOrigin = minimock.CallerInfo(1)
	return mmListModelRunsByRequester.mock
}

// When sets expectation for the ModelPublicServiceServer.ListModelRunsByRequester which will trigger the result defined by the following
// Then helper
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) When(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest) *ModelPublicServiceServerMockListModelRunsByRequesterExpectation {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("ModelPublicServiceServerMock.ListModelRunsByRequester mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListModelRunsByRequesterExpectation{
		mock:               mmListModelRunsByRequester.mock,
		params:             &ModelPublicServiceServerMockListModelRunsByRequesterParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListModelRunsByRequesterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelRunsByRequester.expectations = append(mmListModelRunsByRequester.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListModelRunsByRequester return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListModelRunsByRequesterExpectation) Then(lp2 *mm_modelv1alpha.ListModelRunsByRequesterResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListModelRunsByRequesterResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListModelRunsByRequester should be invoked
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) Times(n uint64) *mModelPublicServiceServerMockListModelRunsByRequester {
	if n == 0 {
		mmListModelRunsByRequester.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListModelRunsByRequester mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelRunsByRequester.expectedInvocations, n)
	mmListModelRunsByRequester.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelRunsByRequester
}

func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) invocationsDone() bool {
	if len(mmListModelRunsByRequester.expectations) == 0 && mmListModelRunsByRequester.defaultExpectation == nil && mmListModelRunsByRequester.mock.funcListModelRunsByRequester == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelRunsByRequester.mock.afterListModelRunsByRequesterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelRunsByRequester.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelRunsByRequester implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListModelRunsByRequester *ModelPublicServiceServerMock) ListModelRunsByRequester(ctx context.Context, lp1 *mm_modelv1alpha.ListModelRunsByRequesterRequest) (lp2 *mm_modelv1alpha.ListModelRunsByRequesterResponse, err error) {
	mm_atomic.AddUint64(&mmListModelRunsByRequester.beforeListModelRunsByRequesterCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelRunsByRequester.afterListModelRunsByRequesterCounter, 1)

	mmListModelRunsByRequester.t.Helper()

	if mmListModelRunsByRequester.inspectFuncListModelRunsByRequester != nil {
		mmListModelRunsByRequester.inspectFuncListModelRunsByRequester(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListModelRunsByRequesterParams{ctx, lp1}

	// Record call args
	mmListModelRunsByRequester.ListModelRunsByRequesterMock.mutex.Lock()
	mmListModelRunsByRequester.ListModelRunsByRequesterMock.callArgs = append(mmListModelRunsByRequester.ListModelRunsByRequesterMock.callArgs, &mm_params)
	mmListModelRunsByRequester.ListModelRunsByRequesterMock.mutex.Unlock()

	for _, e := range mmListModelRunsByRequester.ListModelRunsByRequesterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.params
		mm_want_ptrs := mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListModelRunsByRequesterParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelRunsByRequester.t.Errorf("ModelPublicServiceServerMock.ListModelRunsByRequester got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListModelRunsByRequester.t.Errorf("ModelPublicServiceServerMock.ListModelRunsByRequester got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelRunsByRequester.t.Errorf("ModelPublicServiceServerMock.ListModelRunsByRequester got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelRunsByRequester.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListModelRunsByRequester")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListModelRunsByRequester.funcListModelRunsByRequester != nil {
		return mmListModelRunsByRequester.funcListModelRunsByRequester(ctx, lp1)
	}
	mmListModelRunsByRequester.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListModelRunsByRequester. %v %v", ctx, lp1)
	return
}

// ListModelRunsByRequesterAfterCounter returns a count of finished ModelPublicServiceServerMock.ListModelRunsByRequester invocations
func (mmListModelRunsByRequester *ModelPublicServiceServerMock) ListModelRunsByRequesterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRunsByRequester.afterListModelRunsByRequesterCounter)
}

// ListModelRunsByRequesterBeforeCounter returns a count of ModelPublicServiceServerMock.ListModelRunsByRequester invocations
func (mmListModelRunsByRequester *ModelPublicServiceServerMock) ListModelRunsByRequesterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRunsByRequester.beforeListModelRunsByRequesterCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListModelRunsByRequester.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelRunsByRequester *mModelPublicServiceServerMockListModelRunsByRequester) Calls() []*ModelPublicServiceServerMockListModelRunsByRequesterParams {
	mmListModelRunsByRequester.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListModelRunsByRequesterParams, len(mmListModelRunsByRequester.callArgs))
	copy(argCopy, mmListModelRunsByRequester.callArgs)

	mmListModelRunsByRequester.mutex.RUnlock()

	return argCopy
}

// MinimockListModelRunsByRequesterDone returns true if the count of the ListModelRunsByRequester invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListModelRunsByRequesterDone() bool {
	if m.ListModelRunsByRequesterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelRunsByRequesterMock.invocationsDone()
}

// MinimockListModelRunsByRequesterInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListModelRunsByRequesterInspect() {
	for _, e := range m.ListModelRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRunsByRequester at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelRunsByRequesterCounter := mm_atomic.LoadUint64(&m.afterListModelRunsByRequesterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelRunsByRequesterMock.defaultExpectation != nil && afterListModelRunsByRequesterCounter < 1 {
		if m.ListModelRunsByRequesterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRunsByRequester at\n%s", m.ListModelRunsByRequesterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRunsByRequester at\n%s with params: %#v", m.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *m.ListModelRunsByRequesterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelRunsByRequester != nil && afterListModelRunsByRequesterCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModelRunsByRequester at\n%s", m.funcListModelRunsByRequesterOrigin)
	}

	if !m.ListModelRunsByRequesterMock.invocationsDone() && afterListModelRunsByRequesterCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListModelRunsByRequester at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelRunsByRequesterMock.expectedInvocations), m.ListModelRunsByRequesterMock.expectedInvocationsOrigin, afterListModelRunsByRequesterCounter)
	}
}

type mModelPublicServiceServerMockListModels struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListModelsExpectation
	expectations       []*ModelPublicServiceServerMockListModelsExpectation

	callArgs []*ModelPublicServiceServerMockListModelsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListModelsExpectation specifies expectation struct of the ModelPublicServiceServer.ListModels
type ModelPublicServiceServerMockListModelsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListModelsParams
	paramPtrs          *ModelPublicServiceServerMockListModelsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListModelsExpectationOrigins
	results            *ModelPublicServiceServerMockListModelsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListModelsParams contains parameters of the ModelPublicServiceServer.ListModels
type ModelPublicServiceServerMockListModelsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListModelsRequest
}

// ModelPublicServiceServerMockListModelsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListModels
type ModelPublicServiceServerMockListModelsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListModelsRequest
}

// ModelPublicServiceServerMockListModelsResults contains results of the ModelPublicServiceServer.ListModels
type ModelPublicServiceServerMockListModelsResults struct {
	lp2 *mm_modelv1alpha.ListModelsResponse
	err error
}

// ModelPublicServiceServerMockListModelsOrigins contains origins of expectations of the ModelPublicServiceServer.ListModels
type ModelPublicServiceServerMockListModelsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModels *mModelPublicServiceServerMockListModels) Optional() *mModelPublicServiceServerMockListModels {
	mmListModels.optional = true
	return mmListModels
}

// Expect sets up expected params for ModelPublicServiceServer.ListModels
func (mmListModels *mModelPublicServiceServerMockListModels) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListModelsRequest) *mModelPublicServiceServerMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &ModelPublicServiceServerMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.paramPtrs != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by ExpectParams functions")
	}

	mmListModels.defaultExpectation.params = &ModelPublicServiceServerMockListModelsParams{ctx, lp1}
	mmListModels.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModels.expectations {
		if minimock.Equal(e.params, mmListModels.defaultExpectation.params) {
			mmListModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModels.defaultExpectation.params)
		}
	}

	return mmListModels
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListModels
func (mmListModels *mModelPublicServiceServerMockListModels) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &ModelPublicServiceServerMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModels.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListModels
func (mmListModels *mModelPublicServiceServerMockListModels) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListModelsRequest) *mModelPublicServiceServerMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &ModelPublicServiceServerMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListModels.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListModels
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListModels
func (mmListModels *mModelPublicServiceServerMockListModels) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelsRequest)) *mModelPublicServiceServerMockListModels {
	if mmListModels.mock.inspectFuncListModels != nil {
		mmListModels.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListModels")
	}

	mmListModels.mock.inspectFuncListModels = f

	return mmListModels
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListModels
func (mmListModels *mModelPublicServiceServerMockListModels) Return(lp2 *mm_modelv1alpha.ListModelsResponse, err error) *ModelPublicServiceServerMock {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &ModelPublicServiceServerMockListModelsExpectation{mock: mmListModels.mock}
	}
	mmListModels.defaultExpectation.results = &ModelPublicServiceServerMockListModelsResults{lp2, err}
	mmListModels.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModels.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListModels method
func (mmListModels *mModelPublicServiceServerMockListModels) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListModelsRequest) (lp2 *mm_modelv1alpha.ListModelsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListModels.defaultExpectation != nil {
		mmListModels.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListModels method")
	}

	if len(mmListModels.expectations) > 0 {
		mmListModels.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListModels method")
	}

	mmListModels.mock.funcListModels = f
	mmListModels.mock.funcListModelsOrigin = minimock.CallerInfo(1)
	return mmListModels.mock
}

// When sets expectation for the ModelPublicServiceServer.ListModels which will trigger the result defined by the following
// Then helper
func (mmListModels *mModelPublicServiceServerMockListModels) When(ctx context.Context, lp1 *mm_modelv1alpha.ListModelsRequest) *ModelPublicServiceServerMockListModelsExpectation {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListModels mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListModelsExpectation{
		mock:               mmListModels.mock,
		params:             &ModelPublicServiceServerMockListModelsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListModelsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModels.expectations = append(mmListModels.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListModels return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListModelsExpectation) Then(lp2 *mm_modelv1alpha.ListModelsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListModelsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListModels should be invoked
func (mmListModels *mModelPublicServiceServerMockListModels) Times(n uint64) *mModelPublicServiceServerMockListModels {
	if n == 0 {
		mmListModels.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModels.expectedInvocations, n)
	mmListModels.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModels
}

func (mmListModels *mModelPublicServiceServerMockListModels) invocationsDone() bool {
	if len(mmListModels.expectations) == 0 && mmListModels.defaultExpectation == nil && mmListModels.mock.funcListModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModels.mock.afterListModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModels implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListModels *ModelPublicServiceServerMock) ListModels(ctx context.Context, lp1 *mm_modelv1alpha.ListModelsRequest) (lp2 *mm_modelv1alpha.ListModelsResponse, err error) {
	mm_atomic.AddUint64(&mmListModels.beforeListModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModels.afterListModelsCounter, 1)

	mmListModels.t.Helper()

	if mmListModels.inspectFuncListModels != nil {
		mmListModels.inspectFuncListModels(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListModelsParams{ctx, lp1}

	// Record call args
	mmListModels.ListModelsMock.mutex.Lock()
	mmListModels.ListModelsMock.callArgs = append(mmListModels.ListModelsMock.callArgs, &mm_params)
	mmListModels.ListModelsMock.mutex.Unlock()

	for _, e := range mmListModels.ListModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListModels.ListModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModels.ListModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModels.ListModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListModels.ListModelsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListModelsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModels.t.Errorf("ModelPublicServiceServerMock.ListModels got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListModels.t.Errorf("ModelPublicServiceServerMock.ListModels got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModels.t.Errorf("ModelPublicServiceServerMock.ListModels got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModels.ListModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModels.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListModels")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListModels.funcListModels != nil {
		return mmListModels.funcListModels(ctx, lp1)
	}
	mmListModels.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListModels. %v %v", ctx, lp1)
	return
}

// ListModelsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListModels invocations
func (mmListModels *ModelPublicServiceServerMock) ListModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModels.afterListModelsCounter)
}

// ListModelsBeforeCounter returns a count of ModelPublicServiceServerMock.ListModels invocations
func (mmListModels *ModelPublicServiceServerMock) ListModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModels.beforeListModelsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModels *mModelPublicServiceServerMockListModels) Calls() []*ModelPublicServiceServerMockListModelsParams {
	mmListModels.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListModelsParams, len(mmListModels.callArgs))
	copy(argCopy, mmListModels.callArgs)

	mmListModels.mutex.RUnlock()

	return argCopy
}

// MinimockListModelsDone returns true if the count of the ListModels invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListModelsDone() bool {
	if m.ListModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelsMock.invocationsDone()
}

// MinimockListModelsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListModelsInspect() {
	for _, e := range m.ListModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModels at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelsCounter := mm_atomic.LoadUint64(&m.afterListModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelsMock.defaultExpectation != nil && afterListModelsCounter < 1 {
		if m.ListModelsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModels at\n%s", m.ListModelsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModels at\n%s with params: %#v", m.ListModelsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModels != nil && afterListModelsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListModels at\n%s", m.funcListModelsOrigin)
	}

	if !m.ListModelsMock.invocationsDone() && afterListModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListModels at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelsMock.expectedInvocations), m.ListModelsMock.expectedInvocationsOrigin, afterListModelsCounter)
	}
}

type mModelPublicServiceServerMockListNamespaceModelVersions struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListNamespaceModelVersionsExpectation
	expectations       []*ModelPublicServiceServerMockListNamespaceModelVersionsExpectation

	callArgs []*ModelPublicServiceServerMockListNamespaceModelVersionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListNamespaceModelVersionsExpectation specifies expectation struct of the ModelPublicServiceServer.ListNamespaceModelVersions
type ModelPublicServiceServerMockListNamespaceModelVersionsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListNamespaceModelVersionsParams
	paramPtrs          *ModelPublicServiceServerMockListNamespaceModelVersionsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListNamespaceModelVersionsExpectationOrigins
	results            *ModelPublicServiceServerMockListNamespaceModelVersionsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListNamespaceModelVersionsParams contains parameters of the ModelPublicServiceServer.ListNamespaceModelVersions
type ModelPublicServiceServerMockListNamespaceModelVersionsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest
}

// ModelPublicServiceServerMockListNamespaceModelVersionsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListNamespaceModelVersions
type ModelPublicServiceServerMockListNamespaceModelVersionsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListNamespaceModelVersionsRequest
}

// ModelPublicServiceServerMockListNamespaceModelVersionsResults contains results of the ModelPublicServiceServer.ListNamespaceModelVersions
type ModelPublicServiceServerMockListNamespaceModelVersionsResults struct {
	lp2 *mm_modelv1alpha.ListNamespaceModelVersionsResponse
	err error
}

// ModelPublicServiceServerMockListNamespaceModelVersionsOrigins contains origins of expectations of the ModelPublicServiceServer.ListNamespaceModelVersions
type ModelPublicServiceServerMockListNamespaceModelVersionsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) Optional() *mModelPublicServiceServerMockListNamespaceModelVersions {
	mmListNamespaceModelVersions.optional = true
	return mmListNamespaceModelVersions
}

// Expect sets up expected params for ModelPublicServiceServer.ListNamespaceModelVersions
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest) *mModelPublicServiceServerMockListNamespaceModelVersions {
	if mmListNamespaceModelVersions.mock.funcListNamespaceModelVersions != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by Set")
	}

	if mmListNamespaceModelVersions.defaultExpectation == nil {
		mmListNamespaceModelVersions.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelVersionsExpectation{}
	}

	if mmListNamespaceModelVersions.defaultExpectation.paramPtrs != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by ExpectParams functions")
	}

	mmListNamespaceModelVersions.defaultExpectation.params = &ModelPublicServiceServerMockListNamespaceModelVersionsParams{ctx, lp1}
	mmListNamespaceModelVersions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespaceModelVersions.expectations {
		if minimock.Equal(e.params, mmListNamespaceModelVersions.defaultExpectation.params) {
			mmListNamespaceModelVersions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceModelVersions.defaultExpectation.params)
		}
	}

	return mmListNamespaceModelVersions
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListNamespaceModelVersions
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListNamespaceModelVersions {
	if mmListNamespaceModelVersions.mock.funcListNamespaceModelVersions != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by Set")
	}

	if mmListNamespaceModelVersions.defaultExpectation == nil {
		mmListNamespaceModelVersions.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelVersionsExpectation{}
	}

	if mmListNamespaceModelVersions.defaultExpectation.params != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by Expect")
	}

	if mmListNamespaceModelVersions.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModelVersions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListNamespaceModelVersionsParamPtrs{}
	}
	mmListNamespaceModelVersions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespaceModelVersions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespaceModelVersions
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListNamespaceModelVersions
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest) *mModelPublicServiceServerMockListNamespaceModelVersions {
	if mmListNamespaceModelVersions.mock.funcListNamespaceModelVersions != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by Set")
	}

	if mmListNamespaceModelVersions.defaultExpectation == nil {
		mmListNamespaceModelVersions.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelVersionsExpectation{}
	}

	if mmListNamespaceModelVersions.defaultExpectation.params != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by Expect")
	}

	if mmListNamespaceModelVersions.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModelVersions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListNamespaceModelVersionsParamPtrs{}
	}
	mmListNamespaceModelVersions.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListNamespaceModelVersions.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListNamespaceModelVersions
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListNamespaceModelVersions
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest)) *mModelPublicServiceServerMockListNamespaceModelVersions {
	if mmListNamespaceModelVersions.mock.inspectFuncListNamespaceModelVersions != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListNamespaceModelVersions")
	}

	mmListNamespaceModelVersions.mock.inspectFuncListNamespaceModelVersions = f

	return mmListNamespaceModelVersions
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListNamespaceModelVersions
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) Return(lp2 *mm_modelv1alpha.ListNamespaceModelVersionsResponse, err error) *ModelPublicServiceServerMock {
	if mmListNamespaceModelVersions.mock.funcListNamespaceModelVersions != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by Set")
	}

	if mmListNamespaceModelVersions.defaultExpectation == nil {
		mmListNamespaceModelVersions.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelVersionsExpectation{mock: mmListNamespaceModelVersions.mock}
	}
	mmListNamespaceModelVersions.defaultExpectation.results = &ModelPublicServiceServerMockListNamespaceModelVersionsResults{lp2, err}
	mmListNamespaceModelVersions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModelVersions.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListNamespaceModelVersions method
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest) (lp2 *mm_modelv1alpha.ListNamespaceModelVersionsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListNamespaceModelVersions.defaultExpectation != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListNamespaceModelVersions method")
	}

	if len(mmListNamespaceModelVersions.expectations) > 0 {
		mmListNamespaceModelVersions.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListNamespaceModelVersions method")
	}

	mmListNamespaceModelVersions.mock.funcListNamespaceModelVersions = f
	mmListNamespaceModelVersions.mock.funcListNamespaceModelVersionsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModelVersions.mock
}

// When sets expectation for the ModelPublicServiceServer.ListNamespaceModelVersions which will trigger the result defined by the following
// Then helper
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) When(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest) *ModelPublicServiceServerMockListNamespaceModelVersionsExpectation {
	if mmListNamespaceModelVersions.mock.funcListNamespaceModelVersions != nil {
		mmListNamespaceModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModelVersions mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListNamespaceModelVersionsExpectation{
		mock:               mmListNamespaceModelVersions.mock,
		params:             &ModelPublicServiceServerMockListNamespaceModelVersionsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListNamespaceModelVersionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespaceModelVersions.expectations = append(mmListNamespaceModelVersions.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListNamespaceModelVersions return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListNamespaceModelVersionsExpectation) Then(lp2 *mm_modelv1alpha.ListNamespaceModelVersionsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListNamespaceModelVersionsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListNamespaceModelVersions should be invoked
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) Times(n uint64) *mModelPublicServiceServerMockListNamespaceModelVersions {
	if n == 0 {
		mmListNamespaceModelVersions.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListNamespaceModelVersions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceModelVersions.expectedInvocations, n)
	mmListNamespaceModelVersions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModelVersions
}

func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) invocationsDone() bool {
	if len(mmListNamespaceModelVersions.expectations) == 0 && mmListNamespaceModelVersions.defaultExpectation == nil && mmListNamespaceModelVersions.mock.funcListNamespaceModelVersions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceModelVersions.mock.afterListNamespaceModelVersionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceModelVersions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceModelVersions implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListNamespaceModelVersions *ModelPublicServiceServerMock) ListNamespaceModelVersions(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelVersionsRequest) (lp2 *mm_modelv1alpha.ListNamespaceModelVersionsResponse, err error) {
	mm_atomic.AddUint64(&mmListNamespaceModelVersions.beforeListNamespaceModelVersionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceModelVersions.afterListNamespaceModelVersionsCounter, 1)

	mmListNamespaceModelVersions.t.Helper()

	if mmListNamespaceModelVersions.inspectFuncListNamespaceModelVersions != nil {
		mmListNamespaceModelVersions.inspectFuncListNamespaceModelVersions(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListNamespaceModelVersionsParams{ctx, lp1}

	// Record call args
	mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.mutex.Lock()
	mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.callArgs = append(mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.callArgs, &mm_params)
	mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.mutex.Unlock()

	for _, e := range mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListNamespaceModelVersionsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceModelVersions.t.Errorf("ModelPublicServiceServerMock.ListNamespaceModelVersions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListNamespaceModelVersions.t.Errorf("ModelPublicServiceServerMock.ListNamespaceModelVersions got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceModelVersions.t.Errorf("ModelPublicServiceServerMock.ListNamespaceModelVersions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceModelVersions.ListNamespaceModelVersionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceModelVersions.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListNamespaceModelVersions")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListNamespaceModelVersions.funcListNamespaceModelVersions != nil {
		return mmListNamespaceModelVersions.funcListNamespaceModelVersions(ctx, lp1)
	}
	mmListNamespaceModelVersions.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListNamespaceModelVersions. %v %v", ctx, lp1)
	return
}

// ListNamespaceModelVersionsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListNamespaceModelVersions invocations
func (mmListNamespaceModelVersions *ModelPublicServiceServerMock) ListNamespaceModelVersionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModelVersions.afterListNamespaceModelVersionsCounter)
}

// ListNamespaceModelVersionsBeforeCounter returns a count of ModelPublicServiceServerMock.ListNamespaceModelVersions invocations
func (mmListNamespaceModelVersions *ModelPublicServiceServerMock) ListNamespaceModelVersionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModelVersions.beforeListNamespaceModelVersionsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListNamespaceModelVersions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceModelVersions *mModelPublicServiceServerMockListNamespaceModelVersions) Calls() []*ModelPublicServiceServerMockListNamespaceModelVersionsParams {
	mmListNamespaceModelVersions.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListNamespaceModelVersionsParams, len(mmListNamespaceModelVersions.callArgs))
	copy(argCopy, mmListNamespaceModelVersions.callArgs)

	mmListNamespaceModelVersions.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceModelVersionsDone returns true if the count of the ListNamespaceModelVersions invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListNamespaceModelVersionsDone() bool {
	if m.ListNamespaceModelVersionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceModelVersionsMock.invocationsDone()
}

// MinimockListNamespaceModelVersionsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListNamespaceModelVersionsInspect() {
	for _, e := range m.ListNamespaceModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModelVersions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespaceModelVersionsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceModelVersionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceModelVersionsMock.defaultExpectation != nil && afterListNamespaceModelVersionsCounter < 1 {
		if m.ListNamespaceModelVersionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModelVersions at\n%s", m.ListNamespaceModelVersionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModelVersions at\n%s with params: %#v", m.ListNamespaceModelVersionsMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespaceModelVersionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceModelVersions != nil && afterListNamespaceModelVersionsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModelVersions at\n%s", m.funcListNamespaceModelVersionsOrigin)
	}

	if !m.ListNamespaceModelVersionsMock.invocationsDone() && afterListNamespaceModelVersionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListNamespaceModelVersions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceModelVersionsMock.expectedInvocations), m.ListNamespaceModelVersionsMock.expectedInvocationsOrigin, afterListNamespaceModelVersionsCounter)
	}
}

type mModelPublicServiceServerMockListNamespaceModels struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListNamespaceModelsExpectation
	expectations       []*ModelPublicServiceServerMockListNamespaceModelsExpectation

	callArgs []*ModelPublicServiceServerMockListNamespaceModelsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListNamespaceModelsExpectation specifies expectation struct of the ModelPublicServiceServer.ListNamespaceModels
type ModelPublicServiceServerMockListNamespaceModelsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListNamespaceModelsParams
	paramPtrs          *ModelPublicServiceServerMockListNamespaceModelsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListNamespaceModelsExpectationOrigins
	results            *ModelPublicServiceServerMockListNamespaceModelsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListNamespaceModelsParams contains parameters of the ModelPublicServiceServer.ListNamespaceModels
type ModelPublicServiceServerMockListNamespaceModelsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListNamespaceModelsRequest
}

// ModelPublicServiceServerMockListNamespaceModelsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListNamespaceModels
type ModelPublicServiceServerMockListNamespaceModelsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListNamespaceModelsRequest
}

// ModelPublicServiceServerMockListNamespaceModelsResults contains results of the ModelPublicServiceServer.ListNamespaceModels
type ModelPublicServiceServerMockListNamespaceModelsResults struct {
	lp2 *mm_modelv1alpha.ListNamespaceModelsResponse
	err error
}

// ModelPublicServiceServerMockListNamespaceModelsOrigins contains origins of expectations of the ModelPublicServiceServer.ListNamespaceModels
type ModelPublicServiceServerMockListNamespaceModelsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) Optional() *mModelPublicServiceServerMockListNamespaceModels {
	mmListNamespaceModels.optional = true
	return mmListNamespaceModels
}

// Expect sets up expected params for ModelPublicServiceServer.ListNamespaceModels
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelsRequest) *mModelPublicServiceServerMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by ExpectParams functions")
	}

	mmListNamespaceModels.defaultExpectation.params = &ModelPublicServiceServerMockListNamespaceModelsParams{ctx, lp1}
	mmListNamespaceModels.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespaceModels.expectations {
		if minimock.Equal(e.params, mmListNamespaceModels.defaultExpectation.params) {
			mmListNamespaceModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceModels.defaultExpectation.params)
		}
	}

	return mmListNamespaceModels
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListNamespaceModels
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListNamespaceModels
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListNamespaceModelsRequest) *mModelPublicServiceServerMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListNamespaceModels
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelsRequest)) *mModelPublicServiceServerMockListNamespaceModels {
	if mmListNamespaceModels.mock.inspectFuncListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListNamespaceModels")
	}

	mmListNamespaceModels.mock.inspectFuncListNamespaceModels = f

	return mmListNamespaceModels
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListNamespaceModels
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) Return(lp2 *mm_modelv1alpha.ListNamespaceModelsResponse, err error) *ModelPublicServiceServerMock {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &ModelPublicServiceServerMockListNamespaceModelsExpectation{mock: mmListNamespaceModels.mock}
	}
	mmListNamespaceModels.defaultExpectation.results = &ModelPublicServiceServerMockListNamespaceModelsResults{lp2, err}
	mmListNamespaceModels.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModels.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListNamespaceModels method
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelsRequest) (lp2 *mm_modelv1alpha.ListNamespaceModelsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListNamespaceModels.defaultExpectation != nil {
		mmListNamespaceModels.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListNamespaceModels method")
	}

	if len(mmListNamespaceModels.expectations) > 0 {
		mmListNamespaceModels.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListNamespaceModels method")
	}

	mmListNamespaceModels.mock.funcListNamespaceModels = f
	mmListNamespaceModels.mock.funcListNamespaceModelsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModels.mock
}

// When sets expectation for the ModelPublicServiceServer.ListNamespaceModels which will trigger the result defined by the following
// Then helper
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) When(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelsRequest) *ModelPublicServiceServerMockListNamespaceModelsExpectation {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListNamespaceModels mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListNamespaceModelsExpectation{
		mock:               mmListNamespaceModels.mock,
		params:             &ModelPublicServiceServerMockListNamespaceModelsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListNamespaceModelsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespaceModels.expectations = append(mmListNamespaceModels.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListNamespaceModels return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListNamespaceModelsExpectation) Then(lp2 *mm_modelv1alpha.ListNamespaceModelsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListNamespaceModelsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListNamespaceModels should be invoked
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) Times(n uint64) *mModelPublicServiceServerMockListNamespaceModels {
	if n == 0 {
		mmListNamespaceModels.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListNamespaceModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceModels.expectedInvocations, n)
	mmListNamespaceModels.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModels
}

func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) invocationsDone() bool {
	if len(mmListNamespaceModels.expectations) == 0 && mmListNamespaceModels.defaultExpectation == nil && mmListNamespaceModels.mock.funcListNamespaceModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceModels.mock.afterListNamespaceModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceModels implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListNamespaceModels *ModelPublicServiceServerMock) ListNamespaceModels(ctx context.Context, lp1 *mm_modelv1alpha.ListNamespaceModelsRequest) (lp2 *mm_modelv1alpha.ListNamespaceModelsResponse, err error) {
	mm_atomic.AddUint64(&mmListNamespaceModels.beforeListNamespaceModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceModels.afterListNamespaceModelsCounter, 1)

	mmListNamespaceModels.t.Helper()

	if mmListNamespaceModels.inspectFuncListNamespaceModels != nil {
		mmListNamespaceModels.inspectFuncListNamespaceModels(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListNamespaceModelsParams{ctx, lp1}

	// Record call args
	mmListNamespaceModels.ListNamespaceModelsMock.mutex.Lock()
	mmListNamespaceModels.ListNamespaceModelsMock.callArgs = append(mmListNamespaceModels.ListNamespaceModelsMock.callArgs, &mm_params)
	mmListNamespaceModels.ListNamespaceModelsMock.mutex.Unlock()

	for _, e := range mmListNamespaceModels.ListNamespaceModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListNamespaceModelsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceModels.t.Errorf("ModelPublicServiceServerMock.ListNamespaceModels got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListNamespaceModels.t.Errorf("ModelPublicServiceServerMock.ListNamespaceModels got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceModels.t.Errorf("ModelPublicServiceServerMock.ListNamespaceModels got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceModels.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListNamespaceModels")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListNamespaceModels.funcListNamespaceModels != nil {
		return mmListNamespaceModels.funcListNamespaceModels(ctx, lp1)
	}
	mmListNamespaceModels.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListNamespaceModels. %v %v", ctx, lp1)
	return
}

// ListNamespaceModelsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListNamespaceModels invocations
func (mmListNamespaceModels *ModelPublicServiceServerMock) ListNamespaceModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModels.afterListNamespaceModelsCounter)
}

// ListNamespaceModelsBeforeCounter returns a count of ModelPublicServiceServerMock.ListNamespaceModels invocations
func (mmListNamespaceModels *ModelPublicServiceServerMock) ListNamespaceModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModels.beforeListNamespaceModelsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListNamespaceModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceModels *mModelPublicServiceServerMockListNamespaceModels) Calls() []*ModelPublicServiceServerMockListNamespaceModelsParams {
	mmListNamespaceModels.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListNamespaceModelsParams, len(mmListNamespaceModels.callArgs))
	copy(argCopy, mmListNamespaceModels.callArgs)

	mmListNamespaceModels.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceModelsDone returns true if the count of the ListNamespaceModels invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListNamespaceModelsDone() bool {
	if m.ListNamespaceModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceModelsMock.invocationsDone()
}

// MinimockListNamespaceModelsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListNamespaceModelsInspect() {
	for _, e := range m.ListNamespaceModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModels at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespaceModelsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceModelsMock.defaultExpectation != nil && afterListNamespaceModelsCounter < 1 {
		if m.ListNamespaceModelsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModels at\n%s", m.ListNamespaceModelsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModels at\n%s with params: %#v", m.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespaceModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceModels != nil && afterListNamespaceModelsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListNamespaceModels at\n%s", m.funcListNamespaceModelsOrigin)
	}

	if !m.ListNamespaceModelsMock.invocationsDone() && afterListNamespaceModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListNamespaceModels at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceModelsMock.expectedInvocations), m.ListNamespaceModelsMock.expectedInvocationsOrigin, afterListNamespaceModelsCounter)
	}
}

type mModelPublicServiceServerMockListOrganizationModelVersions struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListOrganizationModelVersionsExpectation
	expectations       []*ModelPublicServiceServerMockListOrganizationModelVersionsExpectation

	callArgs []*ModelPublicServiceServerMockListOrganizationModelVersionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListOrganizationModelVersionsExpectation specifies expectation struct of the ModelPublicServiceServer.ListOrganizationModelVersions
type ModelPublicServiceServerMockListOrganizationModelVersionsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListOrganizationModelVersionsParams
	paramPtrs          *ModelPublicServiceServerMockListOrganizationModelVersionsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListOrganizationModelVersionsExpectationOrigins
	results            *ModelPublicServiceServerMockListOrganizationModelVersionsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListOrganizationModelVersionsParams contains parameters of the ModelPublicServiceServer.ListOrganizationModelVersions
type ModelPublicServiceServerMockListOrganizationModelVersionsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest
}

// ModelPublicServiceServerMockListOrganizationModelVersionsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListOrganizationModelVersions
type ModelPublicServiceServerMockListOrganizationModelVersionsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListOrganizationModelVersionsRequest
}

// ModelPublicServiceServerMockListOrganizationModelVersionsResults contains results of the ModelPublicServiceServer.ListOrganizationModelVersions
type ModelPublicServiceServerMockListOrganizationModelVersionsResults struct {
	lp2 *mm_modelv1alpha.ListOrganizationModelVersionsResponse
	err error
}

// ModelPublicServiceServerMockListOrganizationModelVersionsOrigins contains origins of expectations of the ModelPublicServiceServer.ListOrganizationModelVersions
type ModelPublicServiceServerMockListOrganizationModelVersionsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) Optional() *mModelPublicServiceServerMockListOrganizationModelVersions {
	mmListOrganizationModelVersions.optional = true
	return mmListOrganizationModelVersions
}

// Expect sets up expected params for ModelPublicServiceServer.ListOrganizationModelVersions
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest) *mModelPublicServiceServerMockListOrganizationModelVersions {
	if mmListOrganizationModelVersions.mock.funcListOrganizationModelVersions != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by Set")
	}

	if mmListOrganizationModelVersions.defaultExpectation == nil {
		mmListOrganizationModelVersions.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelVersionsExpectation{}
	}

	if mmListOrganizationModelVersions.defaultExpectation.paramPtrs != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by ExpectParams functions")
	}

	mmListOrganizationModelVersions.defaultExpectation.params = &ModelPublicServiceServerMockListOrganizationModelVersionsParams{ctx, lp1}
	mmListOrganizationModelVersions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListOrganizationModelVersions.expectations {
		if minimock.Equal(e.params, mmListOrganizationModelVersions.defaultExpectation.params) {
			mmListOrganizationModelVersions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrganizationModelVersions.defaultExpectation.params)
		}
	}

	return mmListOrganizationModelVersions
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListOrganizationModelVersions
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListOrganizationModelVersions {
	if mmListOrganizationModelVersions.mock.funcListOrganizationModelVersions != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by Set")
	}

	if mmListOrganizationModelVersions.defaultExpectation == nil {
		mmListOrganizationModelVersions.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelVersionsExpectation{}
	}

	if mmListOrganizationModelVersions.defaultExpectation.params != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by Expect")
	}

	if mmListOrganizationModelVersions.defaultExpectation.paramPtrs == nil {
		mmListOrganizationModelVersions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListOrganizationModelVersionsParamPtrs{}
	}
	mmListOrganizationModelVersions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListOrganizationModelVersions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListOrganizationModelVersions
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListOrganizationModelVersions
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest) *mModelPublicServiceServerMockListOrganizationModelVersions {
	if mmListOrganizationModelVersions.mock.funcListOrganizationModelVersions != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by Set")
	}

	if mmListOrganizationModelVersions.defaultExpectation == nil {
		mmListOrganizationModelVersions.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelVersionsExpectation{}
	}

	if mmListOrganizationModelVersions.defaultExpectation.params != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by Expect")
	}

	if mmListOrganizationModelVersions.defaultExpectation.paramPtrs == nil {
		mmListOrganizationModelVersions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListOrganizationModelVersionsParamPtrs{}
	}
	mmListOrganizationModelVersions.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListOrganizationModelVersions.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListOrganizationModelVersions
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListOrganizationModelVersions
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest)) *mModelPublicServiceServerMockListOrganizationModelVersions {
	if mmListOrganizationModelVersions.mock.inspectFuncListOrganizationModelVersions != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListOrganizationModelVersions")
	}

	mmListOrganizationModelVersions.mock.inspectFuncListOrganizationModelVersions = f

	return mmListOrganizationModelVersions
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListOrganizationModelVersions
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) Return(lp2 *mm_modelv1alpha.ListOrganizationModelVersionsResponse, err error) *ModelPublicServiceServerMock {
	if mmListOrganizationModelVersions.mock.funcListOrganizationModelVersions != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by Set")
	}

	if mmListOrganizationModelVersions.defaultExpectation == nil {
		mmListOrganizationModelVersions.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelVersionsExpectation{mock: mmListOrganizationModelVersions.mock}
	}
	mmListOrganizationModelVersions.defaultExpectation.results = &ModelPublicServiceServerMockListOrganizationModelVersionsResults{lp2, err}
	mmListOrganizationModelVersions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOrganizationModelVersions.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListOrganizationModelVersions method
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest) (lp2 *mm_modelv1alpha.ListOrganizationModelVersionsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListOrganizationModelVersions.defaultExpectation != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListOrganizationModelVersions method")
	}

	if len(mmListOrganizationModelVersions.expectations) > 0 {
		mmListOrganizationModelVersions.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListOrganizationModelVersions method")
	}

	mmListOrganizationModelVersions.mock.funcListOrganizationModelVersions = f
	mmListOrganizationModelVersions.mock.funcListOrganizationModelVersionsOrigin = minimock.CallerInfo(1)
	return mmListOrganizationModelVersions.mock
}

// When sets expectation for the ModelPublicServiceServer.ListOrganizationModelVersions which will trigger the result defined by the following
// Then helper
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) When(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest) *ModelPublicServiceServerMockListOrganizationModelVersionsExpectation {
	if mmListOrganizationModelVersions.mock.funcListOrganizationModelVersions != nil {
		mmListOrganizationModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModelVersions mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListOrganizationModelVersionsExpectation{
		mock:               mmListOrganizationModelVersions.mock,
		params:             &ModelPublicServiceServerMockListOrganizationModelVersionsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListOrganizationModelVersionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListOrganizationModelVersions.expectations = append(mmListOrganizationModelVersions.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListOrganizationModelVersions return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListOrganizationModelVersionsExpectation) Then(lp2 *mm_modelv1alpha.ListOrganizationModelVersionsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListOrganizationModelVersionsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListOrganizationModelVersions should be invoked
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) Times(n uint64) *mModelPublicServiceServerMockListOrganizationModelVersions {
	if n == 0 {
		mmListOrganizationModelVersions.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListOrganizationModelVersions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrganizationModelVersions.expectedInvocations, n)
	mmListOrganizationModelVersions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOrganizationModelVersions
}

func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) invocationsDone() bool {
	if len(mmListOrganizationModelVersions.expectations) == 0 && mmListOrganizationModelVersions.defaultExpectation == nil && mmListOrganizationModelVersions.mock.funcListOrganizationModelVersions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrganizationModelVersions.mock.afterListOrganizationModelVersionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrganizationModelVersions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrganizationModelVersions implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListOrganizationModelVersions *ModelPublicServiceServerMock) ListOrganizationModelVersions(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelVersionsRequest) (lp2 *mm_modelv1alpha.ListOrganizationModelVersionsResponse, err error) {
	mm_atomic.AddUint64(&mmListOrganizationModelVersions.beforeListOrganizationModelVersionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrganizationModelVersions.afterListOrganizationModelVersionsCounter, 1)

	mmListOrganizationModelVersions.t.Helper()

	if mmListOrganizationModelVersions.inspectFuncListOrganizationModelVersions != nil {
		mmListOrganizationModelVersions.inspectFuncListOrganizationModelVersions(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListOrganizationModelVersionsParams{ctx, lp1}

	// Record call args
	mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.mutex.Lock()
	mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.callArgs = append(mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.callArgs, &mm_params)
	mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.mutex.Unlock()

	for _, e := range mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation.params
		mm_want_ptrs := mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListOrganizationModelVersionsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrganizationModelVersions.t.Errorf("ModelPublicServiceServerMock.ListOrganizationModelVersions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListOrganizationModelVersions.t.Errorf("ModelPublicServiceServerMock.ListOrganizationModelVersions got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrganizationModelVersions.t.Errorf("ModelPublicServiceServerMock.ListOrganizationModelVersions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrganizationModelVersions.ListOrganizationModelVersionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrganizationModelVersions.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListOrganizationModelVersions")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListOrganizationModelVersions.funcListOrganizationModelVersions != nil {
		return mmListOrganizationModelVersions.funcListOrganizationModelVersions(ctx, lp1)
	}
	mmListOrganizationModelVersions.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListOrganizationModelVersions. %v %v", ctx, lp1)
	return
}

// ListOrganizationModelVersionsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListOrganizationModelVersions invocations
func (mmListOrganizationModelVersions *ModelPublicServiceServerMock) ListOrganizationModelVersionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrganizationModelVersions.afterListOrganizationModelVersionsCounter)
}

// ListOrganizationModelVersionsBeforeCounter returns a count of ModelPublicServiceServerMock.ListOrganizationModelVersions invocations
func (mmListOrganizationModelVersions *ModelPublicServiceServerMock) ListOrganizationModelVersionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrganizationModelVersions.beforeListOrganizationModelVersionsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListOrganizationModelVersions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrganizationModelVersions *mModelPublicServiceServerMockListOrganizationModelVersions) Calls() []*ModelPublicServiceServerMockListOrganizationModelVersionsParams {
	mmListOrganizationModelVersions.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListOrganizationModelVersionsParams, len(mmListOrganizationModelVersions.callArgs))
	copy(argCopy, mmListOrganizationModelVersions.callArgs)

	mmListOrganizationModelVersions.mutex.RUnlock()

	return argCopy
}

// MinimockListOrganizationModelVersionsDone returns true if the count of the ListOrganizationModelVersions invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListOrganizationModelVersionsDone() bool {
	if m.ListOrganizationModelVersionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrganizationModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrganizationModelVersionsMock.invocationsDone()
}

// MinimockListOrganizationModelVersionsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListOrganizationModelVersionsInspect() {
	for _, e := range m.ListOrganizationModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModelVersions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListOrganizationModelVersionsCounter := mm_atomic.LoadUint64(&m.afterListOrganizationModelVersionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrganizationModelVersionsMock.defaultExpectation != nil && afterListOrganizationModelVersionsCounter < 1 {
		if m.ListOrganizationModelVersionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModelVersions at\n%s", m.ListOrganizationModelVersionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModelVersions at\n%s with params: %#v", m.ListOrganizationModelVersionsMock.defaultExpectation.expectationOrigins.origin, *m.ListOrganizationModelVersionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrganizationModelVersions != nil && afterListOrganizationModelVersionsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModelVersions at\n%s", m.funcListOrganizationModelVersionsOrigin)
	}

	if !m.ListOrganizationModelVersionsMock.invocationsDone() && afterListOrganizationModelVersionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListOrganizationModelVersions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrganizationModelVersionsMock.expectedInvocations), m.ListOrganizationModelVersionsMock.expectedInvocationsOrigin, afterListOrganizationModelVersionsCounter)
	}
}

type mModelPublicServiceServerMockListOrganizationModels struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListOrganizationModelsExpectation
	expectations       []*ModelPublicServiceServerMockListOrganizationModelsExpectation

	callArgs []*ModelPublicServiceServerMockListOrganizationModelsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListOrganizationModelsExpectation specifies expectation struct of the ModelPublicServiceServer.ListOrganizationModels
type ModelPublicServiceServerMockListOrganizationModelsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListOrganizationModelsParams
	paramPtrs          *ModelPublicServiceServerMockListOrganizationModelsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListOrganizationModelsExpectationOrigins
	results            *ModelPublicServiceServerMockListOrganizationModelsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListOrganizationModelsParams contains parameters of the ModelPublicServiceServer.ListOrganizationModels
type ModelPublicServiceServerMockListOrganizationModelsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListOrganizationModelsRequest
}

// ModelPublicServiceServerMockListOrganizationModelsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListOrganizationModels
type ModelPublicServiceServerMockListOrganizationModelsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListOrganizationModelsRequest
}

// ModelPublicServiceServerMockListOrganizationModelsResults contains results of the ModelPublicServiceServer.ListOrganizationModels
type ModelPublicServiceServerMockListOrganizationModelsResults struct {
	lp2 *mm_modelv1alpha.ListOrganizationModelsResponse
	err error
}

// ModelPublicServiceServerMockListOrganizationModelsOrigins contains origins of expectations of the ModelPublicServiceServer.ListOrganizationModels
type ModelPublicServiceServerMockListOrganizationModelsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) Optional() *mModelPublicServiceServerMockListOrganizationModels {
	mmListOrganizationModels.optional = true
	return mmListOrganizationModels
}

// Expect sets up expected params for ModelPublicServiceServer.ListOrganizationModels
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelsRequest) *mModelPublicServiceServerMockListOrganizationModels {
	if mmListOrganizationModels.mock.funcListOrganizationModels != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by Set")
	}

	if mmListOrganizationModels.defaultExpectation == nil {
		mmListOrganizationModels.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelsExpectation{}
	}

	if mmListOrganizationModels.defaultExpectation.paramPtrs != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by ExpectParams functions")
	}

	mmListOrganizationModels.defaultExpectation.params = &ModelPublicServiceServerMockListOrganizationModelsParams{ctx, lp1}
	mmListOrganizationModels.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListOrganizationModels.expectations {
		if minimock.Equal(e.params, mmListOrganizationModels.defaultExpectation.params) {
			mmListOrganizationModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrganizationModels.defaultExpectation.params)
		}
	}

	return mmListOrganizationModels
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListOrganizationModels
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListOrganizationModels {
	if mmListOrganizationModels.mock.funcListOrganizationModels != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by Set")
	}

	if mmListOrganizationModels.defaultExpectation == nil {
		mmListOrganizationModels.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelsExpectation{}
	}

	if mmListOrganizationModels.defaultExpectation.params != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by Expect")
	}

	if mmListOrganizationModels.defaultExpectation.paramPtrs == nil {
		mmListOrganizationModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListOrganizationModelsParamPtrs{}
	}
	mmListOrganizationModels.defaultExpectation.paramPtrs.ctx = &ctx
	mmListOrganizationModels.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListOrganizationModels
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListOrganizationModels
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListOrganizationModelsRequest) *mModelPublicServiceServerMockListOrganizationModels {
	if mmListOrganizationModels.mock.funcListOrganizationModels != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by Set")
	}

	if mmListOrganizationModels.defaultExpectation == nil {
		mmListOrganizationModels.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelsExpectation{}
	}

	if mmListOrganizationModels.defaultExpectation.params != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by Expect")
	}

	if mmListOrganizationModels.defaultExpectation.paramPtrs == nil {
		mmListOrganizationModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListOrganizationModelsParamPtrs{}
	}
	mmListOrganizationModels.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListOrganizationModels.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListOrganizationModels
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListOrganizationModels
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelsRequest)) *mModelPublicServiceServerMockListOrganizationModels {
	if mmListOrganizationModels.mock.inspectFuncListOrganizationModels != nil {
		mmListOrganizationModels.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListOrganizationModels")
	}

	mmListOrganizationModels.mock.inspectFuncListOrganizationModels = f

	return mmListOrganizationModels
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListOrganizationModels
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) Return(lp2 *mm_modelv1alpha.ListOrganizationModelsResponse, err error) *ModelPublicServiceServerMock {
	if mmListOrganizationModels.mock.funcListOrganizationModels != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by Set")
	}

	if mmListOrganizationModels.defaultExpectation == nil {
		mmListOrganizationModels.defaultExpectation = &ModelPublicServiceServerMockListOrganizationModelsExpectation{mock: mmListOrganizationModels.mock}
	}
	mmListOrganizationModels.defaultExpectation.results = &ModelPublicServiceServerMockListOrganizationModelsResults{lp2, err}
	mmListOrganizationModels.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOrganizationModels.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListOrganizationModels method
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelsRequest) (lp2 *mm_modelv1alpha.ListOrganizationModelsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListOrganizationModels.defaultExpectation != nil {
		mmListOrganizationModels.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListOrganizationModels method")
	}

	if len(mmListOrganizationModels.expectations) > 0 {
		mmListOrganizationModels.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListOrganizationModels method")
	}

	mmListOrganizationModels.mock.funcListOrganizationModels = f
	mmListOrganizationModels.mock.funcListOrganizationModelsOrigin = minimock.CallerInfo(1)
	return mmListOrganizationModels.mock
}

// When sets expectation for the ModelPublicServiceServer.ListOrganizationModels which will trigger the result defined by the following
// Then helper
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) When(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelsRequest) *ModelPublicServiceServerMockListOrganizationModelsExpectation {
	if mmListOrganizationModels.mock.funcListOrganizationModels != nil {
		mmListOrganizationModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListOrganizationModels mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListOrganizationModelsExpectation{
		mock:               mmListOrganizationModels.mock,
		params:             &ModelPublicServiceServerMockListOrganizationModelsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListOrganizationModelsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListOrganizationModels.expectations = append(mmListOrganizationModels.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListOrganizationModels return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListOrganizationModelsExpectation) Then(lp2 *mm_modelv1alpha.ListOrganizationModelsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListOrganizationModelsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListOrganizationModels should be invoked
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) Times(n uint64) *mModelPublicServiceServerMockListOrganizationModels {
	if n == 0 {
		mmListOrganizationModels.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListOrganizationModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrganizationModels.expectedInvocations, n)
	mmListOrganizationModels.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOrganizationModels
}

func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) invocationsDone() bool {
	if len(mmListOrganizationModels.expectations) == 0 && mmListOrganizationModels.defaultExpectation == nil && mmListOrganizationModels.mock.funcListOrganizationModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrganizationModels.mock.afterListOrganizationModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrganizationModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrganizationModels implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListOrganizationModels *ModelPublicServiceServerMock) ListOrganizationModels(ctx context.Context, lp1 *mm_modelv1alpha.ListOrganizationModelsRequest) (lp2 *mm_modelv1alpha.ListOrganizationModelsResponse, err error) {
	mm_atomic.AddUint64(&mmListOrganizationModels.beforeListOrganizationModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrganizationModels.afterListOrganizationModelsCounter, 1)

	mmListOrganizationModels.t.Helper()

	if mmListOrganizationModels.inspectFuncListOrganizationModels != nil {
		mmListOrganizationModels.inspectFuncListOrganizationModels(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListOrganizationModelsParams{ctx, lp1}

	// Record call args
	mmListOrganizationModels.ListOrganizationModelsMock.mutex.Lock()
	mmListOrganizationModels.ListOrganizationModelsMock.callArgs = append(mmListOrganizationModels.ListOrganizationModelsMock.callArgs, &mm_params)
	mmListOrganizationModels.ListOrganizationModelsMock.mutex.Unlock()

	for _, e := range mmListOrganizationModels.ListOrganizationModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListOrganizationModelsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrganizationModels.t.Errorf("ModelPublicServiceServerMock.ListOrganizationModels got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListOrganizationModels.t.Errorf("ModelPublicServiceServerMock.ListOrganizationModels got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrganizationModels.t.Errorf("ModelPublicServiceServerMock.ListOrganizationModels got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrganizationModels.ListOrganizationModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrganizationModels.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListOrganizationModels")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListOrganizationModels.funcListOrganizationModels != nil {
		return mmListOrganizationModels.funcListOrganizationModels(ctx, lp1)
	}
	mmListOrganizationModels.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListOrganizationModels. %v %v", ctx, lp1)
	return
}

// ListOrganizationModelsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListOrganizationModels invocations
func (mmListOrganizationModels *ModelPublicServiceServerMock) ListOrganizationModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrganizationModels.afterListOrganizationModelsCounter)
}

// ListOrganizationModelsBeforeCounter returns a count of ModelPublicServiceServerMock.ListOrganizationModels invocations
func (mmListOrganizationModels *ModelPublicServiceServerMock) ListOrganizationModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrganizationModels.beforeListOrganizationModelsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListOrganizationModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrganizationModels *mModelPublicServiceServerMockListOrganizationModels) Calls() []*ModelPublicServiceServerMockListOrganizationModelsParams {
	mmListOrganizationModels.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListOrganizationModelsParams, len(mmListOrganizationModels.callArgs))
	copy(argCopy, mmListOrganizationModels.callArgs)

	mmListOrganizationModels.mutex.RUnlock()

	return argCopy
}

// MinimockListOrganizationModelsDone returns true if the count of the ListOrganizationModels invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListOrganizationModelsDone() bool {
	if m.ListOrganizationModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrganizationModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrganizationModelsMock.invocationsDone()
}

// MinimockListOrganizationModelsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListOrganizationModelsInspect() {
	for _, e := range m.ListOrganizationModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModels at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListOrganizationModelsCounter := mm_atomic.LoadUint64(&m.afterListOrganizationModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrganizationModelsMock.defaultExpectation != nil && afterListOrganizationModelsCounter < 1 {
		if m.ListOrganizationModelsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModels at\n%s", m.ListOrganizationModelsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModels at\n%s with params: %#v", m.ListOrganizationModelsMock.defaultExpectation.expectationOrigins.origin, *m.ListOrganizationModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrganizationModels != nil && afterListOrganizationModelsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListOrganizationModels at\n%s", m.funcListOrganizationModelsOrigin)
	}

	if !m.ListOrganizationModelsMock.invocationsDone() && afterListOrganizationModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListOrganizationModels at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrganizationModelsMock.expectedInvocations), m.ListOrganizationModelsMock.expectedInvocationsOrigin, afterListOrganizationModelsCounter)
	}
}

type mModelPublicServiceServerMockListUserModelVersions struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListUserModelVersionsExpectation
	expectations       []*ModelPublicServiceServerMockListUserModelVersionsExpectation

	callArgs []*ModelPublicServiceServerMockListUserModelVersionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListUserModelVersionsExpectation specifies expectation struct of the ModelPublicServiceServer.ListUserModelVersions
type ModelPublicServiceServerMockListUserModelVersionsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListUserModelVersionsParams
	paramPtrs          *ModelPublicServiceServerMockListUserModelVersionsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListUserModelVersionsExpectationOrigins
	results            *ModelPublicServiceServerMockListUserModelVersionsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListUserModelVersionsParams contains parameters of the ModelPublicServiceServer.ListUserModelVersions
type ModelPublicServiceServerMockListUserModelVersionsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListUserModelVersionsRequest
}

// ModelPublicServiceServerMockListUserModelVersionsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListUserModelVersions
type ModelPublicServiceServerMockListUserModelVersionsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListUserModelVersionsRequest
}

// ModelPublicServiceServerMockListUserModelVersionsResults contains results of the ModelPublicServiceServer.ListUserModelVersions
type ModelPublicServiceServerMockListUserModelVersionsResults struct {
	lp2 *mm_modelv1alpha.ListUserModelVersionsResponse
	err error
}

// ModelPublicServiceServerMockListUserModelVersionsOrigins contains origins of expectations of the ModelPublicServiceServer.ListUserModelVersions
type ModelPublicServiceServerMockListUserModelVersionsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) Optional() *mModelPublicServiceServerMockListUserModelVersions {
	mmListUserModelVersions.optional = true
	return mmListUserModelVersions
}

// Expect sets up expected params for ModelPublicServiceServer.ListUserModelVersions
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelVersionsRequest) *mModelPublicServiceServerMockListUserModelVersions {
	if mmListUserModelVersions.mock.funcListUserModelVersions != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by Set")
	}

	if mmListUserModelVersions.defaultExpectation == nil {
		mmListUserModelVersions.defaultExpectation = &ModelPublicServiceServerMockListUserModelVersionsExpectation{}
	}

	if mmListUserModelVersions.defaultExpectation.paramPtrs != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by ExpectParams functions")
	}

	mmListUserModelVersions.defaultExpectation.params = &ModelPublicServiceServerMockListUserModelVersionsParams{ctx, lp1}
	mmListUserModelVersions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListUserModelVersions.expectations {
		if minimock.Equal(e.params, mmListUserModelVersions.defaultExpectation.params) {
			mmListUserModelVersions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserModelVersions.defaultExpectation.params)
		}
	}

	return mmListUserModelVersions
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListUserModelVersions
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListUserModelVersions {
	if mmListUserModelVersions.mock.funcListUserModelVersions != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by Set")
	}

	if mmListUserModelVersions.defaultExpectation == nil {
		mmListUserModelVersions.defaultExpectation = &ModelPublicServiceServerMockListUserModelVersionsExpectation{}
	}

	if mmListUserModelVersions.defaultExpectation.params != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by Expect")
	}

	if mmListUserModelVersions.defaultExpectation.paramPtrs == nil {
		mmListUserModelVersions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListUserModelVersionsParamPtrs{}
	}
	mmListUserModelVersions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListUserModelVersions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListUserModelVersions
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListUserModelVersions
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListUserModelVersionsRequest) *mModelPublicServiceServerMockListUserModelVersions {
	if mmListUserModelVersions.mock.funcListUserModelVersions != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by Set")
	}

	if mmListUserModelVersions.defaultExpectation == nil {
		mmListUserModelVersions.defaultExpectation = &ModelPublicServiceServerMockListUserModelVersionsExpectation{}
	}

	if mmListUserModelVersions.defaultExpectation.params != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by Expect")
	}

	if mmListUserModelVersions.defaultExpectation.paramPtrs == nil {
		mmListUserModelVersions.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListUserModelVersionsParamPtrs{}
	}
	mmListUserModelVersions.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListUserModelVersions.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListUserModelVersions
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListUserModelVersions
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelVersionsRequest)) *mModelPublicServiceServerMockListUserModelVersions {
	if mmListUserModelVersions.mock.inspectFuncListUserModelVersions != nil {
		mmListUserModelVersions.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListUserModelVersions")
	}

	mmListUserModelVersions.mock.inspectFuncListUserModelVersions = f

	return mmListUserModelVersions
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListUserModelVersions
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) Return(lp2 *mm_modelv1alpha.ListUserModelVersionsResponse, err error) *ModelPublicServiceServerMock {
	if mmListUserModelVersions.mock.funcListUserModelVersions != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by Set")
	}

	if mmListUserModelVersions.defaultExpectation == nil {
		mmListUserModelVersions.defaultExpectation = &ModelPublicServiceServerMockListUserModelVersionsExpectation{mock: mmListUserModelVersions.mock}
	}
	mmListUserModelVersions.defaultExpectation.results = &ModelPublicServiceServerMockListUserModelVersionsResults{lp2, err}
	mmListUserModelVersions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListUserModelVersions.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListUserModelVersions method
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelVersionsRequest) (lp2 *mm_modelv1alpha.ListUserModelVersionsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListUserModelVersions.defaultExpectation != nil {
		mmListUserModelVersions.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListUserModelVersions method")
	}

	if len(mmListUserModelVersions.expectations) > 0 {
		mmListUserModelVersions.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListUserModelVersions method")
	}

	mmListUserModelVersions.mock.funcListUserModelVersions = f
	mmListUserModelVersions.mock.funcListUserModelVersionsOrigin = minimock.CallerInfo(1)
	return mmListUserModelVersions.mock
}

// When sets expectation for the ModelPublicServiceServer.ListUserModelVersions which will trigger the result defined by the following
// Then helper
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) When(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelVersionsRequest) *ModelPublicServiceServerMockListUserModelVersionsExpectation {
	if mmListUserModelVersions.mock.funcListUserModelVersions != nil {
		mmListUserModelVersions.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModelVersions mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListUserModelVersionsExpectation{
		mock:               mmListUserModelVersions.mock,
		params:             &ModelPublicServiceServerMockListUserModelVersionsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListUserModelVersionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListUserModelVersions.expectations = append(mmListUserModelVersions.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListUserModelVersions return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListUserModelVersionsExpectation) Then(lp2 *mm_modelv1alpha.ListUserModelVersionsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListUserModelVersionsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListUserModelVersions should be invoked
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) Times(n uint64) *mModelPublicServiceServerMockListUserModelVersions {
	if n == 0 {
		mmListUserModelVersions.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListUserModelVersions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListUserModelVersions.expectedInvocations, n)
	mmListUserModelVersions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListUserModelVersions
}

func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) invocationsDone() bool {
	if len(mmListUserModelVersions.expectations) == 0 && mmListUserModelVersions.defaultExpectation == nil && mmListUserModelVersions.mock.funcListUserModelVersions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListUserModelVersions.mock.afterListUserModelVersionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListUserModelVersions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListUserModelVersions implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListUserModelVersions *ModelPublicServiceServerMock) ListUserModelVersions(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelVersionsRequest) (lp2 *mm_modelv1alpha.ListUserModelVersionsResponse, err error) {
	mm_atomic.AddUint64(&mmListUserModelVersions.beforeListUserModelVersionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListUserModelVersions.afterListUserModelVersionsCounter, 1)

	mmListUserModelVersions.t.Helper()

	if mmListUserModelVersions.inspectFuncListUserModelVersions != nil {
		mmListUserModelVersions.inspectFuncListUserModelVersions(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListUserModelVersionsParams{ctx, lp1}

	// Record call args
	mmListUserModelVersions.ListUserModelVersionsMock.mutex.Lock()
	mmListUserModelVersions.ListUserModelVersionsMock.callArgs = append(mmListUserModelVersions.ListUserModelVersionsMock.callArgs, &mm_params)
	mmListUserModelVersions.ListUserModelVersionsMock.mutex.Unlock()

	for _, e := range mmListUserModelVersions.ListUserModelVersionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation.params
		mm_want_ptrs := mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListUserModelVersionsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListUserModelVersions.t.Errorf("ModelPublicServiceServerMock.ListUserModelVersions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListUserModelVersions.t.Errorf("ModelPublicServiceServerMock.ListUserModelVersions got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUserModelVersions.t.Errorf("ModelPublicServiceServerMock.ListUserModelVersions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUserModelVersions.ListUserModelVersionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListUserModelVersions.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListUserModelVersions")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListUserModelVersions.funcListUserModelVersions != nil {
		return mmListUserModelVersions.funcListUserModelVersions(ctx, lp1)
	}
	mmListUserModelVersions.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListUserModelVersions. %v %v", ctx, lp1)
	return
}

// ListUserModelVersionsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListUserModelVersions invocations
func (mmListUserModelVersions *ModelPublicServiceServerMock) ListUserModelVersionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserModelVersions.afterListUserModelVersionsCounter)
}

// ListUserModelVersionsBeforeCounter returns a count of ModelPublicServiceServerMock.ListUserModelVersions invocations
func (mmListUserModelVersions *ModelPublicServiceServerMock) ListUserModelVersionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserModelVersions.beforeListUserModelVersionsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListUserModelVersions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserModelVersions *mModelPublicServiceServerMockListUserModelVersions) Calls() []*ModelPublicServiceServerMockListUserModelVersionsParams {
	mmListUserModelVersions.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListUserModelVersionsParams, len(mmListUserModelVersions.callArgs))
	copy(argCopy, mmListUserModelVersions.callArgs)

	mmListUserModelVersions.mutex.RUnlock()

	return argCopy
}

// MinimockListUserModelVersionsDone returns true if the count of the ListUserModelVersions invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListUserModelVersionsDone() bool {
	if m.ListUserModelVersionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListUserModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListUserModelVersionsMock.invocationsDone()
}

// MinimockListUserModelVersionsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListUserModelVersionsInspect() {
	for _, e := range m.ListUserModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModelVersions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListUserModelVersionsCounter := mm_atomic.LoadUint64(&m.afterListUserModelVersionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListUserModelVersionsMock.defaultExpectation != nil && afterListUserModelVersionsCounter < 1 {
		if m.ListUserModelVersionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModelVersions at\n%s", m.ListUserModelVersionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModelVersions at\n%s with params: %#v", m.ListUserModelVersionsMock.defaultExpectation.expectationOrigins.origin, *m.ListUserModelVersionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUserModelVersions != nil && afterListUserModelVersionsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModelVersions at\n%s", m.funcListUserModelVersionsOrigin)
	}

	if !m.ListUserModelVersionsMock.invocationsDone() && afterListUserModelVersionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListUserModelVersions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListUserModelVersionsMock.expectedInvocations), m.ListUserModelVersionsMock.expectedInvocationsOrigin, afterListUserModelVersionsCounter)
	}
}

type mModelPublicServiceServerMockListUserModels struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockListUserModelsExpectation
	expectations       []*ModelPublicServiceServerMockListUserModelsExpectation

	callArgs []*ModelPublicServiceServerMockListUserModelsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockListUserModelsExpectation specifies expectation struct of the ModelPublicServiceServer.ListUserModels
type ModelPublicServiceServerMockListUserModelsExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockListUserModelsParams
	paramPtrs          *ModelPublicServiceServerMockListUserModelsParamPtrs
	expectationOrigins ModelPublicServiceServerMockListUserModelsExpectationOrigins
	results            *ModelPublicServiceServerMockListUserModelsResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockListUserModelsParams contains parameters of the ModelPublicServiceServer.ListUserModels
type ModelPublicServiceServerMockListUserModelsParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.ListUserModelsRequest
}

// ModelPublicServiceServerMockListUserModelsParamPtrs contains pointers to parameters of the ModelPublicServiceServer.ListUserModels
type ModelPublicServiceServerMockListUserModelsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.ListUserModelsRequest
}

// ModelPublicServiceServerMockListUserModelsResults contains results of the ModelPublicServiceServer.ListUserModels
type ModelPublicServiceServerMockListUserModelsResults struct {
	lp2 *mm_modelv1alpha.ListUserModelsResponse
	err error
}

// ModelPublicServiceServerMockListUserModelsOrigins contains origins of expectations of the ModelPublicServiceServer.ListUserModels
type ModelPublicServiceServerMockListUserModelsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) Optional() *mModelPublicServiceServerMockListUserModels {
	mmListUserModels.optional = true
	return mmListUserModels
}

// Expect sets up expected params for ModelPublicServiceServer.ListUserModels
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) Expect(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelsRequest) *mModelPublicServiceServerMockListUserModels {
	if mmListUserModels.mock.funcListUserModels != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by Set")
	}

	if mmListUserModels.defaultExpectation == nil {
		mmListUserModels.defaultExpectation = &ModelPublicServiceServerMockListUserModelsExpectation{}
	}

	if mmListUserModels.defaultExpectation.paramPtrs != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by ExpectParams functions")
	}

	mmListUserModels.defaultExpectation.params = &ModelPublicServiceServerMockListUserModelsParams{ctx, lp1}
	mmListUserModels.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListUserModels.expectations {
		if minimock.Equal(e.params, mmListUserModels.defaultExpectation.params) {
			mmListUserModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListUserModels.defaultExpectation.params)
		}
	}

	return mmListUserModels
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.ListUserModels
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockListUserModels {
	if mmListUserModels.mock.funcListUserModels != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by Set")
	}

	if mmListUserModels.defaultExpectation == nil {
		mmListUserModels.defaultExpectation = &ModelPublicServiceServerMockListUserModelsExpectation{}
	}

	if mmListUserModels.defaultExpectation.params != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by Expect")
	}

	if mmListUserModels.defaultExpectation.paramPtrs == nil {
		mmListUserModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListUserModelsParamPtrs{}
	}
	mmListUserModels.defaultExpectation.paramPtrs.ctx = &ctx
	mmListUserModels.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListUserModels
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.ListUserModels
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) ExpectLp1Param2(lp1 *mm_modelv1alpha.ListUserModelsRequest) *mModelPublicServiceServerMockListUserModels {
	if mmListUserModels.mock.funcListUserModels != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by Set")
	}

	if mmListUserModels.defaultExpectation == nil {
		mmListUserModels.defaultExpectation = &ModelPublicServiceServerMockListUserModelsExpectation{}
	}

	if mmListUserModels.defaultExpectation.params != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by Expect")
	}

	if mmListUserModels.defaultExpectation.paramPtrs == nil {
		mmListUserModels.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockListUserModelsParamPtrs{}
	}
	mmListUserModels.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListUserModels.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListUserModels
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.ListUserModels
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelsRequest)) *mModelPublicServiceServerMockListUserModels {
	if mmListUserModels.mock.inspectFuncListUserModels != nil {
		mmListUserModels.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.ListUserModels")
	}

	mmListUserModels.mock.inspectFuncListUserModels = f

	return mmListUserModels
}

// Return sets up results that will be returned by ModelPublicServiceServer.ListUserModels
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) Return(lp2 *mm_modelv1alpha.ListUserModelsResponse, err error) *ModelPublicServiceServerMock {
	if mmListUserModels.mock.funcListUserModels != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by Set")
	}

	if mmListUserModels.defaultExpectation == nil {
		mmListUserModels.defaultExpectation = &ModelPublicServiceServerMockListUserModelsExpectation{mock: mmListUserModels.mock}
	}
	mmListUserModels.defaultExpectation.results = &ModelPublicServiceServerMockListUserModelsResults{lp2, err}
	mmListUserModels.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListUserModels.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.ListUserModels method
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelsRequest) (lp2 *mm_modelv1alpha.ListUserModelsResponse, err error)) *ModelPublicServiceServerMock {
	if mmListUserModels.defaultExpectation != nil {
		mmListUserModels.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.ListUserModels method")
	}

	if len(mmListUserModels.expectations) > 0 {
		mmListUserModels.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.ListUserModels method")
	}

	mmListUserModels.mock.funcListUserModels = f
	mmListUserModels.mock.funcListUserModelsOrigin = minimock.CallerInfo(1)
	return mmListUserModels.mock
}

// When sets expectation for the ModelPublicServiceServer.ListUserModels which will trigger the result defined by the following
// Then helper
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) When(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelsRequest) *ModelPublicServiceServerMockListUserModelsExpectation {
	if mmListUserModels.mock.funcListUserModels != nil {
		mmListUserModels.mock.t.Fatalf("ModelPublicServiceServerMock.ListUserModels mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockListUserModelsExpectation{
		mock:               mmListUserModels.mock,
		params:             &ModelPublicServiceServerMockListUserModelsParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockListUserModelsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListUserModels.expectations = append(mmListUserModels.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.ListUserModels return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockListUserModelsExpectation) Then(lp2 *mm_modelv1alpha.ListUserModelsResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockListUserModelsResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.ListUserModels should be invoked
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) Times(n uint64) *mModelPublicServiceServerMockListUserModels {
	if n == 0 {
		mmListUserModels.mock.t.Fatalf("Times of ModelPublicServiceServerMock.ListUserModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListUserModels.expectedInvocations, n)
	mmListUserModels.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListUserModels
}

func (mmListUserModels *mModelPublicServiceServerMockListUserModels) invocationsDone() bool {
	if len(mmListUserModels.expectations) == 0 && mmListUserModels.defaultExpectation == nil && mmListUserModels.mock.funcListUserModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListUserModels.mock.afterListUserModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListUserModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListUserModels implements mm_modelv1alpha.ModelPublicServiceServer
func (mmListUserModels *ModelPublicServiceServerMock) ListUserModels(ctx context.Context, lp1 *mm_modelv1alpha.ListUserModelsRequest) (lp2 *mm_modelv1alpha.ListUserModelsResponse, err error) {
	mm_atomic.AddUint64(&mmListUserModels.beforeListUserModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListUserModels.afterListUserModelsCounter, 1)

	mmListUserModels.t.Helper()

	if mmListUserModels.inspectFuncListUserModels != nil {
		mmListUserModels.inspectFuncListUserModels(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockListUserModelsParams{ctx, lp1}

	// Record call args
	mmListUserModels.ListUserModelsMock.mutex.Lock()
	mmListUserModels.ListUserModelsMock.callArgs = append(mmListUserModels.ListUserModelsMock.callArgs, &mm_params)
	mmListUserModels.ListUserModelsMock.mutex.Unlock()

	for _, e := range mmListUserModels.ListUserModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListUserModels.ListUserModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListUserModels.ListUserModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListUserModels.ListUserModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListUserModels.ListUserModelsMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockListUserModelsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListUserModels.t.Errorf("ModelPublicServiceServerMock.ListUserModels got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserModels.ListUserModelsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListUserModels.t.Errorf("ModelPublicServiceServerMock.ListUserModels got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListUserModels.ListUserModelsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListUserModels.t.Errorf("ModelPublicServiceServerMock.ListUserModels got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListUserModels.ListUserModelsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListUserModels.ListUserModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListUserModels.t.Fatal("No results are set for the ModelPublicServiceServerMock.ListUserModels")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListUserModels.funcListUserModels != nil {
		return mmListUserModels.funcListUserModels(ctx, lp1)
	}
	mmListUserModels.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.ListUserModels. %v %v", ctx, lp1)
	return
}

// ListUserModelsAfterCounter returns a count of finished ModelPublicServiceServerMock.ListUserModels invocations
func (mmListUserModels *ModelPublicServiceServerMock) ListUserModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserModels.afterListUserModelsCounter)
}

// ListUserModelsBeforeCounter returns a count of ModelPublicServiceServerMock.ListUserModels invocations
func (mmListUserModels *ModelPublicServiceServerMock) ListUserModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListUserModels.beforeListUserModelsCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.ListUserModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListUserModels *mModelPublicServiceServerMockListUserModels) Calls() []*ModelPublicServiceServerMockListUserModelsParams {
	mmListUserModels.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockListUserModelsParams, len(mmListUserModels.callArgs))
	copy(argCopy, mmListUserModels.callArgs)

	mmListUserModels.mutex.RUnlock()

	return argCopy
}

// MinimockListUserModelsDone returns true if the count of the ListUserModels invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockListUserModelsDone() bool {
	if m.ListUserModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListUserModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListUserModelsMock.invocationsDone()
}

// MinimockListUserModelsInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockListUserModelsInspect() {
	for _, e := range m.ListUserModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModels at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListUserModelsCounter := mm_atomic.LoadUint64(&m.afterListUserModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListUserModelsMock.defaultExpectation != nil && afterListUserModelsCounter < 1 {
		if m.ListUserModelsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModels at\n%s", m.ListUserModelsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModels at\n%s with params: %#v", m.ListUserModelsMock.defaultExpectation.expectationOrigins.origin, *m.ListUserModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListUserModels != nil && afterListUserModelsCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.ListUserModels at\n%s", m.funcListUserModelsOrigin)
	}

	if !m.ListUserModelsMock.invocationsDone() && afterListUserModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.ListUserModels at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListUserModelsMock.expectedInvocations), m.ListUserModelsMock.expectedInvocationsOrigin, afterListUserModelsCounter)
	}
}

type mModelPublicServiceServerMockLiveness struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockLivenessExpectation
	expectations       []*ModelPublicServiceServerMockLivenessExpectation

	callArgs []*ModelPublicServiceServerMockLivenessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockLivenessExpectation specifies expectation struct of the ModelPublicServiceServer.Liveness
type ModelPublicServiceServerMockLivenessExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockLivenessParams
	paramPtrs          *ModelPublicServiceServerMockLivenessParamPtrs
	expectationOrigins ModelPublicServiceServerMockLivenessExpectationOrigins
	results            *ModelPublicServiceServerMockLivenessResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockLivenessParams contains parameters of the ModelPublicServiceServer.Liveness
type ModelPublicServiceServerMockLivenessParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.LivenessRequest
}

// ModelPublicServiceServerMockLivenessParamPtrs contains pointers to parameters of the ModelPublicServiceServer.Liveness
type ModelPublicServiceServerMockLivenessParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.LivenessRequest
}

// ModelPublicServiceServerMockLivenessResults contains results of the ModelPublicServiceServer.Liveness
type ModelPublicServiceServerMockLivenessResults struct {
	lp2 *mm_modelv1alpha.LivenessResponse
	err error
}

// ModelPublicServiceServerMockLivenessOrigins contains origins of expectations of the ModelPublicServiceServer.Liveness
type ModelPublicServiceServerMockLivenessExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLiveness *mModelPublicServiceServerMockLiveness) Optional() *mModelPublicServiceServerMockLiveness {
	mmLiveness.optional = true
	return mmLiveness
}

// Expect sets up expected params for ModelPublicServiceServer.Liveness
func (mmLiveness *mModelPublicServiceServerMockLiveness) Expect(ctx context.Context, lp1 *mm_modelv1alpha.LivenessRequest) *mModelPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ModelPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.paramPtrs != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by ExpectParams functions")
	}

	mmLiveness.defaultExpectation.params = &ModelPublicServiceServerMockLivenessParams{ctx, lp1}
	mmLiveness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLiveness.expectations {
		if minimock.Equal(e.params, mmLiveness.defaultExpectation.params) {
			mmLiveness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLiveness.defaultExpectation.params)
		}
	}

	return mmLiveness
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.Liveness
func (mmLiveness *mModelPublicServiceServerMockLiveness) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ModelPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.ctx = &ctx
	mmLiveness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.Liveness
func (mmLiveness *mModelPublicServiceServerMockLiveness) ExpectLp1Param2(lp1 *mm_modelv1alpha.LivenessRequest) *mModelPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ModelPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.lp1 = &lp1
	mmLiveness.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmLiveness
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.Liveness
func (mmLiveness *mModelPublicServiceServerMockLiveness) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.LivenessRequest)) *mModelPublicServiceServerMockLiveness {
	if mmLiveness.mock.inspectFuncLiveness != nil {
		mmLiveness.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.Liveness")
	}

	mmLiveness.mock.inspectFuncLiveness = f

	return mmLiveness
}

// Return sets up results that will be returned by ModelPublicServiceServer.Liveness
func (mmLiveness *mModelPublicServiceServerMockLiveness) Return(lp2 *mm_modelv1alpha.LivenessResponse, err error) *ModelPublicServiceServerMock {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ModelPublicServiceServerMockLivenessExpectation{mock: mmLiveness.mock}
	}
	mmLiveness.defaultExpectation.results = &ModelPublicServiceServerMockLivenessResults{lp2, err}
	mmLiveness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.Liveness method
func (mmLiveness *mModelPublicServiceServerMockLiveness) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.LivenessRequest) (lp2 *mm_modelv1alpha.LivenessResponse, err error)) *ModelPublicServiceServerMock {
	if mmLiveness.defaultExpectation != nil {
		mmLiveness.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.Liveness method")
	}

	if len(mmLiveness.expectations) > 0 {
		mmLiveness.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.Liveness method")
	}

	mmLiveness.mock.funcLiveness = f
	mmLiveness.mock.funcLivenessOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// When sets expectation for the ModelPublicServiceServer.Liveness which will trigger the result defined by the following
// Then helper
func (mmLiveness *mModelPublicServiceServerMockLiveness) When(ctx context.Context, lp1 *mm_modelv1alpha.LivenessRequest) *ModelPublicServiceServerMockLivenessExpectation {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ModelPublicServiceServerMock.Liveness mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockLivenessExpectation{
		mock:               mmLiveness.mock,
		params:             &ModelPublicServiceServerMockLivenessParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockLivenessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLiveness.expectations = append(mmLiveness.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.Liveness return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockLivenessExpectation) Then(lp2 *mm_modelv1alpha.LivenessResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockLivenessResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.Liveness should be invoked
func (mmLiveness *mModelPublicServiceServerMockLiveness) Times(n uint64) *mModelPublicServiceServerMockLiveness {
	if n == 0 {
		mmLiveness.mock.t.Fatalf("Times of ModelPublicServiceServerMock.Liveness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLiveness.expectedInvocations, n)
	mmLiveness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLiveness
}

func (mmLiveness *mModelPublicServiceServerMockLiveness) invocationsDone() bool {
	if len(mmLiveness.expectations) == 0 && mmLiveness.defaultExpectation == nil && mmLiveness.mock.funcLiveness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLiveness.mock.afterLivenessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLiveness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Liveness implements mm_modelv1alpha.ModelPublicServiceServer
func (mmLiveness *ModelPublicServiceServerMock) Liveness(ctx context.Context, lp1 *mm_modelv1alpha.LivenessRequest) (lp2 *mm_modelv1alpha.LivenessResponse, err error) {
	mm_atomic.AddUint64(&mmLiveness.beforeLivenessCounter, 1)
	defer mm_atomic.AddUint64(&mmLiveness.afterLivenessCounter, 1)

	mmLiveness.t.Helper()

	if mmLiveness.inspectFuncLiveness != nil {
		mmLiveness.inspectFuncLiveness(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockLivenessParams{ctx, lp1}

	// Record call args
	mmLiveness.LivenessMock.mutex.Lock()
	mmLiveness.LivenessMock.callArgs = append(mmLiveness.LivenessMock.callArgs, &mm_params)
	mmLiveness.LivenessMock.mutex.Unlock()

	for _, e := range mmLiveness.LivenessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmLiveness.LivenessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLiveness.LivenessMock.defaultExpectation.Counter, 1)
		mm_want := mmLiveness.LivenessMock.defaultExpectation.params
		mm_want_ptrs := mmLiveness.LivenessMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockLivenessParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLiveness.t.Errorf("ModelPublicServiceServerMock.Liveness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmLiveness.t.Errorf("ModelPublicServiceServerMock.Liveness got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLiveness.t.Errorf("ModelPublicServiceServerMock.Liveness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLiveness.LivenessMock.defaultExpectation.results
		if mm_results == nil {
			mmLiveness.t.Fatal("No results are set for the ModelPublicServiceServerMock.Liveness")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmLiveness.funcLiveness != nil {
		return mmLiveness.funcLiveness(ctx, lp1)
	}
	mmLiveness.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.Liveness. %v %v", ctx, lp1)
	return
}

// LivenessAfterCounter returns a count of finished ModelPublicServiceServerMock.Liveness invocations
func (mmLiveness *ModelPublicServiceServerMock) LivenessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.afterLivenessCounter)
}

// LivenessBeforeCounter returns a count of ModelPublicServiceServerMock.Liveness invocations
func (mmLiveness *ModelPublicServiceServerMock) LivenessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.beforeLivenessCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.Liveness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLiveness *mModelPublicServiceServerMockLiveness) Calls() []*ModelPublicServiceServerMockLivenessParams {
	mmLiveness.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockLivenessParams, len(mmLiveness.callArgs))
	copy(argCopy, mmLiveness.callArgs)

	mmLiveness.mutex.RUnlock()

	return argCopy
}

// MinimockLivenessDone returns true if the count of the Liveness invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockLivenessDone() bool {
	if m.LivenessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LivenessMock.invocationsDone()
}

// MinimockLivenessInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockLivenessInspect() {
	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.Liveness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLivenessCounter := mm_atomic.LoadUint64(&m.afterLivenessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LivenessMock.defaultExpectation != nil && afterLivenessCounter < 1 {
		if m.LivenessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.Liveness at\n%s", m.LivenessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.Liveness at\n%s with params: %#v", m.LivenessMock.defaultExpectation.expectationOrigins.origin, *m.LivenessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLiveness != nil && afterLivenessCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.Liveness at\n%s", m.funcLivenessOrigin)
	}

	if !m.LivenessMock.invocationsDone() && afterLivenessCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.Liveness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LivenessMock.expectedInvocations), m.LivenessMock.expectedInvocationsOrigin, afterLivenessCounter)
	}
}

type mModelPublicServiceServerMockLookUpModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockLookUpModelExpectation
	expectations       []*ModelPublicServiceServerMockLookUpModelExpectation

	callArgs []*ModelPublicServiceServerMockLookUpModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockLookUpModelExpectation specifies expectation struct of the ModelPublicServiceServer.LookUpModel
type ModelPublicServiceServerMockLookUpModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockLookUpModelParams
	paramPtrs          *ModelPublicServiceServerMockLookUpModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockLookUpModelExpectationOrigins
	results            *ModelPublicServiceServerMockLookUpModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockLookUpModelParams contains parameters of the ModelPublicServiceServer.LookUpModel
type ModelPublicServiceServerMockLookUpModelParams struct {
	ctx context.Context
	lp1 *mm_modelv1alpha.LookUpModelRequest
}

// ModelPublicServiceServerMockLookUpModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.LookUpModel
type ModelPublicServiceServerMockLookUpModelParamPtrs struct {
	ctx *context.Context
	lp1 **mm_modelv1alpha.LookUpModelRequest
}

// ModelPublicServiceServerMockLookUpModelResults contains results of the ModelPublicServiceServer.LookUpModel
type ModelPublicServiceServerMockLookUpModelResults struct {
	lp2 *mm_modelv1alpha.LookUpModelResponse
	err error
}

// ModelPublicServiceServerMockLookUpModelOrigins contains origins of expectations of the ModelPublicServiceServer.LookUpModel
type ModelPublicServiceServerMockLookUpModelExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) Optional() *mModelPublicServiceServerMockLookUpModel {
	mmLookUpModel.optional = true
	return mmLookUpModel
}

// Expect sets up expected params for ModelPublicServiceServer.LookUpModel
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) Expect(ctx context.Context, lp1 *mm_modelv1alpha.LookUpModelRequest) *mModelPublicServiceServerMockLookUpModel {
	if mmLookUpModel.mock.funcLookUpModel != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by Set")
	}

	if mmLookUpModel.defaultExpectation == nil {
		mmLookUpModel.defaultExpectation = &ModelPublicServiceServerMockLookUpModelExpectation{}
	}

	if mmLookUpModel.defaultExpectation.paramPtrs != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by ExpectParams functions")
	}

	mmLookUpModel.defaultExpectation.params = &ModelPublicServiceServerMockLookUpModelParams{ctx, lp1}
	mmLookUpModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLookUpModel.expectations {
		if minimock.Equal(e.params, mmLookUpModel.defaultExpectation.params) {
			mmLookUpModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLookUpModel.defaultExpectation.params)
		}
	}

	return mmLookUpModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.LookUpModel
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockLookUpModel {
	if mmLookUpModel.mock.funcLookUpModel != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by Set")
	}

	if mmLookUpModel.defaultExpectation == nil {
		mmLookUpModel.defaultExpectation = &ModelPublicServiceServerMockLookUpModelExpectation{}
	}

	if mmLookUpModel.defaultExpectation.params != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by Expect")
	}

	if mmLookUpModel.defaultExpectation.paramPtrs == nil {
		mmLookUpModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockLookUpModelParamPtrs{}
	}
	mmLookUpModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmLookUpModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLookUpModel
}

// ExpectLp1Param2 sets up expected param lp1 for ModelPublicServiceServer.LookUpModel
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) ExpectLp1Param2(lp1 *mm_modelv1alpha.LookUpModelRequest) *mModelPublicServiceServerMockLookUpModel {
	if mmLookUpModel.mock.funcLookUpModel != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by Set")
	}

	if mmLookUpModel.defaultExpectation == nil {
		mmLookUpModel.defaultExpectation = &ModelPublicServiceServerMockLookUpModelExpectation{}
	}

	if mmLookUpModel.defaultExpectation.params != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by Expect")
	}

	if mmLookUpModel.defaultExpectation.paramPtrs == nil {
		mmLookUpModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockLookUpModelParamPtrs{}
	}
	mmLookUpModel.defaultExpectation.paramPtrs.lp1 = &lp1
	mmLookUpModel.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmLookUpModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.LookUpModel
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) Inspect(f func(ctx context.Context, lp1 *mm_modelv1alpha.LookUpModelRequest)) *mModelPublicServiceServerMockLookUpModel {
	if mmLookUpModel.mock.inspectFuncLookUpModel != nil {
		mmLookUpModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.LookUpModel")
	}

	mmLookUpModel.mock.inspectFuncLookUpModel = f

	return mmLookUpModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.LookUpModel
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) Return(lp2 *mm_modelv1alpha.LookUpModelResponse, err error) *ModelPublicServiceServerMock {
	if mmLookUpModel.mock.funcLookUpModel != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by Set")
	}

	if mmLookUpModel.defaultExpectation == nil {
		mmLookUpModel.defaultExpectation = &ModelPublicServiceServerMockLookUpModelExpectation{mock: mmLookUpModel.mock}
	}
	mmLookUpModel.defaultExpectation.results = &ModelPublicServiceServerMockLookUpModelResults{lp2, err}
	mmLookUpModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLookUpModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.LookUpModel method
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) Set(f func(ctx context.Context, lp1 *mm_modelv1alpha.LookUpModelRequest) (lp2 *mm_modelv1alpha.LookUpModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmLookUpModel.defaultExpectation != nil {
		mmLookUpModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.LookUpModel method")
	}

	if len(mmLookUpModel.expectations) > 0 {
		mmLookUpModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.LookUpModel method")
	}

	mmLookUpModel.mock.funcLookUpModel = f
	mmLookUpModel.mock.funcLookUpModelOrigin = minimock.CallerInfo(1)
	return mmLookUpModel.mock
}

// When sets expectation for the ModelPublicServiceServer.LookUpModel which will trigger the result defined by the following
// Then helper
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) When(ctx context.Context, lp1 *mm_modelv1alpha.LookUpModelRequest) *ModelPublicServiceServerMockLookUpModelExpectation {
	if mmLookUpModel.mock.funcLookUpModel != nil {
		mmLookUpModel.mock.t.Fatalf("ModelPublicServiceServerMock.LookUpModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockLookUpModelExpectation{
		mock:               mmLookUpModel.mock,
		params:             &ModelPublicServiceServerMockLookUpModelParams{ctx, lp1},
		expectationOrigins: ModelPublicServiceServerMockLookUpModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLookUpModel.expectations = append(mmLookUpModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.LookUpModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockLookUpModelExpectation) Then(lp2 *mm_modelv1alpha.LookUpModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockLookUpModelResults{lp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.LookUpModel should be invoked
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) Times(n uint64) *mModelPublicServiceServerMockLookUpModel {
	if n == 0 {
		mmLookUpModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.LookUpModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLookUpModel.expectedInvocations, n)
	mmLookUpModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLookUpModel
}

func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) invocationsDone() bool {
	if len(mmLookUpModel.expectations) == 0 && mmLookUpModel.defaultExpectation == nil && mmLookUpModel.mock.funcLookUpModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLookUpModel.mock.afterLookUpModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLookUpModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LookUpModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmLookUpModel *ModelPublicServiceServerMock) LookUpModel(ctx context.Context, lp1 *mm_modelv1alpha.LookUpModelRequest) (lp2 *mm_modelv1alpha.LookUpModelResponse, err error) {
	mm_atomic.AddUint64(&mmLookUpModel.beforeLookUpModelCounter, 1)
	defer mm_atomic.AddUint64(&mmLookUpModel.afterLookUpModelCounter, 1)

	mmLookUpModel.t.Helper()

	if mmLookUpModel.inspectFuncLookUpModel != nil {
		mmLookUpModel.inspectFuncLookUpModel(ctx, lp1)
	}

	mm_params := ModelPublicServiceServerMockLookUpModelParams{ctx, lp1}

	// Record call args
	mmLookUpModel.LookUpModelMock.mutex.Lock()
	mmLookUpModel.LookUpModelMock.callArgs = append(mmLookUpModel.LookUpModelMock.callArgs, &mm_params)
	mmLookUpModel.LookUpModelMock.mutex.Unlock()

	for _, e := range mmLookUpModel.LookUpModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmLookUpModel.LookUpModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLookUpModel.LookUpModelMock.defaultExpectation.Counter, 1)
		mm_want := mmLookUpModel.LookUpModelMock.defaultExpectation.params
		mm_want_ptrs := mmLookUpModel.LookUpModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockLookUpModelParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLookUpModel.t.Errorf("ModelPublicServiceServerMock.LookUpModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLookUpModel.LookUpModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmLookUpModel.t.Errorf("ModelPublicServiceServerMock.LookUpModel got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLookUpModel.LookUpModelMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLookUpModel.t.Errorf("ModelPublicServiceServerMock.LookUpModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLookUpModel.LookUpModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLookUpModel.LookUpModelMock.defaultExpectation.results
		if mm_results == nil {
			mmLookUpModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.LookUpModel")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmLookUpModel.funcLookUpModel != nil {
		return mmLookUpModel.funcLookUpModel(ctx, lp1)
	}
	mmLookUpModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.LookUpModel. %v %v", ctx, lp1)
	return
}

// LookUpModelAfterCounter returns a count of finished ModelPublicServiceServerMock.LookUpModel invocations
func (mmLookUpModel *ModelPublicServiceServerMock) LookUpModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLookUpModel.afterLookUpModelCounter)
}

// LookUpModelBeforeCounter returns a count of ModelPublicServiceServerMock.LookUpModel invocations
func (mmLookUpModel *ModelPublicServiceServerMock) LookUpModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLookUpModel.beforeLookUpModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.LookUpModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLookUpModel *mModelPublicServiceServerMockLookUpModel) Calls() []*ModelPublicServiceServerMockLookUpModelParams {
	mmLookUpModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockLookUpModelParams, len(mmLookUpModel.callArgs))
	copy(argCopy, mmLookUpModel.callArgs)

	mmLookUpModel.mutex.RUnlock()

	return argCopy
}

// MinimockLookUpModelDone returns true if the count of the LookUpModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockLookUpModelDone() bool {
	if m.LookUpModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LookUpModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LookUpModelMock.invocationsDone()
}

// MinimockLookUpModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockLookUpModelInspect() {
	for _, e := range m.LookUpModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.LookUpModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLookUpModelCounter := mm_atomic.LoadUint64(&m.afterLookUpModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LookUpModelMock.defaultExpectation != nil && afterLookUpModelCounter < 1 {
		if m.LookUpModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.LookUpModel at\n%s", m.LookUpModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.LookUpModel at\n%s with params: %#v", m.LookUpModelMock.defaultExpectation.expectationOrigins.origin, *m.LookUpModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLookUpModel != nil && afterLookUpModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.LookUpModel at\n%s", m.funcLookUpModelOrigin)
	}

	if !m.LookUpModelMock.invocationsDone() && afterLookUpModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.LookUpModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LookUpModelMock.expectedInvocations), m.LookUpModelMock.expectedInvocationsOrigin, afterLookUpModelCounter)
	}
}

type mModelPublicServiceServerMockReadiness struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockReadinessExpectation
	expectations       []*ModelPublicServiceServerMockReadinessExpectation

	callArgs []*ModelPublicServiceServerMockReadinessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockReadinessExpectation specifies expectation struct of the ModelPublicServiceServer.Readiness
type ModelPublicServiceServerMockReadinessExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockReadinessParams
	paramPtrs          *ModelPublicServiceServerMockReadinessParamPtrs
	expectationOrigins ModelPublicServiceServerMockReadinessExpectationOrigins
	results            *ModelPublicServiceServerMockReadinessResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockReadinessParams contains parameters of the ModelPublicServiceServer.Readiness
type ModelPublicServiceServerMockReadinessParams struct {
	ctx context.Context
	rp1 *mm_modelv1alpha.ReadinessRequest
}

// ModelPublicServiceServerMockReadinessParamPtrs contains pointers to parameters of the ModelPublicServiceServer.Readiness
type ModelPublicServiceServerMockReadinessParamPtrs struct {
	ctx *context.Context
	rp1 **mm_modelv1alpha.ReadinessRequest
}

// ModelPublicServiceServerMockReadinessResults contains results of the ModelPublicServiceServer.Readiness
type ModelPublicServiceServerMockReadinessResults struct {
	rp2 *mm_modelv1alpha.ReadinessResponse
	err error
}

// ModelPublicServiceServerMockReadinessOrigins contains origins of expectations of the ModelPublicServiceServer.Readiness
type ModelPublicServiceServerMockReadinessExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadiness *mModelPublicServiceServerMockReadiness) Optional() *mModelPublicServiceServerMockReadiness {
	mmReadiness.optional = true
	return mmReadiness
}

// Expect sets up expected params for ModelPublicServiceServer.Readiness
func (mmReadiness *mModelPublicServiceServerMockReadiness) Expect(ctx context.Context, rp1 *mm_modelv1alpha.ReadinessRequest) *mModelPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ModelPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.paramPtrs != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by ExpectParams functions")
	}

	mmReadiness.defaultExpectation.params = &ModelPublicServiceServerMockReadinessParams{ctx, rp1}
	mmReadiness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadiness.expectations {
		if minimock.Equal(e.params, mmReadiness.defaultExpectation.params) {
			mmReadiness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadiness.defaultExpectation.params)
		}
	}

	return mmReadiness
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.Readiness
func (mmReadiness *mModelPublicServiceServerMockReadiness) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ModelPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadiness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectRp1Param2 sets up expected param rp1 for ModelPublicServiceServer.Readiness
func (mmReadiness *mModelPublicServiceServerMockReadiness) ExpectRp1Param2(rp1 *mm_modelv1alpha.ReadinessRequest) *mModelPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ModelPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.rp1 = &rp1
	mmReadiness.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmReadiness
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.Readiness
func (mmReadiness *mModelPublicServiceServerMockReadiness) Inspect(f func(ctx context.Context, rp1 *mm_modelv1alpha.ReadinessRequest)) *mModelPublicServiceServerMockReadiness {
	if mmReadiness.mock.inspectFuncReadiness != nil {
		mmReadiness.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.Readiness")
	}

	mmReadiness.mock.inspectFuncReadiness = f

	return mmReadiness
}

// Return sets up results that will be returned by ModelPublicServiceServer.Readiness
func (mmReadiness *mModelPublicServiceServerMockReadiness) Return(rp2 *mm_modelv1alpha.ReadinessResponse, err error) *ModelPublicServiceServerMock {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ModelPublicServiceServerMockReadinessExpectation{mock: mmReadiness.mock}
	}
	mmReadiness.defaultExpectation.results = &ModelPublicServiceServerMockReadinessResults{rp2, err}
	mmReadiness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.Readiness method
func (mmReadiness *mModelPublicServiceServerMockReadiness) Set(f func(ctx context.Context, rp1 *mm_modelv1alpha.ReadinessRequest) (rp2 *mm_modelv1alpha.ReadinessResponse, err error)) *ModelPublicServiceServerMock {
	if mmReadiness.defaultExpectation != nil {
		mmReadiness.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.Readiness method")
	}

	if len(mmReadiness.expectations) > 0 {
		mmReadiness.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.Readiness method")
	}

	mmReadiness.mock.funcReadiness = f
	mmReadiness.mock.funcReadinessOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// When sets expectation for the ModelPublicServiceServer.Readiness which will trigger the result defined by the following
// Then helper
func (mmReadiness *mModelPublicServiceServerMockReadiness) When(ctx context.Context, rp1 *mm_modelv1alpha.ReadinessRequest) *ModelPublicServiceServerMockReadinessExpectation {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ModelPublicServiceServerMock.Readiness mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockReadinessExpectation{
		mock:               mmReadiness.mock,
		params:             &ModelPublicServiceServerMockReadinessParams{ctx, rp1},
		expectationOrigins: ModelPublicServiceServerMockReadinessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadiness.expectations = append(mmReadiness.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.Readiness return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockReadinessExpectation) Then(rp2 *mm_modelv1alpha.ReadinessResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockReadinessResults{rp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.Readiness should be invoked
func (mmReadiness *mModelPublicServiceServerMockReadiness) Times(n uint64) *mModelPublicServiceServerMockReadiness {
	if n == 0 {
		mmReadiness.mock.t.Fatalf("Times of ModelPublicServiceServerMock.Readiness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadiness.expectedInvocations, n)
	mmReadiness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadiness
}

func (mmReadiness *mModelPublicServiceServerMockReadiness) invocationsDone() bool {
	if len(mmReadiness.expectations) == 0 && mmReadiness.defaultExpectation == nil && mmReadiness.mock.funcReadiness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadiness.mock.afterReadinessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadiness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Readiness implements mm_modelv1alpha.ModelPublicServiceServer
func (mmReadiness *ModelPublicServiceServerMock) Readiness(ctx context.Context, rp1 *mm_modelv1alpha.ReadinessRequest) (rp2 *mm_modelv1alpha.ReadinessResponse, err error) {
	mm_atomic.AddUint64(&mmReadiness.beforeReadinessCounter, 1)
	defer mm_atomic.AddUint64(&mmReadiness.afterReadinessCounter, 1)

	mmReadiness.t.Helper()

	if mmReadiness.inspectFuncReadiness != nil {
		mmReadiness.inspectFuncReadiness(ctx, rp1)
	}

	mm_params := ModelPublicServiceServerMockReadinessParams{ctx, rp1}

	// Record call args
	mmReadiness.ReadinessMock.mutex.Lock()
	mmReadiness.ReadinessMock.callArgs = append(mmReadiness.ReadinessMock.callArgs, &mm_params)
	mmReadiness.ReadinessMock.mutex.Unlock()

	for _, e := range mmReadiness.ReadinessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmReadiness.ReadinessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadiness.ReadinessMock.defaultExpectation.Counter, 1)
		mm_want := mmReadiness.ReadinessMock.defaultExpectation.params
		mm_want_ptrs := mmReadiness.ReadinessMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockReadinessParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadiness.t.Errorf("ModelPublicServiceServerMock.Readiness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmReadiness.t.Errorf("ModelPublicServiceServerMock.Readiness got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadiness.t.Errorf("ModelPublicServiceServerMock.Readiness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadiness.ReadinessMock.defaultExpectation.results
		if mm_results == nil {
			mmReadiness.t.Fatal("No results are set for the ModelPublicServiceServerMock.Readiness")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmReadiness.funcReadiness != nil {
		return mmReadiness.funcReadiness(ctx, rp1)
	}
	mmReadiness.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.Readiness. %v %v", ctx, rp1)
	return
}

// ReadinessAfterCounter returns a count of finished ModelPublicServiceServerMock.Readiness invocations
func (mmReadiness *ModelPublicServiceServerMock) ReadinessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.afterReadinessCounter)
}

// ReadinessBeforeCounter returns a count of ModelPublicServiceServerMock.Readiness invocations
func (mmReadiness *ModelPublicServiceServerMock) ReadinessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.beforeReadinessCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.Readiness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadiness *mModelPublicServiceServerMockReadiness) Calls() []*ModelPublicServiceServerMockReadinessParams {
	mmReadiness.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockReadinessParams, len(mmReadiness.callArgs))
	copy(argCopy, mmReadiness.callArgs)

	mmReadiness.mutex.RUnlock()

	return argCopy
}

// MinimockReadinessDone returns true if the count of the Readiness invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockReadinessDone() bool {
	if m.ReadinessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadinessMock.invocationsDone()
}

// MinimockReadinessInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockReadinessInspect() {
	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.Readiness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadinessCounter := mm_atomic.LoadUint64(&m.afterReadinessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadinessMock.defaultExpectation != nil && afterReadinessCounter < 1 {
		if m.ReadinessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.Readiness at\n%s", m.ReadinessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.Readiness at\n%s with params: %#v", m.ReadinessMock.defaultExpectation.expectationOrigins.origin, *m.ReadinessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadiness != nil && afterReadinessCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.Readiness at\n%s", m.funcReadinessOrigin)
	}

	if !m.ReadinessMock.invocationsDone() && afterReadinessCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.Readiness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadinessMock.expectedInvocations), m.ReadinessMock.expectedInvocationsOrigin, afterReadinessCounter)
	}
}

type mModelPublicServiceServerMockRenameNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockRenameNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockRenameNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockRenameNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockRenameNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.RenameNamespaceModel
type ModelPublicServiceServerMockRenameNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockRenameNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockRenameNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockRenameNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockRenameNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockRenameNamespaceModelParams contains parameters of the ModelPublicServiceServer.RenameNamespaceModel
type ModelPublicServiceServerMockRenameNamespaceModelParams struct {
	ctx context.Context
	rp1 *mm_modelv1alpha.RenameNamespaceModelRequest
}

// ModelPublicServiceServerMockRenameNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.RenameNamespaceModel
type ModelPublicServiceServerMockRenameNamespaceModelParamPtrs struct {
	ctx *context.Context
	rp1 **mm_modelv1alpha.RenameNamespaceModelRequest
}

// ModelPublicServiceServerMockRenameNamespaceModelResults contains results of the ModelPublicServiceServer.RenameNamespaceModel
type ModelPublicServiceServerMockRenameNamespaceModelResults struct {
	rp2 *mm_modelv1alpha.RenameNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockRenameNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.RenameNamespaceModel
type ModelPublicServiceServerMockRenameNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) Optional() *mModelPublicServiceServerMockRenameNamespaceModel {
	mmRenameNamespaceModel.optional = true
	return mmRenameNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.RenameNamespaceModel
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) Expect(ctx context.Context, rp1 *mm_modelv1alpha.RenameNamespaceModelRequest) *mModelPublicServiceServerMockRenameNamespaceModel {
	if mmRenameNamespaceModel.mock.funcRenameNamespaceModel != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by Set")
	}

	if mmRenameNamespaceModel.defaultExpectation == nil {
		mmRenameNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockRenameNamespaceModelExpectation{}
	}

	if mmRenameNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by ExpectParams functions")
	}

	mmRenameNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockRenameNamespaceModelParams{ctx, rp1}
	mmRenameNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRenameNamespaceModel.expectations {
		if minimock.Equal(e.params, mmRenameNamespaceModel.defaultExpectation.params) {
			mmRenameNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenameNamespaceModel.defaultExpectation.params)
		}
	}

	return mmRenameNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.RenameNamespaceModel
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockRenameNamespaceModel {
	if mmRenameNamespaceModel.mock.funcRenameNamespaceModel != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by Set")
	}

	if mmRenameNamespaceModel.defaultExpectation == nil {
		mmRenameNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockRenameNamespaceModelExpectation{}
	}

	if mmRenameNamespaceModel.defaultExpectation.params != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by Expect")
	}

	if mmRenameNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmRenameNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockRenameNamespaceModelParamPtrs{}
	}
	mmRenameNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmRenameNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRenameNamespaceModel
}

// ExpectRp1Param2 sets up expected param rp1 for ModelPublicServiceServer.RenameNamespaceModel
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) ExpectRp1Param2(rp1 *mm_modelv1alpha.RenameNamespaceModelRequest) *mModelPublicServiceServerMockRenameNamespaceModel {
	if mmRenameNamespaceModel.mock.funcRenameNamespaceModel != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by Set")
	}

	if mmRenameNamespaceModel.defaultExpectation == nil {
		mmRenameNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockRenameNamespaceModelExpectation{}
	}

	if mmRenameNamespaceModel.defaultExpectation.params != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by Expect")
	}

	if mmRenameNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmRenameNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockRenameNamespaceModelParamPtrs{}
	}
	mmRenameNamespaceModel.defaultExpectation.paramPtrs.rp1 = &rp1
	mmRenameNamespaceModel.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmRenameNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.RenameNamespaceModel
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) Inspect(f func(ctx context.Context, rp1 *mm_modelv1alpha.RenameNamespaceModelRequest)) *mModelPublicServiceServerMockRenameNamespaceModel {
	if mmRenameNamespaceModel.mock.inspectFuncRenameNamespaceModel != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.RenameNamespaceModel")
	}

	mmRenameNamespaceModel.mock.inspectFuncRenameNamespaceModel = f

	return mmRenameNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.RenameNamespaceModel
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) Return(rp2 *mm_modelv1alpha.RenameNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmRenameNamespaceModel.mock.funcRenameNamespaceModel != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by Set")
	}

	if mmRenameNamespaceModel.defaultExpectation == nil {
		mmRenameNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockRenameNamespaceModelExpectation{mock: mmRenameNamespaceModel.mock}
	}
	mmRenameNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockRenameNamespaceModelResults{rp2, err}
	mmRenameNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRenameNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.RenameNamespaceModel method
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) Set(f func(ctx context.Context, rp1 *mm_modelv1alpha.RenameNamespaceModelRequest) (rp2 *mm_modelv1alpha.RenameNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmRenameNamespaceModel.defaultExpectation != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.RenameNamespaceModel method")
	}

	if len(mmRenameNamespaceModel.expectations) > 0 {
		mmRenameNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.RenameNamespaceModel method")
	}

	mmRenameNamespaceModel.mock.funcRenameNamespaceModel = f
	mmRenameNamespaceModel.mock.funcRenameNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmRenameNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.RenameNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) When(ctx context.Context, rp1 *mm_modelv1alpha.RenameNamespaceModelRequest) *ModelPublicServiceServerMockRenameNamespaceModelExpectation {
	if mmRenameNamespaceModel.mock.funcRenameNamespaceModel != nil {
		mmRenameNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockRenameNamespaceModelExpectation{
		mock:               mmRenameNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockRenameNamespaceModelParams{ctx, rp1},
		expectationOrigins: ModelPublicServiceServerMockRenameNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRenameNamespaceModel.expectations = append(mmRenameNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.RenameNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockRenameNamespaceModelExpectation) Then(rp2 *mm_modelv1alpha.RenameNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockRenameNamespaceModelResults{rp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.RenameNamespaceModel should be invoked
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockRenameNamespaceModel {
	if n == 0 {
		mmRenameNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.RenameNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRenameNamespaceModel.expectedInvocations, n)
	mmRenameNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRenameNamespaceModel
}

func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) invocationsDone() bool {
	if len(mmRenameNamespaceModel.expectations) == 0 && mmRenameNamespaceModel.defaultExpectation == nil && mmRenameNamespaceModel.mock.funcRenameNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRenameNamespaceModel.mock.afterRenameNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRenameNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RenameNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmRenameNamespaceModel *ModelPublicServiceServerMock) RenameNamespaceModel(ctx context.Context, rp1 *mm_modelv1alpha.RenameNamespaceModelRequest) (rp2 *mm_modelv1alpha.RenameNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmRenameNamespaceModel.beforeRenameNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmRenameNamespaceModel.afterRenameNamespaceModelCounter, 1)

	mmRenameNamespaceModel.t.Helper()

	if mmRenameNamespaceModel.inspectFuncRenameNamespaceModel != nil {
		mmRenameNamespaceModel.inspectFuncRenameNamespaceModel(ctx, rp1)
	}

	mm_params := ModelPublicServiceServerMockRenameNamespaceModelParams{ctx, rp1}

	// Record call args
	mmRenameNamespaceModel.RenameNamespaceModelMock.mutex.Lock()
	mmRenameNamespaceModel.RenameNamespaceModelMock.callArgs = append(mmRenameNamespaceModel.RenameNamespaceModelMock.callArgs, &mm_params)
	mmRenameNamespaceModel.RenameNamespaceModelMock.mutex.Unlock()

	for _, e := range mmRenameNamespaceModel.RenameNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockRenameNamespaceModelParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRenameNamespaceModel.t.Errorf("ModelPublicServiceServerMock.RenameNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmRenameNamespaceModel.t.Errorf("ModelPublicServiceServerMock.RenameNamespaceModel got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRenameNamespaceModel.t.Errorf("ModelPublicServiceServerMock.RenameNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRenameNamespaceModel.RenameNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmRenameNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.RenameNamespaceModel")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmRenameNamespaceModel.funcRenameNamespaceModel != nil {
		return mmRenameNamespaceModel.funcRenameNamespaceModel(ctx, rp1)
	}
	mmRenameNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.RenameNamespaceModel. %v %v", ctx, rp1)
	return
}

// RenameNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.RenameNamespaceModel invocations
func (mmRenameNamespaceModel *ModelPublicServiceServerMock) RenameNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameNamespaceModel.afterRenameNamespaceModelCounter)
}

// RenameNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.RenameNamespaceModel invocations
func (mmRenameNamespaceModel *ModelPublicServiceServerMock) RenameNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameNamespaceModel.beforeRenameNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.RenameNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenameNamespaceModel *mModelPublicServiceServerMockRenameNamespaceModel) Calls() []*ModelPublicServiceServerMockRenameNamespaceModelParams {
	mmRenameNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockRenameNamespaceModelParams, len(mmRenameNamespaceModel.callArgs))
	copy(argCopy, mmRenameNamespaceModel.callArgs)

	mmRenameNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockRenameNamespaceModelDone returns true if the count of the RenameNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockRenameNamespaceModelDone() bool {
	if m.RenameNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RenameNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RenameNamespaceModelMock.invocationsDone()
}

// MinimockRenameNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockRenameNamespaceModelInspect() {
	for _, e := range m.RenameNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRenameNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterRenameNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RenameNamespaceModelMock.defaultExpectation != nil && afterRenameNamespaceModelCounter < 1 {
		if m.RenameNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameNamespaceModel at\n%s", m.RenameNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameNamespaceModel at\n%s with params: %#v", m.RenameNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.RenameNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenameNamespaceModel != nil && afterRenameNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameNamespaceModel at\n%s", m.funcRenameNamespaceModelOrigin)
	}

	if !m.RenameNamespaceModelMock.invocationsDone() && afterRenameNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.RenameNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RenameNamespaceModelMock.expectedInvocations), m.RenameNamespaceModelMock.expectedInvocationsOrigin, afterRenameNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockRenameOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockRenameOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockRenameOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockRenameOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockRenameOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.RenameOrganizationModel
type ModelPublicServiceServerMockRenameOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockRenameOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockRenameOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockRenameOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockRenameOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockRenameOrganizationModelParams contains parameters of the ModelPublicServiceServer.RenameOrganizationModel
type ModelPublicServiceServerMockRenameOrganizationModelParams struct {
	ctx context.Context
	rp1 *mm_modelv1alpha.RenameOrganizationModelRequest
}

// ModelPublicServiceServerMockRenameOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.RenameOrganizationModel
type ModelPublicServiceServerMockRenameOrganizationModelParamPtrs struct {
	ctx *context.Context
	rp1 **mm_modelv1alpha.RenameOrganizationModelRequest
}

// ModelPublicServiceServerMockRenameOrganizationModelResults contains results of the ModelPublicServiceServer.RenameOrganizationModel
type ModelPublicServiceServerMockRenameOrganizationModelResults struct {
	rp2 *mm_modelv1alpha.RenameOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockRenameOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.RenameOrganizationModel
type ModelPublicServiceServerMockRenameOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) Optional() *mModelPublicServiceServerMockRenameOrganizationModel {
	mmRenameOrganizationModel.optional = true
	return mmRenameOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.RenameOrganizationModel
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) Expect(ctx context.Context, rp1 *mm_modelv1alpha.RenameOrganizationModelRequest) *mModelPublicServiceServerMockRenameOrganizationModel {
	if mmRenameOrganizationModel.mock.funcRenameOrganizationModel != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by Set")
	}

	if mmRenameOrganizationModel.defaultExpectation == nil {
		mmRenameOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockRenameOrganizationModelExpectation{}
	}

	if mmRenameOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by ExpectParams functions")
	}

	mmRenameOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockRenameOrganizationModelParams{ctx, rp1}
	mmRenameOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRenameOrganizationModel.expectations {
		if minimock.Equal(e.params, mmRenameOrganizationModel.defaultExpectation.params) {
			mmRenameOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenameOrganizationModel.defaultExpectation.params)
		}
	}

	return mmRenameOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.RenameOrganizationModel
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockRenameOrganizationModel {
	if mmRenameOrganizationModel.mock.funcRenameOrganizationModel != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by Set")
	}

	if mmRenameOrganizationModel.defaultExpectation == nil {
		mmRenameOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockRenameOrganizationModelExpectation{}
	}

	if mmRenameOrganizationModel.defaultExpectation.params != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by Expect")
	}

	if mmRenameOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmRenameOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockRenameOrganizationModelParamPtrs{}
	}
	mmRenameOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmRenameOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRenameOrganizationModel
}

// ExpectRp1Param2 sets up expected param rp1 for ModelPublicServiceServer.RenameOrganizationModel
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) ExpectRp1Param2(rp1 *mm_modelv1alpha.RenameOrganizationModelRequest) *mModelPublicServiceServerMockRenameOrganizationModel {
	if mmRenameOrganizationModel.mock.funcRenameOrganizationModel != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by Set")
	}

	if mmRenameOrganizationModel.defaultExpectation == nil {
		mmRenameOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockRenameOrganizationModelExpectation{}
	}

	if mmRenameOrganizationModel.defaultExpectation.params != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by Expect")
	}

	if mmRenameOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmRenameOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockRenameOrganizationModelParamPtrs{}
	}
	mmRenameOrganizationModel.defaultExpectation.paramPtrs.rp1 = &rp1
	mmRenameOrganizationModel.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmRenameOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.RenameOrganizationModel
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) Inspect(f func(ctx context.Context, rp1 *mm_modelv1alpha.RenameOrganizationModelRequest)) *mModelPublicServiceServerMockRenameOrganizationModel {
	if mmRenameOrganizationModel.mock.inspectFuncRenameOrganizationModel != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.RenameOrganizationModel")
	}

	mmRenameOrganizationModel.mock.inspectFuncRenameOrganizationModel = f

	return mmRenameOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.RenameOrganizationModel
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) Return(rp2 *mm_modelv1alpha.RenameOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmRenameOrganizationModel.mock.funcRenameOrganizationModel != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by Set")
	}

	if mmRenameOrganizationModel.defaultExpectation == nil {
		mmRenameOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockRenameOrganizationModelExpectation{mock: mmRenameOrganizationModel.mock}
	}
	mmRenameOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockRenameOrganizationModelResults{rp2, err}
	mmRenameOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRenameOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.RenameOrganizationModel method
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) Set(f func(ctx context.Context, rp1 *mm_modelv1alpha.RenameOrganizationModelRequest) (rp2 *mm_modelv1alpha.RenameOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmRenameOrganizationModel.defaultExpectation != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.RenameOrganizationModel method")
	}

	if len(mmRenameOrganizationModel.expectations) > 0 {
		mmRenameOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.RenameOrganizationModel method")
	}

	mmRenameOrganizationModel.mock.funcRenameOrganizationModel = f
	mmRenameOrganizationModel.mock.funcRenameOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmRenameOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.RenameOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) When(ctx context.Context, rp1 *mm_modelv1alpha.RenameOrganizationModelRequest) *ModelPublicServiceServerMockRenameOrganizationModelExpectation {
	if mmRenameOrganizationModel.mock.funcRenameOrganizationModel != nil {
		mmRenameOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockRenameOrganizationModelExpectation{
		mock:               mmRenameOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockRenameOrganizationModelParams{ctx, rp1},
		expectationOrigins: ModelPublicServiceServerMockRenameOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRenameOrganizationModel.expectations = append(mmRenameOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.RenameOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockRenameOrganizationModelExpectation) Then(rp2 *mm_modelv1alpha.RenameOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockRenameOrganizationModelResults{rp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.RenameOrganizationModel should be invoked
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockRenameOrganizationModel {
	if n == 0 {
		mmRenameOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.RenameOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRenameOrganizationModel.expectedInvocations, n)
	mmRenameOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRenameOrganizationModel
}

func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) invocationsDone() bool {
	if len(mmRenameOrganizationModel.expectations) == 0 && mmRenameOrganizationModel.defaultExpectation == nil && mmRenameOrganizationModel.mock.funcRenameOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRenameOrganizationModel.mock.afterRenameOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRenameOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RenameOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmRenameOrganizationModel *ModelPublicServiceServerMock) RenameOrganizationModel(ctx context.Context, rp1 *mm_modelv1alpha.RenameOrganizationModelRequest) (rp2 *mm_modelv1alpha.RenameOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmRenameOrganizationModel.beforeRenameOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmRenameOrganizationModel.afterRenameOrganizationModelCounter, 1)

	mmRenameOrganizationModel.t.Helper()

	if mmRenameOrganizationModel.inspectFuncRenameOrganizationModel != nil {
		mmRenameOrganizationModel.inspectFuncRenameOrganizationModel(ctx, rp1)
	}

	mm_params := ModelPublicServiceServerMockRenameOrganizationModelParams{ctx, rp1}

	// Record call args
	mmRenameOrganizationModel.RenameOrganizationModelMock.mutex.Lock()
	mmRenameOrganizationModel.RenameOrganizationModelMock.callArgs = append(mmRenameOrganizationModel.RenameOrganizationModelMock.callArgs, &mm_params)
	mmRenameOrganizationModel.RenameOrganizationModelMock.mutex.Unlock()

	for _, e := range mmRenameOrganizationModel.RenameOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockRenameOrganizationModelParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRenameOrganizationModel.t.Errorf("ModelPublicServiceServerMock.RenameOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmRenameOrganizationModel.t.Errorf("ModelPublicServiceServerMock.RenameOrganizationModel got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRenameOrganizationModel.t.Errorf("ModelPublicServiceServerMock.RenameOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRenameOrganizationModel.RenameOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmRenameOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.RenameOrganizationModel")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmRenameOrganizationModel.funcRenameOrganizationModel != nil {
		return mmRenameOrganizationModel.funcRenameOrganizationModel(ctx, rp1)
	}
	mmRenameOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.RenameOrganizationModel. %v %v", ctx, rp1)
	return
}

// RenameOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.RenameOrganizationModel invocations
func (mmRenameOrganizationModel *ModelPublicServiceServerMock) RenameOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameOrganizationModel.afterRenameOrganizationModelCounter)
}

// RenameOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.RenameOrganizationModel invocations
func (mmRenameOrganizationModel *ModelPublicServiceServerMock) RenameOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameOrganizationModel.beforeRenameOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.RenameOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenameOrganizationModel *mModelPublicServiceServerMockRenameOrganizationModel) Calls() []*ModelPublicServiceServerMockRenameOrganizationModelParams {
	mmRenameOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockRenameOrganizationModelParams, len(mmRenameOrganizationModel.callArgs))
	copy(argCopy, mmRenameOrganizationModel.callArgs)

	mmRenameOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockRenameOrganizationModelDone returns true if the count of the RenameOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockRenameOrganizationModelDone() bool {
	if m.RenameOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RenameOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RenameOrganizationModelMock.invocationsDone()
}

// MinimockRenameOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockRenameOrganizationModelInspect() {
	for _, e := range m.RenameOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRenameOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterRenameOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RenameOrganizationModelMock.defaultExpectation != nil && afterRenameOrganizationModelCounter < 1 {
		if m.RenameOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameOrganizationModel at\n%s", m.RenameOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameOrganizationModel at\n%s with params: %#v", m.RenameOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.RenameOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenameOrganizationModel != nil && afterRenameOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameOrganizationModel at\n%s", m.funcRenameOrganizationModelOrigin)
	}

	if !m.RenameOrganizationModelMock.invocationsDone() && afterRenameOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.RenameOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RenameOrganizationModelMock.expectedInvocations), m.RenameOrganizationModelMock.expectedInvocationsOrigin, afterRenameOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockRenameUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockRenameUserModelExpectation
	expectations       []*ModelPublicServiceServerMockRenameUserModelExpectation

	callArgs []*ModelPublicServiceServerMockRenameUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockRenameUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.RenameUserModel
type ModelPublicServiceServerMockRenameUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockRenameUserModelParams
	paramPtrs          *ModelPublicServiceServerMockRenameUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockRenameUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockRenameUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockRenameUserModelParams contains parameters of the ModelPublicServiceServer.RenameUserModel
type ModelPublicServiceServerMockRenameUserModelParams struct {
	ctx context.Context
	rp1 *mm_modelv1alpha.RenameUserModelRequest
}

// ModelPublicServiceServerMockRenameUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.RenameUserModel
type ModelPublicServiceServerMockRenameUserModelParamPtrs struct {
	ctx *context.Context
	rp1 **mm_modelv1alpha.RenameUserModelRequest
}

// ModelPublicServiceServerMockRenameUserModelResults contains results of the ModelPublicServiceServer.RenameUserModel
type ModelPublicServiceServerMockRenameUserModelResults struct {
	rp2 *mm_modelv1alpha.RenameUserModelResponse
	err error
}

// ModelPublicServiceServerMockRenameUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.RenameUserModel
type ModelPublicServiceServerMockRenameUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) Optional() *mModelPublicServiceServerMockRenameUserModel {
	mmRenameUserModel.optional = true
	return mmRenameUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.RenameUserModel
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) Expect(ctx context.Context, rp1 *mm_modelv1alpha.RenameUserModelRequest) *mModelPublicServiceServerMockRenameUserModel {
	if mmRenameUserModel.mock.funcRenameUserModel != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by Set")
	}

	if mmRenameUserModel.defaultExpectation == nil {
		mmRenameUserModel.defaultExpectation = &ModelPublicServiceServerMockRenameUserModelExpectation{}
	}

	if mmRenameUserModel.defaultExpectation.paramPtrs != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by ExpectParams functions")
	}

	mmRenameUserModel.defaultExpectation.params = &ModelPublicServiceServerMockRenameUserModelParams{ctx, rp1}
	mmRenameUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRenameUserModel.expectations {
		if minimock.Equal(e.params, mmRenameUserModel.defaultExpectation.params) {
			mmRenameUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRenameUserModel.defaultExpectation.params)
		}
	}

	return mmRenameUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.RenameUserModel
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockRenameUserModel {
	if mmRenameUserModel.mock.funcRenameUserModel != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by Set")
	}

	if mmRenameUserModel.defaultExpectation == nil {
		mmRenameUserModel.defaultExpectation = &ModelPublicServiceServerMockRenameUserModelExpectation{}
	}

	if mmRenameUserModel.defaultExpectation.params != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by Expect")
	}

	if mmRenameUserModel.defaultExpectation.paramPtrs == nil {
		mmRenameUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockRenameUserModelParamPtrs{}
	}
	mmRenameUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmRenameUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRenameUserModel
}

// ExpectRp1Param2 sets up expected param rp1 for ModelPublicServiceServer.RenameUserModel
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) ExpectRp1Param2(rp1 *mm_modelv1alpha.RenameUserModelRequest) *mModelPublicServiceServerMockRenameUserModel {
	if mmRenameUserModel.mock.funcRenameUserModel != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by Set")
	}

	if mmRenameUserModel.defaultExpectation == nil {
		mmRenameUserModel.defaultExpectation = &ModelPublicServiceServerMockRenameUserModelExpectation{}
	}

	if mmRenameUserModel.defaultExpectation.params != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by Expect")
	}

	if mmRenameUserModel.defaultExpectation.paramPtrs == nil {
		mmRenameUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockRenameUserModelParamPtrs{}
	}
	mmRenameUserModel.defaultExpectation.paramPtrs.rp1 = &rp1
	mmRenameUserModel.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmRenameUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.RenameUserModel
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) Inspect(f func(ctx context.Context, rp1 *mm_modelv1alpha.RenameUserModelRequest)) *mModelPublicServiceServerMockRenameUserModel {
	if mmRenameUserModel.mock.inspectFuncRenameUserModel != nil {
		mmRenameUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.RenameUserModel")
	}

	mmRenameUserModel.mock.inspectFuncRenameUserModel = f

	return mmRenameUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.RenameUserModel
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) Return(rp2 *mm_modelv1alpha.RenameUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmRenameUserModel.mock.funcRenameUserModel != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by Set")
	}

	if mmRenameUserModel.defaultExpectation == nil {
		mmRenameUserModel.defaultExpectation = &ModelPublicServiceServerMockRenameUserModelExpectation{mock: mmRenameUserModel.mock}
	}
	mmRenameUserModel.defaultExpectation.results = &ModelPublicServiceServerMockRenameUserModelResults{rp2, err}
	mmRenameUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRenameUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.RenameUserModel method
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) Set(f func(ctx context.Context, rp1 *mm_modelv1alpha.RenameUserModelRequest) (rp2 *mm_modelv1alpha.RenameUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmRenameUserModel.defaultExpectation != nil {
		mmRenameUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.RenameUserModel method")
	}

	if len(mmRenameUserModel.expectations) > 0 {
		mmRenameUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.RenameUserModel method")
	}

	mmRenameUserModel.mock.funcRenameUserModel = f
	mmRenameUserModel.mock.funcRenameUserModelOrigin = minimock.CallerInfo(1)
	return mmRenameUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.RenameUserModel which will trigger the result defined by the following
// Then helper
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) When(ctx context.Context, rp1 *mm_modelv1alpha.RenameUserModelRequest) *ModelPublicServiceServerMockRenameUserModelExpectation {
	if mmRenameUserModel.mock.funcRenameUserModel != nil {
		mmRenameUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.RenameUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockRenameUserModelExpectation{
		mock:               mmRenameUserModel.mock,
		params:             &ModelPublicServiceServerMockRenameUserModelParams{ctx, rp1},
		expectationOrigins: ModelPublicServiceServerMockRenameUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRenameUserModel.expectations = append(mmRenameUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.RenameUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockRenameUserModelExpectation) Then(rp2 *mm_modelv1alpha.RenameUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockRenameUserModelResults{rp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.RenameUserModel should be invoked
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) Times(n uint64) *mModelPublicServiceServerMockRenameUserModel {
	if n == 0 {
		mmRenameUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.RenameUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRenameUserModel.expectedInvocations, n)
	mmRenameUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRenameUserModel
}

func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) invocationsDone() bool {
	if len(mmRenameUserModel.expectations) == 0 && mmRenameUserModel.defaultExpectation == nil && mmRenameUserModel.mock.funcRenameUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRenameUserModel.mock.afterRenameUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRenameUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RenameUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmRenameUserModel *ModelPublicServiceServerMock) RenameUserModel(ctx context.Context, rp1 *mm_modelv1alpha.RenameUserModelRequest) (rp2 *mm_modelv1alpha.RenameUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmRenameUserModel.beforeRenameUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmRenameUserModel.afterRenameUserModelCounter, 1)

	mmRenameUserModel.t.Helper()

	if mmRenameUserModel.inspectFuncRenameUserModel != nil {
		mmRenameUserModel.inspectFuncRenameUserModel(ctx, rp1)
	}

	mm_params := ModelPublicServiceServerMockRenameUserModelParams{ctx, rp1}

	// Record call args
	mmRenameUserModel.RenameUserModelMock.mutex.Lock()
	mmRenameUserModel.RenameUserModelMock.callArgs = append(mmRenameUserModel.RenameUserModelMock.callArgs, &mm_params)
	mmRenameUserModel.RenameUserModelMock.mutex.Unlock()

	for _, e := range mmRenameUserModel.RenameUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmRenameUserModel.RenameUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRenameUserModel.RenameUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmRenameUserModel.RenameUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmRenameUserModel.RenameUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockRenameUserModelParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRenameUserModel.t.Errorf("ModelPublicServiceServerMock.RenameUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameUserModel.RenameUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmRenameUserModel.t.Errorf("ModelPublicServiceServerMock.RenameUserModel got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRenameUserModel.RenameUserModelMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRenameUserModel.t.Errorf("ModelPublicServiceServerMock.RenameUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRenameUserModel.RenameUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRenameUserModel.RenameUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmRenameUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.RenameUserModel")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmRenameUserModel.funcRenameUserModel != nil {
		return mmRenameUserModel.funcRenameUserModel(ctx, rp1)
	}
	mmRenameUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.RenameUserModel. %v %v", ctx, rp1)
	return
}

// RenameUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.RenameUserModel invocations
func (mmRenameUserModel *ModelPublicServiceServerMock) RenameUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameUserModel.afterRenameUserModelCounter)
}

// RenameUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.RenameUserModel invocations
func (mmRenameUserModel *ModelPublicServiceServerMock) RenameUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRenameUserModel.beforeRenameUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.RenameUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRenameUserModel *mModelPublicServiceServerMockRenameUserModel) Calls() []*ModelPublicServiceServerMockRenameUserModelParams {
	mmRenameUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockRenameUserModelParams, len(mmRenameUserModel.callArgs))
	copy(argCopy, mmRenameUserModel.callArgs)

	mmRenameUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockRenameUserModelDone returns true if the count of the RenameUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockRenameUserModelDone() bool {
	if m.RenameUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RenameUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RenameUserModelMock.invocationsDone()
}

// MinimockRenameUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockRenameUserModelInspect() {
	for _, e := range m.RenameUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRenameUserModelCounter := mm_atomic.LoadUint64(&m.afterRenameUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RenameUserModelMock.defaultExpectation != nil && afterRenameUserModelCounter < 1 {
		if m.RenameUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameUserModel at\n%s", m.RenameUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameUserModel at\n%s with params: %#v", m.RenameUserModelMock.defaultExpectation.expectationOrigins.origin, *m.RenameUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRenameUserModel != nil && afterRenameUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.RenameUserModel at\n%s", m.funcRenameUserModelOrigin)
	}

	if !m.RenameUserModelMock.invocationsDone() && afterRenameUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.RenameUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RenameUserModelMock.expectedInvocations), m.RenameUserModelMock.expectedInvocationsOrigin, afterRenameUserModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams contains parameters of the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelResults contains results of the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelResults struct {
	tp2 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) Optional() *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel {
	mmTriggerAsyncNamespaceLatestModel.optional = true
	return mmTriggerAsyncNamespaceLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest) *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel {
	if mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModel != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation{}
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation.paramPtrs != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by ExpectParams functions")
	}

	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams{ctx, tp1}
	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerAsyncNamespaceLatestModel.expectations {
		if minimock.Equal(e.params, mmTriggerAsyncNamespaceLatestModel.defaultExpectation.params) {
			mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerAsyncNamespaceLatestModel.defaultExpectation.params)
		}
	}

	return mmTriggerAsyncNamespaceLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel {
	if mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModel != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation{}
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation.params != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by Expect")
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncNamespaceLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParamPtrs{}
	}
	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerAsyncNamespaceLatestModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest) *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel {
	if mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModel != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation{}
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation.params != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by Expect")
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncNamespaceLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParamPtrs{}
	}
	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerAsyncNamespaceLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest)) *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel {
	if mmTriggerAsyncNamespaceLatestModel.mock.inspectFuncTriggerAsyncNamespaceLatestModel != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel")
	}

	mmTriggerAsyncNamespaceLatestModel.mock.inspectFuncTriggerAsyncNamespaceLatestModel = f

	return mmTriggerAsyncNamespaceLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) Return(tp2 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModel != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation{mock: mmTriggerAsyncNamespaceLatestModel.mock}
	}
	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelResults{tp2, err}
	mmTriggerAsyncNamespaceLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncNamespaceLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel method
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerAsyncNamespaceLatestModel.defaultExpectation != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel method")
	}

	if len(mmTriggerAsyncNamespaceLatestModel.expectations) > 0 {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel method")
	}

	mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModel = f
	mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModelOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncNamespaceLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel which will trigger the result defined by the following
// Then helper
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest) *ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation {
	if mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModel != nil {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation{
		mock:               mmTriggerAsyncNamespaceLatestModel.mock,
		params:             &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerAsyncNamespaceLatestModel.expectations = append(mmTriggerAsyncNamespaceLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerAsyncNamespaceLatestModel should be invoked
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) Times(n uint64) *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel {
	if n == 0 {
		mmTriggerAsyncNamespaceLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerAsyncNamespaceLatestModel.expectedInvocations, n)
	mmTriggerAsyncNamespaceLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncNamespaceLatestModel
}

func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) invocationsDone() bool {
	if len(mmTriggerAsyncNamespaceLatestModel.expectations) == 0 && mmTriggerAsyncNamespaceLatestModel.defaultExpectation == nil && mmTriggerAsyncNamespaceLatestModel.mock.funcTriggerAsyncNamespaceLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceLatestModel.mock.afterTriggerAsyncNamespaceLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerAsyncNamespaceLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerAsyncNamespaceLatestModel *ModelPublicServiceServerMock) TriggerAsyncNamespaceLatestModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncNamespaceLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerAsyncNamespaceLatestModel.beforeTriggerAsyncNamespaceLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerAsyncNamespaceLatestModel.afterTriggerAsyncNamespaceLatestModelCounter, 1)

	mmTriggerAsyncNamespaceLatestModel.t.Helper()

	if mmTriggerAsyncNamespaceLatestModel.inspectFuncTriggerAsyncNamespaceLatestModel != nil {
		mmTriggerAsyncNamespaceLatestModel.inspectFuncTriggerAsyncNamespaceLatestModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams{ctx, tp1}

	// Record call args
	mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.mutex.Lock()
	mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.callArgs = append(mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.callArgs, &mm_params)
	mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.mutex.Unlock()

	for _, e := range mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerAsyncNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerAsyncNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerAsyncNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerAsyncNamespaceLatestModel.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerAsyncNamespaceLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerAsyncNamespaceLatestModel.funcTriggerAsyncNamespaceLatestModel != nil {
		return mmTriggerAsyncNamespaceLatestModel.funcTriggerAsyncNamespaceLatestModel(ctx, tp1)
	}
	mmTriggerAsyncNamespaceLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel. %v %v", ctx, tp1)
	return
}

// TriggerAsyncNamespaceLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel invocations
func (mmTriggerAsyncNamespaceLatestModel *ModelPublicServiceServerMock) TriggerAsyncNamespaceLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceLatestModel.afterTriggerAsyncNamespaceLatestModelCounter)
}

// TriggerAsyncNamespaceLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel invocations
func (mmTriggerAsyncNamespaceLatestModel *ModelPublicServiceServerMock) TriggerAsyncNamespaceLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceLatestModel.beforeTriggerAsyncNamespaceLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerAsyncNamespaceLatestModel *mModelPublicServiceServerMockTriggerAsyncNamespaceLatestModel) Calls() []*ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams {
	mmTriggerAsyncNamespaceLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerAsyncNamespaceLatestModelParams, len(mmTriggerAsyncNamespaceLatestModel.callArgs))
	copy(argCopy, mmTriggerAsyncNamespaceLatestModel.callArgs)

	mmTriggerAsyncNamespaceLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerAsyncNamespaceLatestModelDone returns true if the count of the TriggerAsyncNamespaceLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncNamespaceLatestModelDone() bool {
	if m.TriggerAsyncNamespaceLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerAsyncNamespaceLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerAsyncNamespaceLatestModelMock.invocationsDone()
}

// MinimockTriggerAsyncNamespaceLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncNamespaceLatestModelInspect() {
	for _, e := range m.TriggerAsyncNamespaceLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerAsyncNamespaceLatestModelCounter := mm_atomic.LoadUint64(&m.afterTriggerAsyncNamespaceLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerAsyncNamespaceLatestModelMock.defaultExpectation != nil && afterTriggerAsyncNamespaceLatestModelCounter < 1 {
		if m.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel at\n%s", m.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel at\n%s with params: %#v", m.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerAsyncNamespaceLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerAsyncNamespaceLatestModel != nil && afterTriggerAsyncNamespaceLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel at\n%s", m.funcTriggerAsyncNamespaceLatestModelOrigin)
	}

	if !m.TriggerAsyncNamespaceLatestModelMock.invocationsDone() && afterTriggerAsyncNamespaceLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerAsyncNamespaceLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerAsyncNamespaceLatestModelMock.expectedInvocations), m.TriggerAsyncNamespaceLatestModelMock.expectedInvocationsOrigin, afterTriggerAsyncNamespaceLatestModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerAsyncNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerAsyncNamespaceModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerAsyncNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerAsyncNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams contains parameters of the ModelPublicServiceServer.TriggerAsyncNamespaceModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerAsyncNamespaceModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerAsyncNamespaceModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceModelResults contains results of the ModelPublicServiceServer.TriggerAsyncNamespaceModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceModelResults struct {
	tp2 *mm_modelv1alpha.TriggerAsyncNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerAsyncNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerAsyncNamespaceModel
type ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) Optional() *mModelPublicServiceServerMockTriggerAsyncNamespaceModel {
	mmTriggerAsyncNamespaceModel.optional = true
	return mmTriggerAsyncNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerAsyncNamespaceModel
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest) *mModelPublicServiceServerMockTriggerAsyncNamespaceModel {
	if mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModel != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation{}
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by ExpectParams functions")
	}

	mmTriggerAsyncNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams{ctx, tp1}
	mmTriggerAsyncNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerAsyncNamespaceModel.expectations {
		if minimock.Equal(e.params, mmTriggerAsyncNamespaceModel.defaultExpectation.params) {
			mmTriggerAsyncNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerAsyncNamespaceModel.defaultExpectation.params)
		}
	}

	return mmTriggerAsyncNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerAsyncNamespaceModel
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerAsyncNamespaceModel {
	if mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModel != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation{}
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation.params != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by Expect")
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelParamPtrs{}
	}
	mmTriggerAsyncNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerAsyncNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerAsyncNamespaceModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerAsyncNamespaceModel
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest) *mModelPublicServiceServerMockTriggerAsyncNamespaceModel {
	if mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModel != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation{}
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation.params != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by Expect")
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelParamPtrs{}
	}
	mmTriggerAsyncNamespaceModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerAsyncNamespaceModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerAsyncNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerAsyncNamespaceModel
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest)) *mModelPublicServiceServerMockTriggerAsyncNamespaceModel {
	if mmTriggerAsyncNamespaceModel.mock.inspectFuncTriggerAsyncNamespaceModel != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerAsyncNamespaceModel")
	}

	mmTriggerAsyncNamespaceModel.mock.inspectFuncTriggerAsyncNamespaceModel = f

	return mmTriggerAsyncNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerAsyncNamespaceModel
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) Return(tp2 *mm_modelv1alpha.TriggerAsyncNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModel != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by Set")
	}

	if mmTriggerAsyncNamespaceModel.defaultExpectation == nil {
		mmTriggerAsyncNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation{mock: mmTriggerAsyncNamespaceModel.mock}
	}
	mmTriggerAsyncNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelResults{tp2, err}
	mmTriggerAsyncNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerAsyncNamespaceModel method
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerAsyncNamespaceModel.defaultExpectation != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerAsyncNamespaceModel method")
	}

	if len(mmTriggerAsyncNamespaceModel.expectations) > 0 {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerAsyncNamespaceModel method")
	}

	mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModel = f
	mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerAsyncNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest) *ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation {
	if mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModel != nil {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation{
		mock:               mmTriggerAsyncNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerAsyncNamespaceModel.expectations = append(mmTriggerAsyncNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerAsyncNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerAsyncNamespaceModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerAsyncNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerAsyncNamespaceModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerAsyncNamespaceModel should be invoked
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockTriggerAsyncNamespaceModel {
	if n == 0 {
		mmTriggerAsyncNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerAsyncNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerAsyncNamespaceModel.expectedInvocations, n)
	mmTriggerAsyncNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncNamespaceModel
}

func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) invocationsDone() bool {
	if len(mmTriggerAsyncNamespaceModel.expectations) == 0 && mmTriggerAsyncNamespaceModel.defaultExpectation == nil && mmTriggerAsyncNamespaceModel.mock.funcTriggerAsyncNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceModel.mock.afterTriggerAsyncNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerAsyncNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerAsyncNamespaceModel *ModelPublicServiceServerMock) TriggerAsyncNamespaceModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncNamespaceModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerAsyncNamespaceModel.beforeTriggerAsyncNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerAsyncNamespaceModel.afterTriggerAsyncNamespaceModelCounter, 1)

	mmTriggerAsyncNamespaceModel.t.Helper()

	if mmTriggerAsyncNamespaceModel.inspectFuncTriggerAsyncNamespaceModel != nil {
		mmTriggerAsyncNamespaceModel.inspectFuncTriggerAsyncNamespaceModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams{ctx, tp1}

	// Record call args
	mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.mutex.Lock()
	mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.callArgs = append(mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.callArgs, &mm_params)
	mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.mutex.Unlock()

	for _, e := range mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerAsyncNamespaceModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerAsyncNamespaceModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerAsyncNamespaceModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerAsyncNamespaceModel.TriggerAsyncNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerAsyncNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerAsyncNamespaceModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerAsyncNamespaceModel.funcTriggerAsyncNamespaceModel != nil {
		return mmTriggerAsyncNamespaceModel.funcTriggerAsyncNamespaceModel(ctx, tp1)
	}
	mmTriggerAsyncNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceModel. %v %v", ctx, tp1)
	return
}

// TriggerAsyncNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerAsyncNamespaceModel invocations
func (mmTriggerAsyncNamespaceModel *ModelPublicServiceServerMock) TriggerAsyncNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceModel.afterTriggerAsyncNamespaceModelCounter)
}

// TriggerAsyncNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerAsyncNamespaceModel invocations
func (mmTriggerAsyncNamespaceModel *ModelPublicServiceServerMock) TriggerAsyncNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncNamespaceModel.beforeTriggerAsyncNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerAsyncNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerAsyncNamespaceModel *mModelPublicServiceServerMockTriggerAsyncNamespaceModel) Calls() []*ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams {
	mmTriggerAsyncNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerAsyncNamespaceModelParams, len(mmTriggerAsyncNamespaceModel.callArgs))
	copy(argCopy, mmTriggerAsyncNamespaceModel.callArgs)

	mmTriggerAsyncNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerAsyncNamespaceModelDone returns true if the count of the TriggerAsyncNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncNamespaceModelDone() bool {
	if m.TriggerAsyncNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerAsyncNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerAsyncNamespaceModelMock.invocationsDone()
}

// MinimockTriggerAsyncNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncNamespaceModelInspect() {
	for _, e := range m.TriggerAsyncNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerAsyncNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterTriggerAsyncNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerAsyncNamespaceModelMock.defaultExpectation != nil && afterTriggerAsyncNamespaceModelCounter < 1 {
		if m.TriggerAsyncNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceModel at\n%s", m.TriggerAsyncNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceModel at\n%s with params: %#v", m.TriggerAsyncNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerAsyncNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerAsyncNamespaceModel != nil && afterTriggerAsyncNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncNamespaceModel at\n%s", m.funcTriggerAsyncNamespaceModelOrigin)
	}

	if !m.TriggerAsyncNamespaceModelMock.invocationsDone() && afterTriggerAsyncNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerAsyncNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerAsyncNamespaceModelMock.expectedInvocations), m.TriggerAsyncNamespaceModelMock.expectedInvocationsOrigin, afterTriggerAsyncNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams contains parameters of the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelResults contains results of the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelResults struct {
	tp2 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) Optional() *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel {
	mmTriggerAsyncOrganizationLatestModel.optional = true
	return mmTriggerAsyncOrganizationLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest) *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel {
	if mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModel != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation{}
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation.paramPtrs != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by ExpectParams functions")
	}

	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams{ctx, tp1}
	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerAsyncOrganizationLatestModel.expectations {
		if minimock.Equal(e.params, mmTriggerAsyncOrganizationLatestModel.defaultExpectation.params) {
			mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerAsyncOrganizationLatestModel.defaultExpectation.params)
		}
	}

	return mmTriggerAsyncOrganizationLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel {
	if mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModel != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation{}
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation.params != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by Expect")
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncOrganizationLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParamPtrs{}
	}
	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerAsyncOrganizationLatestModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest) *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel {
	if mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModel != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation{}
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation.params != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by Expect")
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncOrganizationLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParamPtrs{}
	}
	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerAsyncOrganizationLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest)) *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel {
	if mmTriggerAsyncOrganizationLatestModel.mock.inspectFuncTriggerAsyncOrganizationLatestModel != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel")
	}

	mmTriggerAsyncOrganizationLatestModel.mock.inspectFuncTriggerAsyncOrganizationLatestModel = f

	return mmTriggerAsyncOrganizationLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) Return(tp2 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModel != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation{mock: mmTriggerAsyncOrganizationLatestModel.mock}
	}
	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelResults{tp2, err}
	mmTriggerAsyncOrganizationLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncOrganizationLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel method
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerAsyncOrganizationLatestModel.defaultExpectation != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel method")
	}

	if len(mmTriggerAsyncOrganizationLatestModel.expectations) > 0 {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel method")
	}

	mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModel = f
	mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModelOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncOrganizationLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel which will trigger the result defined by the following
// Then helper
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest) *ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation {
	if mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModel != nil {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation{
		mock:               mmTriggerAsyncOrganizationLatestModel.mock,
		params:             &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerAsyncOrganizationLatestModel.expectations = append(mmTriggerAsyncOrganizationLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerAsyncOrganizationLatestModel should be invoked
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) Times(n uint64) *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel {
	if n == 0 {
		mmTriggerAsyncOrganizationLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerAsyncOrganizationLatestModel.expectedInvocations, n)
	mmTriggerAsyncOrganizationLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncOrganizationLatestModel
}

func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) invocationsDone() bool {
	if len(mmTriggerAsyncOrganizationLatestModel.expectations) == 0 && mmTriggerAsyncOrganizationLatestModel.defaultExpectation == nil && mmTriggerAsyncOrganizationLatestModel.mock.funcTriggerAsyncOrganizationLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationLatestModel.mock.afterTriggerAsyncOrganizationLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerAsyncOrganizationLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerAsyncOrganizationLatestModel *ModelPublicServiceServerMock) TriggerAsyncOrganizationLatestModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncOrganizationLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerAsyncOrganizationLatestModel.beforeTriggerAsyncOrganizationLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerAsyncOrganizationLatestModel.afterTriggerAsyncOrganizationLatestModelCounter, 1)

	mmTriggerAsyncOrganizationLatestModel.t.Helper()

	if mmTriggerAsyncOrganizationLatestModel.inspectFuncTriggerAsyncOrganizationLatestModel != nil {
		mmTriggerAsyncOrganizationLatestModel.inspectFuncTriggerAsyncOrganizationLatestModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams{ctx, tp1}

	// Record call args
	mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.mutex.Lock()
	mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.callArgs = append(mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.callArgs, &mm_params)
	mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.mutex.Unlock()

	for _, e := range mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerAsyncOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerAsyncOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerAsyncOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerAsyncOrganizationLatestModel.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerAsyncOrganizationLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerAsyncOrganizationLatestModel.funcTriggerAsyncOrganizationLatestModel != nil {
		return mmTriggerAsyncOrganizationLatestModel.funcTriggerAsyncOrganizationLatestModel(ctx, tp1)
	}
	mmTriggerAsyncOrganizationLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel. %v %v", ctx, tp1)
	return
}

// TriggerAsyncOrganizationLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel invocations
func (mmTriggerAsyncOrganizationLatestModel *ModelPublicServiceServerMock) TriggerAsyncOrganizationLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationLatestModel.afterTriggerAsyncOrganizationLatestModelCounter)
}

// TriggerAsyncOrganizationLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel invocations
func (mmTriggerAsyncOrganizationLatestModel *ModelPublicServiceServerMock) TriggerAsyncOrganizationLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationLatestModel.beforeTriggerAsyncOrganizationLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerAsyncOrganizationLatestModel *mModelPublicServiceServerMockTriggerAsyncOrganizationLatestModel) Calls() []*ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams {
	mmTriggerAsyncOrganizationLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerAsyncOrganizationLatestModelParams, len(mmTriggerAsyncOrganizationLatestModel.callArgs))
	copy(argCopy, mmTriggerAsyncOrganizationLatestModel.callArgs)

	mmTriggerAsyncOrganizationLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerAsyncOrganizationLatestModelDone returns true if the count of the TriggerAsyncOrganizationLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncOrganizationLatestModelDone() bool {
	if m.TriggerAsyncOrganizationLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerAsyncOrganizationLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerAsyncOrganizationLatestModelMock.invocationsDone()
}

// MinimockTriggerAsyncOrganizationLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncOrganizationLatestModelInspect() {
	for _, e := range m.TriggerAsyncOrganizationLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerAsyncOrganizationLatestModelCounter := mm_atomic.LoadUint64(&m.afterTriggerAsyncOrganizationLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerAsyncOrganizationLatestModelMock.defaultExpectation != nil && afterTriggerAsyncOrganizationLatestModelCounter < 1 {
		if m.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel at\n%s", m.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel at\n%s with params: %#v", m.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerAsyncOrganizationLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerAsyncOrganizationLatestModel != nil && afterTriggerAsyncOrganizationLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel at\n%s", m.funcTriggerAsyncOrganizationLatestModelOrigin)
	}

	if !m.TriggerAsyncOrganizationLatestModelMock.invocationsDone() && afterTriggerAsyncOrganizationLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerAsyncOrganizationLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerAsyncOrganizationLatestModelMock.expectedInvocations), m.TriggerAsyncOrganizationLatestModelMock.expectedInvocationsOrigin, afterTriggerAsyncOrganizationLatestModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerAsyncOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerAsyncOrganizationModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerAsyncOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerAsyncOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams contains parameters of the ModelPublicServiceServer.TriggerAsyncOrganizationModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerAsyncOrganizationModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerAsyncOrganizationModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationModelResults contains results of the ModelPublicServiceServer.TriggerAsyncOrganizationModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationModelResults struct {
	tp2 *mm_modelv1alpha.TriggerAsyncOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerAsyncOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerAsyncOrganizationModel
type ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) Optional() *mModelPublicServiceServerMockTriggerAsyncOrganizationModel {
	mmTriggerAsyncOrganizationModel.optional = true
	return mmTriggerAsyncOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerAsyncOrganizationModel
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest) *mModelPublicServiceServerMockTriggerAsyncOrganizationModel {
	if mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModel != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation{}
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by ExpectParams functions")
	}

	mmTriggerAsyncOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams{ctx, tp1}
	mmTriggerAsyncOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerAsyncOrganizationModel.expectations {
		if minimock.Equal(e.params, mmTriggerAsyncOrganizationModel.defaultExpectation.params) {
			mmTriggerAsyncOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerAsyncOrganizationModel.defaultExpectation.params)
		}
	}

	return mmTriggerAsyncOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerAsyncOrganizationModel
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerAsyncOrganizationModel {
	if mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModel != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation{}
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation.params != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by Expect")
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelParamPtrs{}
	}
	mmTriggerAsyncOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerAsyncOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerAsyncOrganizationModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerAsyncOrganizationModel
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest) *mModelPublicServiceServerMockTriggerAsyncOrganizationModel {
	if mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModel != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation{}
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation.params != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by Expect")
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelParamPtrs{}
	}
	mmTriggerAsyncOrganizationModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerAsyncOrganizationModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerAsyncOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerAsyncOrganizationModel
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest)) *mModelPublicServiceServerMockTriggerAsyncOrganizationModel {
	if mmTriggerAsyncOrganizationModel.mock.inspectFuncTriggerAsyncOrganizationModel != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerAsyncOrganizationModel")
	}

	mmTriggerAsyncOrganizationModel.mock.inspectFuncTriggerAsyncOrganizationModel = f

	return mmTriggerAsyncOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerAsyncOrganizationModel
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) Return(tp2 *mm_modelv1alpha.TriggerAsyncOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModel != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by Set")
	}

	if mmTriggerAsyncOrganizationModel.defaultExpectation == nil {
		mmTriggerAsyncOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation{mock: mmTriggerAsyncOrganizationModel.mock}
	}
	mmTriggerAsyncOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelResults{tp2, err}
	mmTriggerAsyncOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerAsyncOrganizationModel method
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerAsyncOrganizationModel.defaultExpectation != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerAsyncOrganizationModel method")
	}

	if len(mmTriggerAsyncOrganizationModel.expectations) > 0 {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerAsyncOrganizationModel method")
	}

	mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModel = f
	mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerAsyncOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest) *ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation {
	if mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModel != nil {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation{
		mock:               mmTriggerAsyncOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerAsyncOrganizationModel.expectations = append(mmTriggerAsyncOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerAsyncOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerAsyncOrganizationModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerAsyncOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerAsyncOrganizationModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerAsyncOrganizationModel should be invoked
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockTriggerAsyncOrganizationModel {
	if n == 0 {
		mmTriggerAsyncOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerAsyncOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerAsyncOrganizationModel.expectedInvocations, n)
	mmTriggerAsyncOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncOrganizationModel
}

func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) invocationsDone() bool {
	if len(mmTriggerAsyncOrganizationModel.expectations) == 0 && mmTriggerAsyncOrganizationModel.defaultExpectation == nil && mmTriggerAsyncOrganizationModel.mock.funcTriggerAsyncOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationModel.mock.afterTriggerAsyncOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerAsyncOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerAsyncOrganizationModel *ModelPublicServiceServerMock) TriggerAsyncOrganizationModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncOrganizationModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerAsyncOrganizationModel.beforeTriggerAsyncOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerAsyncOrganizationModel.afterTriggerAsyncOrganizationModelCounter, 1)

	mmTriggerAsyncOrganizationModel.t.Helper()

	if mmTriggerAsyncOrganizationModel.inspectFuncTriggerAsyncOrganizationModel != nil {
		mmTriggerAsyncOrganizationModel.inspectFuncTriggerAsyncOrganizationModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams{ctx, tp1}

	// Record call args
	mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.mutex.Lock()
	mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.callArgs = append(mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.callArgs, &mm_params)
	mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.mutex.Unlock()

	for _, e := range mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerAsyncOrganizationModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerAsyncOrganizationModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerAsyncOrganizationModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerAsyncOrganizationModel.TriggerAsyncOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerAsyncOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerAsyncOrganizationModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerAsyncOrganizationModel.funcTriggerAsyncOrganizationModel != nil {
		return mmTriggerAsyncOrganizationModel.funcTriggerAsyncOrganizationModel(ctx, tp1)
	}
	mmTriggerAsyncOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationModel. %v %v", ctx, tp1)
	return
}

// TriggerAsyncOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerAsyncOrganizationModel invocations
func (mmTriggerAsyncOrganizationModel *ModelPublicServiceServerMock) TriggerAsyncOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationModel.afterTriggerAsyncOrganizationModelCounter)
}

// TriggerAsyncOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerAsyncOrganizationModel invocations
func (mmTriggerAsyncOrganizationModel *ModelPublicServiceServerMock) TriggerAsyncOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncOrganizationModel.beforeTriggerAsyncOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerAsyncOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerAsyncOrganizationModel *mModelPublicServiceServerMockTriggerAsyncOrganizationModel) Calls() []*ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams {
	mmTriggerAsyncOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerAsyncOrganizationModelParams, len(mmTriggerAsyncOrganizationModel.callArgs))
	copy(argCopy, mmTriggerAsyncOrganizationModel.callArgs)

	mmTriggerAsyncOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerAsyncOrganizationModelDone returns true if the count of the TriggerAsyncOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncOrganizationModelDone() bool {
	if m.TriggerAsyncOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerAsyncOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerAsyncOrganizationModelMock.invocationsDone()
}

// MinimockTriggerAsyncOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncOrganizationModelInspect() {
	for _, e := range m.TriggerAsyncOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerAsyncOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterTriggerAsyncOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerAsyncOrganizationModelMock.defaultExpectation != nil && afterTriggerAsyncOrganizationModelCounter < 1 {
		if m.TriggerAsyncOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationModel at\n%s", m.TriggerAsyncOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationModel at\n%s with params: %#v", m.TriggerAsyncOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerAsyncOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerAsyncOrganizationModel != nil && afterTriggerAsyncOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncOrganizationModel at\n%s", m.funcTriggerAsyncOrganizationModelOrigin)
	}

	if !m.TriggerAsyncOrganizationModelMock.invocationsDone() && afterTriggerAsyncOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerAsyncOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerAsyncOrganizationModelMock.expectedInvocations), m.TriggerAsyncOrganizationModelMock.expectedInvocationsOrigin, afterTriggerAsyncOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerAsyncUserLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerAsyncUserLatestModel
type ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerAsyncUserLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerAsyncUserLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams contains parameters of the ModelPublicServiceServer.TriggerAsyncUserLatestModel
type ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncUserLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerAsyncUserLatestModel
type ModelPublicServiceServerMockTriggerAsyncUserLatestModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerAsyncUserLatestModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncUserLatestModelResults contains results of the ModelPublicServiceServer.TriggerAsyncUserLatestModel
type ModelPublicServiceServerMockTriggerAsyncUserLatestModelResults struct {
	tp2 *mm_modelv1alpha.TriggerAsyncUserLatestModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerAsyncUserLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerAsyncUserLatestModel
type ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) Optional() *mModelPublicServiceServerMockTriggerAsyncUserLatestModel {
	mmTriggerAsyncUserLatestModel.optional = true
	return mmTriggerAsyncUserLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerAsyncUserLatestModel
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest) *mModelPublicServiceServerMockTriggerAsyncUserLatestModel {
	if mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModel != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation == nil {
		mmTriggerAsyncUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation{}
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation.paramPtrs != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by ExpectParams functions")
	}

	mmTriggerAsyncUserLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams{ctx, tp1}
	mmTriggerAsyncUserLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerAsyncUserLatestModel.expectations {
		if minimock.Equal(e.params, mmTriggerAsyncUserLatestModel.defaultExpectation.params) {
			mmTriggerAsyncUserLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerAsyncUserLatestModel.defaultExpectation.params)
		}
	}

	return mmTriggerAsyncUserLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerAsyncUserLatestModel
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerAsyncUserLatestModel {
	if mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModel != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation == nil {
		mmTriggerAsyncUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation{}
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation.params != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by Expect")
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncUserLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelParamPtrs{}
	}
	mmTriggerAsyncUserLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerAsyncUserLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerAsyncUserLatestModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerAsyncUserLatestModel
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest) *mModelPublicServiceServerMockTriggerAsyncUserLatestModel {
	if mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModel != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation == nil {
		mmTriggerAsyncUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation{}
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation.params != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by Expect")
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncUserLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelParamPtrs{}
	}
	mmTriggerAsyncUserLatestModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerAsyncUserLatestModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerAsyncUserLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerAsyncUserLatestModel
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest)) *mModelPublicServiceServerMockTriggerAsyncUserLatestModel {
	if mmTriggerAsyncUserLatestModel.mock.inspectFuncTriggerAsyncUserLatestModel != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerAsyncUserLatestModel")
	}

	mmTriggerAsyncUserLatestModel.mock.inspectFuncTriggerAsyncUserLatestModel = f

	return mmTriggerAsyncUserLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerAsyncUserLatestModel
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) Return(tp2 *mm_modelv1alpha.TriggerAsyncUserLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModel != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by Set")
	}

	if mmTriggerAsyncUserLatestModel.defaultExpectation == nil {
		mmTriggerAsyncUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation{mock: mmTriggerAsyncUserLatestModel.mock}
	}
	mmTriggerAsyncUserLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelResults{tp2, err}
	mmTriggerAsyncUserLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncUserLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerAsyncUserLatestModel method
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncUserLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerAsyncUserLatestModel.defaultExpectation != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerAsyncUserLatestModel method")
	}

	if len(mmTriggerAsyncUserLatestModel.expectations) > 0 {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerAsyncUserLatestModel method")
	}

	mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModel = f
	mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModelOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncUserLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerAsyncUserLatestModel which will trigger the result defined by the following
// Then helper
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest) *ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation {
	if mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModel != nil {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation{
		mock:               mmTriggerAsyncUserLatestModel.mock,
		params:             &ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerAsyncUserLatestModel.expectations = append(mmTriggerAsyncUserLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerAsyncUserLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerAsyncUserLatestModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerAsyncUserLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerAsyncUserLatestModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerAsyncUserLatestModel should be invoked
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) Times(n uint64) *mModelPublicServiceServerMockTriggerAsyncUserLatestModel {
	if n == 0 {
		mmTriggerAsyncUserLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerAsyncUserLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerAsyncUserLatestModel.expectedInvocations, n)
	mmTriggerAsyncUserLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncUserLatestModel
}

func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) invocationsDone() bool {
	if len(mmTriggerAsyncUserLatestModel.expectations) == 0 && mmTriggerAsyncUserLatestModel.defaultExpectation == nil && mmTriggerAsyncUserLatestModel.mock.funcTriggerAsyncUserLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncUserLatestModel.mock.afterTriggerAsyncUserLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncUserLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerAsyncUserLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerAsyncUserLatestModel *ModelPublicServiceServerMock) TriggerAsyncUserLatestModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncUserLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerAsyncUserLatestModel.beforeTriggerAsyncUserLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerAsyncUserLatestModel.afterTriggerAsyncUserLatestModelCounter, 1)

	mmTriggerAsyncUserLatestModel.t.Helper()

	if mmTriggerAsyncUserLatestModel.inspectFuncTriggerAsyncUserLatestModel != nil {
		mmTriggerAsyncUserLatestModel.inspectFuncTriggerAsyncUserLatestModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams{ctx, tp1}

	// Record call args
	mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.mutex.Lock()
	mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.callArgs = append(mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.callArgs, &mm_params)
	mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.mutex.Unlock()

	for _, e := range mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerAsyncUserLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerAsyncUserLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerAsyncUserLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncUserLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerAsyncUserLatestModel.TriggerAsyncUserLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerAsyncUserLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerAsyncUserLatestModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerAsyncUserLatestModel.funcTriggerAsyncUserLatestModel != nil {
		return mmTriggerAsyncUserLatestModel.funcTriggerAsyncUserLatestModel(ctx, tp1)
	}
	mmTriggerAsyncUserLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerAsyncUserLatestModel. %v %v", ctx, tp1)
	return
}

// TriggerAsyncUserLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerAsyncUserLatestModel invocations
func (mmTriggerAsyncUserLatestModel *ModelPublicServiceServerMock) TriggerAsyncUserLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncUserLatestModel.afterTriggerAsyncUserLatestModelCounter)
}

// TriggerAsyncUserLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerAsyncUserLatestModel invocations
func (mmTriggerAsyncUserLatestModel *ModelPublicServiceServerMock) TriggerAsyncUserLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncUserLatestModel.beforeTriggerAsyncUserLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerAsyncUserLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerAsyncUserLatestModel *mModelPublicServiceServerMockTriggerAsyncUserLatestModel) Calls() []*ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams {
	mmTriggerAsyncUserLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerAsyncUserLatestModelParams, len(mmTriggerAsyncUserLatestModel.callArgs))
	copy(argCopy, mmTriggerAsyncUserLatestModel.callArgs)

	mmTriggerAsyncUserLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerAsyncUserLatestModelDone returns true if the count of the TriggerAsyncUserLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncUserLatestModelDone() bool {
	if m.TriggerAsyncUserLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerAsyncUserLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerAsyncUserLatestModelMock.invocationsDone()
}

// MinimockTriggerAsyncUserLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncUserLatestModelInspect() {
	for _, e := range m.TriggerAsyncUserLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerAsyncUserLatestModelCounter := mm_atomic.LoadUint64(&m.afterTriggerAsyncUserLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerAsyncUserLatestModelMock.defaultExpectation != nil && afterTriggerAsyncUserLatestModelCounter < 1 {
		if m.TriggerAsyncUserLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserLatestModel at\n%s", m.TriggerAsyncUserLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserLatestModel at\n%s with params: %#v", m.TriggerAsyncUserLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerAsyncUserLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerAsyncUserLatestModel != nil && afterTriggerAsyncUserLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserLatestModel at\n%s", m.funcTriggerAsyncUserLatestModelOrigin)
	}

	if !m.TriggerAsyncUserLatestModelMock.invocationsDone() && afterTriggerAsyncUserLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerAsyncUserLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerAsyncUserLatestModelMock.expectedInvocations), m.TriggerAsyncUserLatestModelMock.expectedInvocationsOrigin, afterTriggerAsyncUserLatestModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerAsyncUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerAsyncUserModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerAsyncUserModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerAsyncUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerAsyncUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerAsyncUserModel
type ModelPublicServiceServerMockTriggerAsyncUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerAsyncUserModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerAsyncUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerAsyncUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerAsyncUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerAsyncUserModelParams contains parameters of the ModelPublicServiceServer.TriggerAsyncUserModel
type ModelPublicServiceServerMockTriggerAsyncUserModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerAsyncUserModel
type ModelPublicServiceServerMockTriggerAsyncUserModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerAsyncUserModelRequest
}

// ModelPublicServiceServerMockTriggerAsyncUserModelResults contains results of the ModelPublicServiceServer.TriggerAsyncUserModel
type ModelPublicServiceServerMockTriggerAsyncUserModelResults struct {
	tp2 *mm_modelv1alpha.TriggerAsyncUserModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerAsyncUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerAsyncUserModel
type ModelPublicServiceServerMockTriggerAsyncUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) Optional() *mModelPublicServiceServerMockTriggerAsyncUserModel {
	mmTriggerAsyncUserModel.optional = true
	return mmTriggerAsyncUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerAsyncUserModel
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest) *mModelPublicServiceServerMockTriggerAsyncUserModel {
	if mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModel != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by Set")
	}

	if mmTriggerAsyncUserModel.defaultExpectation == nil {
		mmTriggerAsyncUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserModelExpectation{}
	}

	if mmTriggerAsyncUserModel.defaultExpectation.paramPtrs != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by ExpectParams functions")
	}

	mmTriggerAsyncUserModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerAsyncUserModelParams{ctx, tp1}
	mmTriggerAsyncUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerAsyncUserModel.expectations {
		if minimock.Equal(e.params, mmTriggerAsyncUserModel.defaultExpectation.params) {
			mmTriggerAsyncUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerAsyncUserModel.defaultExpectation.params)
		}
	}

	return mmTriggerAsyncUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerAsyncUserModel
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerAsyncUserModel {
	if mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModel != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by Set")
	}

	if mmTriggerAsyncUserModel.defaultExpectation == nil {
		mmTriggerAsyncUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserModelExpectation{}
	}

	if mmTriggerAsyncUserModel.defaultExpectation.params != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by Expect")
	}

	if mmTriggerAsyncUserModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncUserModelParamPtrs{}
	}
	mmTriggerAsyncUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerAsyncUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerAsyncUserModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerAsyncUserModel
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest) *mModelPublicServiceServerMockTriggerAsyncUserModel {
	if mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModel != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by Set")
	}

	if mmTriggerAsyncUserModel.defaultExpectation == nil {
		mmTriggerAsyncUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserModelExpectation{}
	}

	if mmTriggerAsyncUserModel.defaultExpectation.params != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by Expect")
	}

	if mmTriggerAsyncUserModel.defaultExpectation.paramPtrs == nil {
		mmTriggerAsyncUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerAsyncUserModelParamPtrs{}
	}
	mmTriggerAsyncUserModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerAsyncUserModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerAsyncUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerAsyncUserModel
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest)) *mModelPublicServiceServerMockTriggerAsyncUserModel {
	if mmTriggerAsyncUserModel.mock.inspectFuncTriggerAsyncUserModel != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerAsyncUserModel")
	}

	mmTriggerAsyncUserModel.mock.inspectFuncTriggerAsyncUserModel = f

	return mmTriggerAsyncUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerAsyncUserModel
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) Return(tp2 *mm_modelv1alpha.TriggerAsyncUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModel != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by Set")
	}

	if mmTriggerAsyncUserModel.defaultExpectation == nil {
		mmTriggerAsyncUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerAsyncUserModelExpectation{mock: mmTriggerAsyncUserModel.mock}
	}
	mmTriggerAsyncUserModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerAsyncUserModelResults{tp2, err}
	mmTriggerAsyncUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerAsyncUserModel method
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerAsyncUserModel.defaultExpectation != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerAsyncUserModel method")
	}

	if len(mmTriggerAsyncUserModel.expectations) > 0 {
		mmTriggerAsyncUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerAsyncUserModel method")
	}

	mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModel = f
	mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModelOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerAsyncUserModel which will trigger the result defined by the following
// Then helper
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest) *ModelPublicServiceServerMockTriggerAsyncUserModelExpectation {
	if mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModel != nil {
		mmTriggerAsyncUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerAsyncUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerAsyncUserModelExpectation{
		mock:               mmTriggerAsyncUserModel.mock,
		params:             &ModelPublicServiceServerMockTriggerAsyncUserModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerAsyncUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerAsyncUserModel.expectations = append(mmTriggerAsyncUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerAsyncUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerAsyncUserModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerAsyncUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerAsyncUserModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerAsyncUserModel should be invoked
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) Times(n uint64) *mModelPublicServiceServerMockTriggerAsyncUserModel {
	if n == 0 {
		mmTriggerAsyncUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerAsyncUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerAsyncUserModel.expectedInvocations, n)
	mmTriggerAsyncUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerAsyncUserModel
}

func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) invocationsDone() bool {
	if len(mmTriggerAsyncUserModel.expectations) == 0 && mmTriggerAsyncUserModel.defaultExpectation == nil && mmTriggerAsyncUserModel.mock.funcTriggerAsyncUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncUserModel.mock.afterTriggerAsyncUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerAsyncUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerAsyncUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerAsyncUserModel *ModelPublicServiceServerMock) TriggerAsyncUserModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerAsyncUserModelRequest) (tp2 *mm_modelv1alpha.TriggerAsyncUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerAsyncUserModel.beforeTriggerAsyncUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerAsyncUserModel.afterTriggerAsyncUserModelCounter, 1)

	mmTriggerAsyncUserModel.t.Helper()

	if mmTriggerAsyncUserModel.inspectFuncTriggerAsyncUserModel != nil {
		mmTriggerAsyncUserModel.inspectFuncTriggerAsyncUserModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerAsyncUserModelParams{ctx, tp1}

	// Record call args
	mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.mutex.Lock()
	mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.callArgs = append(mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.callArgs, &mm_params)
	mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.mutex.Unlock()

	for _, e := range mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerAsyncUserModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerAsyncUserModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerAsyncUserModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncUserModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerAsyncUserModel.t.Errorf("ModelPublicServiceServerMock.TriggerAsyncUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerAsyncUserModel.TriggerAsyncUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerAsyncUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerAsyncUserModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerAsyncUserModel.funcTriggerAsyncUserModel != nil {
		return mmTriggerAsyncUserModel.funcTriggerAsyncUserModel(ctx, tp1)
	}
	mmTriggerAsyncUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerAsyncUserModel. %v %v", ctx, tp1)
	return
}

// TriggerAsyncUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerAsyncUserModel invocations
func (mmTriggerAsyncUserModel *ModelPublicServiceServerMock) TriggerAsyncUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncUserModel.afterTriggerAsyncUserModelCounter)
}

// TriggerAsyncUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerAsyncUserModel invocations
func (mmTriggerAsyncUserModel *ModelPublicServiceServerMock) TriggerAsyncUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerAsyncUserModel.beforeTriggerAsyncUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerAsyncUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerAsyncUserModel *mModelPublicServiceServerMockTriggerAsyncUserModel) Calls() []*ModelPublicServiceServerMockTriggerAsyncUserModelParams {
	mmTriggerAsyncUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerAsyncUserModelParams, len(mmTriggerAsyncUserModel.callArgs))
	copy(argCopy, mmTriggerAsyncUserModel.callArgs)

	mmTriggerAsyncUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerAsyncUserModelDone returns true if the count of the TriggerAsyncUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncUserModelDone() bool {
	if m.TriggerAsyncUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerAsyncUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerAsyncUserModelMock.invocationsDone()
}

// MinimockTriggerAsyncUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerAsyncUserModelInspect() {
	for _, e := range m.TriggerAsyncUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerAsyncUserModelCounter := mm_atomic.LoadUint64(&m.afterTriggerAsyncUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerAsyncUserModelMock.defaultExpectation != nil && afterTriggerAsyncUserModelCounter < 1 {
		if m.TriggerAsyncUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserModel at\n%s", m.TriggerAsyncUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserModel at\n%s with params: %#v", m.TriggerAsyncUserModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerAsyncUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerAsyncUserModel != nil && afterTriggerAsyncUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerAsyncUserModel at\n%s", m.funcTriggerAsyncUserModelOrigin)
	}

	if !m.TriggerAsyncUserModelMock.invocationsDone() && afterTriggerAsyncUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerAsyncUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerAsyncUserModelMock.expectedInvocations), m.TriggerAsyncUserModelMock.expectedInvocationsOrigin, afterTriggerAsyncUserModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerNamespaceLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerNamespaceLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerNamespaceLatestModel
type ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerNamespaceLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerNamespaceLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerNamespaceLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelParams contains parameters of the ModelPublicServiceServer.TriggerNamespaceLatestModel
type ModelPublicServiceServerMockTriggerNamespaceLatestModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerNamespaceLatestModel
type ModelPublicServiceServerMockTriggerNamespaceLatestModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerNamespaceLatestModelRequest
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelResults contains results of the ModelPublicServiceServer.TriggerNamespaceLatestModel
type ModelPublicServiceServerMockTriggerNamespaceLatestModelResults struct {
	tp2 *mm_modelv1alpha.TriggerNamespaceLatestModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerNamespaceLatestModel
type ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) Optional() *mModelPublicServiceServerMockTriggerNamespaceLatestModel {
	mmTriggerNamespaceLatestModel.optional = true
	return mmTriggerNamespaceLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerNamespaceLatestModel
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest) *mModelPublicServiceServerMockTriggerNamespaceLatestModel {
	if mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModel != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation{}
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation.paramPtrs != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by ExpectParams functions")
	}

	mmTriggerNamespaceLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerNamespaceLatestModelParams{ctx, tp1}
	mmTriggerNamespaceLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerNamespaceLatestModel.expectations {
		if minimock.Equal(e.params, mmTriggerNamespaceLatestModel.defaultExpectation.params) {
			mmTriggerNamespaceLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerNamespaceLatestModel.defaultExpectation.params)
		}
	}

	return mmTriggerNamespaceLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerNamespaceLatestModel
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerNamespaceLatestModel {
	if mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModel != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation{}
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation.params != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by Expect")
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerNamespaceLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerNamespaceLatestModelParamPtrs{}
	}
	mmTriggerNamespaceLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerNamespaceLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerNamespaceLatestModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerNamespaceLatestModel
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest) *mModelPublicServiceServerMockTriggerNamespaceLatestModel {
	if mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModel != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation{}
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation.params != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by Expect")
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerNamespaceLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerNamespaceLatestModelParamPtrs{}
	}
	mmTriggerNamespaceLatestModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerNamespaceLatestModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerNamespaceLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerNamespaceLatestModel
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest)) *mModelPublicServiceServerMockTriggerNamespaceLatestModel {
	if mmTriggerNamespaceLatestModel.mock.inspectFuncTriggerNamespaceLatestModel != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerNamespaceLatestModel")
	}

	mmTriggerNamespaceLatestModel.mock.inspectFuncTriggerNamespaceLatestModel = f

	return mmTriggerNamespaceLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerNamespaceLatestModel
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) Return(tp2 *mm_modelv1alpha.TriggerNamespaceLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModel != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by Set")
	}

	if mmTriggerNamespaceLatestModel.defaultExpectation == nil {
		mmTriggerNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation{mock: mmTriggerNamespaceLatestModel.mock}
	}
	mmTriggerNamespaceLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerNamespaceLatestModelResults{tp2, err}
	mmTriggerNamespaceLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerNamespaceLatestModel method
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerNamespaceLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceLatestModel.defaultExpectation != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerNamespaceLatestModel method")
	}

	if len(mmTriggerNamespaceLatestModel.expectations) > 0 {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerNamespaceLatestModel method")
	}

	mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModel = f
	mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModelOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerNamespaceLatestModel which will trigger the result defined by the following
// Then helper
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest) *ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation {
	if mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModel != nil {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation{
		mock:               mmTriggerNamespaceLatestModel.mock,
		params:             &ModelPublicServiceServerMockTriggerNamespaceLatestModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerNamespaceLatestModel.expectations = append(mmTriggerNamespaceLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerNamespaceLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerNamespaceLatestModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerNamespaceLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerNamespaceLatestModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerNamespaceLatestModel should be invoked
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) Times(n uint64) *mModelPublicServiceServerMockTriggerNamespaceLatestModel {
	if n == 0 {
		mmTriggerNamespaceLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerNamespaceLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerNamespaceLatestModel.expectedInvocations, n)
	mmTriggerNamespaceLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceLatestModel
}

func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) invocationsDone() bool {
	if len(mmTriggerNamespaceLatestModel.expectations) == 0 && mmTriggerNamespaceLatestModel.defaultExpectation == nil && mmTriggerNamespaceLatestModel.mock.funcTriggerNamespaceLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModel.mock.afterTriggerNamespaceLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerNamespaceLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerNamespaceLatestModel *ModelPublicServiceServerMock) TriggerNamespaceLatestModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerNamespaceLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerNamespaceLatestModel.beforeTriggerNamespaceLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerNamespaceLatestModel.afterTriggerNamespaceLatestModelCounter, 1)

	mmTriggerNamespaceLatestModel.t.Helper()

	if mmTriggerNamespaceLatestModel.inspectFuncTriggerNamespaceLatestModel != nil {
		mmTriggerNamespaceLatestModel.inspectFuncTriggerNamespaceLatestModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerNamespaceLatestModelParams{ctx, tp1}

	// Record call args
	mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.mutex.Lock()
	mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.callArgs = append(mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.callArgs, &mm_params)
	mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.mutex.Unlock()

	for _, e := range mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerNamespaceLatestModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerNamespaceLatestModel.TriggerNamespaceLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerNamespaceLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerNamespaceLatestModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerNamespaceLatestModel.funcTriggerNamespaceLatestModel != nil {
		return mmTriggerNamespaceLatestModel.funcTriggerNamespaceLatestModel(ctx, tp1)
	}
	mmTriggerNamespaceLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModel. %v %v", ctx, tp1)
	return
}

// TriggerNamespaceLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerNamespaceLatestModel invocations
func (mmTriggerNamespaceLatestModel *ModelPublicServiceServerMock) TriggerNamespaceLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModel.afterTriggerNamespaceLatestModelCounter)
}

// TriggerNamespaceLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerNamespaceLatestModel invocations
func (mmTriggerNamespaceLatestModel *ModelPublicServiceServerMock) TriggerNamespaceLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModel.beforeTriggerNamespaceLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerNamespaceLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerNamespaceLatestModel *mModelPublicServiceServerMockTriggerNamespaceLatestModel) Calls() []*ModelPublicServiceServerMockTriggerNamespaceLatestModelParams {
	mmTriggerNamespaceLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerNamespaceLatestModelParams, len(mmTriggerNamespaceLatestModel.callArgs))
	copy(argCopy, mmTriggerNamespaceLatestModel.callArgs)

	mmTriggerNamespaceLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerNamespaceLatestModelDone returns true if the count of the TriggerNamespaceLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceLatestModelDone() bool {
	if m.TriggerNamespaceLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerNamespaceLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerNamespaceLatestModelMock.invocationsDone()
}

// MinimockTriggerNamespaceLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceLatestModelInspect() {
	for _, e := range m.TriggerNamespaceLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerNamespaceLatestModelCounter := mm_atomic.LoadUint64(&m.afterTriggerNamespaceLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerNamespaceLatestModelMock.defaultExpectation != nil && afterTriggerNamespaceLatestModelCounter < 1 {
		if m.TriggerNamespaceLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModel at\n%s", m.TriggerNamespaceLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModel at\n%s with params: %#v", m.TriggerNamespaceLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerNamespaceLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerNamespaceLatestModel != nil && afterTriggerNamespaceLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModel at\n%s", m.funcTriggerNamespaceLatestModelOrigin)
	}

	if !m.TriggerNamespaceLatestModelMock.invocationsDone() && afterTriggerNamespaceLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerNamespaceLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerNamespaceLatestModelMock.expectedInvocations), m.TriggerNamespaceLatestModelMock.expectedInvocationsOrigin, afterTriggerNamespaceLatestModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation
	expectations       []*ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation

	callArgs []*ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams
	paramPtrs          *ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams contains parameters of the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams struct {
	m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParamPtrs struct {
	m1 *mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadResults contains results of the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadResults struct {
	err error
}

// ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectationOrigins struct {
	origin   string
	originM1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) Optional() *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload {
	mmTriggerNamespaceLatestModelBinaryFileUpload.optional = true
	return mmTriggerNamespaceLatestModelBinaryFileUpload
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) Expect(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload {
	if mmTriggerNamespaceLatestModelBinaryFileUpload.mock.funcTriggerNamespaceLatestModelBinaryFileUpload != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation{}
	}

	if mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.paramPtrs != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload mock is already set by ExpectParams functions")
	}

	mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.params = &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams{m1}
	mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerNamespaceLatestModelBinaryFileUpload.expectations {
		if minimock.Equal(e.params, mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.params) {
			mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.params)
		}
	}

	return mmTriggerNamespaceLatestModelBinaryFileUpload
}

// ExpectM1Param1 sets up expected param m1 for ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) ExpectM1Param1(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload {
	if mmTriggerNamespaceLatestModelBinaryFileUpload.mock.funcTriggerNamespaceLatestModelBinaryFileUpload != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation{}
	}

	if mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.params != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload mock is already set by Expect")
	}

	if mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.paramPtrs == nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParamPtrs{}
	}
	mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.paramPtrs.m1 = &m1
	mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.expectationOrigins.originM1 = minimock.CallerInfo(1)

	return mmTriggerNamespaceLatestModelBinaryFileUpload
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) Inspect(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer)) *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload {
	if mmTriggerNamespaceLatestModelBinaryFileUpload.mock.inspectFuncTriggerNamespaceLatestModelBinaryFileUpload != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload")
	}

	mmTriggerNamespaceLatestModelBinaryFileUpload.mock.inspectFuncTriggerNamespaceLatestModelBinaryFileUpload = f

	return mmTriggerNamespaceLatestModelBinaryFileUpload
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) Return(err error) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceLatestModelBinaryFileUpload.mock.funcTriggerNamespaceLatestModelBinaryFileUpload != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation{mock: mmTriggerNamespaceLatestModelBinaryFileUpload.mock}
	}
	mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.results = &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadResults{err}
	mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceLatestModelBinaryFileUpload.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload method
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) Set(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer) (err error)) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload method")
	}

	if len(mmTriggerNamespaceLatestModelBinaryFileUpload.expectations) > 0 {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload method")
	}

	mmTriggerNamespaceLatestModelBinaryFileUpload.mock.funcTriggerNamespaceLatestModelBinaryFileUpload = f
	mmTriggerNamespaceLatestModelBinaryFileUpload.mock.funcTriggerNamespaceLatestModelBinaryFileUploadOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceLatestModelBinaryFileUpload.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload which will trigger the result defined by the following
// Then helper
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) When(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer) *ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation {
	if mmTriggerNamespaceLatestModelBinaryFileUpload.mock.funcTriggerNamespaceLatestModelBinaryFileUpload != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation{
		mock:               mmTriggerNamespaceLatestModelBinaryFileUpload.mock,
		params:             &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams{m1},
		expectationOrigins: ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerNamespaceLatestModelBinaryFileUpload.expectations = append(mmTriggerNamespaceLatestModelBinaryFileUpload.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadExpectation) Then(err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadResults{err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerNamespaceLatestModelBinaryFileUpload should be invoked
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) Times(n uint64) *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload {
	if n == 0 {
		mmTriggerNamespaceLatestModelBinaryFileUpload.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.expectedInvocations, n)
	mmTriggerNamespaceLatestModelBinaryFileUpload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceLatestModelBinaryFileUpload
}

func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) invocationsDone() bool {
	if len(mmTriggerNamespaceLatestModelBinaryFileUpload.expectations) == 0 && mmTriggerNamespaceLatestModelBinaryFileUpload.defaultExpectation == nil && mmTriggerNamespaceLatestModelBinaryFileUpload.mock.funcTriggerNamespaceLatestModelBinaryFileUpload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.mock.afterTriggerNamespaceLatestModelBinaryFileUploadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerNamespaceLatestModelBinaryFileUpload implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerNamespaceLatestModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerNamespaceLatestModelBinaryFileUpload(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceLatestModelBinaryFileUploadServer) (err error) {
	mm_atomic.AddUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.beforeTriggerNamespaceLatestModelBinaryFileUploadCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.afterTriggerNamespaceLatestModelBinaryFileUploadCounter, 1)

	mmTriggerNamespaceLatestModelBinaryFileUpload.t.Helper()

	if mmTriggerNamespaceLatestModelBinaryFileUpload.inspectFuncTriggerNamespaceLatestModelBinaryFileUpload != nil {
		mmTriggerNamespaceLatestModelBinaryFileUpload.inspectFuncTriggerNamespaceLatestModelBinaryFileUpload(m1)
	}

	mm_params := ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams{m1}

	// Record call args
	mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.mutex.Lock()
	mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.callArgs = append(mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.callArgs, &mm_params)
	mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.mutex.Unlock()

	for _, e := range mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams{m1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.m1 != nil && !minimock.Equal(*mm_want_ptrs.m1, mm_got.m1) {
				mmTriggerNamespaceLatestModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload got unexpected parameter m1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.originM1, *mm_want_ptrs.m1, mm_got.m1, minimock.Diff(*mm_want_ptrs.m1, mm_got.m1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerNamespaceLatestModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerNamespaceLatestModelBinaryFileUpload.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerNamespaceLatestModelBinaryFileUpload.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload")
		}
		return (*mm_results).err
	}
	if mmTriggerNamespaceLatestModelBinaryFileUpload.funcTriggerNamespaceLatestModelBinaryFileUpload != nil {
		return mmTriggerNamespaceLatestModelBinaryFileUpload.funcTriggerNamespaceLatestModelBinaryFileUpload(m1)
	}
	mmTriggerNamespaceLatestModelBinaryFileUpload.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload. %v", m1)
	return
}

// TriggerNamespaceLatestModelBinaryFileUploadAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload invocations
func (mmTriggerNamespaceLatestModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerNamespaceLatestModelBinaryFileUploadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.afterTriggerNamespaceLatestModelBinaryFileUploadCounter)
}

// TriggerNamespaceLatestModelBinaryFileUploadBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload invocations
func (mmTriggerNamespaceLatestModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerNamespaceLatestModelBinaryFileUploadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceLatestModelBinaryFileUpload.beforeTriggerNamespaceLatestModelBinaryFileUploadCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerNamespaceLatestModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUpload) Calls() []*ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams {
	mmTriggerNamespaceLatestModelBinaryFileUpload.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerNamespaceLatestModelBinaryFileUploadParams, len(mmTriggerNamespaceLatestModelBinaryFileUpload.callArgs))
	copy(argCopy, mmTriggerNamespaceLatestModelBinaryFileUpload.callArgs)

	mmTriggerNamespaceLatestModelBinaryFileUpload.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerNamespaceLatestModelBinaryFileUploadDone returns true if the count of the TriggerNamespaceLatestModelBinaryFileUpload invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceLatestModelBinaryFileUploadDone() bool {
	if m.TriggerNamespaceLatestModelBinaryFileUploadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerNamespaceLatestModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerNamespaceLatestModelBinaryFileUploadMock.invocationsDone()
}

// MinimockTriggerNamespaceLatestModelBinaryFileUploadInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceLatestModelBinaryFileUploadInspect() {
	for _, e := range m.TriggerNamespaceLatestModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerNamespaceLatestModelBinaryFileUploadCounter := mm_atomic.LoadUint64(&m.afterTriggerNamespaceLatestModelBinaryFileUploadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation != nil && afterTriggerNamespaceLatestModelBinaryFileUploadCounter < 1 {
		if m.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload at\n%s", m.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload at\n%s with params: %#v", m.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *m.TriggerNamespaceLatestModelBinaryFileUploadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerNamespaceLatestModelBinaryFileUpload != nil && afterTriggerNamespaceLatestModelBinaryFileUploadCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload at\n%s", m.funcTriggerNamespaceLatestModelBinaryFileUploadOrigin)
	}

	if !m.TriggerNamespaceLatestModelBinaryFileUploadMock.invocationsDone() && afterTriggerNamespaceLatestModelBinaryFileUploadCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerNamespaceLatestModelBinaryFileUpload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerNamespaceLatestModelBinaryFileUploadMock.expectedInvocations), m.TriggerNamespaceLatestModelBinaryFileUploadMock.expectedInvocationsOrigin, afterTriggerNamespaceLatestModelBinaryFileUploadCounter)
	}
}

type mModelPublicServiceServerMockTriggerNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerNamespaceModel
type ModelPublicServiceServerMockTriggerNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerNamespaceModelParams contains parameters of the ModelPublicServiceServer.TriggerNamespaceModel
type ModelPublicServiceServerMockTriggerNamespaceModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest
}

// ModelPublicServiceServerMockTriggerNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerNamespaceModel
type ModelPublicServiceServerMockTriggerNamespaceModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerNamespaceModelRequest
}

// ModelPublicServiceServerMockTriggerNamespaceModelResults contains results of the ModelPublicServiceServer.TriggerNamespaceModel
type ModelPublicServiceServerMockTriggerNamespaceModelResults struct {
	tp2 *mm_modelv1alpha.TriggerNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerNamespaceModel
type ModelPublicServiceServerMockTriggerNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) Optional() *mModelPublicServiceServerMockTriggerNamespaceModel {
	mmTriggerNamespaceModel.optional = true
	return mmTriggerNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerNamespaceModel
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest) *mModelPublicServiceServerMockTriggerNamespaceModel {
	if mmTriggerNamespaceModel.mock.funcTriggerNamespaceModel != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by Set")
	}

	if mmTriggerNamespaceModel.defaultExpectation == nil {
		mmTriggerNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceModelExpectation{}
	}

	if mmTriggerNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by ExpectParams functions")
	}

	mmTriggerNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerNamespaceModelParams{ctx, tp1}
	mmTriggerNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerNamespaceModel.expectations {
		if minimock.Equal(e.params, mmTriggerNamespaceModel.defaultExpectation.params) {
			mmTriggerNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerNamespaceModel.defaultExpectation.params)
		}
	}

	return mmTriggerNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerNamespaceModel
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerNamespaceModel {
	if mmTriggerNamespaceModel.mock.funcTriggerNamespaceModel != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by Set")
	}

	if mmTriggerNamespaceModel.defaultExpectation == nil {
		mmTriggerNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceModelExpectation{}
	}

	if mmTriggerNamespaceModel.defaultExpectation.params != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by Expect")
	}

	if mmTriggerNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmTriggerNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerNamespaceModelParamPtrs{}
	}
	mmTriggerNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerNamespaceModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerNamespaceModel
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest) *mModelPublicServiceServerMockTriggerNamespaceModel {
	if mmTriggerNamespaceModel.mock.funcTriggerNamespaceModel != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by Set")
	}

	if mmTriggerNamespaceModel.defaultExpectation == nil {
		mmTriggerNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceModelExpectation{}
	}

	if mmTriggerNamespaceModel.defaultExpectation.params != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by Expect")
	}

	if mmTriggerNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmTriggerNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerNamespaceModelParamPtrs{}
	}
	mmTriggerNamespaceModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerNamespaceModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerNamespaceModel
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest)) *mModelPublicServiceServerMockTriggerNamespaceModel {
	if mmTriggerNamespaceModel.mock.inspectFuncTriggerNamespaceModel != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerNamespaceModel")
	}

	mmTriggerNamespaceModel.mock.inspectFuncTriggerNamespaceModel = f

	return mmTriggerNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerNamespaceModel
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) Return(tp2 *mm_modelv1alpha.TriggerNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceModel.mock.funcTriggerNamespaceModel != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by Set")
	}

	if mmTriggerNamespaceModel.defaultExpectation == nil {
		mmTriggerNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceModelExpectation{mock: mmTriggerNamespaceModel.mock}
	}
	mmTriggerNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerNamespaceModelResults{tp2, err}
	mmTriggerNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerNamespaceModel method
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest) (tp2 *mm_modelv1alpha.TriggerNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceModel.defaultExpectation != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerNamespaceModel method")
	}

	if len(mmTriggerNamespaceModel.expectations) > 0 {
		mmTriggerNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerNamespaceModel method")
	}

	mmTriggerNamespaceModel.mock.funcTriggerNamespaceModel = f
	mmTriggerNamespaceModel.mock.funcTriggerNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest) *ModelPublicServiceServerMockTriggerNamespaceModelExpectation {
	if mmTriggerNamespaceModel.mock.funcTriggerNamespaceModel != nil {
		mmTriggerNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerNamespaceModelExpectation{
		mock:               mmTriggerNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockTriggerNamespaceModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerNamespaceModel.expectations = append(mmTriggerNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerNamespaceModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerNamespaceModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerNamespaceModel should be invoked
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockTriggerNamespaceModel {
	if n == 0 {
		mmTriggerNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerNamespaceModel.expectedInvocations, n)
	mmTriggerNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceModel
}

func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) invocationsDone() bool {
	if len(mmTriggerNamespaceModel.expectations) == 0 && mmTriggerNamespaceModel.defaultExpectation == nil && mmTriggerNamespaceModel.mock.funcTriggerNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceModel.mock.afterTriggerNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerNamespaceModel *ModelPublicServiceServerMock) TriggerNamespaceModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerNamespaceModelRequest) (tp2 *mm_modelv1alpha.TriggerNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerNamespaceModel.beforeTriggerNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerNamespaceModel.afterTriggerNamespaceModelCounter, 1)

	mmTriggerNamespaceModel.t.Helper()

	if mmTriggerNamespaceModel.inspectFuncTriggerNamespaceModel != nil {
		mmTriggerNamespaceModel.inspectFuncTriggerNamespaceModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerNamespaceModelParams{ctx, tp1}

	// Record call args
	mmTriggerNamespaceModel.TriggerNamespaceModelMock.mutex.Lock()
	mmTriggerNamespaceModel.TriggerNamespaceModelMock.callArgs = append(mmTriggerNamespaceModel.TriggerNamespaceModelMock.callArgs, &mm_params)
	mmTriggerNamespaceModel.TriggerNamespaceModelMock.mutex.Unlock()

	for _, e := range mmTriggerNamespaceModel.TriggerNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerNamespaceModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerNamespaceModel.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerNamespaceModel.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerNamespaceModel.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerNamespaceModel.TriggerNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerNamespaceModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerNamespaceModel.funcTriggerNamespaceModel != nil {
		return mmTriggerNamespaceModel.funcTriggerNamespaceModel(ctx, tp1)
	}
	mmTriggerNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerNamespaceModel. %v %v", ctx, tp1)
	return
}

// TriggerNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerNamespaceModel invocations
func (mmTriggerNamespaceModel *ModelPublicServiceServerMock) TriggerNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceModel.afterTriggerNamespaceModelCounter)
}

// TriggerNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerNamespaceModel invocations
func (mmTriggerNamespaceModel *ModelPublicServiceServerMock) TriggerNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceModel.beforeTriggerNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerNamespaceModel *mModelPublicServiceServerMockTriggerNamespaceModel) Calls() []*ModelPublicServiceServerMockTriggerNamespaceModelParams {
	mmTriggerNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerNamespaceModelParams, len(mmTriggerNamespaceModel.callArgs))
	copy(argCopy, mmTriggerNamespaceModel.callArgs)

	mmTriggerNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerNamespaceModelDone returns true if the count of the TriggerNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceModelDone() bool {
	if m.TriggerNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerNamespaceModelMock.invocationsDone()
}

// MinimockTriggerNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceModelInspect() {
	for _, e := range m.TriggerNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterTriggerNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerNamespaceModelMock.defaultExpectation != nil && afterTriggerNamespaceModelCounter < 1 {
		if m.TriggerNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModel at\n%s", m.TriggerNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModel at\n%s with params: %#v", m.TriggerNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerNamespaceModel != nil && afterTriggerNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModel at\n%s", m.funcTriggerNamespaceModelOrigin)
	}

	if !m.TriggerNamespaceModelMock.invocationsDone() && afterTriggerNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerNamespaceModelMock.expectedInvocations), m.TriggerNamespaceModelMock.expectedInvocationsOrigin, afterTriggerNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation
	expectations       []*ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation

	callArgs []*ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams
	paramPtrs          *ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams contains parameters of the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams struct {
	m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParamPtrs struct {
	m1 *mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadResults contains results of the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadResults struct {
	err error
}

// ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectationOrigins struct {
	origin   string
	originM1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) Optional() *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload {
	mmTriggerNamespaceModelBinaryFileUpload.optional = true
	return mmTriggerNamespaceModelBinaryFileUpload
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) Expect(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload {
	if mmTriggerNamespaceModelBinaryFileUpload.mock.funcTriggerNamespaceModelBinaryFileUpload != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation{}
	}

	if mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.paramPtrs != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload mock is already set by ExpectParams functions")
	}

	mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.params = &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams{m1}
	mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerNamespaceModelBinaryFileUpload.expectations {
		if minimock.Equal(e.params, mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.params) {
			mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.params)
		}
	}

	return mmTriggerNamespaceModelBinaryFileUpload
}

// ExpectM1Param1 sets up expected param m1 for ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) ExpectM1Param1(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload {
	if mmTriggerNamespaceModelBinaryFileUpload.mock.funcTriggerNamespaceModelBinaryFileUpload != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation{}
	}

	if mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.params != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload mock is already set by Expect")
	}

	if mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.paramPtrs == nil {
		mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParamPtrs{}
	}
	mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.paramPtrs.m1 = &m1
	mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.expectationOrigins.originM1 = minimock.CallerInfo(1)

	return mmTriggerNamespaceModelBinaryFileUpload
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) Inspect(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer)) *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload {
	if mmTriggerNamespaceModelBinaryFileUpload.mock.inspectFuncTriggerNamespaceModelBinaryFileUpload != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload")
	}

	mmTriggerNamespaceModelBinaryFileUpload.mock.inspectFuncTriggerNamespaceModelBinaryFileUpload = f

	return mmTriggerNamespaceModelBinaryFileUpload
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) Return(err error) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceModelBinaryFileUpload.mock.funcTriggerNamespaceModelBinaryFileUpload != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation{mock: mmTriggerNamespaceModelBinaryFileUpload.mock}
	}
	mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.results = &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadResults{err}
	mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceModelBinaryFileUpload.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload method
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) Set(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer) (err error)) *ModelPublicServiceServerMock {
	if mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload method")
	}

	if len(mmTriggerNamespaceModelBinaryFileUpload.expectations) > 0 {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload method")
	}

	mmTriggerNamespaceModelBinaryFileUpload.mock.funcTriggerNamespaceModelBinaryFileUpload = f
	mmTriggerNamespaceModelBinaryFileUpload.mock.funcTriggerNamespaceModelBinaryFileUploadOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceModelBinaryFileUpload.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload which will trigger the result defined by the following
// Then helper
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) When(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer) *ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation {
	if mmTriggerNamespaceModelBinaryFileUpload.mock.funcTriggerNamespaceModelBinaryFileUpload != nil {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation{
		mock:               mmTriggerNamespaceModelBinaryFileUpload.mock,
		params:             &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams{m1},
		expectationOrigins: ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerNamespaceModelBinaryFileUpload.expectations = append(mmTriggerNamespaceModelBinaryFileUpload.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadExpectation) Then(err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadResults{err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerNamespaceModelBinaryFileUpload should be invoked
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) Times(n uint64) *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload {
	if n == 0 {
		mmTriggerNamespaceModelBinaryFileUpload.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerNamespaceModelBinaryFileUpload.expectedInvocations, n)
	mmTriggerNamespaceModelBinaryFileUpload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerNamespaceModelBinaryFileUpload
}

func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) invocationsDone() bool {
	if len(mmTriggerNamespaceModelBinaryFileUpload.expectations) == 0 && mmTriggerNamespaceModelBinaryFileUpload.defaultExpectation == nil && mmTriggerNamespaceModelBinaryFileUpload.mock.funcTriggerNamespaceModelBinaryFileUpload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceModelBinaryFileUpload.mock.afterTriggerNamespaceModelBinaryFileUploadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerNamespaceModelBinaryFileUpload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerNamespaceModelBinaryFileUpload implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerNamespaceModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerNamespaceModelBinaryFileUpload(m1 mm_modelv1alpha.ModelPublicService_TriggerNamespaceModelBinaryFileUploadServer) (err error) {
	mm_atomic.AddUint64(&mmTriggerNamespaceModelBinaryFileUpload.beforeTriggerNamespaceModelBinaryFileUploadCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerNamespaceModelBinaryFileUpload.afterTriggerNamespaceModelBinaryFileUploadCounter, 1)

	mmTriggerNamespaceModelBinaryFileUpload.t.Helper()

	if mmTriggerNamespaceModelBinaryFileUpload.inspectFuncTriggerNamespaceModelBinaryFileUpload != nil {
		mmTriggerNamespaceModelBinaryFileUpload.inspectFuncTriggerNamespaceModelBinaryFileUpload(m1)
	}

	mm_params := ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams{m1}

	// Record call args
	mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.mutex.Lock()
	mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.callArgs = append(mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.callArgs, &mm_params)
	mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.mutex.Unlock()

	for _, e := range mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams{m1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.m1 != nil && !minimock.Equal(*mm_want_ptrs.m1, mm_got.m1) {
				mmTriggerNamespaceModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload got unexpected parameter m1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.originM1, *mm_want_ptrs.m1, mm_got.m1, minimock.Diff(*mm_want_ptrs.m1, mm_got.m1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerNamespaceModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerNamespaceModelBinaryFileUpload.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerNamespaceModelBinaryFileUpload.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload")
		}
		return (*mm_results).err
	}
	if mmTriggerNamespaceModelBinaryFileUpload.funcTriggerNamespaceModelBinaryFileUpload != nil {
		return mmTriggerNamespaceModelBinaryFileUpload.funcTriggerNamespaceModelBinaryFileUpload(m1)
	}
	mmTriggerNamespaceModelBinaryFileUpload.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload. %v", m1)
	return
}

// TriggerNamespaceModelBinaryFileUploadAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload invocations
func (mmTriggerNamespaceModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerNamespaceModelBinaryFileUploadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceModelBinaryFileUpload.afterTriggerNamespaceModelBinaryFileUploadCounter)
}

// TriggerNamespaceModelBinaryFileUploadBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload invocations
func (mmTriggerNamespaceModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerNamespaceModelBinaryFileUploadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerNamespaceModelBinaryFileUpload.beforeTriggerNamespaceModelBinaryFileUploadCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerNamespaceModelBinaryFileUpload *mModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUpload) Calls() []*ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams {
	mmTriggerNamespaceModelBinaryFileUpload.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerNamespaceModelBinaryFileUploadParams, len(mmTriggerNamespaceModelBinaryFileUpload.callArgs))
	copy(argCopy, mmTriggerNamespaceModelBinaryFileUpload.callArgs)

	mmTriggerNamespaceModelBinaryFileUpload.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerNamespaceModelBinaryFileUploadDone returns true if the count of the TriggerNamespaceModelBinaryFileUpload invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceModelBinaryFileUploadDone() bool {
	if m.TriggerNamespaceModelBinaryFileUploadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerNamespaceModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerNamespaceModelBinaryFileUploadMock.invocationsDone()
}

// MinimockTriggerNamespaceModelBinaryFileUploadInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerNamespaceModelBinaryFileUploadInspect() {
	for _, e := range m.TriggerNamespaceModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerNamespaceModelBinaryFileUploadCounter := mm_atomic.LoadUint64(&m.afterTriggerNamespaceModelBinaryFileUploadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation != nil && afterTriggerNamespaceModelBinaryFileUploadCounter < 1 {
		if m.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload at\n%s", m.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload at\n%s with params: %#v", m.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *m.TriggerNamespaceModelBinaryFileUploadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerNamespaceModelBinaryFileUpload != nil && afterTriggerNamespaceModelBinaryFileUploadCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload at\n%s", m.funcTriggerNamespaceModelBinaryFileUploadOrigin)
	}

	if !m.TriggerNamespaceModelBinaryFileUploadMock.invocationsDone() && afterTriggerNamespaceModelBinaryFileUploadCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerNamespaceModelBinaryFileUpload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerNamespaceModelBinaryFileUploadMock.expectedInvocations), m.TriggerNamespaceModelBinaryFileUploadMock.expectedInvocationsOrigin, afterTriggerNamespaceModelBinaryFileUploadCounter)
	}
}

type mModelPublicServiceServerMockTriggerOrganizationLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerOrganizationLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerOrganizationLatestModel
type ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerOrganizationLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerOrganizationLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerOrganizationLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerOrganizationLatestModelParams contains parameters of the ModelPublicServiceServer.TriggerOrganizationLatestModel
type ModelPublicServiceServerMockTriggerOrganizationLatestModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest
}

// ModelPublicServiceServerMockTriggerOrganizationLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerOrganizationLatestModel
type ModelPublicServiceServerMockTriggerOrganizationLatestModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerOrganizationLatestModelRequest
}

// ModelPublicServiceServerMockTriggerOrganizationLatestModelResults contains results of the ModelPublicServiceServer.TriggerOrganizationLatestModel
type ModelPublicServiceServerMockTriggerOrganizationLatestModelResults struct {
	tp2 *mm_modelv1alpha.TriggerOrganizationLatestModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerOrganizationLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerOrganizationLatestModel
type ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) Optional() *mModelPublicServiceServerMockTriggerOrganizationLatestModel {
	mmTriggerOrganizationLatestModel.optional = true
	return mmTriggerOrganizationLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerOrganizationLatestModel
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest) *mModelPublicServiceServerMockTriggerOrganizationLatestModel {
	if mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModel != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation{}
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation.paramPtrs != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by ExpectParams functions")
	}

	mmTriggerOrganizationLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerOrganizationLatestModelParams{ctx, tp1}
	mmTriggerOrganizationLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerOrganizationLatestModel.expectations {
		if minimock.Equal(e.params, mmTriggerOrganizationLatestModel.defaultExpectation.params) {
			mmTriggerOrganizationLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerOrganizationLatestModel.defaultExpectation.params)
		}
	}

	return mmTriggerOrganizationLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerOrganizationLatestModel
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerOrganizationLatestModel {
	if mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModel != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation{}
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation.params != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by Expect")
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerOrganizationLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerOrganizationLatestModelParamPtrs{}
	}
	mmTriggerOrganizationLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerOrganizationLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerOrganizationLatestModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerOrganizationLatestModel
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest) *mModelPublicServiceServerMockTriggerOrganizationLatestModel {
	if mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModel != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation{}
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation.params != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by Expect")
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerOrganizationLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerOrganizationLatestModelParamPtrs{}
	}
	mmTriggerOrganizationLatestModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerOrganizationLatestModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerOrganizationLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerOrganizationLatestModel
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest)) *mModelPublicServiceServerMockTriggerOrganizationLatestModel {
	if mmTriggerOrganizationLatestModel.mock.inspectFuncTriggerOrganizationLatestModel != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerOrganizationLatestModel")
	}

	mmTriggerOrganizationLatestModel.mock.inspectFuncTriggerOrganizationLatestModel = f

	return mmTriggerOrganizationLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerOrganizationLatestModel
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) Return(tp2 *mm_modelv1alpha.TriggerOrganizationLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModel != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by Set")
	}

	if mmTriggerOrganizationLatestModel.defaultExpectation == nil {
		mmTriggerOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation{mock: mmTriggerOrganizationLatestModel.mock}
	}
	mmTriggerOrganizationLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerOrganizationLatestModelResults{tp2, err}
	mmTriggerOrganizationLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerOrganizationLatestModel method
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerOrganizationLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerOrganizationLatestModel.defaultExpectation != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerOrganizationLatestModel method")
	}

	if len(mmTriggerOrganizationLatestModel.expectations) > 0 {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerOrganizationLatestModel method")
	}

	mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModel = f
	mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModelOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerOrganizationLatestModel which will trigger the result defined by the following
// Then helper
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest) *ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation {
	if mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModel != nil {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation{
		mock:               mmTriggerOrganizationLatestModel.mock,
		params:             &ModelPublicServiceServerMockTriggerOrganizationLatestModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerOrganizationLatestModel.expectations = append(mmTriggerOrganizationLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerOrganizationLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerOrganizationLatestModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerOrganizationLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerOrganizationLatestModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerOrganizationLatestModel should be invoked
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) Times(n uint64) *mModelPublicServiceServerMockTriggerOrganizationLatestModel {
	if n == 0 {
		mmTriggerOrganizationLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerOrganizationLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerOrganizationLatestModel.expectedInvocations, n)
	mmTriggerOrganizationLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationLatestModel
}

func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) invocationsDone() bool {
	if len(mmTriggerOrganizationLatestModel.expectations) == 0 && mmTriggerOrganizationLatestModel.defaultExpectation == nil && mmTriggerOrganizationLatestModel.mock.funcTriggerOrganizationLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerOrganizationLatestModel.mock.afterTriggerOrganizationLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerOrganizationLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerOrganizationLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerOrganizationLatestModel *ModelPublicServiceServerMock) TriggerOrganizationLatestModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerOrganizationLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerOrganizationLatestModel.beforeTriggerOrganizationLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerOrganizationLatestModel.afterTriggerOrganizationLatestModelCounter, 1)

	mmTriggerOrganizationLatestModel.t.Helper()

	if mmTriggerOrganizationLatestModel.inspectFuncTriggerOrganizationLatestModel != nil {
		mmTriggerOrganizationLatestModel.inspectFuncTriggerOrganizationLatestModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerOrganizationLatestModelParams{ctx, tp1}

	// Record call args
	mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.mutex.Lock()
	mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.callArgs = append(mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.callArgs, &mm_params)
	mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.mutex.Unlock()

	for _, e := range mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerOrganizationLatestModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerOrganizationLatestModel.TriggerOrganizationLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerOrganizationLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerOrganizationLatestModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerOrganizationLatestModel.funcTriggerOrganizationLatestModel != nil {
		return mmTriggerOrganizationLatestModel.funcTriggerOrganizationLatestModel(ctx, tp1)
	}
	mmTriggerOrganizationLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerOrganizationLatestModel. %v %v", ctx, tp1)
	return
}

// TriggerOrganizationLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerOrganizationLatestModel invocations
func (mmTriggerOrganizationLatestModel *ModelPublicServiceServerMock) TriggerOrganizationLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerOrganizationLatestModel.afterTriggerOrganizationLatestModelCounter)
}

// TriggerOrganizationLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerOrganizationLatestModel invocations
func (mmTriggerOrganizationLatestModel *ModelPublicServiceServerMock) TriggerOrganizationLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerOrganizationLatestModel.beforeTriggerOrganizationLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerOrganizationLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerOrganizationLatestModel *mModelPublicServiceServerMockTriggerOrganizationLatestModel) Calls() []*ModelPublicServiceServerMockTriggerOrganizationLatestModelParams {
	mmTriggerOrganizationLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerOrganizationLatestModelParams, len(mmTriggerOrganizationLatestModel.callArgs))
	copy(argCopy, mmTriggerOrganizationLatestModel.callArgs)

	mmTriggerOrganizationLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerOrganizationLatestModelDone returns true if the count of the TriggerOrganizationLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerOrganizationLatestModelDone() bool {
	if m.TriggerOrganizationLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerOrganizationLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerOrganizationLatestModelMock.invocationsDone()
}

// MinimockTriggerOrganizationLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerOrganizationLatestModelInspect() {
	for _, e := range m.TriggerOrganizationLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerOrganizationLatestModelCounter := mm_atomic.LoadUint64(&m.afterTriggerOrganizationLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerOrganizationLatestModelMock.defaultExpectation != nil && afterTriggerOrganizationLatestModelCounter < 1 {
		if m.TriggerOrganizationLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationLatestModel at\n%s", m.TriggerOrganizationLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationLatestModel at\n%s with params: %#v", m.TriggerOrganizationLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerOrganizationLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerOrganizationLatestModel != nil && afterTriggerOrganizationLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationLatestModel at\n%s", m.funcTriggerOrganizationLatestModelOrigin)
	}

	if !m.TriggerOrganizationLatestModelMock.invocationsDone() && afterTriggerOrganizationLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerOrganizationLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerOrganizationLatestModelMock.expectedInvocations), m.TriggerOrganizationLatestModelMock.expectedInvocationsOrigin, afterTriggerOrganizationLatestModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerOrganizationModel
type ModelPublicServiceServerMockTriggerOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerOrganizationModelParams contains parameters of the ModelPublicServiceServer.TriggerOrganizationModel
type ModelPublicServiceServerMockTriggerOrganizationModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest
}

// ModelPublicServiceServerMockTriggerOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerOrganizationModel
type ModelPublicServiceServerMockTriggerOrganizationModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerOrganizationModelRequest
}

// ModelPublicServiceServerMockTriggerOrganizationModelResults contains results of the ModelPublicServiceServer.TriggerOrganizationModel
type ModelPublicServiceServerMockTriggerOrganizationModelResults struct {
	tp2 *mm_modelv1alpha.TriggerOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerOrganizationModel
type ModelPublicServiceServerMockTriggerOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) Optional() *mModelPublicServiceServerMockTriggerOrganizationModel {
	mmTriggerOrganizationModel.optional = true
	return mmTriggerOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerOrganizationModel
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest) *mModelPublicServiceServerMockTriggerOrganizationModel {
	if mmTriggerOrganizationModel.mock.funcTriggerOrganizationModel != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by Set")
	}

	if mmTriggerOrganizationModel.defaultExpectation == nil {
		mmTriggerOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationModelExpectation{}
	}

	if mmTriggerOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by ExpectParams functions")
	}

	mmTriggerOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerOrganizationModelParams{ctx, tp1}
	mmTriggerOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerOrganizationModel.expectations {
		if minimock.Equal(e.params, mmTriggerOrganizationModel.defaultExpectation.params) {
			mmTriggerOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerOrganizationModel.defaultExpectation.params)
		}
	}

	return mmTriggerOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerOrganizationModel
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerOrganizationModel {
	if mmTriggerOrganizationModel.mock.funcTriggerOrganizationModel != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by Set")
	}

	if mmTriggerOrganizationModel.defaultExpectation == nil {
		mmTriggerOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationModelExpectation{}
	}

	if mmTriggerOrganizationModel.defaultExpectation.params != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by Expect")
	}

	if mmTriggerOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmTriggerOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerOrganizationModelParamPtrs{}
	}
	mmTriggerOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerOrganizationModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerOrganizationModel
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest) *mModelPublicServiceServerMockTriggerOrganizationModel {
	if mmTriggerOrganizationModel.mock.funcTriggerOrganizationModel != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by Set")
	}

	if mmTriggerOrganizationModel.defaultExpectation == nil {
		mmTriggerOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationModelExpectation{}
	}

	if mmTriggerOrganizationModel.defaultExpectation.params != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by Expect")
	}

	if mmTriggerOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmTriggerOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerOrganizationModelParamPtrs{}
	}
	mmTriggerOrganizationModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerOrganizationModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerOrganizationModel
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest)) *mModelPublicServiceServerMockTriggerOrganizationModel {
	if mmTriggerOrganizationModel.mock.inspectFuncTriggerOrganizationModel != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerOrganizationModel")
	}

	mmTriggerOrganizationModel.mock.inspectFuncTriggerOrganizationModel = f

	return mmTriggerOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerOrganizationModel
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) Return(tp2 *mm_modelv1alpha.TriggerOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerOrganizationModel.mock.funcTriggerOrganizationModel != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by Set")
	}

	if mmTriggerOrganizationModel.defaultExpectation == nil {
		mmTriggerOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationModelExpectation{mock: mmTriggerOrganizationModel.mock}
	}
	mmTriggerOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerOrganizationModelResults{tp2, err}
	mmTriggerOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerOrganizationModel method
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest) (tp2 *mm_modelv1alpha.TriggerOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerOrganizationModel.defaultExpectation != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerOrganizationModel method")
	}

	if len(mmTriggerOrganizationModel.expectations) > 0 {
		mmTriggerOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerOrganizationModel method")
	}

	mmTriggerOrganizationModel.mock.funcTriggerOrganizationModel = f
	mmTriggerOrganizationModel.mock.funcTriggerOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest) *ModelPublicServiceServerMockTriggerOrganizationModelExpectation {
	if mmTriggerOrganizationModel.mock.funcTriggerOrganizationModel != nil {
		mmTriggerOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerOrganizationModelExpectation{
		mock:               mmTriggerOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockTriggerOrganizationModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerOrganizationModel.expectations = append(mmTriggerOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerOrganizationModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerOrganizationModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerOrganizationModel should be invoked
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockTriggerOrganizationModel {
	if n == 0 {
		mmTriggerOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerOrganizationModel.expectedInvocations, n)
	mmTriggerOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationModel
}

func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) invocationsDone() bool {
	if len(mmTriggerOrganizationModel.expectations) == 0 && mmTriggerOrganizationModel.defaultExpectation == nil && mmTriggerOrganizationModel.mock.funcTriggerOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerOrganizationModel.mock.afterTriggerOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerOrganizationModel *ModelPublicServiceServerMock) TriggerOrganizationModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerOrganizationModelRequest) (tp2 *mm_modelv1alpha.TriggerOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerOrganizationModel.beforeTriggerOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerOrganizationModel.afterTriggerOrganizationModelCounter, 1)

	mmTriggerOrganizationModel.t.Helper()

	if mmTriggerOrganizationModel.inspectFuncTriggerOrganizationModel != nil {
		mmTriggerOrganizationModel.inspectFuncTriggerOrganizationModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerOrganizationModelParams{ctx, tp1}

	// Record call args
	mmTriggerOrganizationModel.TriggerOrganizationModelMock.mutex.Lock()
	mmTriggerOrganizationModel.TriggerOrganizationModelMock.callArgs = append(mmTriggerOrganizationModel.TriggerOrganizationModelMock.callArgs, &mm_params)
	mmTriggerOrganizationModel.TriggerOrganizationModelMock.mutex.Unlock()

	for _, e := range mmTriggerOrganizationModel.TriggerOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerOrganizationModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerOrganizationModel.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerOrganizationModel.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerOrganizationModel.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerOrganizationModel.TriggerOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerOrganizationModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerOrganizationModel.funcTriggerOrganizationModel != nil {
		return mmTriggerOrganizationModel.funcTriggerOrganizationModel(ctx, tp1)
	}
	mmTriggerOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerOrganizationModel. %v %v", ctx, tp1)
	return
}

// TriggerOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerOrganizationModel invocations
func (mmTriggerOrganizationModel *ModelPublicServiceServerMock) TriggerOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerOrganizationModel.afterTriggerOrganizationModelCounter)
}

// TriggerOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerOrganizationModel invocations
func (mmTriggerOrganizationModel *ModelPublicServiceServerMock) TriggerOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerOrganizationModel.beforeTriggerOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerOrganizationModel *mModelPublicServiceServerMockTriggerOrganizationModel) Calls() []*ModelPublicServiceServerMockTriggerOrganizationModelParams {
	mmTriggerOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerOrganizationModelParams, len(mmTriggerOrganizationModel.callArgs))
	copy(argCopy, mmTriggerOrganizationModel.callArgs)

	mmTriggerOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerOrganizationModelDone returns true if the count of the TriggerOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerOrganizationModelDone() bool {
	if m.TriggerOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerOrganizationModelMock.invocationsDone()
}

// MinimockTriggerOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerOrganizationModelInspect() {
	for _, e := range m.TriggerOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterTriggerOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerOrganizationModelMock.defaultExpectation != nil && afterTriggerOrganizationModelCounter < 1 {
		if m.TriggerOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModel at\n%s", m.TriggerOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModel at\n%s with params: %#v", m.TriggerOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerOrganizationModel != nil && afterTriggerOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModel at\n%s", m.funcTriggerOrganizationModelOrigin)
	}

	if !m.TriggerOrganizationModelMock.invocationsDone() && afterTriggerOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerOrganizationModelMock.expectedInvocations), m.TriggerOrganizationModelMock.expectedInvocationsOrigin, afterTriggerOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation
	expectations       []*ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation

	callArgs []*ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams
	paramPtrs          *ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams contains parameters of the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams struct {
	m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParamPtrs struct {
	m1 *mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadResults contains results of the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadResults struct {
	err error
}

// ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectationOrigins struct {
	origin   string
	originM1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) Optional() *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload {
	mmTriggerOrganizationModelBinaryFileUpload.optional = true
	return mmTriggerOrganizationModelBinaryFileUpload
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) Expect(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload {
	if mmTriggerOrganizationModelBinaryFileUpload.mock.funcTriggerOrganizationModelBinaryFileUpload != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation{}
	}

	if mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.paramPtrs != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload mock is already set by ExpectParams functions")
	}

	mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.params = &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams{m1}
	mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerOrganizationModelBinaryFileUpload.expectations {
		if minimock.Equal(e.params, mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.params) {
			mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.params)
		}
	}

	return mmTriggerOrganizationModelBinaryFileUpload
}

// ExpectM1Param1 sets up expected param m1 for ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) ExpectM1Param1(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload {
	if mmTriggerOrganizationModelBinaryFileUpload.mock.funcTriggerOrganizationModelBinaryFileUpload != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation{}
	}

	if mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.params != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload mock is already set by Expect")
	}

	if mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.paramPtrs == nil {
		mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParamPtrs{}
	}
	mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.paramPtrs.m1 = &m1
	mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.expectationOrigins.originM1 = minimock.CallerInfo(1)

	return mmTriggerOrganizationModelBinaryFileUpload
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) Inspect(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer)) *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload {
	if mmTriggerOrganizationModelBinaryFileUpload.mock.inspectFuncTriggerOrganizationModelBinaryFileUpload != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload")
	}

	mmTriggerOrganizationModelBinaryFileUpload.mock.inspectFuncTriggerOrganizationModelBinaryFileUpload = f

	return mmTriggerOrganizationModelBinaryFileUpload
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) Return(err error) *ModelPublicServiceServerMock {
	if mmTriggerOrganizationModelBinaryFileUpload.mock.funcTriggerOrganizationModelBinaryFileUpload != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation{mock: mmTriggerOrganizationModelBinaryFileUpload.mock}
	}
	mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.results = &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadResults{err}
	mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationModelBinaryFileUpload.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload method
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) Set(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer) (err error)) *ModelPublicServiceServerMock {
	if mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload method")
	}

	if len(mmTriggerOrganizationModelBinaryFileUpload.expectations) > 0 {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload method")
	}

	mmTriggerOrganizationModelBinaryFileUpload.mock.funcTriggerOrganizationModelBinaryFileUpload = f
	mmTriggerOrganizationModelBinaryFileUpload.mock.funcTriggerOrganizationModelBinaryFileUploadOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationModelBinaryFileUpload.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload which will trigger the result defined by the following
// Then helper
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) When(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer) *ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation {
	if mmTriggerOrganizationModelBinaryFileUpload.mock.funcTriggerOrganizationModelBinaryFileUpload != nil {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation{
		mock:               mmTriggerOrganizationModelBinaryFileUpload.mock,
		params:             &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams{m1},
		expectationOrigins: ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerOrganizationModelBinaryFileUpload.expectations = append(mmTriggerOrganizationModelBinaryFileUpload.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadExpectation) Then(err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadResults{err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerOrganizationModelBinaryFileUpload should be invoked
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) Times(n uint64) *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload {
	if n == 0 {
		mmTriggerOrganizationModelBinaryFileUpload.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerOrganizationModelBinaryFileUpload.expectedInvocations, n)
	mmTriggerOrganizationModelBinaryFileUpload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerOrganizationModelBinaryFileUpload
}

func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) invocationsDone() bool {
	if len(mmTriggerOrganizationModelBinaryFileUpload.expectations) == 0 && mmTriggerOrganizationModelBinaryFileUpload.defaultExpectation == nil && mmTriggerOrganizationModelBinaryFileUpload.mock.funcTriggerOrganizationModelBinaryFileUpload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerOrganizationModelBinaryFileUpload.mock.afterTriggerOrganizationModelBinaryFileUploadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerOrganizationModelBinaryFileUpload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerOrganizationModelBinaryFileUpload implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerOrganizationModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerOrganizationModelBinaryFileUpload(m1 mm_modelv1alpha.ModelPublicService_TriggerOrganizationModelBinaryFileUploadServer) (err error) {
	mm_atomic.AddUint64(&mmTriggerOrganizationModelBinaryFileUpload.beforeTriggerOrganizationModelBinaryFileUploadCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerOrganizationModelBinaryFileUpload.afterTriggerOrganizationModelBinaryFileUploadCounter, 1)

	mmTriggerOrganizationModelBinaryFileUpload.t.Helper()

	if mmTriggerOrganizationModelBinaryFileUpload.inspectFuncTriggerOrganizationModelBinaryFileUpload != nil {
		mmTriggerOrganizationModelBinaryFileUpload.inspectFuncTriggerOrganizationModelBinaryFileUpload(m1)
	}

	mm_params := ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams{m1}

	// Record call args
	mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.mutex.Lock()
	mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.callArgs = append(mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.callArgs, &mm_params)
	mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.mutex.Unlock()

	for _, e := range mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams{m1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.m1 != nil && !minimock.Equal(*mm_want_ptrs.m1, mm_got.m1) {
				mmTriggerOrganizationModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload got unexpected parameter m1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.originM1, *mm_want_ptrs.m1, mm_got.m1, minimock.Diff(*mm_want_ptrs.m1, mm_got.m1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerOrganizationModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerOrganizationModelBinaryFileUpload.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerOrganizationModelBinaryFileUpload.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload")
		}
		return (*mm_results).err
	}
	if mmTriggerOrganizationModelBinaryFileUpload.funcTriggerOrganizationModelBinaryFileUpload != nil {
		return mmTriggerOrganizationModelBinaryFileUpload.funcTriggerOrganizationModelBinaryFileUpload(m1)
	}
	mmTriggerOrganizationModelBinaryFileUpload.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload. %v", m1)
	return
}

// TriggerOrganizationModelBinaryFileUploadAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload invocations
func (mmTriggerOrganizationModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerOrganizationModelBinaryFileUploadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerOrganizationModelBinaryFileUpload.afterTriggerOrganizationModelBinaryFileUploadCounter)
}

// TriggerOrganizationModelBinaryFileUploadBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload invocations
func (mmTriggerOrganizationModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerOrganizationModelBinaryFileUploadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerOrganizationModelBinaryFileUpload.beforeTriggerOrganizationModelBinaryFileUploadCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerOrganizationModelBinaryFileUpload *mModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUpload) Calls() []*ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams {
	mmTriggerOrganizationModelBinaryFileUpload.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerOrganizationModelBinaryFileUploadParams, len(mmTriggerOrganizationModelBinaryFileUpload.callArgs))
	copy(argCopy, mmTriggerOrganizationModelBinaryFileUpload.callArgs)

	mmTriggerOrganizationModelBinaryFileUpload.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerOrganizationModelBinaryFileUploadDone returns true if the count of the TriggerOrganizationModelBinaryFileUpload invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerOrganizationModelBinaryFileUploadDone() bool {
	if m.TriggerOrganizationModelBinaryFileUploadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerOrganizationModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerOrganizationModelBinaryFileUploadMock.invocationsDone()
}

// MinimockTriggerOrganizationModelBinaryFileUploadInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerOrganizationModelBinaryFileUploadInspect() {
	for _, e := range m.TriggerOrganizationModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerOrganizationModelBinaryFileUploadCounter := mm_atomic.LoadUint64(&m.afterTriggerOrganizationModelBinaryFileUploadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation != nil && afterTriggerOrganizationModelBinaryFileUploadCounter < 1 {
		if m.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload at\n%s", m.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload at\n%s with params: %#v", m.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *m.TriggerOrganizationModelBinaryFileUploadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerOrganizationModelBinaryFileUpload != nil && afterTriggerOrganizationModelBinaryFileUploadCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload at\n%s", m.funcTriggerOrganizationModelBinaryFileUploadOrigin)
	}

	if !m.TriggerOrganizationModelBinaryFileUploadMock.invocationsDone() && afterTriggerOrganizationModelBinaryFileUploadCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerOrganizationModelBinaryFileUpload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerOrganizationModelBinaryFileUploadMock.expectedInvocations), m.TriggerOrganizationModelBinaryFileUploadMock.expectedInvocationsOrigin, afterTriggerOrganizationModelBinaryFileUploadCounter)
	}
}

type mModelPublicServiceServerMockTriggerUserLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerUserLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerUserLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerUserLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerUserLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerUserLatestModel
type ModelPublicServiceServerMockTriggerUserLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerUserLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerUserLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerUserLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerUserLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerUserLatestModelParams contains parameters of the ModelPublicServiceServer.TriggerUserLatestModel
type ModelPublicServiceServerMockTriggerUserLatestModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest
}

// ModelPublicServiceServerMockTriggerUserLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerUserLatestModel
type ModelPublicServiceServerMockTriggerUserLatestModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerUserLatestModelRequest
}

// ModelPublicServiceServerMockTriggerUserLatestModelResults contains results of the ModelPublicServiceServer.TriggerUserLatestModel
type ModelPublicServiceServerMockTriggerUserLatestModelResults struct {
	tp2 *mm_modelv1alpha.TriggerUserLatestModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerUserLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerUserLatestModel
type ModelPublicServiceServerMockTriggerUserLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) Optional() *mModelPublicServiceServerMockTriggerUserLatestModel {
	mmTriggerUserLatestModel.optional = true
	return mmTriggerUserLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerUserLatestModel
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest) *mModelPublicServiceServerMockTriggerUserLatestModel {
	if mmTriggerUserLatestModel.mock.funcTriggerUserLatestModel != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by Set")
	}

	if mmTriggerUserLatestModel.defaultExpectation == nil {
		mmTriggerUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserLatestModelExpectation{}
	}

	if mmTriggerUserLatestModel.defaultExpectation.paramPtrs != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by ExpectParams functions")
	}

	mmTriggerUserLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerUserLatestModelParams{ctx, tp1}
	mmTriggerUserLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerUserLatestModel.expectations {
		if minimock.Equal(e.params, mmTriggerUserLatestModel.defaultExpectation.params) {
			mmTriggerUserLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerUserLatestModel.defaultExpectation.params)
		}
	}

	return mmTriggerUserLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerUserLatestModel
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerUserLatestModel {
	if mmTriggerUserLatestModel.mock.funcTriggerUserLatestModel != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by Set")
	}

	if mmTriggerUserLatestModel.defaultExpectation == nil {
		mmTriggerUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserLatestModelExpectation{}
	}

	if mmTriggerUserLatestModel.defaultExpectation.params != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by Expect")
	}

	if mmTriggerUserLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerUserLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerUserLatestModelParamPtrs{}
	}
	mmTriggerUserLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerUserLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerUserLatestModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerUserLatestModel
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest) *mModelPublicServiceServerMockTriggerUserLatestModel {
	if mmTriggerUserLatestModel.mock.funcTriggerUserLatestModel != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by Set")
	}

	if mmTriggerUserLatestModel.defaultExpectation == nil {
		mmTriggerUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserLatestModelExpectation{}
	}

	if mmTriggerUserLatestModel.defaultExpectation.params != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by Expect")
	}

	if mmTriggerUserLatestModel.defaultExpectation.paramPtrs == nil {
		mmTriggerUserLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerUserLatestModelParamPtrs{}
	}
	mmTriggerUserLatestModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerUserLatestModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerUserLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerUserLatestModel
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest)) *mModelPublicServiceServerMockTriggerUserLatestModel {
	if mmTriggerUserLatestModel.mock.inspectFuncTriggerUserLatestModel != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerUserLatestModel")
	}

	mmTriggerUserLatestModel.mock.inspectFuncTriggerUserLatestModel = f

	return mmTriggerUserLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerUserLatestModel
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) Return(tp2 *mm_modelv1alpha.TriggerUserLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerUserLatestModel.mock.funcTriggerUserLatestModel != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by Set")
	}

	if mmTriggerUserLatestModel.defaultExpectation == nil {
		mmTriggerUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserLatestModelExpectation{mock: mmTriggerUserLatestModel.mock}
	}
	mmTriggerUserLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerUserLatestModelResults{tp2, err}
	mmTriggerUserLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerUserLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerUserLatestModel method
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerUserLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerUserLatestModel.defaultExpectation != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerUserLatestModel method")
	}

	if len(mmTriggerUserLatestModel.expectations) > 0 {
		mmTriggerUserLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerUserLatestModel method")
	}

	mmTriggerUserLatestModel.mock.funcTriggerUserLatestModel = f
	mmTriggerUserLatestModel.mock.funcTriggerUserLatestModelOrigin = minimock.CallerInfo(1)
	return mmTriggerUserLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerUserLatestModel which will trigger the result defined by the following
// Then helper
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest) *ModelPublicServiceServerMockTriggerUserLatestModelExpectation {
	if mmTriggerUserLatestModel.mock.funcTriggerUserLatestModel != nil {
		mmTriggerUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerUserLatestModelExpectation{
		mock:               mmTriggerUserLatestModel.mock,
		params:             &ModelPublicServiceServerMockTriggerUserLatestModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerUserLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerUserLatestModel.expectations = append(mmTriggerUserLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerUserLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerUserLatestModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerUserLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerUserLatestModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerUserLatestModel should be invoked
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) Times(n uint64) *mModelPublicServiceServerMockTriggerUserLatestModel {
	if n == 0 {
		mmTriggerUserLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerUserLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerUserLatestModel.expectedInvocations, n)
	mmTriggerUserLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerUserLatestModel
}

func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) invocationsDone() bool {
	if len(mmTriggerUserLatestModel.expectations) == 0 && mmTriggerUserLatestModel.defaultExpectation == nil && mmTriggerUserLatestModel.mock.funcTriggerUserLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerUserLatestModel.mock.afterTriggerUserLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerUserLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerUserLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerUserLatestModel *ModelPublicServiceServerMock) TriggerUserLatestModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserLatestModelRequest) (tp2 *mm_modelv1alpha.TriggerUserLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerUserLatestModel.beforeTriggerUserLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerUserLatestModel.afterTriggerUserLatestModelCounter, 1)

	mmTriggerUserLatestModel.t.Helper()

	if mmTriggerUserLatestModel.inspectFuncTriggerUserLatestModel != nil {
		mmTriggerUserLatestModel.inspectFuncTriggerUserLatestModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerUserLatestModelParams{ctx, tp1}

	// Record call args
	mmTriggerUserLatestModel.TriggerUserLatestModelMock.mutex.Lock()
	mmTriggerUserLatestModel.TriggerUserLatestModelMock.callArgs = append(mmTriggerUserLatestModel.TriggerUserLatestModelMock.callArgs, &mm_params)
	mmTriggerUserLatestModel.TriggerUserLatestModelMock.mutex.Unlock()

	for _, e := range mmTriggerUserLatestModel.TriggerUserLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerUserLatestModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerUserLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerUserLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerUserLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerUserLatestModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerUserLatestModel.t.Errorf("ModelPublicServiceServerMock.TriggerUserLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerUserLatestModel.TriggerUserLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerUserLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerUserLatestModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerUserLatestModel.funcTriggerUserLatestModel != nil {
		return mmTriggerUserLatestModel.funcTriggerUserLatestModel(ctx, tp1)
	}
	mmTriggerUserLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerUserLatestModel. %v %v", ctx, tp1)
	return
}

// TriggerUserLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerUserLatestModel invocations
func (mmTriggerUserLatestModel *ModelPublicServiceServerMock) TriggerUserLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerUserLatestModel.afterTriggerUserLatestModelCounter)
}

// TriggerUserLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerUserLatestModel invocations
func (mmTriggerUserLatestModel *ModelPublicServiceServerMock) TriggerUserLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerUserLatestModel.beforeTriggerUserLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerUserLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerUserLatestModel *mModelPublicServiceServerMockTriggerUserLatestModel) Calls() []*ModelPublicServiceServerMockTriggerUserLatestModelParams {
	mmTriggerUserLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerUserLatestModelParams, len(mmTriggerUserLatestModel.callArgs))
	copy(argCopy, mmTriggerUserLatestModel.callArgs)

	mmTriggerUserLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerUserLatestModelDone returns true if the count of the TriggerUserLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerUserLatestModelDone() bool {
	if m.TriggerUserLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerUserLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerUserLatestModelMock.invocationsDone()
}

// MinimockTriggerUserLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerUserLatestModelInspect() {
	for _, e := range m.TriggerUserLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerUserLatestModelCounter := mm_atomic.LoadUint64(&m.afterTriggerUserLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerUserLatestModelMock.defaultExpectation != nil && afterTriggerUserLatestModelCounter < 1 {
		if m.TriggerUserLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserLatestModel at\n%s", m.TriggerUserLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserLatestModel at\n%s with params: %#v", m.TriggerUserLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerUserLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerUserLatestModel != nil && afterTriggerUserLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserLatestModel at\n%s", m.funcTriggerUserLatestModelOrigin)
	}

	if !m.TriggerUserLatestModelMock.invocationsDone() && afterTriggerUserLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerUserLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerUserLatestModelMock.expectedInvocations), m.TriggerUserLatestModelMock.expectedInvocationsOrigin, afterTriggerUserLatestModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerUserModelExpectation
	expectations       []*ModelPublicServiceServerMockTriggerUserModelExpectation

	callArgs []*ModelPublicServiceServerMockTriggerUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerUserModel
type ModelPublicServiceServerMockTriggerUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerUserModelParams
	paramPtrs          *ModelPublicServiceServerMockTriggerUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerUserModelParams contains parameters of the ModelPublicServiceServer.TriggerUserModel
type ModelPublicServiceServerMockTriggerUserModelParams struct {
	ctx context.Context
	tp1 *mm_modelv1alpha.TriggerUserModelRequest
}

// ModelPublicServiceServerMockTriggerUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerUserModel
type ModelPublicServiceServerMockTriggerUserModelParamPtrs struct {
	ctx *context.Context
	tp1 **mm_modelv1alpha.TriggerUserModelRequest
}

// ModelPublicServiceServerMockTriggerUserModelResults contains results of the ModelPublicServiceServer.TriggerUserModel
type ModelPublicServiceServerMockTriggerUserModelResults struct {
	tp2 *mm_modelv1alpha.TriggerUserModelResponse
	err error
}

// ModelPublicServiceServerMockTriggerUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerUserModel
type ModelPublicServiceServerMockTriggerUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originTp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) Optional() *mModelPublicServiceServerMockTriggerUserModel {
	mmTriggerUserModel.optional = true
	return mmTriggerUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerUserModel
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) Expect(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserModelRequest) *mModelPublicServiceServerMockTriggerUserModel {
	if mmTriggerUserModel.mock.funcTriggerUserModel != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by Set")
	}

	if mmTriggerUserModel.defaultExpectation == nil {
		mmTriggerUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserModelExpectation{}
	}

	if mmTriggerUserModel.defaultExpectation.paramPtrs != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by ExpectParams functions")
	}

	mmTriggerUserModel.defaultExpectation.params = &ModelPublicServiceServerMockTriggerUserModelParams{ctx, tp1}
	mmTriggerUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerUserModel.expectations {
		if minimock.Equal(e.params, mmTriggerUserModel.defaultExpectation.params) {
			mmTriggerUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerUserModel.defaultExpectation.params)
		}
	}

	return mmTriggerUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.TriggerUserModel
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockTriggerUserModel {
	if mmTriggerUserModel.mock.funcTriggerUserModel != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by Set")
	}

	if mmTriggerUserModel.defaultExpectation == nil {
		mmTriggerUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserModelExpectation{}
	}

	if mmTriggerUserModel.defaultExpectation.params != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by Expect")
	}

	if mmTriggerUserModel.defaultExpectation.paramPtrs == nil {
		mmTriggerUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerUserModelParamPtrs{}
	}
	mmTriggerUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmTriggerUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTriggerUserModel
}

// ExpectTp1Param2 sets up expected param tp1 for ModelPublicServiceServer.TriggerUserModel
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) ExpectTp1Param2(tp1 *mm_modelv1alpha.TriggerUserModelRequest) *mModelPublicServiceServerMockTriggerUserModel {
	if mmTriggerUserModel.mock.funcTriggerUserModel != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by Set")
	}

	if mmTriggerUserModel.defaultExpectation == nil {
		mmTriggerUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserModelExpectation{}
	}

	if mmTriggerUserModel.defaultExpectation.params != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by Expect")
	}

	if mmTriggerUserModel.defaultExpectation.paramPtrs == nil {
		mmTriggerUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerUserModelParamPtrs{}
	}
	mmTriggerUserModel.defaultExpectation.paramPtrs.tp1 = &tp1
	mmTriggerUserModel.defaultExpectation.expectationOrigins.originTp1 = minimock.CallerInfo(1)

	return mmTriggerUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerUserModel
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) Inspect(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserModelRequest)) *mModelPublicServiceServerMockTriggerUserModel {
	if mmTriggerUserModel.mock.inspectFuncTriggerUserModel != nil {
		mmTriggerUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerUserModel")
	}

	mmTriggerUserModel.mock.inspectFuncTriggerUserModel = f

	return mmTriggerUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerUserModel
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) Return(tp2 *mm_modelv1alpha.TriggerUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmTriggerUserModel.mock.funcTriggerUserModel != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by Set")
	}

	if mmTriggerUserModel.defaultExpectation == nil {
		mmTriggerUserModel.defaultExpectation = &ModelPublicServiceServerMockTriggerUserModelExpectation{mock: mmTriggerUserModel.mock}
	}
	mmTriggerUserModel.defaultExpectation.results = &ModelPublicServiceServerMockTriggerUserModelResults{tp2, err}
	mmTriggerUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerUserModel method
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) Set(f func(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserModelRequest) (tp2 *mm_modelv1alpha.TriggerUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmTriggerUserModel.defaultExpectation != nil {
		mmTriggerUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerUserModel method")
	}

	if len(mmTriggerUserModel.expectations) > 0 {
		mmTriggerUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerUserModel method")
	}

	mmTriggerUserModel.mock.funcTriggerUserModel = f
	mmTriggerUserModel.mock.funcTriggerUserModelOrigin = minimock.CallerInfo(1)
	return mmTriggerUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerUserModel which will trigger the result defined by the following
// Then helper
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) When(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserModelRequest) *ModelPublicServiceServerMockTriggerUserModelExpectation {
	if mmTriggerUserModel.mock.funcTriggerUserModel != nil {
		mmTriggerUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerUserModelExpectation{
		mock:               mmTriggerUserModel.mock,
		params:             &ModelPublicServiceServerMockTriggerUserModelParams{ctx, tp1},
		expectationOrigins: ModelPublicServiceServerMockTriggerUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerUserModel.expectations = append(mmTriggerUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerUserModelExpectation) Then(tp2 *mm_modelv1alpha.TriggerUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerUserModelResults{tp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerUserModel should be invoked
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) Times(n uint64) *mModelPublicServiceServerMockTriggerUserModel {
	if n == 0 {
		mmTriggerUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerUserModel.expectedInvocations, n)
	mmTriggerUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerUserModel
}

func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) invocationsDone() bool {
	if len(mmTriggerUserModel.expectations) == 0 && mmTriggerUserModel.defaultExpectation == nil && mmTriggerUserModel.mock.funcTriggerUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerUserModel.mock.afterTriggerUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerUserModel *ModelPublicServiceServerMock) TriggerUserModel(ctx context.Context, tp1 *mm_modelv1alpha.TriggerUserModelRequest) (tp2 *mm_modelv1alpha.TriggerUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmTriggerUserModel.beforeTriggerUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerUserModel.afterTriggerUserModelCounter, 1)

	mmTriggerUserModel.t.Helper()

	if mmTriggerUserModel.inspectFuncTriggerUserModel != nil {
		mmTriggerUserModel.inspectFuncTriggerUserModel(ctx, tp1)
	}

	mm_params := ModelPublicServiceServerMockTriggerUserModelParams{ctx, tp1}

	// Record call args
	mmTriggerUserModel.TriggerUserModelMock.mutex.Lock()
	mmTriggerUserModel.TriggerUserModelMock.callArgs = append(mmTriggerUserModel.TriggerUserModelMock.callArgs, &mm_params)
	mmTriggerUserModel.TriggerUserModelMock.mutex.Unlock()

	for _, e := range mmTriggerUserModel.TriggerUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp2, e.results.err
		}
	}

	if mmTriggerUserModel.TriggerUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerUserModel.TriggerUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerUserModel.TriggerUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerUserModel.TriggerUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerUserModelParams{ctx, tp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTriggerUserModel.t.Errorf("ModelPublicServiceServerMock.TriggerUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerUserModel.TriggerUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tp1 != nil && !minimock.Equal(*mm_want_ptrs.tp1, mm_got.tp1) {
				mmTriggerUserModel.t.Errorf("ModelPublicServiceServerMock.TriggerUserModel got unexpected parameter tp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerUserModel.TriggerUserModelMock.defaultExpectation.expectationOrigins.originTp1, *mm_want_ptrs.tp1, mm_got.tp1, minimock.Diff(*mm_want_ptrs.tp1, mm_got.tp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerUserModel.t.Errorf("ModelPublicServiceServerMock.TriggerUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerUserModel.TriggerUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerUserModel.TriggerUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerUserModel")
		}
		return (*mm_results).tp2, (*mm_results).err
	}
	if mmTriggerUserModel.funcTriggerUserModel != nil {
		return mmTriggerUserModel.funcTriggerUserModel(ctx, tp1)
	}
	mmTriggerUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerUserModel. %v %v", ctx, tp1)
	return
}

// TriggerUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerUserModel invocations
func (mmTriggerUserModel *ModelPublicServiceServerMock) TriggerUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerUserModel.afterTriggerUserModelCounter)
}

// TriggerUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerUserModel invocations
func (mmTriggerUserModel *ModelPublicServiceServerMock) TriggerUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerUserModel.beforeTriggerUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerUserModel *mModelPublicServiceServerMockTriggerUserModel) Calls() []*ModelPublicServiceServerMockTriggerUserModelParams {
	mmTriggerUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerUserModelParams, len(mmTriggerUserModel.callArgs))
	copy(argCopy, mmTriggerUserModel.callArgs)

	mmTriggerUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerUserModelDone returns true if the count of the TriggerUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerUserModelDone() bool {
	if m.TriggerUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerUserModelMock.invocationsDone()
}

// MinimockTriggerUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerUserModelInspect() {
	for _, e := range m.TriggerUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerUserModelCounter := mm_atomic.LoadUint64(&m.afterTriggerUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerUserModelMock.defaultExpectation != nil && afterTriggerUserModelCounter < 1 {
		if m.TriggerUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModel at\n%s", m.TriggerUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModel at\n%s with params: %#v", m.TriggerUserModelMock.defaultExpectation.expectationOrigins.origin, *m.TriggerUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerUserModel != nil && afterTriggerUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModel at\n%s", m.funcTriggerUserModelOrigin)
	}

	if !m.TriggerUserModelMock.invocationsDone() && afterTriggerUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerUserModelMock.expectedInvocations), m.TriggerUserModelMock.expectedInvocationsOrigin, afterTriggerUserModelCounter)
	}
}

type mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation
	expectations       []*ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation

	callArgs []*ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation specifies expectation struct of the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams
	paramPtrs          *ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParamPtrs
	expectationOrigins ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectationOrigins
	results            *ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams contains parameters of the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams struct {
	m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParamPtrs contains pointers to parameters of the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParamPtrs struct {
	m1 *mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer
}

// ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadResults contains results of the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadResults struct {
	err error
}

// ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadOrigins contains origins of expectations of the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
type ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectationOrigins struct {
	origin   string
	originM1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) Optional() *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload {
	mmTriggerUserModelBinaryFileUpload.optional = true
	return mmTriggerUserModelBinaryFileUpload
}

// Expect sets up expected params for ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) Expect(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload {
	if mmTriggerUserModelBinaryFileUpload.mock.funcTriggerUserModelBinaryFileUpload != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerUserModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerUserModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation{}
	}

	if mmTriggerUserModelBinaryFileUpload.defaultExpectation.paramPtrs != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload mock is already set by ExpectParams functions")
	}

	mmTriggerUserModelBinaryFileUpload.defaultExpectation.params = &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams{m1}
	mmTriggerUserModelBinaryFileUpload.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTriggerUserModelBinaryFileUpload.expectations {
		if minimock.Equal(e.params, mmTriggerUserModelBinaryFileUpload.defaultExpectation.params) {
			mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTriggerUserModelBinaryFileUpload.defaultExpectation.params)
		}
	}

	return mmTriggerUserModelBinaryFileUpload
}

// ExpectM1Param1 sets up expected param m1 for ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) ExpectM1Param1(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer) *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload {
	if mmTriggerUserModelBinaryFileUpload.mock.funcTriggerUserModelBinaryFileUpload != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerUserModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerUserModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation{}
	}

	if mmTriggerUserModelBinaryFileUpload.defaultExpectation.params != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload mock is already set by Expect")
	}

	if mmTriggerUserModelBinaryFileUpload.defaultExpectation.paramPtrs == nil {
		mmTriggerUserModelBinaryFileUpload.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParamPtrs{}
	}
	mmTriggerUserModelBinaryFileUpload.defaultExpectation.paramPtrs.m1 = &m1
	mmTriggerUserModelBinaryFileUpload.defaultExpectation.expectationOrigins.originM1 = minimock.CallerInfo(1)

	return mmTriggerUserModelBinaryFileUpload
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) Inspect(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer)) *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload {
	if mmTriggerUserModelBinaryFileUpload.mock.inspectFuncTriggerUserModelBinaryFileUpload != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload")
	}

	mmTriggerUserModelBinaryFileUpload.mock.inspectFuncTriggerUserModelBinaryFileUpload = f

	return mmTriggerUserModelBinaryFileUpload
}

// Return sets up results that will be returned by ModelPublicServiceServer.TriggerUserModelBinaryFileUpload
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) Return(err error) *ModelPublicServiceServerMock {
	if mmTriggerUserModelBinaryFileUpload.mock.funcTriggerUserModelBinaryFileUpload != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload mock is already set by Set")
	}

	if mmTriggerUserModelBinaryFileUpload.defaultExpectation == nil {
		mmTriggerUserModelBinaryFileUpload.defaultExpectation = &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation{mock: mmTriggerUserModelBinaryFileUpload.mock}
	}
	mmTriggerUserModelBinaryFileUpload.defaultExpectation.results = &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadResults{err}
	mmTriggerUserModelBinaryFileUpload.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTriggerUserModelBinaryFileUpload.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload method
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) Set(f func(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer) (err error)) *ModelPublicServiceServerMock {
	if mmTriggerUserModelBinaryFileUpload.defaultExpectation != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload method")
	}

	if len(mmTriggerUserModelBinaryFileUpload.expectations) > 0 {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload method")
	}

	mmTriggerUserModelBinaryFileUpload.mock.funcTriggerUserModelBinaryFileUpload = f
	mmTriggerUserModelBinaryFileUpload.mock.funcTriggerUserModelBinaryFileUploadOrigin = minimock.CallerInfo(1)
	return mmTriggerUserModelBinaryFileUpload.mock
}

// When sets expectation for the ModelPublicServiceServer.TriggerUserModelBinaryFileUpload which will trigger the result defined by the following
// Then helper
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) When(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer) *ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation {
	if mmTriggerUserModelBinaryFileUpload.mock.funcTriggerUserModelBinaryFileUpload != nil {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation{
		mock:               mmTriggerUserModelBinaryFileUpload.mock,
		params:             &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams{m1},
		expectationOrigins: ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTriggerUserModelBinaryFileUpload.expectations = append(mmTriggerUserModelBinaryFileUpload.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.TriggerUserModelBinaryFileUpload return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadExpectation) Then(err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadResults{err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.TriggerUserModelBinaryFileUpload should be invoked
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) Times(n uint64) *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload {
	if n == 0 {
		mmTriggerUserModelBinaryFileUpload.mock.t.Fatalf("Times of ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTriggerUserModelBinaryFileUpload.expectedInvocations, n)
	mmTriggerUserModelBinaryFileUpload.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTriggerUserModelBinaryFileUpload
}

func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) invocationsDone() bool {
	if len(mmTriggerUserModelBinaryFileUpload.expectations) == 0 && mmTriggerUserModelBinaryFileUpload.defaultExpectation == nil && mmTriggerUserModelBinaryFileUpload.mock.funcTriggerUserModelBinaryFileUpload == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTriggerUserModelBinaryFileUpload.mock.afterTriggerUserModelBinaryFileUploadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTriggerUserModelBinaryFileUpload.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TriggerUserModelBinaryFileUpload implements mm_modelv1alpha.ModelPublicServiceServer
func (mmTriggerUserModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerUserModelBinaryFileUpload(m1 mm_modelv1alpha.ModelPublicService_TriggerUserModelBinaryFileUploadServer) (err error) {
	mm_atomic.AddUint64(&mmTriggerUserModelBinaryFileUpload.beforeTriggerUserModelBinaryFileUploadCounter, 1)
	defer mm_atomic.AddUint64(&mmTriggerUserModelBinaryFileUpload.afterTriggerUserModelBinaryFileUploadCounter, 1)

	mmTriggerUserModelBinaryFileUpload.t.Helper()

	if mmTriggerUserModelBinaryFileUpload.inspectFuncTriggerUserModelBinaryFileUpload != nil {
		mmTriggerUserModelBinaryFileUpload.inspectFuncTriggerUserModelBinaryFileUpload(m1)
	}

	mm_params := ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams{m1}

	// Record call args
	mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.mutex.Lock()
	mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.callArgs = append(mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.callArgs, &mm_params)
	mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.mutex.Unlock()

	for _, e := range mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.defaultExpectation.Counter, 1)
		mm_want := mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.defaultExpectation.params
		mm_want_ptrs := mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams{m1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.m1 != nil && !minimock.Equal(*mm_want_ptrs.m1, mm_got.m1) {
				mmTriggerUserModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload got unexpected parameter m1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.originM1, *mm_want_ptrs.m1, mm_got.m1, minimock.Diff(*mm_want_ptrs.m1, mm_got.m1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTriggerUserModelBinaryFileUpload.t.Errorf("ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTriggerUserModelBinaryFileUpload.TriggerUserModelBinaryFileUploadMock.defaultExpectation.results
		if mm_results == nil {
			mmTriggerUserModelBinaryFileUpload.t.Fatal("No results are set for the ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload")
		}
		return (*mm_results).err
	}
	if mmTriggerUserModelBinaryFileUpload.funcTriggerUserModelBinaryFileUpload != nil {
		return mmTriggerUserModelBinaryFileUpload.funcTriggerUserModelBinaryFileUpload(m1)
	}
	mmTriggerUserModelBinaryFileUpload.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload. %v", m1)
	return
}

// TriggerUserModelBinaryFileUploadAfterCounter returns a count of finished ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload invocations
func (mmTriggerUserModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerUserModelBinaryFileUploadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerUserModelBinaryFileUpload.afterTriggerUserModelBinaryFileUploadCounter)
}

// TriggerUserModelBinaryFileUploadBeforeCounter returns a count of ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload invocations
func (mmTriggerUserModelBinaryFileUpload *ModelPublicServiceServerMock) TriggerUserModelBinaryFileUploadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTriggerUserModelBinaryFileUpload.beforeTriggerUserModelBinaryFileUploadCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTriggerUserModelBinaryFileUpload *mModelPublicServiceServerMockTriggerUserModelBinaryFileUpload) Calls() []*ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams {
	mmTriggerUserModelBinaryFileUpload.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockTriggerUserModelBinaryFileUploadParams, len(mmTriggerUserModelBinaryFileUpload.callArgs))
	copy(argCopy, mmTriggerUserModelBinaryFileUpload.callArgs)

	mmTriggerUserModelBinaryFileUpload.mutex.RUnlock()

	return argCopy
}

// MinimockTriggerUserModelBinaryFileUploadDone returns true if the count of the TriggerUserModelBinaryFileUpload invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockTriggerUserModelBinaryFileUploadDone() bool {
	if m.TriggerUserModelBinaryFileUploadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TriggerUserModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TriggerUserModelBinaryFileUploadMock.invocationsDone()
}

// MinimockTriggerUserModelBinaryFileUploadInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockTriggerUserModelBinaryFileUploadInspect() {
	for _, e := range m.TriggerUserModelBinaryFileUploadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTriggerUserModelBinaryFileUploadCounter := mm_atomic.LoadUint64(&m.afterTriggerUserModelBinaryFileUploadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TriggerUserModelBinaryFileUploadMock.defaultExpectation != nil && afterTriggerUserModelBinaryFileUploadCounter < 1 {
		if m.TriggerUserModelBinaryFileUploadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload at\n%s", m.TriggerUserModelBinaryFileUploadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload at\n%s with params: %#v", m.TriggerUserModelBinaryFileUploadMock.defaultExpectation.expectationOrigins.origin, *m.TriggerUserModelBinaryFileUploadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTriggerUserModelBinaryFileUpload != nil && afterTriggerUserModelBinaryFileUploadCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload at\n%s", m.funcTriggerUserModelBinaryFileUploadOrigin)
	}

	if !m.TriggerUserModelBinaryFileUploadMock.invocationsDone() && afterTriggerUserModelBinaryFileUploadCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.TriggerUserModelBinaryFileUpload at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TriggerUserModelBinaryFileUploadMock.expectedInvocations), m.TriggerUserModelBinaryFileUploadMock.expectedInvocationsOrigin, afterTriggerUserModelBinaryFileUploadCounter)
	}
}

type mModelPublicServiceServerMockUpdateNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockUpdateNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockUpdateNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockUpdateNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockUpdateNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.UpdateNamespaceModel
type ModelPublicServiceServerMockUpdateNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockUpdateNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockUpdateNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockUpdateNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockUpdateNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockUpdateNamespaceModelParams contains parameters of the ModelPublicServiceServer.UpdateNamespaceModel
type ModelPublicServiceServerMockUpdateNamespaceModelParams struct {
	ctx context.Context
	up1 *mm_modelv1alpha.UpdateNamespaceModelRequest
}

// ModelPublicServiceServerMockUpdateNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.UpdateNamespaceModel
type ModelPublicServiceServerMockUpdateNamespaceModelParamPtrs struct {
	ctx *context.Context
	up1 **mm_modelv1alpha.UpdateNamespaceModelRequest
}

// ModelPublicServiceServerMockUpdateNamespaceModelResults contains results of the ModelPublicServiceServer.UpdateNamespaceModel
type ModelPublicServiceServerMockUpdateNamespaceModelResults struct {
	up2 *mm_modelv1alpha.UpdateNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockUpdateNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.UpdateNamespaceModel
type ModelPublicServiceServerMockUpdateNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) Optional() *mModelPublicServiceServerMockUpdateNamespaceModel {
	mmUpdateNamespaceModel.optional = true
	return mmUpdateNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.UpdateNamespaceModel
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) Expect(ctx context.Context, up1 *mm_modelv1alpha.UpdateNamespaceModelRequest) *mModelPublicServiceServerMockUpdateNamespaceModel {
	if mmUpdateNamespaceModel.mock.funcUpdateNamespaceModel != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by Set")
	}

	if mmUpdateNamespaceModel.defaultExpectation == nil {
		mmUpdateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockUpdateNamespaceModelExpectation{}
	}

	if mmUpdateNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockUpdateNamespaceModelParams{ctx, up1}
	mmUpdateNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespaceModel.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceModel.defaultExpectation.params) {
			mmUpdateNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceModel.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.UpdateNamespaceModel
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockUpdateNamespaceModel {
	if mmUpdateNamespaceModel.mock.funcUpdateNamespaceModel != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by Set")
	}

	if mmUpdateNamespaceModel.defaultExpectation == nil {
		mmUpdateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockUpdateNamespaceModelExpectation{}
	}

	if mmUpdateNamespaceModel.defaultExpectation.params != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by Expect")
	}

	if mmUpdateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockUpdateNamespaceModelParamPtrs{}
	}
	mmUpdateNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespaceModel
}

// ExpectUp1Param2 sets up expected param up1 for ModelPublicServiceServer.UpdateNamespaceModel
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) ExpectUp1Param2(up1 *mm_modelv1alpha.UpdateNamespaceModelRequest) *mModelPublicServiceServerMockUpdateNamespaceModel {
	if mmUpdateNamespaceModel.mock.funcUpdateNamespaceModel != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by Set")
	}

	if mmUpdateNamespaceModel.defaultExpectation == nil {
		mmUpdateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockUpdateNamespaceModelExpectation{}
	}

	if mmUpdateNamespaceModel.defaultExpectation.params != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by Expect")
	}

	if mmUpdateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockUpdateNamespaceModelParamPtrs{}
	}
	mmUpdateNamespaceModel.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateNamespaceModel.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.UpdateNamespaceModel
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) Inspect(f func(ctx context.Context, up1 *mm_modelv1alpha.UpdateNamespaceModelRequest)) *mModelPublicServiceServerMockUpdateNamespaceModel {
	if mmUpdateNamespaceModel.mock.inspectFuncUpdateNamespaceModel != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.UpdateNamespaceModel")
	}

	mmUpdateNamespaceModel.mock.inspectFuncUpdateNamespaceModel = f

	return mmUpdateNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.UpdateNamespaceModel
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) Return(up2 *mm_modelv1alpha.UpdateNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmUpdateNamespaceModel.mock.funcUpdateNamespaceModel != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by Set")
	}

	if mmUpdateNamespaceModel.defaultExpectation == nil {
		mmUpdateNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockUpdateNamespaceModelExpectation{mock: mmUpdateNamespaceModel.mock}
	}
	mmUpdateNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockUpdateNamespaceModelResults{up2, err}
	mmUpdateNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.UpdateNamespaceModel method
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) Set(f func(ctx context.Context, up1 *mm_modelv1alpha.UpdateNamespaceModelRequest) (up2 *mm_modelv1alpha.UpdateNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmUpdateNamespaceModel.defaultExpectation != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.UpdateNamespaceModel method")
	}

	if len(mmUpdateNamespaceModel.expectations) > 0 {
		mmUpdateNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.UpdateNamespaceModel method")
	}

	mmUpdateNamespaceModel.mock.funcUpdateNamespaceModel = f
	mmUpdateNamespaceModel.mock.funcUpdateNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.UpdateNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) When(ctx context.Context, up1 *mm_modelv1alpha.UpdateNamespaceModelRequest) *ModelPublicServiceServerMockUpdateNamespaceModelExpectation {
	if mmUpdateNamespaceModel.mock.funcUpdateNamespaceModel != nil {
		mmUpdateNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockUpdateNamespaceModelExpectation{
		mock:               mmUpdateNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockUpdateNamespaceModelParams{ctx, up1},
		expectationOrigins: ModelPublicServiceServerMockUpdateNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespaceModel.expectations = append(mmUpdateNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.UpdateNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockUpdateNamespaceModelExpectation) Then(up2 *mm_modelv1alpha.UpdateNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockUpdateNamespaceModelResults{up2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.UpdateNamespaceModel should be invoked
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockUpdateNamespaceModel {
	if n == 0 {
		mmUpdateNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.UpdateNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceModel.expectedInvocations, n)
	mmUpdateNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModel
}

func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) invocationsDone() bool {
	if len(mmUpdateNamespaceModel.expectations) == 0 && mmUpdateNamespaceModel.defaultExpectation == nil && mmUpdateNamespaceModel.mock.funcUpdateNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModel.mock.afterUpdateNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmUpdateNamespaceModel *ModelPublicServiceServerMock) UpdateNamespaceModel(ctx context.Context, up1 *mm_modelv1alpha.UpdateNamespaceModelRequest) (up2 *mm_modelv1alpha.UpdateNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceModel.beforeUpdateNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceModel.afterUpdateNamespaceModelCounter, 1)

	mmUpdateNamespaceModel.t.Helper()

	if mmUpdateNamespaceModel.inspectFuncUpdateNamespaceModel != nil {
		mmUpdateNamespaceModel.inspectFuncUpdateNamespaceModel(ctx, up1)
	}

	mm_params := ModelPublicServiceServerMockUpdateNamespaceModelParams{ctx, up1}

	// Record call args
	mmUpdateNamespaceModel.UpdateNamespaceModelMock.mutex.Lock()
	mmUpdateNamespaceModel.UpdateNamespaceModelMock.callArgs = append(mmUpdateNamespaceModel.UpdateNamespaceModelMock.callArgs, &mm_params)
	mmUpdateNamespaceModel.UpdateNamespaceModelMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceModel.UpdateNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockUpdateNamespaceModelParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceModel.t.Errorf("ModelPublicServiceServerMock.UpdateNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateNamespaceModel.t.Errorf("ModelPublicServiceServerMock.UpdateNamespaceModel got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceModel.t.Errorf("ModelPublicServiceServerMock.UpdateNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceModel.UpdateNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.UpdateNamespaceModel")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateNamespaceModel.funcUpdateNamespaceModel != nil {
		return mmUpdateNamespaceModel.funcUpdateNamespaceModel(ctx, up1)
	}
	mmUpdateNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.UpdateNamespaceModel. %v %v", ctx, up1)
	return
}

// UpdateNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.UpdateNamespaceModel invocations
func (mmUpdateNamespaceModel *ModelPublicServiceServerMock) UpdateNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModel.afterUpdateNamespaceModelCounter)
}

// UpdateNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.UpdateNamespaceModel invocations
func (mmUpdateNamespaceModel *ModelPublicServiceServerMock) UpdateNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModel.beforeUpdateNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.UpdateNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceModel *mModelPublicServiceServerMockUpdateNamespaceModel) Calls() []*ModelPublicServiceServerMockUpdateNamespaceModelParams {
	mmUpdateNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockUpdateNamespaceModelParams, len(mmUpdateNamespaceModel.callArgs))
	copy(argCopy, mmUpdateNamespaceModel.callArgs)

	mmUpdateNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceModelDone returns true if the count of the UpdateNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockUpdateNamespaceModelDone() bool {
	if m.UpdateNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceModelMock.invocationsDone()
}

// MinimockUpdateNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockUpdateNamespaceModelInspect() {
	for _, e := range m.UpdateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceModelMock.defaultExpectation != nil && afterUpdateNamespaceModelCounter < 1 {
		if m.UpdateNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateNamespaceModel at\n%s", m.UpdateNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateNamespaceModel at\n%s with params: %#v", m.UpdateNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceModel != nil && afterUpdateNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateNamespaceModel at\n%s", m.funcUpdateNamespaceModelOrigin)
	}

	if !m.UpdateNamespaceModelMock.invocationsDone() && afterUpdateNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.UpdateNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceModelMock.expectedInvocations), m.UpdateNamespaceModelMock.expectedInvocationsOrigin, afterUpdateNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockUpdateOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockUpdateOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockUpdateOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockUpdateOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockUpdateOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.UpdateOrganizationModel
type ModelPublicServiceServerMockUpdateOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockUpdateOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockUpdateOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockUpdateOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockUpdateOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockUpdateOrganizationModelParams contains parameters of the ModelPublicServiceServer.UpdateOrganizationModel
type ModelPublicServiceServerMockUpdateOrganizationModelParams struct {
	ctx context.Context
	up1 *mm_modelv1alpha.UpdateOrganizationModelRequest
}

// ModelPublicServiceServerMockUpdateOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.UpdateOrganizationModel
type ModelPublicServiceServerMockUpdateOrganizationModelParamPtrs struct {
	ctx *context.Context
	up1 **mm_modelv1alpha.UpdateOrganizationModelRequest
}

// ModelPublicServiceServerMockUpdateOrganizationModelResults contains results of the ModelPublicServiceServer.UpdateOrganizationModel
type ModelPublicServiceServerMockUpdateOrganizationModelResults struct {
	up2 *mm_modelv1alpha.UpdateOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockUpdateOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.UpdateOrganizationModel
type ModelPublicServiceServerMockUpdateOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) Optional() *mModelPublicServiceServerMockUpdateOrganizationModel {
	mmUpdateOrganizationModel.optional = true
	return mmUpdateOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.UpdateOrganizationModel
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) Expect(ctx context.Context, up1 *mm_modelv1alpha.UpdateOrganizationModelRequest) *mModelPublicServiceServerMockUpdateOrganizationModel {
	if mmUpdateOrganizationModel.mock.funcUpdateOrganizationModel != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by Set")
	}

	if mmUpdateOrganizationModel.defaultExpectation == nil {
		mmUpdateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockUpdateOrganizationModelExpectation{}
	}

	if mmUpdateOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by ExpectParams functions")
	}

	mmUpdateOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockUpdateOrganizationModelParams{ctx, up1}
	mmUpdateOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrganizationModel.expectations {
		if minimock.Equal(e.params, mmUpdateOrganizationModel.defaultExpectation.params) {
			mmUpdateOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrganizationModel.defaultExpectation.params)
		}
	}

	return mmUpdateOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.UpdateOrganizationModel
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockUpdateOrganizationModel {
	if mmUpdateOrganizationModel.mock.funcUpdateOrganizationModel != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by Set")
	}

	if mmUpdateOrganizationModel.defaultExpectation == nil {
		mmUpdateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockUpdateOrganizationModelExpectation{}
	}

	if mmUpdateOrganizationModel.defaultExpectation.params != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by Expect")
	}

	if mmUpdateOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockUpdateOrganizationModelParamPtrs{}
	}
	mmUpdateOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrganizationModel
}

// ExpectUp1Param2 sets up expected param up1 for ModelPublicServiceServer.UpdateOrganizationModel
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) ExpectUp1Param2(up1 *mm_modelv1alpha.UpdateOrganizationModelRequest) *mModelPublicServiceServerMockUpdateOrganizationModel {
	if mmUpdateOrganizationModel.mock.funcUpdateOrganizationModel != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by Set")
	}

	if mmUpdateOrganizationModel.defaultExpectation == nil {
		mmUpdateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockUpdateOrganizationModelExpectation{}
	}

	if mmUpdateOrganizationModel.defaultExpectation.params != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by Expect")
	}

	if mmUpdateOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmUpdateOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockUpdateOrganizationModelParamPtrs{}
	}
	mmUpdateOrganizationModel.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateOrganizationModel.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.UpdateOrganizationModel
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) Inspect(f func(ctx context.Context, up1 *mm_modelv1alpha.UpdateOrganizationModelRequest)) *mModelPublicServiceServerMockUpdateOrganizationModel {
	if mmUpdateOrganizationModel.mock.inspectFuncUpdateOrganizationModel != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.UpdateOrganizationModel")
	}

	mmUpdateOrganizationModel.mock.inspectFuncUpdateOrganizationModel = f

	return mmUpdateOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.UpdateOrganizationModel
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) Return(up2 *mm_modelv1alpha.UpdateOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmUpdateOrganizationModel.mock.funcUpdateOrganizationModel != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by Set")
	}

	if mmUpdateOrganizationModel.defaultExpectation == nil {
		mmUpdateOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockUpdateOrganizationModelExpectation{mock: mmUpdateOrganizationModel.mock}
	}
	mmUpdateOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockUpdateOrganizationModelResults{up2, err}
	mmUpdateOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.UpdateOrganizationModel method
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) Set(f func(ctx context.Context, up1 *mm_modelv1alpha.UpdateOrganizationModelRequest) (up2 *mm_modelv1alpha.UpdateOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmUpdateOrganizationModel.defaultExpectation != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.UpdateOrganizationModel method")
	}

	if len(mmUpdateOrganizationModel.expectations) > 0 {
		mmUpdateOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.UpdateOrganizationModel method")
	}

	mmUpdateOrganizationModel.mock.funcUpdateOrganizationModel = f
	mmUpdateOrganizationModel.mock.funcUpdateOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.UpdateOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) When(ctx context.Context, up1 *mm_modelv1alpha.UpdateOrganizationModelRequest) *ModelPublicServiceServerMockUpdateOrganizationModelExpectation {
	if mmUpdateOrganizationModel.mock.funcUpdateOrganizationModel != nil {
		mmUpdateOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockUpdateOrganizationModelExpectation{
		mock:               mmUpdateOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockUpdateOrganizationModelParams{ctx, up1},
		expectationOrigins: ModelPublicServiceServerMockUpdateOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrganizationModel.expectations = append(mmUpdateOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.UpdateOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockUpdateOrganizationModelExpectation) Then(up2 *mm_modelv1alpha.UpdateOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockUpdateOrganizationModelResults{up2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.UpdateOrganizationModel should be invoked
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockUpdateOrganizationModel {
	if n == 0 {
		mmUpdateOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.UpdateOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrganizationModel.expectedInvocations, n)
	mmUpdateOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrganizationModel
}

func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) invocationsDone() bool {
	if len(mmUpdateOrganizationModel.expectations) == 0 && mmUpdateOrganizationModel.defaultExpectation == nil && mmUpdateOrganizationModel.mock.funcUpdateOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationModel.mock.afterUpdateOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmUpdateOrganizationModel *ModelPublicServiceServerMock) UpdateOrganizationModel(ctx context.Context, up1 *mm_modelv1alpha.UpdateOrganizationModelRequest) (up2 *mm_modelv1alpha.UpdateOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateOrganizationModel.beforeUpdateOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrganizationModel.afterUpdateOrganizationModelCounter, 1)

	mmUpdateOrganizationModel.t.Helper()

	if mmUpdateOrganizationModel.inspectFuncUpdateOrganizationModel != nil {
		mmUpdateOrganizationModel.inspectFuncUpdateOrganizationModel(ctx, up1)
	}

	mm_params := ModelPublicServiceServerMockUpdateOrganizationModelParams{ctx, up1}

	// Record call args
	mmUpdateOrganizationModel.UpdateOrganizationModelMock.mutex.Lock()
	mmUpdateOrganizationModel.UpdateOrganizationModelMock.callArgs = append(mmUpdateOrganizationModel.UpdateOrganizationModelMock.callArgs, &mm_params)
	mmUpdateOrganizationModel.UpdateOrganizationModelMock.mutex.Unlock()

	for _, e := range mmUpdateOrganizationModel.UpdateOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockUpdateOrganizationModelParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrganizationModel.t.Errorf("ModelPublicServiceServerMock.UpdateOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateOrganizationModel.t.Errorf("ModelPublicServiceServerMock.UpdateOrganizationModel got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrganizationModel.t.Errorf("ModelPublicServiceServerMock.UpdateOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrganizationModel.UpdateOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.UpdateOrganizationModel")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateOrganizationModel.funcUpdateOrganizationModel != nil {
		return mmUpdateOrganizationModel.funcUpdateOrganizationModel(ctx, up1)
	}
	mmUpdateOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.UpdateOrganizationModel. %v %v", ctx, up1)
	return
}

// UpdateOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.UpdateOrganizationModel invocations
func (mmUpdateOrganizationModel *ModelPublicServiceServerMock) UpdateOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationModel.afterUpdateOrganizationModelCounter)
}

// UpdateOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.UpdateOrganizationModel invocations
func (mmUpdateOrganizationModel *ModelPublicServiceServerMock) UpdateOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrganizationModel.beforeUpdateOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.UpdateOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrganizationModel *mModelPublicServiceServerMockUpdateOrganizationModel) Calls() []*ModelPublicServiceServerMockUpdateOrganizationModelParams {
	mmUpdateOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockUpdateOrganizationModelParams, len(mmUpdateOrganizationModel.callArgs))
	copy(argCopy, mmUpdateOrganizationModel.callArgs)

	mmUpdateOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrganizationModelDone returns true if the count of the UpdateOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockUpdateOrganizationModelDone() bool {
	if m.UpdateOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrganizationModelMock.invocationsDone()
}

// MinimockUpdateOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockUpdateOrganizationModelInspect() {
	for _, e := range m.UpdateOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterUpdateOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrganizationModelMock.defaultExpectation != nil && afterUpdateOrganizationModelCounter < 1 {
		if m.UpdateOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateOrganizationModel at\n%s", m.UpdateOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateOrganizationModel at\n%s with params: %#v", m.UpdateOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrganizationModel != nil && afterUpdateOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateOrganizationModel at\n%s", m.funcUpdateOrganizationModelOrigin)
	}

	if !m.UpdateOrganizationModelMock.invocationsDone() && afterUpdateOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.UpdateOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrganizationModelMock.expectedInvocations), m.UpdateOrganizationModelMock.expectedInvocationsOrigin, afterUpdateOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockUpdateUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockUpdateUserModelExpectation
	expectations       []*ModelPublicServiceServerMockUpdateUserModelExpectation

	callArgs []*ModelPublicServiceServerMockUpdateUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockUpdateUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.UpdateUserModel
type ModelPublicServiceServerMockUpdateUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockUpdateUserModelParams
	paramPtrs          *ModelPublicServiceServerMockUpdateUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockUpdateUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockUpdateUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockUpdateUserModelParams contains parameters of the ModelPublicServiceServer.UpdateUserModel
type ModelPublicServiceServerMockUpdateUserModelParams struct {
	ctx context.Context
	up1 *mm_modelv1alpha.UpdateUserModelRequest
}

// ModelPublicServiceServerMockUpdateUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.UpdateUserModel
type ModelPublicServiceServerMockUpdateUserModelParamPtrs struct {
	ctx *context.Context
	up1 **mm_modelv1alpha.UpdateUserModelRequest
}

// ModelPublicServiceServerMockUpdateUserModelResults contains results of the ModelPublicServiceServer.UpdateUserModel
type ModelPublicServiceServerMockUpdateUserModelResults struct {
	up2 *mm_modelv1alpha.UpdateUserModelResponse
	err error
}

// ModelPublicServiceServerMockUpdateUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.UpdateUserModel
type ModelPublicServiceServerMockUpdateUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) Optional() *mModelPublicServiceServerMockUpdateUserModel {
	mmUpdateUserModel.optional = true
	return mmUpdateUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.UpdateUserModel
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) Expect(ctx context.Context, up1 *mm_modelv1alpha.UpdateUserModelRequest) *mModelPublicServiceServerMockUpdateUserModel {
	if mmUpdateUserModel.mock.funcUpdateUserModel != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by Set")
	}

	if mmUpdateUserModel.defaultExpectation == nil {
		mmUpdateUserModel.defaultExpectation = &ModelPublicServiceServerMockUpdateUserModelExpectation{}
	}

	if mmUpdateUserModel.defaultExpectation.paramPtrs != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by ExpectParams functions")
	}

	mmUpdateUserModel.defaultExpectation.params = &ModelPublicServiceServerMockUpdateUserModelParams{ctx, up1}
	mmUpdateUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUserModel.expectations {
		if minimock.Equal(e.params, mmUpdateUserModel.defaultExpectation.params) {
			mmUpdateUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserModel.defaultExpectation.params)
		}
	}

	return mmUpdateUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.UpdateUserModel
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockUpdateUserModel {
	if mmUpdateUserModel.mock.funcUpdateUserModel != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by Set")
	}

	if mmUpdateUserModel.defaultExpectation == nil {
		mmUpdateUserModel.defaultExpectation = &ModelPublicServiceServerMockUpdateUserModelExpectation{}
	}

	if mmUpdateUserModel.defaultExpectation.params != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by Expect")
	}

	if mmUpdateUserModel.defaultExpectation.paramPtrs == nil {
		mmUpdateUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockUpdateUserModelParamPtrs{}
	}
	mmUpdateUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUserModel
}

// ExpectUp1Param2 sets up expected param up1 for ModelPublicServiceServer.UpdateUserModel
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) ExpectUp1Param2(up1 *mm_modelv1alpha.UpdateUserModelRequest) *mModelPublicServiceServerMockUpdateUserModel {
	if mmUpdateUserModel.mock.funcUpdateUserModel != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by Set")
	}

	if mmUpdateUserModel.defaultExpectation == nil {
		mmUpdateUserModel.defaultExpectation = &ModelPublicServiceServerMockUpdateUserModelExpectation{}
	}

	if mmUpdateUserModel.defaultExpectation.params != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by Expect")
	}

	if mmUpdateUserModel.defaultExpectation.paramPtrs == nil {
		mmUpdateUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockUpdateUserModelParamPtrs{}
	}
	mmUpdateUserModel.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateUserModel.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.UpdateUserModel
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) Inspect(f func(ctx context.Context, up1 *mm_modelv1alpha.UpdateUserModelRequest)) *mModelPublicServiceServerMockUpdateUserModel {
	if mmUpdateUserModel.mock.inspectFuncUpdateUserModel != nil {
		mmUpdateUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.UpdateUserModel")
	}

	mmUpdateUserModel.mock.inspectFuncUpdateUserModel = f

	return mmUpdateUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.UpdateUserModel
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) Return(up2 *mm_modelv1alpha.UpdateUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmUpdateUserModel.mock.funcUpdateUserModel != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by Set")
	}

	if mmUpdateUserModel.defaultExpectation == nil {
		mmUpdateUserModel.defaultExpectation = &ModelPublicServiceServerMockUpdateUserModelExpectation{mock: mmUpdateUserModel.mock}
	}
	mmUpdateUserModel.defaultExpectation.results = &ModelPublicServiceServerMockUpdateUserModelResults{up2, err}
	mmUpdateUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.UpdateUserModel method
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) Set(f func(ctx context.Context, up1 *mm_modelv1alpha.UpdateUserModelRequest) (up2 *mm_modelv1alpha.UpdateUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmUpdateUserModel.defaultExpectation != nil {
		mmUpdateUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.UpdateUserModel method")
	}

	if len(mmUpdateUserModel.expectations) > 0 {
		mmUpdateUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.UpdateUserModel method")
	}

	mmUpdateUserModel.mock.funcUpdateUserModel = f
	mmUpdateUserModel.mock.funcUpdateUserModelOrigin = minimock.CallerInfo(1)
	return mmUpdateUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.UpdateUserModel which will trigger the result defined by the following
// Then helper
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) When(ctx context.Context, up1 *mm_modelv1alpha.UpdateUserModelRequest) *ModelPublicServiceServerMockUpdateUserModelExpectation {
	if mmUpdateUserModel.mock.funcUpdateUserModel != nil {
		mmUpdateUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.UpdateUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockUpdateUserModelExpectation{
		mock:               mmUpdateUserModel.mock,
		params:             &ModelPublicServiceServerMockUpdateUserModelParams{ctx, up1},
		expectationOrigins: ModelPublicServiceServerMockUpdateUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUserModel.expectations = append(mmUpdateUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.UpdateUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockUpdateUserModelExpectation) Then(up2 *mm_modelv1alpha.UpdateUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockUpdateUserModelResults{up2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.UpdateUserModel should be invoked
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) Times(n uint64) *mModelPublicServiceServerMockUpdateUserModel {
	if n == 0 {
		mmUpdateUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.UpdateUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUserModel.expectedInvocations, n)
	mmUpdateUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUserModel
}

func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) invocationsDone() bool {
	if len(mmUpdateUserModel.expectations) == 0 && mmUpdateUserModel.defaultExpectation == nil && mmUpdateUserModel.mock.funcUpdateUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUserModel.mock.afterUpdateUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmUpdateUserModel *ModelPublicServiceServerMock) UpdateUserModel(ctx context.Context, up1 *mm_modelv1alpha.UpdateUserModelRequest) (up2 *mm_modelv1alpha.UpdateUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateUserModel.beforeUpdateUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserModel.afterUpdateUserModelCounter, 1)

	mmUpdateUserModel.t.Helper()

	if mmUpdateUserModel.inspectFuncUpdateUserModel != nil {
		mmUpdateUserModel.inspectFuncUpdateUserModel(ctx, up1)
	}

	mm_params := ModelPublicServiceServerMockUpdateUserModelParams{ctx, up1}

	// Record call args
	mmUpdateUserModel.UpdateUserModelMock.mutex.Lock()
	mmUpdateUserModel.UpdateUserModelMock.callArgs = append(mmUpdateUserModel.UpdateUserModelMock.callArgs, &mm_params)
	mmUpdateUserModel.UpdateUserModelMock.mutex.Unlock()

	for _, e := range mmUpdateUserModel.UpdateUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateUserModel.UpdateUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserModel.UpdateUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserModel.UpdateUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUserModel.UpdateUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockUpdateUserModelParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUserModel.t.Errorf("ModelPublicServiceServerMock.UpdateUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserModel.UpdateUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateUserModel.t.Errorf("ModelPublicServiceServerMock.UpdateUserModel got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUserModel.UpdateUserModelMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserModel.t.Errorf("ModelPublicServiceServerMock.UpdateUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUserModel.UpdateUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserModel.UpdateUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.UpdateUserModel")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateUserModel.funcUpdateUserModel != nil {
		return mmUpdateUserModel.funcUpdateUserModel(ctx, up1)
	}
	mmUpdateUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.UpdateUserModel. %v %v", ctx, up1)
	return
}

// UpdateUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.UpdateUserModel invocations
func (mmUpdateUserModel *ModelPublicServiceServerMock) UpdateUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserModel.afterUpdateUserModelCounter)
}

// UpdateUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.UpdateUserModel invocations
func (mmUpdateUserModel *ModelPublicServiceServerMock) UpdateUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserModel.beforeUpdateUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.UpdateUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserModel *mModelPublicServiceServerMockUpdateUserModel) Calls() []*ModelPublicServiceServerMockUpdateUserModelParams {
	mmUpdateUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockUpdateUserModelParams, len(mmUpdateUserModel.callArgs))
	copy(argCopy, mmUpdateUserModel.callArgs)

	mmUpdateUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserModelDone returns true if the count of the UpdateUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockUpdateUserModelDone() bool {
	if m.UpdateUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserModelMock.invocationsDone()
}

// MinimockUpdateUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockUpdateUserModelInspect() {
	for _, e := range m.UpdateUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserModelCounter := mm_atomic.LoadUint64(&m.afterUpdateUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserModelMock.defaultExpectation != nil && afterUpdateUserModelCounter < 1 {
		if m.UpdateUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateUserModel at\n%s", m.UpdateUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateUserModel at\n%s with params: %#v", m.UpdateUserModelMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserModel != nil && afterUpdateUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.UpdateUserModel at\n%s", m.funcUpdateUserModelOrigin)
	}

	if !m.UpdateUserModelMock.invocationsDone() && afterUpdateUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.UpdateUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserModelMock.expectedInvocations), m.UpdateUserModelMock.expectedInvocationsOrigin, afterUpdateUserModelCounter)
	}
}

type mModelPublicServiceServerMockWatchNamespaceLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockWatchNamespaceLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.WatchNamespaceLatestModel
type ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockWatchNamespaceLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockWatchNamespaceLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockWatchNamespaceLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockWatchNamespaceLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockWatchNamespaceLatestModelParams contains parameters of the ModelPublicServiceServer.WatchNamespaceLatestModel
type ModelPublicServiceServerMockWatchNamespaceLatestModelParams struct {
	ctx context.Context
	wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest
}

// ModelPublicServiceServerMockWatchNamespaceLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.WatchNamespaceLatestModel
type ModelPublicServiceServerMockWatchNamespaceLatestModelParamPtrs struct {
	ctx *context.Context
	wp1 **mm_modelv1alpha.WatchNamespaceLatestModelRequest
}

// ModelPublicServiceServerMockWatchNamespaceLatestModelResults contains results of the ModelPublicServiceServer.WatchNamespaceLatestModel
type ModelPublicServiceServerMockWatchNamespaceLatestModelResults struct {
	wp2 *mm_modelv1alpha.WatchNamespaceLatestModelResponse
	err error
}

// ModelPublicServiceServerMockWatchNamespaceLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.WatchNamespaceLatestModel
type ModelPublicServiceServerMockWatchNamespaceLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originWp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) Optional() *mModelPublicServiceServerMockWatchNamespaceLatestModel {
	mmWatchNamespaceLatestModel.optional = true
	return mmWatchNamespaceLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.WatchNamespaceLatestModel
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) Expect(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest) *mModelPublicServiceServerMockWatchNamespaceLatestModel {
	if mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModel != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by Set")
	}

	if mmWatchNamespaceLatestModel.defaultExpectation == nil {
		mmWatchNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation{}
	}

	if mmWatchNamespaceLatestModel.defaultExpectation.paramPtrs != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by ExpectParams functions")
	}

	mmWatchNamespaceLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockWatchNamespaceLatestModelParams{ctx, wp1}
	mmWatchNamespaceLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWatchNamespaceLatestModel.expectations {
		if minimock.Equal(e.params, mmWatchNamespaceLatestModel.defaultExpectation.params) {
			mmWatchNamespaceLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatchNamespaceLatestModel.defaultExpectation.params)
		}
	}

	return mmWatchNamespaceLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.WatchNamespaceLatestModel
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockWatchNamespaceLatestModel {
	if mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModel != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by Set")
	}

	if mmWatchNamespaceLatestModel.defaultExpectation == nil {
		mmWatchNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation{}
	}

	if mmWatchNamespaceLatestModel.defaultExpectation.params != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by Expect")
	}

	if mmWatchNamespaceLatestModel.defaultExpectation.paramPtrs == nil {
		mmWatchNamespaceLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchNamespaceLatestModelParamPtrs{}
	}
	mmWatchNamespaceLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmWatchNamespaceLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWatchNamespaceLatestModel
}

// ExpectWp1Param2 sets up expected param wp1 for ModelPublicServiceServer.WatchNamespaceLatestModel
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) ExpectWp1Param2(wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest) *mModelPublicServiceServerMockWatchNamespaceLatestModel {
	if mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModel != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by Set")
	}

	if mmWatchNamespaceLatestModel.defaultExpectation == nil {
		mmWatchNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation{}
	}

	if mmWatchNamespaceLatestModel.defaultExpectation.params != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by Expect")
	}

	if mmWatchNamespaceLatestModel.defaultExpectation.paramPtrs == nil {
		mmWatchNamespaceLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchNamespaceLatestModelParamPtrs{}
	}
	mmWatchNamespaceLatestModel.defaultExpectation.paramPtrs.wp1 = &wp1
	mmWatchNamespaceLatestModel.defaultExpectation.expectationOrigins.originWp1 = minimock.CallerInfo(1)

	return mmWatchNamespaceLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.WatchNamespaceLatestModel
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) Inspect(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest)) *mModelPublicServiceServerMockWatchNamespaceLatestModel {
	if mmWatchNamespaceLatestModel.mock.inspectFuncWatchNamespaceLatestModel != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.WatchNamespaceLatestModel")
	}

	mmWatchNamespaceLatestModel.mock.inspectFuncWatchNamespaceLatestModel = f

	return mmWatchNamespaceLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.WatchNamespaceLatestModel
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) Return(wp2 *mm_modelv1alpha.WatchNamespaceLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModel != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by Set")
	}

	if mmWatchNamespaceLatestModel.defaultExpectation == nil {
		mmWatchNamespaceLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation{mock: mmWatchNamespaceLatestModel.mock}
	}
	mmWatchNamespaceLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockWatchNamespaceLatestModelResults{wp2, err}
	mmWatchNamespaceLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWatchNamespaceLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.WatchNamespaceLatestModel method
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) Set(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest) (wp2 *mm_modelv1alpha.WatchNamespaceLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmWatchNamespaceLatestModel.defaultExpectation != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.WatchNamespaceLatestModel method")
	}

	if len(mmWatchNamespaceLatestModel.expectations) > 0 {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.WatchNamespaceLatestModel method")
	}

	mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModel = f
	mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModelOrigin = minimock.CallerInfo(1)
	return mmWatchNamespaceLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.WatchNamespaceLatestModel which will trigger the result defined by the following
// Then helper
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) When(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest) *ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation {
	if mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModel != nil {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation{
		mock:               mmWatchNamespaceLatestModel.mock,
		params:             &ModelPublicServiceServerMockWatchNamespaceLatestModelParams{ctx, wp1},
		expectationOrigins: ModelPublicServiceServerMockWatchNamespaceLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWatchNamespaceLatestModel.expectations = append(mmWatchNamespaceLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.WatchNamespaceLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockWatchNamespaceLatestModelExpectation) Then(wp2 *mm_modelv1alpha.WatchNamespaceLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockWatchNamespaceLatestModelResults{wp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.WatchNamespaceLatestModel should be invoked
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) Times(n uint64) *mModelPublicServiceServerMockWatchNamespaceLatestModel {
	if n == 0 {
		mmWatchNamespaceLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.WatchNamespaceLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWatchNamespaceLatestModel.expectedInvocations, n)
	mmWatchNamespaceLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWatchNamespaceLatestModel
}

func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) invocationsDone() bool {
	if len(mmWatchNamespaceLatestModel.expectations) == 0 && mmWatchNamespaceLatestModel.defaultExpectation == nil && mmWatchNamespaceLatestModel.mock.funcWatchNamespaceLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWatchNamespaceLatestModel.mock.afterWatchNamespaceLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWatchNamespaceLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WatchNamespaceLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmWatchNamespaceLatestModel *ModelPublicServiceServerMock) WatchNamespaceLatestModel(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceLatestModelRequest) (wp2 *mm_modelv1alpha.WatchNamespaceLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmWatchNamespaceLatestModel.beforeWatchNamespaceLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmWatchNamespaceLatestModel.afterWatchNamespaceLatestModelCounter, 1)

	mmWatchNamespaceLatestModel.t.Helper()

	if mmWatchNamespaceLatestModel.inspectFuncWatchNamespaceLatestModel != nil {
		mmWatchNamespaceLatestModel.inspectFuncWatchNamespaceLatestModel(ctx, wp1)
	}

	mm_params := ModelPublicServiceServerMockWatchNamespaceLatestModelParams{ctx, wp1}

	// Record call args
	mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.mutex.Lock()
	mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.callArgs = append(mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.callArgs, &mm_params)
	mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.mutex.Unlock()

	for _, e := range mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp2, e.results.err
		}
	}

	if mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockWatchNamespaceLatestModelParams{ctx, wp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWatchNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchNamespaceLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wp1 != nil && !minimock.Equal(*mm_want_ptrs.wp1, mm_got.wp1) {
				mmWatchNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchNamespaceLatestModel got unexpected parameter wp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation.expectationOrigins.originWp1, *mm_want_ptrs.wp1, mm_got.wp1, minimock.Diff(*mm_want_ptrs.wp1, mm_got.wp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatchNamespaceLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchNamespaceLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatchNamespaceLatestModel.WatchNamespaceLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmWatchNamespaceLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.WatchNamespaceLatestModel")
		}
		return (*mm_results).wp2, (*mm_results).err
	}
	if mmWatchNamespaceLatestModel.funcWatchNamespaceLatestModel != nil {
		return mmWatchNamespaceLatestModel.funcWatchNamespaceLatestModel(ctx, wp1)
	}
	mmWatchNamespaceLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.WatchNamespaceLatestModel. %v %v", ctx, wp1)
	return
}

// WatchNamespaceLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.WatchNamespaceLatestModel invocations
func (mmWatchNamespaceLatestModel *ModelPublicServiceServerMock) WatchNamespaceLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchNamespaceLatestModel.afterWatchNamespaceLatestModelCounter)
}

// WatchNamespaceLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.WatchNamespaceLatestModel invocations
func (mmWatchNamespaceLatestModel *ModelPublicServiceServerMock) WatchNamespaceLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchNamespaceLatestModel.beforeWatchNamespaceLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.WatchNamespaceLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatchNamespaceLatestModel *mModelPublicServiceServerMockWatchNamespaceLatestModel) Calls() []*ModelPublicServiceServerMockWatchNamespaceLatestModelParams {
	mmWatchNamespaceLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockWatchNamespaceLatestModelParams, len(mmWatchNamespaceLatestModel.callArgs))
	copy(argCopy, mmWatchNamespaceLatestModel.callArgs)

	mmWatchNamespaceLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockWatchNamespaceLatestModelDone returns true if the count of the WatchNamespaceLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockWatchNamespaceLatestModelDone() bool {
	if m.WatchNamespaceLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WatchNamespaceLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WatchNamespaceLatestModelMock.invocationsDone()
}

// MinimockWatchNamespaceLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockWatchNamespaceLatestModelInspect() {
	for _, e := range m.WatchNamespaceLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWatchNamespaceLatestModelCounter := mm_atomic.LoadUint64(&m.afterWatchNamespaceLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WatchNamespaceLatestModelMock.defaultExpectation != nil && afterWatchNamespaceLatestModelCounter < 1 {
		if m.WatchNamespaceLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceLatestModel at\n%s", m.WatchNamespaceLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceLatestModel at\n%s with params: %#v", m.WatchNamespaceLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.WatchNamespaceLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatchNamespaceLatestModel != nil && afterWatchNamespaceLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceLatestModel at\n%s", m.funcWatchNamespaceLatestModelOrigin)
	}

	if !m.WatchNamespaceLatestModelMock.invocationsDone() && afterWatchNamespaceLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.WatchNamespaceLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WatchNamespaceLatestModelMock.expectedInvocations), m.WatchNamespaceLatestModelMock.expectedInvocationsOrigin, afterWatchNamespaceLatestModelCounter)
	}
}

type mModelPublicServiceServerMockWatchNamespaceModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockWatchNamespaceModelExpectation
	expectations       []*ModelPublicServiceServerMockWatchNamespaceModelExpectation

	callArgs []*ModelPublicServiceServerMockWatchNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockWatchNamespaceModelExpectation specifies expectation struct of the ModelPublicServiceServer.WatchNamespaceModel
type ModelPublicServiceServerMockWatchNamespaceModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockWatchNamespaceModelParams
	paramPtrs          *ModelPublicServiceServerMockWatchNamespaceModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockWatchNamespaceModelExpectationOrigins
	results            *ModelPublicServiceServerMockWatchNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockWatchNamespaceModelParams contains parameters of the ModelPublicServiceServer.WatchNamespaceModel
type ModelPublicServiceServerMockWatchNamespaceModelParams struct {
	ctx context.Context
	wp1 *mm_modelv1alpha.WatchNamespaceModelRequest
}

// ModelPublicServiceServerMockWatchNamespaceModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.WatchNamespaceModel
type ModelPublicServiceServerMockWatchNamespaceModelParamPtrs struct {
	ctx *context.Context
	wp1 **mm_modelv1alpha.WatchNamespaceModelRequest
}

// ModelPublicServiceServerMockWatchNamespaceModelResults contains results of the ModelPublicServiceServer.WatchNamespaceModel
type ModelPublicServiceServerMockWatchNamespaceModelResults struct {
	wp2 *mm_modelv1alpha.WatchNamespaceModelResponse
	err error
}

// ModelPublicServiceServerMockWatchNamespaceModelOrigins contains origins of expectations of the ModelPublicServiceServer.WatchNamespaceModel
type ModelPublicServiceServerMockWatchNamespaceModelExpectationOrigins struct {
	origin    string
	originCtx string
	originWp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) Optional() *mModelPublicServiceServerMockWatchNamespaceModel {
	mmWatchNamespaceModel.optional = true
	return mmWatchNamespaceModel
}

// Expect sets up expected params for ModelPublicServiceServer.WatchNamespaceModel
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) Expect(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceModelRequest) *mModelPublicServiceServerMockWatchNamespaceModel {
	if mmWatchNamespaceModel.mock.funcWatchNamespaceModel != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by Set")
	}

	if mmWatchNamespaceModel.defaultExpectation == nil {
		mmWatchNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceModelExpectation{}
	}

	if mmWatchNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by ExpectParams functions")
	}

	mmWatchNamespaceModel.defaultExpectation.params = &ModelPublicServiceServerMockWatchNamespaceModelParams{ctx, wp1}
	mmWatchNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWatchNamespaceModel.expectations {
		if minimock.Equal(e.params, mmWatchNamespaceModel.defaultExpectation.params) {
			mmWatchNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatchNamespaceModel.defaultExpectation.params)
		}
	}

	return mmWatchNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.WatchNamespaceModel
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockWatchNamespaceModel {
	if mmWatchNamespaceModel.mock.funcWatchNamespaceModel != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by Set")
	}

	if mmWatchNamespaceModel.defaultExpectation == nil {
		mmWatchNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceModelExpectation{}
	}

	if mmWatchNamespaceModel.defaultExpectation.params != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by Expect")
	}

	if mmWatchNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmWatchNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchNamespaceModelParamPtrs{}
	}
	mmWatchNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmWatchNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWatchNamespaceModel
}

// ExpectWp1Param2 sets up expected param wp1 for ModelPublicServiceServer.WatchNamespaceModel
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) ExpectWp1Param2(wp1 *mm_modelv1alpha.WatchNamespaceModelRequest) *mModelPublicServiceServerMockWatchNamespaceModel {
	if mmWatchNamespaceModel.mock.funcWatchNamespaceModel != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by Set")
	}

	if mmWatchNamespaceModel.defaultExpectation == nil {
		mmWatchNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceModelExpectation{}
	}

	if mmWatchNamespaceModel.defaultExpectation.params != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by Expect")
	}

	if mmWatchNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmWatchNamespaceModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchNamespaceModelParamPtrs{}
	}
	mmWatchNamespaceModel.defaultExpectation.paramPtrs.wp1 = &wp1
	mmWatchNamespaceModel.defaultExpectation.expectationOrigins.originWp1 = minimock.CallerInfo(1)

	return mmWatchNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.WatchNamespaceModel
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) Inspect(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceModelRequest)) *mModelPublicServiceServerMockWatchNamespaceModel {
	if mmWatchNamespaceModel.mock.inspectFuncWatchNamespaceModel != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.WatchNamespaceModel")
	}

	mmWatchNamespaceModel.mock.inspectFuncWatchNamespaceModel = f

	return mmWatchNamespaceModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.WatchNamespaceModel
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) Return(wp2 *mm_modelv1alpha.WatchNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	if mmWatchNamespaceModel.mock.funcWatchNamespaceModel != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by Set")
	}

	if mmWatchNamespaceModel.defaultExpectation == nil {
		mmWatchNamespaceModel.defaultExpectation = &ModelPublicServiceServerMockWatchNamespaceModelExpectation{mock: mmWatchNamespaceModel.mock}
	}
	mmWatchNamespaceModel.defaultExpectation.results = &ModelPublicServiceServerMockWatchNamespaceModelResults{wp2, err}
	mmWatchNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWatchNamespaceModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.WatchNamespaceModel method
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) Set(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceModelRequest) (wp2 *mm_modelv1alpha.WatchNamespaceModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmWatchNamespaceModel.defaultExpectation != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.WatchNamespaceModel method")
	}

	if len(mmWatchNamespaceModel.expectations) > 0 {
		mmWatchNamespaceModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.WatchNamespaceModel method")
	}

	mmWatchNamespaceModel.mock.funcWatchNamespaceModel = f
	mmWatchNamespaceModel.mock.funcWatchNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmWatchNamespaceModel.mock
}

// When sets expectation for the ModelPublicServiceServer.WatchNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) When(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceModelRequest) *ModelPublicServiceServerMockWatchNamespaceModelExpectation {
	if mmWatchNamespaceModel.mock.funcWatchNamespaceModel != nil {
		mmWatchNamespaceModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchNamespaceModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockWatchNamespaceModelExpectation{
		mock:               mmWatchNamespaceModel.mock,
		params:             &ModelPublicServiceServerMockWatchNamespaceModelParams{ctx, wp1},
		expectationOrigins: ModelPublicServiceServerMockWatchNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWatchNamespaceModel.expectations = append(mmWatchNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.WatchNamespaceModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockWatchNamespaceModelExpectation) Then(wp2 *mm_modelv1alpha.WatchNamespaceModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockWatchNamespaceModelResults{wp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.WatchNamespaceModel should be invoked
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) Times(n uint64) *mModelPublicServiceServerMockWatchNamespaceModel {
	if n == 0 {
		mmWatchNamespaceModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.WatchNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWatchNamespaceModel.expectedInvocations, n)
	mmWatchNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWatchNamespaceModel
}

func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) invocationsDone() bool {
	if len(mmWatchNamespaceModel.expectations) == 0 && mmWatchNamespaceModel.defaultExpectation == nil && mmWatchNamespaceModel.mock.funcWatchNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWatchNamespaceModel.mock.afterWatchNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWatchNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WatchNamespaceModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmWatchNamespaceModel *ModelPublicServiceServerMock) WatchNamespaceModel(ctx context.Context, wp1 *mm_modelv1alpha.WatchNamespaceModelRequest) (wp2 *mm_modelv1alpha.WatchNamespaceModelResponse, err error) {
	mm_atomic.AddUint64(&mmWatchNamespaceModel.beforeWatchNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmWatchNamespaceModel.afterWatchNamespaceModelCounter, 1)

	mmWatchNamespaceModel.t.Helper()

	if mmWatchNamespaceModel.inspectFuncWatchNamespaceModel != nil {
		mmWatchNamespaceModel.inspectFuncWatchNamespaceModel(ctx, wp1)
	}

	mm_params := ModelPublicServiceServerMockWatchNamespaceModelParams{ctx, wp1}

	// Record call args
	mmWatchNamespaceModel.WatchNamespaceModelMock.mutex.Lock()
	mmWatchNamespaceModel.WatchNamespaceModelMock.callArgs = append(mmWatchNamespaceModel.WatchNamespaceModelMock.callArgs, &mm_params)
	mmWatchNamespaceModel.WatchNamespaceModelMock.mutex.Unlock()

	for _, e := range mmWatchNamespaceModel.WatchNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp2, e.results.err
		}
	}

	if mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockWatchNamespaceModelParams{ctx, wp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWatchNamespaceModel.t.Errorf("ModelPublicServiceServerMock.WatchNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wp1 != nil && !minimock.Equal(*mm_want_ptrs.wp1, mm_got.wp1) {
				mmWatchNamespaceModel.t.Errorf("ModelPublicServiceServerMock.WatchNamespaceModel got unexpected parameter wp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation.expectationOrigins.originWp1, *mm_want_ptrs.wp1, mm_got.wp1, minimock.Diff(*mm_want_ptrs.wp1, mm_got.wp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatchNamespaceModel.t.Errorf("ModelPublicServiceServerMock.WatchNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatchNamespaceModel.WatchNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmWatchNamespaceModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.WatchNamespaceModel")
		}
		return (*mm_results).wp2, (*mm_results).err
	}
	if mmWatchNamespaceModel.funcWatchNamespaceModel != nil {
		return mmWatchNamespaceModel.funcWatchNamespaceModel(ctx, wp1)
	}
	mmWatchNamespaceModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.WatchNamespaceModel. %v %v", ctx, wp1)
	return
}

// WatchNamespaceModelAfterCounter returns a count of finished ModelPublicServiceServerMock.WatchNamespaceModel invocations
func (mmWatchNamespaceModel *ModelPublicServiceServerMock) WatchNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchNamespaceModel.afterWatchNamespaceModelCounter)
}

// WatchNamespaceModelBeforeCounter returns a count of ModelPublicServiceServerMock.WatchNamespaceModel invocations
func (mmWatchNamespaceModel *ModelPublicServiceServerMock) WatchNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchNamespaceModel.beforeWatchNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.WatchNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatchNamespaceModel *mModelPublicServiceServerMockWatchNamespaceModel) Calls() []*ModelPublicServiceServerMockWatchNamespaceModelParams {
	mmWatchNamespaceModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockWatchNamespaceModelParams, len(mmWatchNamespaceModel.callArgs))
	copy(argCopy, mmWatchNamespaceModel.callArgs)

	mmWatchNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockWatchNamespaceModelDone returns true if the count of the WatchNamespaceModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockWatchNamespaceModelDone() bool {
	if m.WatchNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WatchNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WatchNamespaceModelMock.invocationsDone()
}

// MinimockWatchNamespaceModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockWatchNamespaceModelInspect() {
	for _, e := range m.WatchNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWatchNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterWatchNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WatchNamespaceModelMock.defaultExpectation != nil && afterWatchNamespaceModelCounter < 1 {
		if m.WatchNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceModel at\n%s", m.WatchNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceModel at\n%s with params: %#v", m.WatchNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.WatchNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatchNamespaceModel != nil && afterWatchNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchNamespaceModel at\n%s", m.funcWatchNamespaceModelOrigin)
	}

	if !m.WatchNamespaceModelMock.invocationsDone() && afterWatchNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.WatchNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WatchNamespaceModelMock.expectedInvocations), m.WatchNamespaceModelMock.expectedInvocationsOrigin, afterWatchNamespaceModelCounter)
	}
}

type mModelPublicServiceServerMockWatchOrganizationLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockWatchOrganizationLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.WatchOrganizationLatestModel
type ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockWatchOrganizationLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockWatchOrganizationLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockWatchOrganizationLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockWatchOrganizationLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockWatchOrganizationLatestModelParams contains parameters of the ModelPublicServiceServer.WatchOrganizationLatestModel
type ModelPublicServiceServerMockWatchOrganizationLatestModelParams struct {
	ctx context.Context
	wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest
}

// ModelPublicServiceServerMockWatchOrganizationLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.WatchOrganizationLatestModel
type ModelPublicServiceServerMockWatchOrganizationLatestModelParamPtrs struct {
	ctx *context.Context
	wp1 **mm_modelv1alpha.WatchOrganizationLatestModelRequest
}

// ModelPublicServiceServerMockWatchOrganizationLatestModelResults contains results of the ModelPublicServiceServer.WatchOrganizationLatestModel
type ModelPublicServiceServerMockWatchOrganizationLatestModelResults struct {
	wp2 *mm_modelv1alpha.WatchOrganizationLatestModelResponse
	err error
}

// ModelPublicServiceServerMockWatchOrganizationLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.WatchOrganizationLatestModel
type ModelPublicServiceServerMockWatchOrganizationLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originWp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) Optional() *mModelPublicServiceServerMockWatchOrganizationLatestModel {
	mmWatchOrganizationLatestModel.optional = true
	return mmWatchOrganizationLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.WatchOrganizationLatestModel
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) Expect(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest) *mModelPublicServiceServerMockWatchOrganizationLatestModel {
	if mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModel != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by Set")
	}

	if mmWatchOrganizationLatestModel.defaultExpectation == nil {
		mmWatchOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation{}
	}

	if mmWatchOrganizationLatestModel.defaultExpectation.paramPtrs != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by ExpectParams functions")
	}

	mmWatchOrganizationLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockWatchOrganizationLatestModelParams{ctx, wp1}
	mmWatchOrganizationLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWatchOrganizationLatestModel.expectations {
		if minimock.Equal(e.params, mmWatchOrganizationLatestModel.defaultExpectation.params) {
			mmWatchOrganizationLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatchOrganizationLatestModel.defaultExpectation.params)
		}
	}

	return mmWatchOrganizationLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.WatchOrganizationLatestModel
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockWatchOrganizationLatestModel {
	if mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModel != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by Set")
	}

	if mmWatchOrganizationLatestModel.defaultExpectation == nil {
		mmWatchOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation{}
	}

	if mmWatchOrganizationLatestModel.defaultExpectation.params != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by Expect")
	}

	if mmWatchOrganizationLatestModel.defaultExpectation.paramPtrs == nil {
		mmWatchOrganizationLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchOrganizationLatestModelParamPtrs{}
	}
	mmWatchOrganizationLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmWatchOrganizationLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWatchOrganizationLatestModel
}

// ExpectWp1Param2 sets up expected param wp1 for ModelPublicServiceServer.WatchOrganizationLatestModel
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) ExpectWp1Param2(wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest) *mModelPublicServiceServerMockWatchOrganizationLatestModel {
	if mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModel != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by Set")
	}

	if mmWatchOrganizationLatestModel.defaultExpectation == nil {
		mmWatchOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation{}
	}

	if mmWatchOrganizationLatestModel.defaultExpectation.params != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by Expect")
	}

	if mmWatchOrganizationLatestModel.defaultExpectation.paramPtrs == nil {
		mmWatchOrganizationLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchOrganizationLatestModelParamPtrs{}
	}
	mmWatchOrganizationLatestModel.defaultExpectation.paramPtrs.wp1 = &wp1
	mmWatchOrganizationLatestModel.defaultExpectation.expectationOrigins.originWp1 = minimock.CallerInfo(1)

	return mmWatchOrganizationLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.WatchOrganizationLatestModel
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) Inspect(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest)) *mModelPublicServiceServerMockWatchOrganizationLatestModel {
	if mmWatchOrganizationLatestModel.mock.inspectFuncWatchOrganizationLatestModel != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.WatchOrganizationLatestModel")
	}

	mmWatchOrganizationLatestModel.mock.inspectFuncWatchOrganizationLatestModel = f

	return mmWatchOrganizationLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.WatchOrganizationLatestModel
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) Return(wp2 *mm_modelv1alpha.WatchOrganizationLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModel != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by Set")
	}

	if mmWatchOrganizationLatestModel.defaultExpectation == nil {
		mmWatchOrganizationLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation{mock: mmWatchOrganizationLatestModel.mock}
	}
	mmWatchOrganizationLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockWatchOrganizationLatestModelResults{wp2, err}
	mmWatchOrganizationLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWatchOrganizationLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.WatchOrganizationLatestModel method
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) Set(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest) (wp2 *mm_modelv1alpha.WatchOrganizationLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmWatchOrganizationLatestModel.defaultExpectation != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.WatchOrganizationLatestModel method")
	}

	if len(mmWatchOrganizationLatestModel.expectations) > 0 {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.WatchOrganizationLatestModel method")
	}

	mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModel = f
	mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModelOrigin = minimock.CallerInfo(1)
	return mmWatchOrganizationLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.WatchOrganizationLatestModel which will trigger the result defined by the following
// Then helper
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) When(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest) *ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation {
	if mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModel != nil {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation{
		mock:               mmWatchOrganizationLatestModel.mock,
		params:             &ModelPublicServiceServerMockWatchOrganizationLatestModelParams{ctx, wp1},
		expectationOrigins: ModelPublicServiceServerMockWatchOrganizationLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWatchOrganizationLatestModel.expectations = append(mmWatchOrganizationLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.WatchOrganizationLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockWatchOrganizationLatestModelExpectation) Then(wp2 *mm_modelv1alpha.WatchOrganizationLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockWatchOrganizationLatestModelResults{wp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.WatchOrganizationLatestModel should be invoked
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) Times(n uint64) *mModelPublicServiceServerMockWatchOrganizationLatestModel {
	if n == 0 {
		mmWatchOrganizationLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.WatchOrganizationLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWatchOrganizationLatestModel.expectedInvocations, n)
	mmWatchOrganizationLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWatchOrganizationLatestModel
}

func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) invocationsDone() bool {
	if len(mmWatchOrganizationLatestModel.expectations) == 0 && mmWatchOrganizationLatestModel.defaultExpectation == nil && mmWatchOrganizationLatestModel.mock.funcWatchOrganizationLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWatchOrganizationLatestModel.mock.afterWatchOrganizationLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWatchOrganizationLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WatchOrganizationLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmWatchOrganizationLatestModel *ModelPublicServiceServerMock) WatchOrganizationLatestModel(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationLatestModelRequest) (wp2 *mm_modelv1alpha.WatchOrganizationLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmWatchOrganizationLatestModel.beforeWatchOrganizationLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmWatchOrganizationLatestModel.afterWatchOrganizationLatestModelCounter, 1)

	mmWatchOrganizationLatestModel.t.Helper()

	if mmWatchOrganizationLatestModel.inspectFuncWatchOrganizationLatestModel != nil {
		mmWatchOrganizationLatestModel.inspectFuncWatchOrganizationLatestModel(ctx, wp1)
	}

	mm_params := ModelPublicServiceServerMockWatchOrganizationLatestModelParams{ctx, wp1}

	// Record call args
	mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.mutex.Lock()
	mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.callArgs = append(mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.callArgs, &mm_params)
	mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.mutex.Unlock()

	for _, e := range mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp2, e.results.err
		}
	}

	if mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockWatchOrganizationLatestModelParams{ctx, wp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWatchOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchOrganizationLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wp1 != nil && !minimock.Equal(*mm_want_ptrs.wp1, mm_got.wp1) {
				mmWatchOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchOrganizationLatestModel got unexpected parameter wp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation.expectationOrigins.originWp1, *mm_want_ptrs.wp1, mm_got.wp1, minimock.Diff(*mm_want_ptrs.wp1, mm_got.wp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatchOrganizationLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchOrganizationLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatchOrganizationLatestModel.WatchOrganizationLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmWatchOrganizationLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.WatchOrganizationLatestModel")
		}
		return (*mm_results).wp2, (*mm_results).err
	}
	if mmWatchOrganizationLatestModel.funcWatchOrganizationLatestModel != nil {
		return mmWatchOrganizationLatestModel.funcWatchOrganizationLatestModel(ctx, wp1)
	}
	mmWatchOrganizationLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.WatchOrganizationLatestModel. %v %v", ctx, wp1)
	return
}

// WatchOrganizationLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.WatchOrganizationLatestModel invocations
func (mmWatchOrganizationLatestModel *ModelPublicServiceServerMock) WatchOrganizationLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchOrganizationLatestModel.afterWatchOrganizationLatestModelCounter)
}

// WatchOrganizationLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.WatchOrganizationLatestModel invocations
func (mmWatchOrganizationLatestModel *ModelPublicServiceServerMock) WatchOrganizationLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchOrganizationLatestModel.beforeWatchOrganizationLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.WatchOrganizationLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatchOrganizationLatestModel *mModelPublicServiceServerMockWatchOrganizationLatestModel) Calls() []*ModelPublicServiceServerMockWatchOrganizationLatestModelParams {
	mmWatchOrganizationLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockWatchOrganizationLatestModelParams, len(mmWatchOrganizationLatestModel.callArgs))
	copy(argCopy, mmWatchOrganizationLatestModel.callArgs)

	mmWatchOrganizationLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockWatchOrganizationLatestModelDone returns true if the count of the WatchOrganizationLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockWatchOrganizationLatestModelDone() bool {
	if m.WatchOrganizationLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WatchOrganizationLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WatchOrganizationLatestModelMock.invocationsDone()
}

// MinimockWatchOrganizationLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockWatchOrganizationLatestModelInspect() {
	for _, e := range m.WatchOrganizationLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWatchOrganizationLatestModelCounter := mm_atomic.LoadUint64(&m.afterWatchOrganizationLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WatchOrganizationLatestModelMock.defaultExpectation != nil && afterWatchOrganizationLatestModelCounter < 1 {
		if m.WatchOrganizationLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationLatestModel at\n%s", m.WatchOrganizationLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationLatestModel at\n%s with params: %#v", m.WatchOrganizationLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.WatchOrganizationLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatchOrganizationLatestModel != nil && afterWatchOrganizationLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationLatestModel at\n%s", m.funcWatchOrganizationLatestModelOrigin)
	}

	if !m.WatchOrganizationLatestModelMock.invocationsDone() && afterWatchOrganizationLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.WatchOrganizationLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WatchOrganizationLatestModelMock.expectedInvocations), m.WatchOrganizationLatestModelMock.expectedInvocationsOrigin, afterWatchOrganizationLatestModelCounter)
	}
}

type mModelPublicServiceServerMockWatchOrganizationModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockWatchOrganizationModelExpectation
	expectations       []*ModelPublicServiceServerMockWatchOrganizationModelExpectation

	callArgs []*ModelPublicServiceServerMockWatchOrganizationModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockWatchOrganizationModelExpectation specifies expectation struct of the ModelPublicServiceServer.WatchOrganizationModel
type ModelPublicServiceServerMockWatchOrganizationModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockWatchOrganizationModelParams
	paramPtrs          *ModelPublicServiceServerMockWatchOrganizationModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockWatchOrganizationModelExpectationOrigins
	results            *ModelPublicServiceServerMockWatchOrganizationModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockWatchOrganizationModelParams contains parameters of the ModelPublicServiceServer.WatchOrganizationModel
type ModelPublicServiceServerMockWatchOrganizationModelParams struct {
	ctx context.Context
	wp1 *mm_modelv1alpha.WatchOrganizationModelRequest
}

// ModelPublicServiceServerMockWatchOrganizationModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.WatchOrganizationModel
type ModelPublicServiceServerMockWatchOrganizationModelParamPtrs struct {
	ctx *context.Context
	wp1 **mm_modelv1alpha.WatchOrganizationModelRequest
}

// ModelPublicServiceServerMockWatchOrganizationModelResults contains results of the ModelPublicServiceServer.WatchOrganizationModel
type ModelPublicServiceServerMockWatchOrganizationModelResults struct {
	wp2 *mm_modelv1alpha.WatchOrganizationModelResponse
	err error
}

// ModelPublicServiceServerMockWatchOrganizationModelOrigins contains origins of expectations of the ModelPublicServiceServer.WatchOrganizationModel
type ModelPublicServiceServerMockWatchOrganizationModelExpectationOrigins struct {
	origin    string
	originCtx string
	originWp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) Optional() *mModelPublicServiceServerMockWatchOrganizationModel {
	mmWatchOrganizationModel.optional = true
	return mmWatchOrganizationModel
}

// Expect sets up expected params for ModelPublicServiceServer.WatchOrganizationModel
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) Expect(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationModelRequest) *mModelPublicServiceServerMockWatchOrganizationModel {
	if mmWatchOrganizationModel.mock.funcWatchOrganizationModel != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by Set")
	}

	if mmWatchOrganizationModel.defaultExpectation == nil {
		mmWatchOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationModelExpectation{}
	}

	if mmWatchOrganizationModel.defaultExpectation.paramPtrs != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by ExpectParams functions")
	}

	mmWatchOrganizationModel.defaultExpectation.params = &ModelPublicServiceServerMockWatchOrganizationModelParams{ctx, wp1}
	mmWatchOrganizationModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWatchOrganizationModel.expectations {
		if minimock.Equal(e.params, mmWatchOrganizationModel.defaultExpectation.params) {
			mmWatchOrganizationModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatchOrganizationModel.defaultExpectation.params)
		}
	}

	return mmWatchOrganizationModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.WatchOrganizationModel
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockWatchOrganizationModel {
	if mmWatchOrganizationModel.mock.funcWatchOrganizationModel != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by Set")
	}

	if mmWatchOrganizationModel.defaultExpectation == nil {
		mmWatchOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationModelExpectation{}
	}

	if mmWatchOrganizationModel.defaultExpectation.params != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by Expect")
	}

	if mmWatchOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmWatchOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchOrganizationModelParamPtrs{}
	}
	mmWatchOrganizationModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmWatchOrganizationModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWatchOrganizationModel
}

// ExpectWp1Param2 sets up expected param wp1 for ModelPublicServiceServer.WatchOrganizationModel
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) ExpectWp1Param2(wp1 *mm_modelv1alpha.WatchOrganizationModelRequest) *mModelPublicServiceServerMockWatchOrganizationModel {
	if mmWatchOrganizationModel.mock.funcWatchOrganizationModel != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by Set")
	}

	if mmWatchOrganizationModel.defaultExpectation == nil {
		mmWatchOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationModelExpectation{}
	}

	if mmWatchOrganizationModel.defaultExpectation.params != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by Expect")
	}

	if mmWatchOrganizationModel.defaultExpectation.paramPtrs == nil {
		mmWatchOrganizationModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchOrganizationModelParamPtrs{}
	}
	mmWatchOrganizationModel.defaultExpectation.paramPtrs.wp1 = &wp1
	mmWatchOrganizationModel.defaultExpectation.expectationOrigins.originWp1 = minimock.CallerInfo(1)

	return mmWatchOrganizationModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.WatchOrganizationModel
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) Inspect(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationModelRequest)) *mModelPublicServiceServerMockWatchOrganizationModel {
	if mmWatchOrganizationModel.mock.inspectFuncWatchOrganizationModel != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.WatchOrganizationModel")
	}

	mmWatchOrganizationModel.mock.inspectFuncWatchOrganizationModel = f

	return mmWatchOrganizationModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.WatchOrganizationModel
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) Return(wp2 *mm_modelv1alpha.WatchOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	if mmWatchOrganizationModel.mock.funcWatchOrganizationModel != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by Set")
	}

	if mmWatchOrganizationModel.defaultExpectation == nil {
		mmWatchOrganizationModel.defaultExpectation = &ModelPublicServiceServerMockWatchOrganizationModelExpectation{mock: mmWatchOrganizationModel.mock}
	}
	mmWatchOrganizationModel.defaultExpectation.results = &ModelPublicServiceServerMockWatchOrganizationModelResults{wp2, err}
	mmWatchOrganizationModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWatchOrganizationModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.WatchOrganizationModel method
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) Set(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationModelRequest) (wp2 *mm_modelv1alpha.WatchOrganizationModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmWatchOrganizationModel.defaultExpectation != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.WatchOrganizationModel method")
	}

	if len(mmWatchOrganizationModel.expectations) > 0 {
		mmWatchOrganizationModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.WatchOrganizationModel method")
	}

	mmWatchOrganizationModel.mock.funcWatchOrganizationModel = f
	mmWatchOrganizationModel.mock.funcWatchOrganizationModelOrigin = minimock.CallerInfo(1)
	return mmWatchOrganizationModel.mock
}

// When sets expectation for the ModelPublicServiceServer.WatchOrganizationModel which will trigger the result defined by the following
// Then helper
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) When(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationModelRequest) *ModelPublicServiceServerMockWatchOrganizationModelExpectation {
	if mmWatchOrganizationModel.mock.funcWatchOrganizationModel != nil {
		mmWatchOrganizationModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchOrganizationModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockWatchOrganizationModelExpectation{
		mock:               mmWatchOrganizationModel.mock,
		params:             &ModelPublicServiceServerMockWatchOrganizationModelParams{ctx, wp1},
		expectationOrigins: ModelPublicServiceServerMockWatchOrganizationModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWatchOrganizationModel.expectations = append(mmWatchOrganizationModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.WatchOrganizationModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockWatchOrganizationModelExpectation) Then(wp2 *mm_modelv1alpha.WatchOrganizationModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockWatchOrganizationModelResults{wp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.WatchOrganizationModel should be invoked
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) Times(n uint64) *mModelPublicServiceServerMockWatchOrganizationModel {
	if n == 0 {
		mmWatchOrganizationModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.WatchOrganizationModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWatchOrganizationModel.expectedInvocations, n)
	mmWatchOrganizationModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWatchOrganizationModel
}

func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) invocationsDone() bool {
	if len(mmWatchOrganizationModel.expectations) == 0 && mmWatchOrganizationModel.defaultExpectation == nil && mmWatchOrganizationModel.mock.funcWatchOrganizationModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWatchOrganizationModel.mock.afterWatchOrganizationModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWatchOrganizationModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WatchOrganizationModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmWatchOrganizationModel *ModelPublicServiceServerMock) WatchOrganizationModel(ctx context.Context, wp1 *mm_modelv1alpha.WatchOrganizationModelRequest) (wp2 *mm_modelv1alpha.WatchOrganizationModelResponse, err error) {
	mm_atomic.AddUint64(&mmWatchOrganizationModel.beforeWatchOrganizationModelCounter, 1)
	defer mm_atomic.AddUint64(&mmWatchOrganizationModel.afterWatchOrganizationModelCounter, 1)

	mmWatchOrganizationModel.t.Helper()

	if mmWatchOrganizationModel.inspectFuncWatchOrganizationModel != nil {
		mmWatchOrganizationModel.inspectFuncWatchOrganizationModel(ctx, wp1)
	}

	mm_params := ModelPublicServiceServerMockWatchOrganizationModelParams{ctx, wp1}

	// Record call args
	mmWatchOrganizationModel.WatchOrganizationModelMock.mutex.Lock()
	mmWatchOrganizationModel.WatchOrganizationModelMock.callArgs = append(mmWatchOrganizationModel.WatchOrganizationModelMock.callArgs, &mm_params)
	mmWatchOrganizationModel.WatchOrganizationModelMock.mutex.Unlock()

	for _, e := range mmWatchOrganizationModel.WatchOrganizationModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp2, e.results.err
		}
	}

	if mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation.Counter, 1)
		mm_want := mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation.params
		mm_want_ptrs := mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockWatchOrganizationModelParams{ctx, wp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWatchOrganizationModel.t.Errorf("ModelPublicServiceServerMock.WatchOrganizationModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wp1 != nil && !minimock.Equal(*mm_want_ptrs.wp1, mm_got.wp1) {
				mmWatchOrganizationModel.t.Errorf("ModelPublicServiceServerMock.WatchOrganizationModel got unexpected parameter wp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation.expectationOrigins.originWp1, *mm_want_ptrs.wp1, mm_got.wp1, minimock.Diff(*mm_want_ptrs.wp1, mm_got.wp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatchOrganizationModel.t.Errorf("ModelPublicServiceServerMock.WatchOrganizationModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatchOrganizationModel.WatchOrganizationModelMock.defaultExpectation.results
		if mm_results == nil {
			mmWatchOrganizationModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.WatchOrganizationModel")
		}
		return (*mm_results).wp2, (*mm_results).err
	}
	if mmWatchOrganizationModel.funcWatchOrganizationModel != nil {
		return mmWatchOrganizationModel.funcWatchOrganizationModel(ctx, wp1)
	}
	mmWatchOrganizationModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.WatchOrganizationModel. %v %v", ctx, wp1)
	return
}

// WatchOrganizationModelAfterCounter returns a count of finished ModelPublicServiceServerMock.WatchOrganizationModel invocations
func (mmWatchOrganizationModel *ModelPublicServiceServerMock) WatchOrganizationModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchOrganizationModel.afterWatchOrganizationModelCounter)
}

// WatchOrganizationModelBeforeCounter returns a count of ModelPublicServiceServerMock.WatchOrganizationModel invocations
func (mmWatchOrganizationModel *ModelPublicServiceServerMock) WatchOrganizationModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchOrganizationModel.beforeWatchOrganizationModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.WatchOrganizationModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatchOrganizationModel *mModelPublicServiceServerMockWatchOrganizationModel) Calls() []*ModelPublicServiceServerMockWatchOrganizationModelParams {
	mmWatchOrganizationModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockWatchOrganizationModelParams, len(mmWatchOrganizationModel.callArgs))
	copy(argCopy, mmWatchOrganizationModel.callArgs)

	mmWatchOrganizationModel.mutex.RUnlock()

	return argCopy
}

// MinimockWatchOrganizationModelDone returns true if the count of the WatchOrganizationModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockWatchOrganizationModelDone() bool {
	if m.WatchOrganizationModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WatchOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WatchOrganizationModelMock.invocationsDone()
}

// MinimockWatchOrganizationModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockWatchOrganizationModelInspect() {
	for _, e := range m.WatchOrganizationModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWatchOrganizationModelCounter := mm_atomic.LoadUint64(&m.afterWatchOrganizationModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WatchOrganizationModelMock.defaultExpectation != nil && afterWatchOrganizationModelCounter < 1 {
		if m.WatchOrganizationModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationModel at\n%s", m.WatchOrganizationModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationModel at\n%s with params: %#v", m.WatchOrganizationModelMock.defaultExpectation.expectationOrigins.origin, *m.WatchOrganizationModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatchOrganizationModel != nil && afterWatchOrganizationModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchOrganizationModel at\n%s", m.funcWatchOrganizationModelOrigin)
	}

	if !m.WatchOrganizationModelMock.invocationsDone() && afterWatchOrganizationModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.WatchOrganizationModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WatchOrganizationModelMock.expectedInvocations), m.WatchOrganizationModelMock.expectedInvocationsOrigin, afterWatchOrganizationModelCounter)
	}
}

type mModelPublicServiceServerMockWatchUserLatestModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockWatchUserLatestModelExpectation
	expectations       []*ModelPublicServiceServerMockWatchUserLatestModelExpectation

	callArgs []*ModelPublicServiceServerMockWatchUserLatestModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockWatchUserLatestModelExpectation specifies expectation struct of the ModelPublicServiceServer.WatchUserLatestModel
type ModelPublicServiceServerMockWatchUserLatestModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockWatchUserLatestModelParams
	paramPtrs          *ModelPublicServiceServerMockWatchUserLatestModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockWatchUserLatestModelExpectationOrigins
	results            *ModelPublicServiceServerMockWatchUserLatestModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockWatchUserLatestModelParams contains parameters of the ModelPublicServiceServer.WatchUserLatestModel
type ModelPublicServiceServerMockWatchUserLatestModelParams struct {
	ctx context.Context
	wp1 *mm_modelv1alpha.WatchUserLatestModelRequest
}

// ModelPublicServiceServerMockWatchUserLatestModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.WatchUserLatestModel
type ModelPublicServiceServerMockWatchUserLatestModelParamPtrs struct {
	ctx *context.Context
	wp1 **mm_modelv1alpha.WatchUserLatestModelRequest
}

// ModelPublicServiceServerMockWatchUserLatestModelResults contains results of the ModelPublicServiceServer.WatchUserLatestModel
type ModelPublicServiceServerMockWatchUserLatestModelResults struct {
	wp2 *mm_modelv1alpha.WatchUserLatestModelResponse
	err error
}

// ModelPublicServiceServerMockWatchUserLatestModelOrigins contains origins of expectations of the ModelPublicServiceServer.WatchUserLatestModel
type ModelPublicServiceServerMockWatchUserLatestModelExpectationOrigins struct {
	origin    string
	originCtx string
	originWp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) Optional() *mModelPublicServiceServerMockWatchUserLatestModel {
	mmWatchUserLatestModel.optional = true
	return mmWatchUserLatestModel
}

// Expect sets up expected params for ModelPublicServiceServer.WatchUserLatestModel
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) Expect(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserLatestModelRequest) *mModelPublicServiceServerMockWatchUserLatestModel {
	if mmWatchUserLatestModel.mock.funcWatchUserLatestModel != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by Set")
	}

	if mmWatchUserLatestModel.defaultExpectation == nil {
		mmWatchUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserLatestModelExpectation{}
	}

	if mmWatchUserLatestModel.defaultExpectation.paramPtrs != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by ExpectParams functions")
	}

	mmWatchUserLatestModel.defaultExpectation.params = &ModelPublicServiceServerMockWatchUserLatestModelParams{ctx, wp1}
	mmWatchUserLatestModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWatchUserLatestModel.expectations {
		if minimock.Equal(e.params, mmWatchUserLatestModel.defaultExpectation.params) {
			mmWatchUserLatestModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatchUserLatestModel.defaultExpectation.params)
		}
	}

	return mmWatchUserLatestModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.WatchUserLatestModel
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockWatchUserLatestModel {
	if mmWatchUserLatestModel.mock.funcWatchUserLatestModel != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by Set")
	}

	if mmWatchUserLatestModel.defaultExpectation == nil {
		mmWatchUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserLatestModelExpectation{}
	}

	if mmWatchUserLatestModel.defaultExpectation.params != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by Expect")
	}

	if mmWatchUserLatestModel.defaultExpectation.paramPtrs == nil {
		mmWatchUserLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchUserLatestModelParamPtrs{}
	}
	mmWatchUserLatestModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmWatchUserLatestModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWatchUserLatestModel
}

// ExpectWp1Param2 sets up expected param wp1 for ModelPublicServiceServer.WatchUserLatestModel
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) ExpectWp1Param2(wp1 *mm_modelv1alpha.WatchUserLatestModelRequest) *mModelPublicServiceServerMockWatchUserLatestModel {
	if mmWatchUserLatestModel.mock.funcWatchUserLatestModel != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by Set")
	}

	if mmWatchUserLatestModel.defaultExpectation == nil {
		mmWatchUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserLatestModelExpectation{}
	}

	if mmWatchUserLatestModel.defaultExpectation.params != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by Expect")
	}

	if mmWatchUserLatestModel.defaultExpectation.paramPtrs == nil {
		mmWatchUserLatestModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchUserLatestModelParamPtrs{}
	}
	mmWatchUserLatestModel.defaultExpectation.paramPtrs.wp1 = &wp1
	mmWatchUserLatestModel.defaultExpectation.expectationOrigins.originWp1 = minimock.CallerInfo(1)

	return mmWatchUserLatestModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.WatchUserLatestModel
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) Inspect(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserLatestModelRequest)) *mModelPublicServiceServerMockWatchUserLatestModel {
	if mmWatchUserLatestModel.mock.inspectFuncWatchUserLatestModel != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.WatchUserLatestModel")
	}

	mmWatchUserLatestModel.mock.inspectFuncWatchUserLatestModel = f

	return mmWatchUserLatestModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.WatchUserLatestModel
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) Return(wp2 *mm_modelv1alpha.WatchUserLatestModelResponse, err error) *ModelPublicServiceServerMock {
	if mmWatchUserLatestModel.mock.funcWatchUserLatestModel != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by Set")
	}

	if mmWatchUserLatestModel.defaultExpectation == nil {
		mmWatchUserLatestModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserLatestModelExpectation{mock: mmWatchUserLatestModel.mock}
	}
	mmWatchUserLatestModel.defaultExpectation.results = &ModelPublicServiceServerMockWatchUserLatestModelResults{wp2, err}
	mmWatchUserLatestModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWatchUserLatestModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.WatchUserLatestModel method
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) Set(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserLatestModelRequest) (wp2 *mm_modelv1alpha.WatchUserLatestModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmWatchUserLatestModel.defaultExpectation != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.WatchUserLatestModel method")
	}

	if len(mmWatchUserLatestModel.expectations) > 0 {
		mmWatchUserLatestModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.WatchUserLatestModel method")
	}

	mmWatchUserLatestModel.mock.funcWatchUserLatestModel = f
	mmWatchUserLatestModel.mock.funcWatchUserLatestModelOrigin = minimock.CallerInfo(1)
	return mmWatchUserLatestModel.mock
}

// When sets expectation for the ModelPublicServiceServer.WatchUserLatestModel which will trigger the result defined by the following
// Then helper
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) When(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserLatestModelRequest) *ModelPublicServiceServerMockWatchUserLatestModelExpectation {
	if mmWatchUserLatestModel.mock.funcWatchUserLatestModel != nil {
		mmWatchUserLatestModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserLatestModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockWatchUserLatestModelExpectation{
		mock:               mmWatchUserLatestModel.mock,
		params:             &ModelPublicServiceServerMockWatchUserLatestModelParams{ctx, wp1},
		expectationOrigins: ModelPublicServiceServerMockWatchUserLatestModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWatchUserLatestModel.expectations = append(mmWatchUserLatestModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.WatchUserLatestModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockWatchUserLatestModelExpectation) Then(wp2 *mm_modelv1alpha.WatchUserLatestModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockWatchUserLatestModelResults{wp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.WatchUserLatestModel should be invoked
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) Times(n uint64) *mModelPublicServiceServerMockWatchUserLatestModel {
	if n == 0 {
		mmWatchUserLatestModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.WatchUserLatestModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWatchUserLatestModel.expectedInvocations, n)
	mmWatchUserLatestModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWatchUserLatestModel
}

func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) invocationsDone() bool {
	if len(mmWatchUserLatestModel.expectations) == 0 && mmWatchUserLatestModel.defaultExpectation == nil && mmWatchUserLatestModel.mock.funcWatchUserLatestModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWatchUserLatestModel.mock.afterWatchUserLatestModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWatchUserLatestModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WatchUserLatestModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmWatchUserLatestModel *ModelPublicServiceServerMock) WatchUserLatestModel(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserLatestModelRequest) (wp2 *mm_modelv1alpha.WatchUserLatestModelResponse, err error) {
	mm_atomic.AddUint64(&mmWatchUserLatestModel.beforeWatchUserLatestModelCounter, 1)
	defer mm_atomic.AddUint64(&mmWatchUserLatestModel.afterWatchUserLatestModelCounter, 1)

	mmWatchUserLatestModel.t.Helper()

	if mmWatchUserLatestModel.inspectFuncWatchUserLatestModel != nil {
		mmWatchUserLatestModel.inspectFuncWatchUserLatestModel(ctx, wp1)
	}

	mm_params := ModelPublicServiceServerMockWatchUserLatestModelParams{ctx, wp1}

	// Record call args
	mmWatchUserLatestModel.WatchUserLatestModelMock.mutex.Lock()
	mmWatchUserLatestModel.WatchUserLatestModelMock.callArgs = append(mmWatchUserLatestModel.WatchUserLatestModelMock.callArgs, &mm_params)
	mmWatchUserLatestModel.WatchUserLatestModelMock.mutex.Unlock()

	for _, e := range mmWatchUserLatestModel.WatchUserLatestModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp2, e.results.err
		}
	}

	if mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation.Counter, 1)
		mm_want := mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation.params
		mm_want_ptrs := mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockWatchUserLatestModelParams{ctx, wp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWatchUserLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchUserLatestModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wp1 != nil && !minimock.Equal(*mm_want_ptrs.wp1, mm_got.wp1) {
				mmWatchUserLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchUserLatestModel got unexpected parameter wp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation.expectationOrigins.originWp1, *mm_want_ptrs.wp1, mm_got.wp1, minimock.Diff(*mm_want_ptrs.wp1, mm_got.wp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatchUserLatestModel.t.Errorf("ModelPublicServiceServerMock.WatchUserLatestModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatchUserLatestModel.WatchUserLatestModelMock.defaultExpectation.results
		if mm_results == nil {
			mmWatchUserLatestModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.WatchUserLatestModel")
		}
		return (*mm_results).wp2, (*mm_results).err
	}
	if mmWatchUserLatestModel.funcWatchUserLatestModel != nil {
		return mmWatchUserLatestModel.funcWatchUserLatestModel(ctx, wp1)
	}
	mmWatchUserLatestModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.WatchUserLatestModel. %v %v", ctx, wp1)
	return
}

// WatchUserLatestModelAfterCounter returns a count of finished ModelPublicServiceServerMock.WatchUserLatestModel invocations
func (mmWatchUserLatestModel *ModelPublicServiceServerMock) WatchUserLatestModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchUserLatestModel.afterWatchUserLatestModelCounter)
}

// WatchUserLatestModelBeforeCounter returns a count of ModelPublicServiceServerMock.WatchUserLatestModel invocations
func (mmWatchUserLatestModel *ModelPublicServiceServerMock) WatchUserLatestModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchUserLatestModel.beforeWatchUserLatestModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.WatchUserLatestModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatchUserLatestModel *mModelPublicServiceServerMockWatchUserLatestModel) Calls() []*ModelPublicServiceServerMockWatchUserLatestModelParams {
	mmWatchUserLatestModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockWatchUserLatestModelParams, len(mmWatchUserLatestModel.callArgs))
	copy(argCopy, mmWatchUserLatestModel.callArgs)

	mmWatchUserLatestModel.mutex.RUnlock()

	return argCopy
}

// MinimockWatchUserLatestModelDone returns true if the count of the WatchUserLatestModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockWatchUserLatestModelDone() bool {
	if m.WatchUserLatestModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WatchUserLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WatchUserLatestModelMock.invocationsDone()
}

// MinimockWatchUserLatestModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockWatchUserLatestModelInspect() {
	for _, e := range m.WatchUserLatestModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserLatestModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWatchUserLatestModelCounter := mm_atomic.LoadUint64(&m.afterWatchUserLatestModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WatchUserLatestModelMock.defaultExpectation != nil && afterWatchUserLatestModelCounter < 1 {
		if m.WatchUserLatestModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserLatestModel at\n%s", m.WatchUserLatestModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserLatestModel at\n%s with params: %#v", m.WatchUserLatestModelMock.defaultExpectation.expectationOrigins.origin, *m.WatchUserLatestModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatchUserLatestModel != nil && afterWatchUserLatestModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserLatestModel at\n%s", m.funcWatchUserLatestModelOrigin)
	}

	if !m.WatchUserLatestModelMock.invocationsDone() && afterWatchUserLatestModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.WatchUserLatestModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WatchUserLatestModelMock.expectedInvocations), m.WatchUserLatestModelMock.expectedInvocationsOrigin, afterWatchUserLatestModelCounter)
	}
}

type mModelPublicServiceServerMockWatchUserModel struct {
	optional           bool
	mock               *ModelPublicServiceServerMock
	defaultExpectation *ModelPublicServiceServerMockWatchUserModelExpectation
	expectations       []*ModelPublicServiceServerMockWatchUserModelExpectation

	callArgs []*ModelPublicServiceServerMockWatchUserModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModelPublicServiceServerMockWatchUserModelExpectation specifies expectation struct of the ModelPublicServiceServer.WatchUserModel
type ModelPublicServiceServerMockWatchUserModelExpectation struct {
	mock               *ModelPublicServiceServerMock
	params             *ModelPublicServiceServerMockWatchUserModelParams
	paramPtrs          *ModelPublicServiceServerMockWatchUserModelParamPtrs
	expectationOrigins ModelPublicServiceServerMockWatchUserModelExpectationOrigins
	results            *ModelPublicServiceServerMockWatchUserModelResults
	returnOrigin       string
	Counter            uint64
}

// ModelPublicServiceServerMockWatchUserModelParams contains parameters of the ModelPublicServiceServer.WatchUserModel
type ModelPublicServiceServerMockWatchUserModelParams struct {
	ctx context.Context
	wp1 *mm_modelv1alpha.WatchUserModelRequest
}

// ModelPublicServiceServerMockWatchUserModelParamPtrs contains pointers to parameters of the ModelPublicServiceServer.WatchUserModel
type ModelPublicServiceServerMockWatchUserModelParamPtrs struct {
	ctx *context.Context
	wp1 **mm_modelv1alpha.WatchUserModelRequest
}

// ModelPublicServiceServerMockWatchUserModelResults contains results of the ModelPublicServiceServer.WatchUserModel
type ModelPublicServiceServerMockWatchUserModelResults struct {
	wp2 *mm_modelv1alpha.WatchUserModelResponse
	err error
}

// ModelPublicServiceServerMockWatchUserModelOrigins contains origins of expectations of the ModelPublicServiceServer.WatchUserModel
type ModelPublicServiceServerMockWatchUserModelExpectationOrigins struct {
	origin    string
	originCtx string
	originWp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) Optional() *mModelPublicServiceServerMockWatchUserModel {
	mmWatchUserModel.optional = true
	return mmWatchUserModel
}

// Expect sets up expected params for ModelPublicServiceServer.WatchUserModel
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) Expect(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserModelRequest) *mModelPublicServiceServerMockWatchUserModel {
	if mmWatchUserModel.mock.funcWatchUserModel != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by Set")
	}

	if mmWatchUserModel.defaultExpectation == nil {
		mmWatchUserModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserModelExpectation{}
	}

	if mmWatchUserModel.defaultExpectation.paramPtrs != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by ExpectParams functions")
	}

	mmWatchUserModel.defaultExpectation.params = &ModelPublicServiceServerMockWatchUserModelParams{ctx, wp1}
	mmWatchUserModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWatchUserModel.expectations {
		if minimock.Equal(e.params, mmWatchUserModel.defaultExpectation.params) {
			mmWatchUserModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatchUserModel.defaultExpectation.params)
		}
	}

	return mmWatchUserModel
}

// ExpectCtxParam1 sets up expected param ctx for ModelPublicServiceServer.WatchUserModel
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) ExpectCtxParam1(ctx context.Context) *mModelPublicServiceServerMockWatchUserModel {
	if mmWatchUserModel.mock.funcWatchUserModel != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by Set")
	}

	if mmWatchUserModel.defaultExpectation == nil {
		mmWatchUserModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserModelExpectation{}
	}

	if mmWatchUserModel.defaultExpectation.params != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by Expect")
	}

	if mmWatchUserModel.defaultExpectation.paramPtrs == nil {
		mmWatchUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchUserModelParamPtrs{}
	}
	mmWatchUserModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmWatchUserModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmWatchUserModel
}

// ExpectWp1Param2 sets up expected param wp1 for ModelPublicServiceServer.WatchUserModel
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) ExpectWp1Param2(wp1 *mm_modelv1alpha.WatchUserModelRequest) *mModelPublicServiceServerMockWatchUserModel {
	if mmWatchUserModel.mock.funcWatchUserModel != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by Set")
	}

	if mmWatchUserModel.defaultExpectation == nil {
		mmWatchUserModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserModelExpectation{}
	}

	if mmWatchUserModel.defaultExpectation.params != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by Expect")
	}

	if mmWatchUserModel.defaultExpectation.paramPtrs == nil {
		mmWatchUserModel.defaultExpectation.paramPtrs = &ModelPublicServiceServerMockWatchUserModelParamPtrs{}
	}
	mmWatchUserModel.defaultExpectation.paramPtrs.wp1 = &wp1
	mmWatchUserModel.defaultExpectation.expectationOrigins.originWp1 = minimock.CallerInfo(1)

	return mmWatchUserModel
}

// Inspect accepts an inspector function that has same arguments as the ModelPublicServiceServer.WatchUserModel
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) Inspect(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserModelRequest)) *mModelPublicServiceServerMockWatchUserModel {
	if mmWatchUserModel.mock.inspectFuncWatchUserModel != nil {
		mmWatchUserModel.mock.t.Fatalf("Inspect function is already set for ModelPublicServiceServerMock.WatchUserModel")
	}

	mmWatchUserModel.mock.inspectFuncWatchUserModel = f

	return mmWatchUserModel
}

// Return sets up results that will be returned by ModelPublicServiceServer.WatchUserModel
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) Return(wp2 *mm_modelv1alpha.WatchUserModelResponse, err error) *ModelPublicServiceServerMock {
	if mmWatchUserModel.mock.funcWatchUserModel != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by Set")
	}

	if mmWatchUserModel.defaultExpectation == nil {
		mmWatchUserModel.defaultExpectation = &ModelPublicServiceServerMockWatchUserModelExpectation{mock: mmWatchUserModel.mock}
	}
	mmWatchUserModel.defaultExpectation.results = &ModelPublicServiceServerMockWatchUserModelResults{wp2, err}
	mmWatchUserModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWatchUserModel.mock
}

// Set uses given function f to mock the ModelPublicServiceServer.WatchUserModel method
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) Set(f func(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserModelRequest) (wp2 *mm_modelv1alpha.WatchUserModelResponse, err error)) *ModelPublicServiceServerMock {
	if mmWatchUserModel.defaultExpectation != nil {
		mmWatchUserModel.mock.t.Fatalf("Default expectation is already set for the ModelPublicServiceServer.WatchUserModel method")
	}

	if len(mmWatchUserModel.expectations) > 0 {
		mmWatchUserModel.mock.t.Fatalf("Some expectations are already set for the ModelPublicServiceServer.WatchUserModel method")
	}

	mmWatchUserModel.mock.funcWatchUserModel = f
	mmWatchUserModel.mock.funcWatchUserModelOrigin = minimock.CallerInfo(1)
	return mmWatchUserModel.mock
}

// When sets expectation for the ModelPublicServiceServer.WatchUserModel which will trigger the result defined by the following
// Then helper
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) When(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserModelRequest) *ModelPublicServiceServerMockWatchUserModelExpectation {
	if mmWatchUserModel.mock.funcWatchUserModel != nil {
		mmWatchUserModel.mock.t.Fatalf("ModelPublicServiceServerMock.WatchUserModel mock is already set by Set")
	}

	expectation := &ModelPublicServiceServerMockWatchUserModelExpectation{
		mock:               mmWatchUserModel.mock,
		params:             &ModelPublicServiceServerMockWatchUserModelParams{ctx, wp1},
		expectationOrigins: ModelPublicServiceServerMockWatchUserModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWatchUserModel.expectations = append(mmWatchUserModel.expectations, expectation)
	return expectation
}

// Then sets up ModelPublicServiceServer.WatchUserModel return parameters for the expectation previously defined by the When method
func (e *ModelPublicServiceServerMockWatchUserModelExpectation) Then(wp2 *mm_modelv1alpha.WatchUserModelResponse, err error) *ModelPublicServiceServerMock {
	e.results = &ModelPublicServiceServerMockWatchUserModelResults{wp2, err}
	return e.mock
}

// Times sets number of times ModelPublicServiceServer.WatchUserModel should be invoked
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) Times(n uint64) *mModelPublicServiceServerMockWatchUserModel {
	if n == 0 {
		mmWatchUserModel.mock.t.Fatalf("Times of ModelPublicServiceServerMock.WatchUserModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWatchUserModel.expectedInvocations, n)
	mmWatchUserModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWatchUserModel
}

func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) invocationsDone() bool {
	if len(mmWatchUserModel.expectations) == 0 && mmWatchUserModel.defaultExpectation == nil && mmWatchUserModel.mock.funcWatchUserModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWatchUserModel.mock.afterWatchUserModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWatchUserModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// WatchUserModel implements mm_modelv1alpha.ModelPublicServiceServer
func (mmWatchUserModel *ModelPublicServiceServerMock) WatchUserModel(ctx context.Context, wp1 *mm_modelv1alpha.WatchUserModelRequest) (wp2 *mm_modelv1alpha.WatchUserModelResponse, err error) {
	mm_atomic.AddUint64(&mmWatchUserModel.beforeWatchUserModelCounter, 1)
	defer mm_atomic.AddUint64(&mmWatchUserModel.afterWatchUserModelCounter, 1)

	mmWatchUserModel.t.Helper()

	if mmWatchUserModel.inspectFuncWatchUserModel != nil {
		mmWatchUserModel.inspectFuncWatchUserModel(ctx, wp1)
	}

	mm_params := ModelPublicServiceServerMockWatchUserModelParams{ctx, wp1}

	// Record call args
	mmWatchUserModel.WatchUserModelMock.mutex.Lock()
	mmWatchUserModel.WatchUserModelMock.callArgs = append(mmWatchUserModel.WatchUserModelMock.callArgs, &mm_params)
	mmWatchUserModel.WatchUserModelMock.mutex.Unlock()

	for _, e := range mmWatchUserModel.WatchUserModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp2, e.results.err
		}
	}

	if mmWatchUserModel.WatchUserModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatchUserModel.WatchUserModelMock.defaultExpectation.Counter, 1)
		mm_want := mmWatchUserModel.WatchUserModelMock.defaultExpectation.params
		mm_want_ptrs := mmWatchUserModel.WatchUserModelMock.defaultExpectation.paramPtrs

		mm_got := ModelPublicServiceServerMockWatchUserModelParams{ctx, wp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmWatchUserModel.t.Errorf("ModelPublicServiceServerMock.WatchUserModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchUserModel.WatchUserModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.wp1 != nil && !minimock.Equal(*mm_want_ptrs.wp1, mm_got.wp1) {
				mmWatchUserModel.t.Errorf("ModelPublicServiceServerMock.WatchUserModel got unexpected parameter wp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWatchUserModel.WatchUserModelMock.defaultExpectation.expectationOrigins.originWp1, *mm_want_ptrs.wp1, mm_got.wp1, minimock.Diff(*mm_want_ptrs.wp1, mm_got.wp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatchUserModel.t.Errorf("ModelPublicServiceServerMock.WatchUserModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWatchUserModel.WatchUserModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatchUserModel.WatchUserModelMock.defaultExpectation.results
		if mm_results == nil {
			mmWatchUserModel.t.Fatal("No results are set for the ModelPublicServiceServerMock.WatchUserModel")
		}
		return (*mm_results).wp2, (*mm_results).err
	}
	if mmWatchUserModel.funcWatchUserModel != nil {
		return mmWatchUserModel.funcWatchUserModel(ctx, wp1)
	}
	mmWatchUserModel.t.Fatalf("Unexpected call to ModelPublicServiceServerMock.WatchUserModel. %v %v", ctx, wp1)
	return
}

// WatchUserModelAfterCounter returns a count of finished ModelPublicServiceServerMock.WatchUserModel invocations
func (mmWatchUserModel *ModelPublicServiceServerMock) WatchUserModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchUserModel.afterWatchUserModelCounter)
}

// WatchUserModelBeforeCounter returns a count of ModelPublicServiceServerMock.WatchUserModel invocations
func (mmWatchUserModel *ModelPublicServiceServerMock) WatchUserModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatchUserModel.beforeWatchUserModelCounter)
}

// Calls returns a list of arguments used in each call to ModelPublicServiceServerMock.WatchUserModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatchUserModel *mModelPublicServiceServerMockWatchUserModel) Calls() []*ModelPublicServiceServerMockWatchUserModelParams {
	mmWatchUserModel.mutex.RLock()

	argCopy := make([]*ModelPublicServiceServerMockWatchUserModelParams, len(mmWatchUserModel.callArgs))
	copy(argCopy, mmWatchUserModel.callArgs)

	mmWatchUserModel.mutex.RUnlock()

	return argCopy
}

// MinimockWatchUserModelDone returns true if the count of the WatchUserModel invocations corresponds
// the number of defined expectations
func (m *ModelPublicServiceServerMock) MinimockWatchUserModelDone() bool {
	if m.WatchUserModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WatchUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WatchUserModelMock.invocationsDone()
}

// MinimockWatchUserModelInspect logs each unmet expectation
func (m *ModelPublicServiceServerMock) MinimockWatchUserModelInspect() {
	for _, e := range m.WatchUserModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWatchUserModelCounter := mm_atomic.LoadUint64(&m.afterWatchUserModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WatchUserModelMock.defaultExpectation != nil && afterWatchUserModelCounter < 1 {
		if m.WatchUserModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserModel at\n%s", m.WatchUserModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserModel at\n%s with params: %#v", m.WatchUserModelMock.defaultExpectation.expectationOrigins.origin, *m.WatchUserModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatchUserModel != nil && afterWatchUserModelCounter < 1 {
		m.t.Errorf("Expected call to ModelPublicServiceServerMock.WatchUserModel at\n%s", m.funcWatchUserModelOrigin)
	}

	if !m.WatchUserModelMock.invocationsDone() && afterWatchUserModelCounter > 0 {
		m.t.Errorf("Expected %d calls to ModelPublicServiceServerMock.WatchUserModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WatchUserModelMock.expectedInvocations), m.WatchUserModelMock.expectedInvocationsOrigin, afterWatchUserModelCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ModelPublicServiceServerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateNamespaceModelInspect()

			m.MinimockCreateOrganizationModelInspect()

			m.MinimockCreateUserModelInspect()

			m.MinimockDeleteNamespaceModelInspect()

			m.MinimockDeleteNamespaceModelVersionInspect()

			m.MinimockDeleteOrganizationModelInspect()

			m.MinimockDeleteOrganizationModelVersionInspect()

			m.MinimockDeleteUserModelInspect()

			m.MinimockDeleteUserModelVersionInspect()

			m.MinimockGetModelDefinitionInspect()

			m.MinimockGetModelOperationInspect()

			m.MinimockGetNamespaceLatestModelOperationInspect()

			m.MinimockGetNamespaceModelInspect()

			m.MinimockGetNamespaceModelOperationInspect()

			m.MinimockGetOrganizationLatestModelOperationInspect()

			m.MinimockGetOrganizationModelInspect()

			m.MinimockGetUserLatestModelOperationInspect()

			m.MinimockGetUserModelInspect()

			m.MinimockListAvailableRegionsInspect()

			m.MinimockListModelDefinitionsInspect()

			m.MinimockListModelRunsInspect()

			m.MinimockListModelRunsByRequesterInspect()

			m.MinimockListModelsInspect()

			m.MinimockListNamespaceModelVersionsInspect()

			m.MinimockListNamespaceModelsInspect()

			m.MinimockListOrganizationModelVersionsInspect()

			m.MinimockListOrganizationModelsInspect()

			m.MinimockListUserModelVersionsInspect()

			m.MinimockListUserModelsInspect()

			m.MinimockLivenessInspect()

			m.MinimockLookUpModelInspect()

			m.MinimockReadinessInspect()

			m.MinimockRenameNamespaceModelInspect()

			m.MinimockRenameOrganizationModelInspect()

			m.MinimockRenameUserModelInspect()

			m.MinimockTriggerAsyncNamespaceLatestModelInspect()

			m.MinimockTriggerAsyncNamespaceModelInspect()

			m.MinimockTriggerAsyncOrganizationLatestModelInspect()

			m.MinimockTriggerAsyncOrganizationModelInspect()

			m.MinimockTriggerAsyncUserLatestModelInspect()

			m.MinimockTriggerAsyncUserModelInspect()

			m.MinimockTriggerNamespaceLatestModelInspect()

			m.MinimockTriggerNamespaceLatestModelBinaryFileUploadInspect()

			m.MinimockTriggerNamespaceModelInspect()

			m.MinimockTriggerNamespaceModelBinaryFileUploadInspect()

			m.MinimockTriggerOrganizationLatestModelInspect()

			m.MinimockTriggerOrganizationModelInspect()

			m.MinimockTriggerOrganizationModelBinaryFileUploadInspect()

			m.MinimockTriggerUserLatestModelInspect()

			m.MinimockTriggerUserModelInspect()

			m.MinimockTriggerUserModelBinaryFileUploadInspect()

			m.MinimockUpdateNamespaceModelInspect()

			m.MinimockUpdateOrganizationModelInspect()

			m.MinimockUpdateUserModelInspect()

			m.MinimockWatchNamespaceLatestModelInspect()

			m.MinimockWatchNamespaceModelInspect()

			m.MinimockWatchOrganizationLatestModelInspect()

			m.MinimockWatchOrganizationModelInspect()

			m.MinimockWatchUserLatestModelInspect()

			m.MinimockWatchUserModelInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ModelPublicServiceServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ModelPublicServiceServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateNamespaceModelDone() &&
		m.MinimockCreateOrganizationModelDone() &&
		m.MinimockCreateUserModelDone() &&
		m.MinimockDeleteNamespaceModelDone() &&
		m.MinimockDeleteNamespaceModelVersionDone() &&
		m.MinimockDeleteOrganizationModelDone() &&
		m.MinimockDeleteOrganizationModelVersionDone() &&
		m.MinimockDeleteUserModelDone() &&
		m.MinimockDeleteUserModelVersionDone() &&
		m.MinimockGetModelDefinitionDone() &&
		m.MinimockGetModelOperationDone() &&
		m.MinimockGetNamespaceLatestModelOperationDone() &&
		m.MinimockGetNamespaceModelDone() &&
		m.MinimockGetNamespaceModelOperationDone() &&
		m.MinimockGetOrganizationLatestModelOperationDone() &&
		m.MinimockGetOrganizationModelDone() &&
		m.MinimockGetUserLatestModelOperationDone() &&
		m.MinimockGetUserModelDone() &&
		m.MinimockListAvailableRegionsDone() &&
		m.MinimockListModelDefinitionsDone() &&
		m.MinimockListModelRunsDone() &&
		m.MinimockListModelRunsByRequesterDone() &&
		m.MinimockListModelsDone() &&
		m.MinimockListNamespaceModelVersionsDone() &&
		m.MinimockListNamespaceModelsDone() &&
		m.MinimockListOrganizationModelVersionsDone() &&
		m.MinimockListOrganizationModelsDone() &&
		m.MinimockListUserModelVersionsDone() &&
		m.MinimockListUserModelsDone() &&
		m.MinimockLivenessDone() &&
		m.MinimockLookUpModelDone() &&
		m.MinimockReadinessDone() &&
		m.MinimockRenameNamespaceModelDone() &&
		m.MinimockRenameOrganizationModelDone() &&
		m.MinimockRenameUserModelDone() &&
		m.MinimockTriggerAsyncNamespaceLatestModelDone() &&
		m.MinimockTriggerAsyncNamespaceModelDone() &&
		m.MinimockTriggerAsyncOrganizationLatestModelDone() &&
		m.MinimockTriggerAsyncOrganizationModelDone() &&
		m.MinimockTriggerAsyncUserLatestModelDone() &&
		m.MinimockTriggerAsyncUserModelDone() &&
		m.MinimockTriggerNamespaceLatestModelDone() &&
		m.MinimockTriggerNamespaceLatestModelBinaryFileUploadDone() &&
		m.MinimockTriggerNamespaceModelDone() &&
		m.MinimockTriggerNamespaceModelBinaryFileUploadDone() &&
		m.MinimockTriggerOrganizationLatestModelDone() &&
		m.MinimockTriggerOrganizationModelDone() &&
		m.MinimockTriggerOrganizationModelBinaryFileUploadDone() &&
		m.MinimockTriggerUserLatestModelDone() &&
		m.MinimockTriggerUserModelDone() &&
		m.MinimockTriggerUserModelBinaryFileUploadDone() &&
		m.MinimockUpdateNamespaceModelDone() &&
		m.MinimockUpdateOrganizationModelDone() &&
		m.MinimockUpdateUserModelDone() &&
		m.MinimockWatchNamespaceLatestModelDone() &&
		m.MinimockWatchNamespaceModelDone() &&
		m.MinimockWatchOrganizationLatestModelDone() &&
		m.MinimockWatchOrganizationModelDone() &&
		m.MinimockWatchUserLatestModelDone() &&
		m.MinimockWatchUserModelDone()
}
