// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_appv1alpha "github.com/instill-ai/protogen-go/app/app/v1alpha"
)

// AppPublicServiceServerMock implements mm_appv1alpha.AppPublicServiceServer
type AppPublicServiceServerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChat          func(ctx context.Context, cp1 *mm_appv1alpha.ChatRequest) (cp2 *mm_appv1alpha.ChatResponse, err error)
	funcChatOrigin    string
	inspectFuncChat   func(ctx context.Context, cp1 *mm_appv1alpha.ChatRequest)
	afterChatCounter  uint64
	beforeChatCounter uint64
	ChatMock          mAppPublicServiceServerMockChat

	funcCreateApp          func(ctx context.Context, cp1 *mm_appv1alpha.CreateAppRequest) (cp2 *mm_appv1alpha.CreateAppResponse, err error)
	funcCreateAppOrigin    string
	inspectFuncCreateApp   func(ctx context.Context, cp1 *mm_appv1alpha.CreateAppRequest)
	afterCreateAppCounter  uint64
	beforeCreateAppCounter uint64
	CreateAppMock          mAppPublicServiceServerMockCreateApp

	funcCreateConversation          func(ctx context.Context, cp1 *mm_appv1alpha.CreateConversationRequest) (cp2 *mm_appv1alpha.CreateConversationResponse, err error)
	funcCreateConversationOrigin    string
	inspectFuncCreateConversation   func(ctx context.Context, cp1 *mm_appv1alpha.CreateConversationRequest)
	afterCreateConversationCounter  uint64
	beforeCreateConversationCounter uint64
	CreateConversationMock          mAppPublicServiceServerMockCreateConversation

	funcCreateMessage          func(ctx context.Context, cp1 *mm_appv1alpha.CreateMessageRequest) (cp2 *mm_appv1alpha.CreateMessageResponse, err error)
	funcCreateMessageOrigin    string
	inspectFuncCreateMessage   func(ctx context.Context, cp1 *mm_appv1alpha.CreateMessageRequest)
	afterCreateMessageCounter  uint64
	beforeCreateMessageCounter uint64
	CreateMessageMock          mAppPublicServiceServerMockCreateMessage

	funcDeleteApp          func(ctx context.Context, dp1 *mm_appv1alpha.DeleteAppRequest) (dp2 *mm_appv1alpha.DeleteAppResponse, err error)
	funcDeleteAppOrigin    string
	inspectFuncDeleteApp   func(ctx context.Context, dp1 *mm_appv1alpha.DeleteAppRequest)
	afterDeleteAppCounter  uint64
	beforeDeleteAppCounter uint64
	DeleteAppMock          mAppPublicServiceServerMockDeleteApp

	funcDeleteConversation          func(ctx context.Context, dp1 *mm_appv1alpha.DeleteConversationRequest) (dp2 *mm_appv1alpha.DeleteConversationResponse, err error)
	funcDeleteConversationOrigin    string
	inspectFuncDeleteConversation   func(ctx context.Context, dp1 *mm_appv1alpha.DeleteConversationRequest)
	afterDeleteConversationCounter  uint64
	beforeDeleteConversationCounter uint64
	DeleteConversationMock          mAppPublicServiceServerMockDeleteConversation

	funcDeleteMessage          func(ctx context.Context, dp1 *mm_appv1alpha.DeleteMessageRequest) (dp2 *mm_appv1alpha.DeleteMessageResponse, err error)
	funcDeleteMessageOrigin    string
	inspectFuncDeleteMessage   func(ctx context.Context, dp1 *mm_appv1alpha.DeleteMessageRequest)
	afterDeleteMessageCounter  uint64
	beforeDeleteMessageCounter uint64
	DeleteMessageMock          mAppPublicServiceServerMockDeleteMessage

	funcGetPlaygroundConversation          func(ctx context.Context, gp1 *mm_appv1alpha.GetPlaygroundConversationRequest) (gp2 *mm_appv1alpha.GetPlaygroundConversationResponse, err error)
	funcGetPlaygroundConversationOrigin    string
	inspectFuncGetPlaygroundConversation   func(ctx context.Context, gp1 *mm_appv1alpha.GetPlaygroundConversationRequest)
	afterGetPlaygroundConversationCounter  uint64
	beforeGetPlaygroundConversationCounter uint64
	GetPlaygroundConversationMock          mAppPublicServiceServerMockGetPlaygroundConversation

	funcListApps          func(ctx context.Context, lp1 *mm_appv1alpha.ListAppsRequest) (lp2 *mm_appv1alpha.ListAppsResponse, err error)
	funcListAppsOrigin    string
	inspectFuncListApps   func(ctx context.Context, lp1 *mm_appv1alpha.ListAppsRequest)
	afterListAppsCounter  uint64
	beforeListAppsCounter uint64
	ListAppsMock          mAppPublicServiceServerMockListApps

	funcListConversations          func(ctx context.Context, lp1 *mm_appv1alpha.ListConversationsRequest) (lp2 *mm_appv1alpha.ListConversationsResponse, err error)
	funcListConversationsOrigin    string
	inspectFuncListConversations   func(ctx context.Context, lp1 *mm_appv1alpha.ListConversationsRequest)
	afterListConversationsCounter  uint64
	beforeListConversationsCounter uint64
	ListConversationsMock          mAppPublicServiceServerMockListConversations

	funcListMessages          func(ctx context.Context, lp1 *mm_appv1alpha.ListMessagesRequest) (lp2 *mm_appv1alpha.ListMessagesResponse, err error)
	funcListMessagesOrigin    string
	inspectFuncListMessages   func(ctx context.Context, lp1 *mm_appv1alpha.ListMessagesRequest)
	afterListMessagesCounter  uint64
	beforeListMessagesCounter uint64
	ListMessagesMock          mAppPublicServiceServerMockListMessages

	funcLiveness          func(ctx context.Context, lp1 *mm_appv1alpha.LivenessRequest) (lp2 *mm_appv1alpha.LivenessResponse, err error)
	funcLivenessOrigin    string
	inspectFuncLiveness   func(ctx context.Context, lp1 *mm_appv1alpha.LivenessRequest)
	afterLivenessCounter  uint64
	beforeLivenessCounter uint64
	LivenessMock          mAppPublicServiceServerMockLiveness

	funcReadiness          func(ctx context.Context, rp1 *mm_appv1alpha.ReadinessRequest) (rp2 *mm_appv1alpha.ReadinessResponse, err error)
	funcReadinessOrigin    string
	inspectFuncReadiness   func(ctx context.Context, rp1 *mm_appv1alpha.ReadinessRequest)
	afterReadinessCounter  uint64
	beforeReadinessCounter uint64
	ReadinessMock          mAppPublicServiceServerMockReadiness

	funcRestartPlaygroundConversation          func(ctx context.Context, rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest) (rp2 *mm_appv1alpha.RestartPlaygroundConversationResponse, err error)
	funcRestartPlaygroundConversationOrigin    string
	inspectFuncRestartPlaygroundConversation   func(ctx context.Context, rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest)
	afterRestartPlaygroundConversationCounter  uint64
	beforeRestartPlaygroundConversationCounter uint64
	RestartPlaygroundConversationMock          mAppPublicServiceServerMockRestartPlaygroundConversation

	funcUpdateApp          func(ctx context.Context, up1 *mm_appv1alpha.UpdateAppRequest) (up2 *mm_appv1alpha.UpdateAppResponse, err error)
	funcUpdateAppOrigin    string
	inspectFuncUpdateApp   func(ctx context.Context, up1 *mm_appv1alpha.UpdateAppRequest)
	afterUpdateAppCounter  uint64
	beforeUpdateAppCounter uint64
	UpdateAppMock          mAppPublicServiceServerMockUpdateApp

	funcUpdateConversation          func(ctx context.Context, up1 *mm_appv1alpha.UpdateConversationRequest) (up2 *mm_appv1alpha.UpdateConversationResponse, err error)
	funcUpdateConversationOrigin    string
	inspectFuncUpdateConversation   func(ctx context.Context, up1 *mm_appv1alpha.UpdateConversationRequest)
	afterUpdateConversationCounter  uint64
	beforeUpdateConversationCounter uint64
	UpdateConversationMock          mAppPublicServiceServerMockUpdateConversation

	funcUpdateMessage          func(ctx context.Context, up1 *mm_appv1alpha.UpdateMessageRequest) (up2 *mm_appv1alpha.UpdateMessageResponse, err error)
	funcUpdateMessageOrigin    string
	inspectFuncUpdateMessage   func(ctx context.Context, up1 *mm_appv1alpha.UpdateMessageRequest)
	afterUpdateMessageCounter  uint64
	beforeUpdateMessageCounter uint64
	UpdateMessageMock          mAppPublicServiceServerMockUpdateMessage
}

// NewAppPublicServiceServerMock returns a mock for mm_appv1alpha.AppPublicServiceServer
func NewAppPublicServiceServerMock(t minimock.Tester) *AppPublicServiceServerMock {
	m := &AppPublicServiceServerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChatMock = mAppPublicServiceServerMockChat{mock: m}
	m.ChatMock.callArgs = []*AppPublicServiceServerMockChatParams{}

	m.CreateAppMock = mAppPublicServiceServerMockCreateApp{mock: m}
	m.CreateAppMock.callArgs = []*AppPublicServiceServerMockCreateAppParams{}

	m.CreateConversationMock = mAppPublicServiceServerMockCreateConversation{mock: m}
	m.CreateConversationMock.callArgs = []*AppPublicServiceServerMockCreateConversationParams{}

	m.CreateMessageMock = mAppPublicServiceServerMockCreateMessage{mock: m}
	m.CreateMessageMock.callArgs = []*AppPublicServiceServerMockCreateMessageParams{}

	m.DeleteAppMock = mAppPublicServiceServerMockDeleteApp{mock: m}
	m.DeleteAppMock.callArgs = []*AppPublicServiceServerMockDeleteAppParams{}

	m.DeleteConversationMock = mAppPublicServiceServerMockDeleteConversation{mock: m}
	m.DeleteConversationMock.callArgs = []*AppPublicServiceServerMockDeleteConversationParams{}

	m.DeleteMessageMock = mAppPublicServiceServerMockDeleteMessage{mock: m}
	m.DeleteMessageMock.callArgs = []*AppPublicServiceServerMockDeleteMessageParams{}

	m.GetPlaygroundConversationMock = mAppPublicServiceServerMockGetPlaygroundConversation{mock: m}
	m.GetPlaygroundConversationMock.callArgs = []*AppPublicServiceServerMockGetPlaygroundConversationParams{}

	m.ListAppsMock = mAppPublicServiceServerMockListApps{mock: m}
	m.ListAppsMock.callArgs = []*AppPublicServiceServerMockListAppsParams{}

	m.ListConversationsMock = mAppPublicServiceServerMockListConversations{mock: m}
	m.ListConversationsMock.callArgs = []*AppPublicServiceServerMockListConversationsParams{}

	m.ListMessagesMock = mAppPublicServiceServerMockListMessages{mock: m}
	m.ListMessagesMock.callArgs = []*AppPublicServiceServerMockListMessagesParams{}

	m.LivenessMock = mAppPublicServiceServerMockLiveness{mock: m}
	m.LivenessMock.callArgs = []*AppPublicServiceServerMockLivenessParams{}

	m.ReadinessMock = mAppPublicServiceServerMockReadiness{mock: m}
	m.ReadinessMock.callArgs = []*AppPublicServiceServerMockReadinessParams{}

	m.RestartPlaygroundConversationMock = mAppPublicServiceServerMockRestartPlaygroundConversation{mock: m}
	m.RestartPlaygroundConversationMock.callArgs = []*AppPublicServiceServerMockRestartPlaygroundConversationParams{}

	m.UpdateAppMock = mAppPublicServiceServerMockUpdateApp{mock: m}
	m.UpdateAppMock.callArgs = []*AppPublicServiceServerMockUpdateAppParams{}

	m.UpdateConversationMock = mAppPublicServiceServerMockUpdateConversation{mock: m}
	m.UpdateConversationMock.callArgs = []*AppPublicServiceServerMockUpdateConversationParams{}

	m.UpdateMessageMock = mAppPublicServiceServerMockUpdateMessage{mock: m}
	m.UpdateMessageMock.callArgs = []*AppPublicServiceServerMockUpdateMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAppPublicServiceServerMockChat struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockChatExpectation
	expectations       []*AppPublicServiceServerMockChatExpectation

	callArgs []*AppPublicServiceServerMockChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockChatExpectation specifies expectation struct of the AppPublicServiceServer.Chat
type AppPublicServiceServerMockChatExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockChatParams
	paramPtrs          *AppPublicServiceServerMockChatParamPtrs
	expectationOrigins AppPublicServiceServerMockChatExpectationOrigins
	results            *AppPublicServiceServerMockChatResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockChatParams contains parameters of the AppPublicServiceServer.Chat
type AppPublicServiceServerMockChatParams struct {
	ctx context.Context
	cp1 *mm_appv1alpha.ChatRequest
}

// AppPublicServiceServerMockChatParamPtrs contains pointers to parameters of the AppPublicServiceServer.Chat
type AppPublicServiceServerMockChatParamPtrs struct {
	ctx *context.Context
	cp1 **mm_appv1alpha.ChatRequest
}

// AppPublicServiceServerMockChatResults contains results of the AppPublicServiceServer.Chat
type AppPublicServiceServerMockChatResults struct {
	cp2 *mm_appv1alpha.ChatResponse
	err error
}

// AppPublicServiceServerMockChatOrigins contains origins of expectations of the AppPublicServiceServer.Chat
type AppPublicServiceServerMockChatExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChat *mAppPublicServiceServerMockChat) Optional() *mAppPublicServiceServerMockChat {
	mmChat.optional = true
	return mmChat
}

// Expect sets up expected params for AppPublicServiceServer.Chat
func (mmChat *mAppPublicServiceServerMockChat) Expect(ctx context.Context, cp1 *mm_appv1alpha.ChatRequest) *mAppPublicServiceServerMockChat {
	if mmChat.mock.funcChat != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by Set")
	}

	if mmChat.defaultExpectation == nil {
		mmChat.defaultExpectation = &AppPublicServiceServerMockChatExpectation{}
	}

	if mmChat.defaultExpectation.paramPtrs != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by ExpectParams functions")
	}

	mmChat.defaultExpectation.params = &AppPublicServiceServerMockChatParams{ctx, cp1}
	mmChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChat.expectations {
		if minimock.Equal(e.params, mmChat.defaultExpectation.params) {
			mmChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChat.defaultExpectation.params)
		}
	}

	return mmChat
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.Chat
func (mmChat *mAppPublicServiceServerMockChat) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockChat {
	if mmChat.mock.funcChat != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by Set")
	}

	if mmChat.defaultExpectation == nil {
		mmChat.defaultExpectation = &AppPublicServiceServerMockChatExpectation{}
	}

	if mmChat.defaultExpectation.params != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by Expect")
	}

	if mmChat.defaultExpectation.paramPtrs == nil {
		mmChat.defaultExpectation.paramPtrs = &AppPublicServiceServerMockChatParamPtrs{}
	}
	mmChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChat
}

// ExpectCp1Param2 sets up expected param cp1 for AppPublicServiceServer.Chat
func (mmChat *mAppPublicServiceServerMockChat) ExpectCp1Param2(cp1 *mm_appv1alpha.ChatRequest) *mAppPublicServiceServerMockChat {
	if mmChat.mock.funcChat != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by Set")
	}

	if mmChat.defaultExpectation == nil {
		mmChat.defaultExpectation = &AppPublicServiceServerMockChatExpectation{}
	}

	if mmChat.defaultExpectation.params != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by Expect")
	}

	if mmChat.defaultExpectation.paramPtrs == nil {
		mmChat.defaultExpectation.paramPtrs = &AppPublicServiceServerMockChatParamPtrs{}
	}
	mmChat.defaultExpectation.paramPtrs.cp1 = &cp1
	mmChat.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmChat
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.Chat
func (mmChat *mAppPublicServiceServerMockChat) Inspect(f func(ctx context.Context, cp1 *mm_appv1alpha.ChatRequest)) *mAppPublicServiceServerMockChat {
	if mmChat.mock.inspectFuncChat != nil {
		mmChat.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.Chat")
	}

	mmChat.mock.inspectFuncChat = f

	return mmChat
}

// Return sets up results that will be returned by AppPublicServiceServer.Chat
func (mmChat *mAppPublicServiceServerMockChat) Return(cp2 *mm_appv1alpha.ChatResponse, err error) *AppPublicServiceServerMock {
	if mmChat.mock.funcChat != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by Set")
	}

	if mmChat.defaultExpectation == nil {
		mmChat.defaultExpectation = &AppPublicServiceServerMockChatExpectation{mock: mmChat.mock}
	}
	mmChat.defaultExpectation.results = &AppPublicServiceServerMockChatResults{cp2, err}
	mmChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChat.mock
}

// Set uses given function f to mock the AppPublicServiceServer.Chat method
func (mmChat *mAppPublicServiceServerMockChat) Set(f func(ctx context.Context, cp1 *mm_appv1alpha.ChatRequest) (cp2 *mm_appv1alpha.ChatResponse, err error)) *AppPublicServiceServerMock {
	if mmChat.defaultExpectation != nil {
		mmChat.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.Chat method")
	}

	if len(mmChat.expectations) > 0 {
		mmChat.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.Chat method")
	}

	mmChat.mock.funcChat = f
	mmChat.mock.funcChatOrigin = minimock.CallerInfo(1)
	return mmChat.mock
}

// When sets expectation for the AppPublicServiceServer.Chat which will trigger the result defined by the following
// Then helper
func (mmChat *mAppPublicServiceServerMockChat) When(ctx context.Context, cp1 *mm_appv1alpha.ChatRequest) *AppPublicServiceServerMockChatExpectation {
	if mmChat.mock.funcChat != nil {
		mmChat.mock.t.Fatalf("AppPublicServiceServerMock.Chat mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockChatExpectation{
		mock:               mmChat.mock,
		params:             &AppPublicServiceServerMockChatParams{ctx, cp1},
		expectationOrigins: AppPublicServiceServerMockChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChat.expectations = append(mmChat.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.Chat return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockChatExpectation) Then(cp2 *mm_appv1alpha.ChatResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockChatResults{cp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.Chat should be invoked
func (mmChat *mAppPublicServiceServerMockChat) Times(n uint64) *mAppPublicServiceServerMockChat {
	if n == 0 {
		mmChat.mock.t.Fatalf("Times of AppPublicServiceServerMock.Chat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChat.expectedInvocations, n)
	mmChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChat
}

func (mmChat *mAppPublicServiceServerMockChat) invocationsDone() bool {
	if len(mmChat.expectations) == 0 && mmChat.defaultExpectation == nil && mmChat.mock.funcChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChat.mock.afterChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Chat implements mm_appv1alpha.AppPublicServiceServer
func (mmChat *AppPublicServiceServerMock) Chat(ctx context.Context, cp1 *mm_appv1alpha.ChatRequest) (cp2 *mm_appv1alpha.ChatResponse, err error) {
	mm_atomic.AddUint64(&mmChat.beforeChatCounter, 1)
	defer mm_atomic.AddUint64(&mmChat.afterChatCounter, 1)

	mmChat.t.Helper()

	if mmChat.inspectFuncChat != nil {
		mmChat.inspectFuncChat(ctx, cp1)
	}

	mm_params := AppPublicServiceServerMockChatParams{ctx, cp1}

	// Record call args
	mmChat.ChatMock.mutex.Lock()
	mmChat.ChatMock.callArgs = append(mmChat.ChatMock.callArgs, &mm_params)
	mmChat.ChatMock.mutex.Unlock()

	for _, e := range mmChat.ChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmChat.ChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChat.ChatMock.defaultExpectation.Counter, 1)
		mm_want := mmChat.ChatMock.defaultExpectation.params
		mm_want_ptrs := mmChat.ChatMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockChatParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChat.t.Errorf("AppPublicServiceServerMock.Chat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChat.ChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmChat.t.Errorf("AppPublicServiceServerMock.Chat got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChat.ChatMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChat.t.Errorf("AppPublicServiceServerMock.Chat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChat.ChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChat.ChatMock.defaultExpectation.results
		if mm_results == nil {
			mmChat.t.Fatal("No results are set for the AppPublicServiceServerMock.Chat")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmChat.funcChat != nil {
		return mmChat.funcChat(ctx, cp1)
	}
	mmChat.t.Fatalf("Unexpected call to AppPublicServiceServerMock.Chat. %v %v", ctx, cp1)
	return
}

// ChatAfterCounter returns a count of finished AppPublicServiceServerMock.Chat invocations
func (mmChat *AppPublicServiceServerMock) ChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChat.afterChatCounter)
}

// ChatBeforeCounter returns a count of AppPublicServiceServerMock.Chat invocations
func (mmChat *AppPublicServiceServerMock) ChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChat.beforeChatCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.Chat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChat *mAppPublicServiceServerMockChat) Calls() []*AppPublicServiceServerMockChatParams {
	mmChat.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockChatParams, len(mmChat.callArgs))
	copy(argCopy, mmChat.callArgs)

	mmChat.mutex.RUnlock()

	return argCopy
}

// MinimockChatDone returns true if the count of the Chat invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockChatDone() bool {
	if m.ChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChatMock.invocationsDone()
}

// MinimockChatInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockChatInspect() {
	for _, e := range m.ChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Chat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChatCounter := mm_atomic.LoadUint64(&m.afterChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChatMock.defaultExpectation != nil && afterChatCounter < 1 {
		if m.ChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Chat at\n%s", m.ChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Chat at\n%s with params: %#v", m.ChatMock.defaultExpectation.expectationOrigins.origin, *m.ChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChat != nil && afterChatCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.Chat at\n%s", m.funcChatOrigin)
	}

	if !m.ChatMock.invocationsDone() && afterChatCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.Chat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChatMock.expectedInvocations), m.ChatMock.expectedInvocationsOrigin, afterChatCounter)
	}
}

type mAppPublicServiceServerMockCreateApp struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockCreateAppExpectation
	expectations       []*AppPublicServiceServerMockCreateAppExpectation

	callArgs []*AppPublicServiceServerMockCreateAppParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockCreateAppExpectation specifies expectation struct of the AppPublicServiceServer.CreateApp
type AppPublicServiceServerMockCreateAppExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockCreateAppParams
	paramPtrs          *AppPublicServiceServerMockCreateAppParamPtrs
	expectationOrigins AppPublicServiceServerMockCreateAppExpectationOrigins
	results            *AppPublicServiceServerMockCreateAppResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockCreateAppParams contains parameters of the AppPublicServiceServer.CreateApp
type AppPublicServiceServerMockCreateAppParams struct {
	ctx context.Context
	cp1 *mm_appv1alpha.CreateAppRequest
}

// AppPublicServiceServerMockCreateAppParamPtrs contains pointers to parameters of the AppPublicServiceServer.CreateApp
type AppPublicServiceServerMockCreateAppParamPtrs struct {
	ctx *context.Context
	cp1 **mm_appv1alpha.CreateAppRequest
}

// AppPublicServiceServerMockCreateAppResults contains results of the AppPublicServiceServer.CreateApp
type AppPublicServiceServerMockCreateAppResults struct {
	cp2 *mm_appv1alpha.CreateAppResponse
	err error
}

// AppPublicServiceServerMockCreateAppOrigins contains origins of expectations of the AppPublicServiceServer.CreateApp
type AppPublicServiceServerMockCreateAppExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) Optional() *mAppPublicServiceServerMockCreateApp {
	mmCreateApp.optional = true
	return mmCreateApp
}

// Expect sets up expected params for AppPublicServiceServer.CreateApp
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) Expect(ctx context.Context, cp1 *mm_appv1alpha.CreateAppRequest) *mAppPublicServiceServerMockCreateApp {
	if mmCreateApp.mock.funcCreateApp != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by Set")
	}

	if mmCreateApp.defaultExpectation == nil {
		mmCreateApp.defaultExpectation = &AppPublicServiceServerMockCreateAppExpectation{}
	}

	if mmCreateApp.defaultExpectation.paramPtrs != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by ExpectParams functions")
	}

	mmCreateApp.defaultExpectation.params = &AppPublicServiceServerMockCreateAppParams{ctx, cp1}
	mmCreateApp.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateApp.expectations {
		if minimock.Equal(e.params, mmCreateApp.defaultExpectation.params) {
			mmCreateApp.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateApp.defaultExpectation.params)
		}
	}

	return mmCreateApp
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.CreateApp
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockCreateApp {
	if mmCreateApp.mock.funcCreateApp != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by Set")
	}

	if mmCreateApp.defaultExpectation == nil {
		mmCreateApp.defaultExpectation = &AppPublicServiceServerMockCreateAppExpectation{}
	}

	if mmCreateApp.defaultExpectation.params != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by Expect")
	}

	if mmCreateApp.defaultExpectation.paramPtrs == nil {
		mmCreateApp.defaultExpectation.paramPtrs = &AppPublicServiceServerMockCreateAppParamPtrs{}
	}
	mmCreateApp.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateApp.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateApp
}

// ExpectCp1Param2 sets up expected param cp1 for AppPublicServiceServer.CreateApp
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) ExpectCp1Param2(cp1 *mm_appv1alpha.CreateAppRequest) *mAppPublicServiceServerMockCreateApp {
	if mmCreateApp.mock.funcCreateApp != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by Set")
	}

	if mmCreateApp.defaultExpectation == nil {
		mmCreateApp.defaultExpectation = &AppPublicServiceServerMockCreateAppExpectation{}
	}

	if mmCreateApp.defaultExpectation.params != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by Expect")
	}

	if mmCreateApp.defaultExpectation.paramPtrs == nil {
		mmCreateApp.defaultExpectation.paramPtrs = &AppPublicServiceServerMockCreateAppParamPtrs{}
	}
	mmCreateApp.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateApp.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateApp
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.CreateApp
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) Inspect(f func(ctx context.Context, cp1 *mm_appv1alpha.CreateAppRequest)) *mAppPublicServiceServerMockCreateApp {
	if mmCreateApp.mock.inspectFuncCreateApp != nil {
		mmCreateApp.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.CreateApp")
	}

	mmCreateApp.mock.inspectFuncCreateApp = f

	return mmCreateApp
}

// Return sets up results that will be returned by AppPublicServiceServer.CreateApp
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) Return(cp2 *mm_appv1alpha.CreateAppResponse, err error) *AppPublicServiceServerMock {
	if mmCreateApp.mock.funcCreateApp != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by Set")
	}

	if mmCreateApp.defaultExpectation == nil {
		mmCreateApp.defaultExpectation = &AppPublicServiceServerMockCreateAppExpectation{mock: mmCreateApp.mock}
	}
	mmCreateApp.defaultExpectation.results = &AppPublicServiceServerMockCreateAppResults{cp2, err}
	mmCreateApp.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateApp.mock
}

// Set uses given function f to mock the AppPublicServiceServer.CreateApp method
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) Set(f func(ctx context.Context, cp1 *mm_appv1alpha.CreateAppRequest) (cp2 *mm_appv1alpha.CreateAppResponse, err error)) *AppPublicServiceServerMock {
	if mmCreateApp.defaultExpectation != nil {
		mmCreateApp.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.CreateApp method")
	}

	if len(mmCreateApp.expectations) > 0 {
		mmCreateApp.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.CreateApp method")
	}

	mmCreateApp.mock.funcCreateApp = f
	mmCreateApp.mock.funcCreateAppOrigin = minimock.CallerInfo(1)
	return mmCreateApp.mock
}

// When sets expectation for the AppPublicServiceServer.CreateApp which will trigger the result defined by the following
// Then helper
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) When(ctx context.Context, cp1 *mm_appv1alpha.CreateAppRequest) *AppPublicServiceServerMockCreateAppExpectation {
	if mmCreateApp.mock.funcCreateApp != nil {
		mmCreateApp.mock.t.Fatalf("AppPublicServiceServerMock.CreateApp mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockCreateAppExpectation{
		mock:               mmCreateApp.mock,
		params:             &AppPublicServiceServerMockCreateAppParams{ctx, cp1},
		expectationOrigins: AppPublicServiceServerMockCreateAppExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateApp.expectations = append(mmCreateApp.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.CreateApp return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockCreateAppExpectation) Then(cp2 *mm_appv1alpha.CreateAppResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockCreateAppResults{cp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.CreateApp should be invoked
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) Times(n uint64) *mAppPublicServiceServerMockCreateApp {
	if n == 0 {
		mmCreateApp.mock.t.Fatalf("Times of AppPublicServiceServerMock.CreateApp mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateApp.expectedInvocations, n)
	mmCreateApp.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateApp
}

func (mmCreateApp *mAppPublicServiceServerMockCreateApp) invocationsDone() bool {
	if len(mmCreateApp.expectations) == 0 && mmCreateApp.defaultExpectation == nil && mmCreateApp.mock.funcCreateApp == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateApp.mock.afterCreateAppCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateApp.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateApp implements mm_appv1alpha.AppPublicServiceServer
func (mmCreateApp *AppPublicServiceServerMock) CreateApp(ctx context.Context, cp1 *mm_appv1alpha.CreateAppRequest) (cp2 *mm_appv1alpha.CreateAppResponse, err error) {
	mm_atomic.AddUint64(&mmCreateApp.beforeCreateAppCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateApp.afterCreateAppCounter, 1)

	mmCreateApp.t.Helper()

	if mmCreateApp.inspectFuncCreateApp != nil {
		mmCreateApp.inspectFuncCreateApp(ctx, cp1)
	}

	mm_params := AppPublicServiceServerMockCreateAppParams{ctx, cp1}

	// Record call args
	mmCreateApp.CreateAppMock.mutex.Lock()
	mmCreateApp.CreateAppMock.callArgs = append(mmCreateApp.CreateAppMock.callArgs, &mm_params)
	mmCreateApp.CreateAppMock.mutex.Unlock()

	for _, e := range mmCreateApp.CreateAppMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateApp.CreateAppMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateApp.CreateAppMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateApp.CreateAppMock.defaultExpectation.params
		mm_want_ptrs := mmCreateApp.CreateAppMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockCreateAppParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateApp.t.Errorf("AppPublicServiceServerMock.CreateApp got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateApp.CreateAppMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateApp.t.Errorf("AppPublicServiceServerMock.CreateApp got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateApp.CreateAppMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateApp.t.Errorf("AppPublicServiceServerMock.CreateApp got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateApp.CreateAppMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateApp.CreateAppMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateApp.t.Fatal("No results are set for the AppPublicServiceServerMock.CreateApp")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateApp.funcCreateApp != nil {
		return mmCreateApp.funcCreateApp(ctx, cp1)
	}
	mmCreateApp.t.Fatalf("Unexpected call to AppPublicServiceServerMock.CreateApp. %v %v", ctx, cp1)
	return
}

// CreateAppAfterCounter returns a count of finished AppPublicServiceServerMock.CreateApp invocations
func (mmCreateApp *AppPublicServiceServerMock) CreateAppAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApp.afterCreateAppCounter)
}

// CreateAppBeforeCounter returns a count of AppPublicServiceServerMock.CreateApp invocations
func (mmCreateApp *AppPublicServiceServerMock) CreateAppBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateApp.beforeCreateAppCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.CreateApp.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateApp *mAppPublicServiceServerMockCreateApp) Calls() []*AppPublicServiceServerMockCreateAppParams {
	mmCreateApp.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockCreateAppParams, len(mmCreateApp.callArgs))
	copy(argCopy, mmCreateApp.callArgs)

	mmCreateApp.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAppDone returns true if the count of the CreateApp invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockCreateAppDone() bool {
	if m.CreateAppMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAppMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAppMock.invocationsDone()
}

// MinimockCreateAppInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockCreateAppInspect() {
	for _, e := range m.CreateAppMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateApp at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAppCounter := mm_atomic.LoadUint64(&m.afterCreateAppCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAppMock.defaultExpectation != nil && afterCreateAppCounter < 1 {
		if m.CreateAppMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateApp at\n%s", m.CreateAppMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateApp at\n%s with params: %#v", m.CreateAppMock.defaultExpectation.expectationOrigins.origin, *m.CreateAppMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateApp != nil && afterCreateAppCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateApp at\n%s", m.funcCreateAppOrigin)
	}

	if !m.CreateAppMock.invocationsDone() && afterCreateAppCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.CreateApp at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAppMock.expectedInvocations), m.CreateAppMock.expectedInvocationsOrigin, afterCreateAppCounter)
	}
}

type mAppPublicServiceServerMockCreateConversation struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockCreateConversationExpectation
	expectations       []*AppPublicServiceServerMockCreateConversationExpectation

	callArgs []*AppPublicServiceServerMockCreateConversationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockCreateConversationExpectation specifies expectation struct of the AppPublicServiceServer.CreateConversation
type AppPublicServiceServerMockCreateConversationExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockCreateConversationParams
	paramPtrs          *AppPublicServiceServerMockCreateConversationParamPtrs
	expectationOrigins AppPublicServiceServerMockCreateConversationExpectationOrigins
	results            *AppPublicServiceServerMockCreateConversationResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockCreateConversationParams contains parameters of the AppPublicServiceServer.CreateConversation
type AppPublicServiceServerMockCreateConversationParams struct {
	ctx context.Context
	cp1 *mm_appv1alpha.CreateConversationRequest
}

// AppPublicServiceServerMockCreateConversationParamPtrs contains pointers to parameters of the AppPublicServiceServer.CreateConversation
type AppPublicServiceServerMockCreateConversationParamPtrs struct {
	ctx *context.Context
	cp1 **mm_appv1alpha.CreateConversationRequest
}

// AppPublicServiceServerMockCreateConversationResults contains results of the AppPublicServiceServer.CreateConversation
type AppPublicServiceServerMockCreateConversationResults struct {
	cp2 *mm_appv1alpha.CreateConversationResponse
	err error
}

// AppPublicServiceServerMockCreateConversationOrigins contains origins of expectations of the AppPublicServiceServer.CreateConversation
type AppPublicServiceServerMockCreateConversationExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) Optional() *mAppPublicServiceServerMockCreateConversation {
	mmCreateConversation.optional = true
	return mmCreateConversation
}

// Expect sets up expected params for AppPublicServiceServer.CreateConversation
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) Expect(ctx context.Context, cp1 *mm_appv1alpha.CreateConversationRequest) *mAppPublicServiceServerMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &AppPublicServiceServerMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.paramPtrs != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by ExpectParams functions")
	}

	mmCreateConversation.defaultExpectation.params = &AppPublicServiceServerMockCreateConversationParams{ctx, cp1}
	mmCreateConversation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateConversation.expectations {
		if minimock.Equal(e.params, mmCreateConversation.defaultExpectation.params) {
			mmCreateConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateConversation.defaultExpectation.params)
		}
	}

	return mmCreateConversation
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.CreateConversation
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &AppPublicServiceServerMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.params != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by Expect")
	}

	if mmCreateConversation.defaultExpectation.paramPtrs == nil {
		mmCreateConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockCreateConversationParamPtrs{}
	}
	mmCreateConversation.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateConversation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateConversation
}

// ExpectCp1Param2 sets up expected param cp1 for AppPublicServiceServer.CreateConversation
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) ExpectCp1Param2(cp1 *mm_appv1alpha.CreateConversationRequest) *mAppPublicServiceServerMockCreateConversation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &AppPublicServiceServerMockCreateConversationExpectation{}
	}

	if mmCreateConversation.defaultExpectation.params != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by Expect")
	}

	if mmCreateConversation.defaultExpectation.paramPtrs == nil {
		mmCreateConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockCreateConversationParamPtrs{}
	}
	mmCreateConversation.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateConversation.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateConversation
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.CreateConversation
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) Inspect(f func(ctx context.Context, cp1 *mm_appv1alpha.CreateConversationRequest)) *mAppPublicServiceServerMockCreateConversation {
	if mmCreateConversation.mock.inspectFuncCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.CreateConversation")
	}

	mmCreateConversation.mock.inspectFuncCreateConversation = f

	return mmCreateConversation
}

// Return sets up results that will be returned by AppPublicServiceServer.CreateConversation
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) Return(cp2 *mm_appv1alpha.CreateConversationResponse, err error) *AppPublicServiceServerMock {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by Set")
	}

	if mmCreateConversation.defaultExpectation == nil {
		mmCreateConversation.defaultExpectation = &AppPublicServiceServerMockCreateConversationExpectation{mock: mmCreateConversation.mock}
	}
	mmCreateConversation.defaultExpectation.results = &AppPublicServiceServerMockCreateConversationResults{cp2, err}
	mmCreateConversation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateConversation.mock
}

// Set uses given function f to mock the AppPublicServiceServer.CreateConversation method
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) Set(f func(ctx context.Context, cp1 *mm_appv1alpha.CreateConversationRequest) (cp2 *mm_appv1alpha.CreateConversationResponse, err error)) *AppPublicServiceServerMock {
	if mmCreateConversation.defaultExpectation != nil {
		mmCreateConversation.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.CreateConversation method")
	}

	if len(mmCreateConversation.expectations) > 0 {
		mmCreateConversation.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.CreateConversation method")
	}

	mmCreateConversation.mock.funcCreateConversation = f
	mmCreateConversation.mock.funcCreateConversationOrigin = minimock.CallerInfo(1)
	return mmCreateConversation.mock
}

// When sets expectation for the AppPublicServiceServer.CreateConversation which will trigger the result defined by the following
// Then helper
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) When(ctx context.Context, cp1 *mm_appv1alpha.CreateConversationRequest) *AppPublicServiceServerMockCreateConversationExpectation {
	if mmCreateConversation.mock.funcCreateConversation != nil {
		mmCreateConversation.mock.t.Fatalf("AppPublicServiceServerMock.CreateConversation mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockCreateConversationExpectation{
		mock:               mmCreateConversation.mock,
		params:             &AppPublicServiceServerMockCreateConversationParams{ctx, cp1},
		expectationOrigins: AppPublicServiceServerMockCreateConversationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateConversation.expectations = append(mmCreateConversation.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.CreateConversation return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockCreateConversationExpectation) Then(cp2 *mm_appv1alpha.CreateConversationResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockCreateConversationResults{cp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.CreateConversation should be invoked
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) Times(n uint64) *mAppPublicServiceServerMockCreateConversation {
	if n == 0 {
		mmCreateConversation.mock.t.Fatalf("Times of AppPublicServiceServerMock.CreateConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateConversation.expectedInvocations, n)
	mmCreateConversation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateConversation
}

func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) invocationsDone() bool {
	if len(mmCreateConversation.expectations) == 0 && mmCreateConversation.defaultExpectation == nil && mmCreateConversation.mock.funcCreateConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateConversation.mock.afterCreateConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateConversation implements mm_appv1alpha.AppPublicServiceServer
func (mmCreateConversation *AppPublicServiceServerMock) CreateConversation(ctx context.Context, cp1 *mm_appv1alpha.CreateConversationRequest) (cp2 *mm_appv1alpha.CreateConversationResponse, err error) {
	mm_atomic.AddUint64(&mmCreateConversation.beforeCreateConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateConversation.afterCreateConversationCounter, 1)

	mmCreateConversation.t.Helper()

	if mmCreateConversation.inspectFuncCreateConversation != nil {
		mmCreateConversation.inspectFuncCreateConversation(ctx, cp1)
	}

	mm_params := AppPublicServiceServerMockCreateConversationParams{ctx, cp1}

	// Record call args
	mmCreateConversation.CreateConversationMock.mutex.Lock()
	mmCreateConversation.CreateConversationMock.callArgs = append(mmCreateConversation.CreateConversationMock.callArgs, &mm_params)
	mmCreateConversation.CreateConversationMock.mutex.Unlock()

	for _, e := range mmCreateConversation.CreateConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateConversation.CreateConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateConversation.CreateConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateConversation.CreateConversationMock.defaultExpectation.params
		mm_want_ptrs := mmCreateConversation.CreateConversationMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockCreateConversationParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateConversation.t.Errorf("AppPublicServiceServerMock.CreateConversation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateConversation.CreateConversationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateConversation.t.Errorf("AppPublicServiceServerMock.CreateConversation got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateConversation.CreateConversationMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateConversation.t.Errorf("AppPublicServiceServerMock.CreateConversation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateConversation.CreateConversationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateConversation.CreateConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateConversation.t.Fatal("No results are set for the AppPublicServiceServerMock.CreateConversation")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateConversation.funcCreateConversation != nil {
		return mmCreateConversation.funcCreateConversation(ctx, cp1)
	}
	mmCreateConversation.t.Fatalf("Unexpected call to AppPublicServiceServerMock.CreateConversation. %v %v", ctx, cp1)
	return
}

// CreateConversationAfterCounter returns a count of finished AppPublicServiceServerMock.CreateConversation invocations
func (mmCreateConversation *AppPublicServiceServerMock) CreateConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConversation.afterCreateConversationCounter)
}

// CreateConversationBeforeCounter returns a count of AppPublicServiceServerMock.CreateConversation invocations
func (mmCreateConversation *AppPublicServiceServerMock) CreateConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateConversation.beforeCreateConversationCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.CreateConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateConversation *mAppPublicServiceServerMockCreateConversation) Calls() []*AppPublicServiceServerMockCreateConversationParams {
	mmCreateConversation.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockCreateConversationParams, len(mmCreateConversation.callArgs))
	copy(argCopy, mmCreateConversation.callArgs)

	mmCreateConversation.mutex.RUnlock()

	return argCopy
}

// MinimockCreateConversationDone returns true if the count of the CreateConversation invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockCreateConversationDone() bool {
	if m.CreateConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateConversationMock.invocationsDone()
}

// MinimockCreateConversationInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockCreateConversationInspect() {
	for _, e := range m.CreateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateConversation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateConversationCounter := mm_atomic.LoadUint64(&m.afterCreateConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateConversationMock.defaultExpectation != nil && afterCreateConversationCounter < 1 {
		if m.CreateConversationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateConversation at\n%s", m.CreateConversationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateConversation at\n%s with params: %#v", m.CreateConversationMock.defaultExpectation.expectationOrigins.origin, *m.CreateConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateConversation != nil && afterCreateConversationCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateConversation at\n%s", m.funcCreateConversationOrigin)
	}

	if !m.CreateConversationMock.invocationsDone() && afterCreateConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.CreateConversation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateConversationMock.expectedInvocations), m.CreateConversationMock.expectedInvocationsOrigin, afterCreateConversationCounter)
	}
}

type mAppPublicServiceServerMockCreateMessage struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockCreateMessageExpectation
	expectations       []*AppPublicServiceServerMockCreateMessageExpectation

	callArgs []*AppPublicServiceServerMockCreateMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockCreateMessageExpectation specifies expectation struct of the AppPublicServiceServer.CreateMessage
type AppPublicServiceServerMockCreateMessageExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockCreateMessageParams
	paramPtrs          *AppPublicServiceServerMockCreateMessageParamPtrs
	expectationOrigins AppPublicServiceServerMockCreateMessageExpectationOrigins
	results            *AppPublicServiceServerMockCreateMessageResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockCreateMessageParams contains parameters of the AppPublicServiceServer.CreateMessage
type AppPublicServiceServerMockCreateMessageParams struct {
	ctx context.Context
	cp1 *mm_appv1alpha.CreateMessageRequest
}

// AppPublicServiceServerMockCreateMessageParamPtrs contains pointers to parameters of the AppPublicServiceServer.CreateMessage
type AppPublicServiceServerMockCreateMessageParamPtrs struct {
	ctx *context.Context
	cp1 **mm_appv1alpha.CreateMessageRequest
}

// AppPublicServiceServerMockCreateMessageResults contains results of the AppPublicServiceServer.CreateMessage
type AppPublicServiceServerMockCreateMessageResults struct {
	cp2 *mm_appv1alpha.CreateMessageResponse
	err error
}

// AppPublicServiceServerMockCreateMessageOrigins contains origins of expectations of the AppPublicServiceServer.CreateMessage
type AppPublicServiceServerMockCreateMessageExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) Optional() *mAppPublicServiceServerMockCreateMessage {
	mmCreateMessage.optional = true
	return mmCreateMessage
}

// Expect sets up expected params for AppPublicServiceServer.CreateMessage
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) Expect(ctx context.Context, cp1 *mm_appv1alpha.CreateMessageRequest) *mAppPublicServiceServerMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &AppPublicServiceServerMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.paramPtrs != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by ExpectParams functions")
	}

	mmCreateMessage.defaultExpectation.params = &AppPublicServiceServerMockCreateMessageParams{ctx, cp1}
	mmCreateMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateMessage.expectations {
		if minimock.Equal(e.params, mmCreateMessage.defaultExpectation.params) {
			mmCreateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateMessage.defaultExpectation.params)
		}
	}

	return mmCreateMessage
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.CreateMessage
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &AppPublicServiceServerMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &AppPublicServiceServerMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateMessage
}

// ExpectCp1Param2 sets up expected param cp1 for AppPublicServiceServer.CreateMessage
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) ExpectCp1Param2(cp1 *mm_appv1alpha.CreateMessageRequest) *mAppPublicServiceServerMockCreateMessage {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &AppPublicServiceServerMockCreateMessageExpectation{}
	}

	if mmCreateMessage.defaultExpectation.params != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by Expect")
	}

	if mmCreateMessage.defaultExpectation.paramPtrs == nil {
		mmCreateMessage.defaultExpectation.paramPtrs = &AppPublicServiceServerMockCreateMessageParamPtrs{}
	}
	mmCreateMessage.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateMessage.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateMessage
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.CreateMessage
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) Inspect(f func(ctx context.Context, cp1 *mm_appv1alpha.CreateMessageRequest)) *mAppPublicServiceServerMockCreateMessage {
	if mmCreateMessage.mock.inspectFuncCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.CreateMessage")
	}

	mmCreateMessage.mock.inspectFuncCreateMessage = f

	return mmCreateMessage
}

// Return sets up results that will be returned by AppPublicServiceServer.CreateMessage
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) Return(cp2 *mm_appv1alpha.CreateMessageResponse, err error) *AppPublicServiceServerMock {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by Set")
	}

	if mmCreateMessage.defaultExpectation == nil {
		mmCreateMessage.defaultExpectation = &AppPublicServiceServerMockCreateMessageExpectation{mock: mmCreateMessage.mock}
	}
	mmCreateMessage.defaultExpectation.results = &AppPublicServiceServerMockCreateMessageResults{cp2, err}
	mmCreateMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// Set uses given function f to mock the AppPublicServiceServer.CreateMessage method
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) Set(f func(ctx context.Context, cp1 *mm_appv1alpha.CreateMessageRequest) (cp2 *mm_appv1alpha.CreateMessageResponse, err error)) *AppPublicServiceServerMock {
	if mmCreateMessage.defaultExpectation != nil {
		mmCreateMessage.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.CreateMessage method")
	}

	if len(mmCreateMessage.expectations) > 0 {
		mmCreateMessage.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.CreateMessage method")
	}

	mmCreateMessage.mock.funcCreateMessage = f
	mmCreateMessage.mock.funcCreateMessageOrigin = minimock.CallerInfo(1)
	return mmCreateMessage.mock
}

// When sets expectation for the AppPublicServiceServer.CreateMessage which will trigger the result defined by the following
// Then helper
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) When(ctx context.Context, cp1 *mm_appv1alpha.CreateMessageRequest) *AppPublicServiceServerMockCreateMessageExpectation {
	if mmCreateMessage.mock.funcCreateMessage != nil {
		mmCreateMessage.mock.t.Fatalf("AppPublicServiceServerMock.CreateMessage mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockCreateMessageExpectation{
		mock:               mmCreateMessage.mock,
		params:             &AppPublicServiceServerMockCreateMessageParams{ctx, cp1},
		expectationOrigins: AppPublicServiceServerMockCreateMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateMessage.expectations = append(mmCreateMessage.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.CreateMessage return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockCreateMessageExpectation) Then(cp2 *mm_appv1alpha.CreateMessageResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockCreateMessageResults{cp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.CreateMessage should be invoked
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) Times(n uint64) *mAppPublicServiceServerMockCreateMessage {
	if n == 0 {
		mmCreateMessage.mock.t.Fatalf("Times of AppPublicServiceServerMock.CreateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateMessage.expectedInvocations, n)
	mmCreateMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateMessage
}

func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) invocationsDone() bool {
	if len(mmCreateMessage.expectations) == 0 && mmCreateMessage.defaultExpectation == nil && mmCreateMessage.mock.funcCreateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateMessage.mock.afterCreateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateMessage implements mm_appv1alpha.AppPublicServiceServer
func (mmCreateMessage *AppPublicServiceServerMock) CreateMessage(ctx context.Context, cp1 *mm_appv1alpha.CreateMessageRequest) (cp2 *mm_appv1alpha.CreateMessageResponse, err error) {
	mm_atomic.AddUint64(&mmCreateMessage.beforeCreateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateMessage.afterCreateMessageCounter, 1)

	mmCreateMessage.t.Helper()

	if mmCreateMessage.inspectFuncCreateMessage != nil {
		mmCreateMessage.inspectFuncCreateMessage(ctx, cp1)
	}

	mm_params := AppPublicServiceServerMockCreateMessageParams{ctx, cp1}

	// Record call args
	mmCreateMessage.CreateMessageMock.mutex.Lock()
	mmCreateMessage.CreateMessageMock.callArgs = append(mmCreateMessage.CreateMessageMock.callArgs, &mm_params)
	mmCreateMessage.CreateMessageMock.mutex.Unlock()

	for _, e := range mmCreateMessage.CreateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateMessage.CreateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateMessage.CreateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateMessage.CreateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmCreateMessage.CreateMessageMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockCreateMessageParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateMessage.t.Errorf("AppPublicServiceServerMock.CreateMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateMessage.t.Errorf("AppPublicServiceServerMock.CreateMessage got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateMessage.t.Errorf("AppPublicServiceServerMock.CreateMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateMessage.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateMessage.CreateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateMessage.t.Fatal("No results are set for the AppPublicServiceServerMock.CreateMessage")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateMessage.funcCreateMessage != nil {
		return mmCreateMessage.funcCreateMessage(ctx, cp1)
	}
	mmCreateMessage.t.Fatalf("Unexpected call to AppPublicServiceServerMock.CreateMessage. %v %v", ctx, cp1)
	return
}

// CreateMessageAfterCounter returns a count of finished AppPublicServiceServerMock.CreateMessage invocations
func (mmCreateMessage *AppPublicServiceServerMock) CreateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.afterCreateMessageCounter)
}

// CreateMessageBeforeCounter returns a count of AppPublicServiceServerMock.CreateMessage invocations
func (mmCreateMessage *AppPublicServiceServerMock) CreateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateMessage.beforeCreateMessageCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.CreateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateMessage *mAppPublicServiceServerMockCreateMessage) Calls() []*AppPublicServiceServerMockCreateMessageParams {
	mmCreateMessage.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockCreateMessageParams, len(mmCreateMessage.callArgs))
	copy(argCopy, mmCreateMessage.callArgs)

	mmCreateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockCreateMessageDone returns true if the count of the CreateMessage invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockCreateMessageDone() bool {
	if m.CreateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMessageMock.invocationsDone()
}

// MinimockCreateMessageInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockCreateMessageInspect() {
	for _, e := range m.CreateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateMessageCounter := mm_atomic.LoadUint64(&m.afterCreateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMessageMock.defaultExpectation != nil && afterCreateMessageCounter < 1 {
		if m.CreateMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateMessage at\n%s", m.CreateMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateMessage at\n%s with params: %#v", m.CreateMessageMock.defaultExpectation.expectationOrigins.origin, *m.CreateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateMessage != nil && afterCreateMessageCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.CreateMessage at\n%s", m.funcCreateMessageOrigin)
	}

	if !m.CreateMessageMock.invocationsDone() && afterCreateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.CreateMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMessageMock.expectedInvocations), m.CreateMessageMock.expectedInvocationsOrigin, afterCreateMessageCounter)
	}
}

type mAppPublicServiceServerMockDeleteApp struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockDeleteAppExpectation
	expectations       []*AppPublicServiceServerMockDeleteAppExpectation

	callArgs []*AppPublicServiceServerMockDeleteAppParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockDeleteAppExpectation specifies expectation struct of the AppPublicServiceServer.DeleteApp
type AppPublicServiceServerMockDeleteAppExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockDeleteAppParams
	paramPtrs          *AppPublicServiceServerMockDeleteAppParamPtrs
	expectationOrigins AppPublicServiceServerMockDeleteAppExpectationOrigins
	results            *AppPublicServiceServerMockDeleteAppResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockDeleteAppParams contains parameters of the AppPublicServiceServer.DeleteApp
type AppPublicServiceServerMockDeleteAppParams struct {
	ctx context.Context
	dp1 *mm_appv1alpha.DeleteAppRequest
}

// AppPublicServiceServerMockDeleteAppParamPtrs contains pointers to parameters of the AppPublicServiceServer.DeleteApp
type AppPublicServiceServerMockDeleteAppParamPtrs struct {
	ctx *context.Context
	dp1 **mm_appv1alpha.DeleteAppRequest
}

// AppPublicServiceServerMockDeleteAppResults contains results of the AppPublicServiceServer.DeleteApp
type AppPublicServiceServerMockDeleteAppResults struct {
	dp2 *mm_appv1alpha.DeleteAppResponse
	err error
}

// AppPublicServiceServerMockDeleteAppOrigins contains origins of expectations of the AppPublicServiceServer.DeleteApp
type AppPublicServiceServerMockDeleteAppExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) Optional() *mAppPublicServiceServerMockDeleteApp {
	mmDeleteApp.optional = true
	return mmDeleteApp
}

// Expect sets up expected params for AppPublicServiceServer.DeleteApp
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) Expect(ctx context.Context, dp1 *mm_appv1alpha.DeleteAppRequest) *mAppPublicServiceServerMockDeleteApp {
	if mmDeleteApp.mock.funcDeleteApp != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by Set")
	}

	if mmDeleteApp.defaultExpectation == nil {
		mmDeleteApp.defaultExpectation = &AppPublicServiceServerMockDeleteAppExpectation{}
	}

	if mmDeleteApp.defaultExpectation.paramPtrs != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by ExpectParams functions")
	}

	mmDeleteApp.defaultExpectation.params = &AppPublicServiceServerMockDeleteAppParams{ctx, dp1}
	mmDeleteApp.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteApp.expectations {
		if minimock.Equal(e.params, mmDeleteApp.defaultExpectation.params) {
			mmDeleteApp.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteApp.defaultExpectation.params)
		}
	}

	return mmDeleteApp
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.DeleteApp
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockDeleteApp {
	if mmDeleteApp.mock.funcDeleteApp != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by Set")
	}

	if mmDeleteApp.defaultExpectation == nil {
		mmDeleteApp.defaultExpectation = &AppPublicServiceServerMockDeleteAppExpectation{}
	}

	if mmDeleteApp.defaultExpectation.params != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by Expect")
	}

	if mmDeleteApp.defaultExpectation.paramPtrs == nil {
		mmDeleteApp.defaultExpectation.paramPtrs = &AppPublicServiceServerMockDeleteAppParamPtrs{}
	}
	mmDeleteApp.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteApp.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteApp
}

// ExpectDp1Param2 sets up expected param dp1 for AppPublicServiceServer.DeleteApp
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) ExpectDp1Param2(dp1 *mm_appv1alpha.DeleteAppRequest) *mAppPublicServiceServerMockDeleteApp {
	if mmDeleteApp.mock.funcDeleteApp != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by Set")
	}

	if mmDeleteApp.defaultExpectation == nil {
		mmDeleteApp.defaultExpectation = &AppPublicServiceServerMockDeleteAppExpectation{}
	}

	if mmDeleteApp.defaultExpectation.params != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by Expect")
	}

	if mmDeleteApp.defaultExpectation.paramPtrs == nil {
		mmDeleteApp.defaultExpectation.paramPtrs = &AppPublicServiceServerMockDeleteAppParamPtrs{}
	}
	mmDeleteApp.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteApp.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteApp
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.DeleteApp
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) Inspect(f func(ctx context.Context, dp1 *mm_appv1alpha.DeleteAppRequest)) *mAppPublicServiceServerMockDeleteApp {
	if mmDeleteApp.mock.inspectFuncDeleteApp != nil {
		mmDeleteApp.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.DeleteApp")
	}

	mmDeleteApp.mock.inspectFuncDeleteApp = f

	return mmDeleteApp
}

// Return sets up results that will be returned by AppPublicServiceServer.DeleteApp
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) Return(dp2 *mm_appv1alpha.DeleteAppResponse, err error) *AppPublicServiceServerMock {
	if mmDeleteApp.mock.funcDeleteApp != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by Set")
	}

	if mmDeleteApp.defaultExpectation == nil {
		mmDeleteApp.defaultExpectation = &AppPublicServiceServerMockDeleteAppExpectation{mock: mmDeleteApp.mock}
	}
	mmDeleteApp.defaultExpectation.results = &AppPublicServiceServerMockDeleteAppResults{dp2, err}
	mmDeleteApp.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteApp.mock
}

// Set uses given function f to mock the AppPublicServiceServer.DeleteApp method
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) Set(f func(ctx context.Context, dp1 *mm_appv1alpha.DeleteAppRequest) (dp2 *mm_appv1alpha.DeleteAppResponse, err error)) *AppPublicServiceServerMock {
	if mmDeleteApp.defaultExpectation != nil {
		mmDeleteApp.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.DeleteApp method")
	}

	if len(mmDeleteApp.expectations) > 0 {
		mmDeleteApp.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.DeleteApp method")
	}

	mmDeleteApp.mock.funcDeleteApp = f
	mmDeleteApp.mock.funcDeleteAppOrigin = minimock.CallerInfo(1)
	return mmDeleteApp.mock
}

// When sets expectation for the AppPublicServiceServer.DeleteApp which will trigger the result defined by the following
// Then helper
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) When(ctx context.Context, dp1 *mm_appv1alpha.DeleteAppRequest) *AppPublicServiceServerMockDeleteAppExpectation {
	if mmDeleteApp.mock.funcDeleteApp != nil {
		mmDeleteApp.mock.t.Fatalf("AppPublicServiceServerMock.DeleteApp mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockDeleteAppExpectation{
		mock:               mmDeleteApp.mock,
		params:             &AppPublicServiceServerMockDeleteAppParams{ctx, dp1},
		expectationOrigins: AppPublicServiceServerMockDeleteAppExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteApp.expectations = append(mmDeleteApp.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.DeleteApp return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockDeleteAppExpectation) Then(dp2 *mm_appv1alpha.DeleteAppResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockDeleteAppResults{dp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.DeleteApp should be invoked
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) Times(n uint64) *mAppPublicServiceServerMockDeleteApp {
	if n == 0 {
		mmDeleteApp.mock.t.Fatalf("Times of AppPublicServiceServerMock.DeleteApp mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteApp.expectedInvocations, n)
	mmDeleteApp.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteApp
}

func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) invocationsDone() bool {
	if len(mmDeleteApp.expectations) == 0 && mmDeleteApp.defaultExpectation == nil && mmDeleteApp.mock.funcDeleteApp == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteApp.mock.afterDeleteAppCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteApp.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteApp implements mm_appv1alpha.AppPublicServiceServer
func (mmDeleteApp *AppPublicServiceServerMock) DeleteApp(ctx context.Context, dp1 *mm_appv1alpha.DeleteAppRequest) (dp2 *mm_appv1alpha.DeleteAppResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteApp.beforeDeleteAppCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteApp.afterDeleteAppCounter, 1)

	mmDeleteApp.t.Helper()

	if mmDeleteApp.inspectFuncDeleteApp != nil {
		mmDeleteApp.inspectFuncDeleteApp(ctx, dp1)
	}

	mm_params := AppPublicServiceServerMockDeleteAppParams{ctx, dp1}

	// Record call args
	mmDeleteApp.DeleteAppMock.mutex.Lock()
	mmDeleteApp.DeleteAppMock.callArgs = append(mmDeleteApp.DeleteAppMock.callArgs, &mm_params)
	mmDeleteApp.DeleteAppMock.mutex.Unlock()

	for _, e := range mmDeleteApp.DeleteAppMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteApp.DeleteAppMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteApp.DeleteAppMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteApp.DeleteAppMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteApp.DeleteAppMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockDeleteAppParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteApp.t.Errorf("AppPublicServiceServerMock.DeleteApp got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteApp.DeleteAppMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteApp.t.Errorf("AppPublicServiceServerMock.DeleteApp got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteApp.DeleteAppMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteApp.t.Errorf("AppPublicServiceServerMock.DeleteApp got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteApp.DeleteAppMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteApp.DeleteAppMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteApp.t.Fatal("No results are set for the AppPublicServiceServerMock.DeleteApp")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteApp.funcDeleteApp != nil {
		return mmDeleteApp.funcDeleteApp(ctx, dp1)
	}
	mmDeleteApp.t.Fatalf("Unexpected call to AppPublicServiceServerMock.DeleteApp. %v %v", ctx, dp1)
	return
}

// DeleteAppAfterCounter returns a count of finished AppPublicServiceServerMock.DeleteApp invocations
func (mmDeleteApp *AppPublicServiceServerMock) DeleteAppAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApp.afterDeleteAppCounter)
}

// DeleteAppBeforeCounter returns a count of AppPublicServiceServerMock.DeleteApp invocations
func (mmDeleteApp *AppPublicServiceServerMock) DeleteAppBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteApp.beforeDeleteAppCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.DeleteApp.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteApp *mAppPublicServiceServerMockDeleteApp) Calls() []*AppPublicServiceServerMockDeleteAppParams {
	mmDeleteApp.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockDeleteAppParams, len(mmDeleteApp.callArgs))
	copy(argCopy, mmDeleteApp.callArgs)

	mmDeleteApp.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAppDone returns true if the count of the DeleteApp invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockDeleteAppDone() bool {
	if m.DeleteAppMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAppMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAppMock.invocationsDone()
}

// MinimockDeleteAppInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockDeleteAppInspect() {
	for _, e := range m.DeleteAppMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteApp at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAppCounter := mm_atomic.LoadUint64(&m.afterDeleteAppCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAppMock.defaultExpectation != nil && afterDeleteAppCounter < 1 {
		if m.DeleteAppMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteApp at\n%s", m.DeleteAppMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteApp at\n%s with params: %#v", m.DeleteAppMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAppMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteApp != nil && afterDeleteAppCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteApp at\n%s", m.funcDeleteAppOrigin)
	}

	if !m.DeleteAppMock.invocationsDone() && afterDeleteAppCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.DeleteApp at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAppMock.expectedInvocations), m.DeleteAppMock.expectedInvocationsOrigin, afterDeleteAppCounter)
	}
}

type mAppPublicServiceServerMockDeleteConversation struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockDeleteConversationExpectation
	expectations       []*AppPublicServiceServerMockDeleteConversationExpectation

	callArgs []*AppPublicServiceServerMockDeleteConversationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockDeleteConversationExpectation specifies expectation struct of the AppPublicServiceServer.DeleteConversation
type AppPublicServiceServerMockDeleteConversationExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockDeleteConversationParams
	paramPtrs          *AppPublicServiceServerMockDeleteConversationParamPtrs
	expectationOrigins AppPublicServiceServerMockDeleteConversationExpectationOrigins
	results            *AppPublicServiceServerMockDeleteConversationResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockDeleteConversationParams contains parameters of the AppPublicServiceServer.DeleteConversation
type AppPublicServiceServerMockDeleteConversationParams struct {
	ctx context.Context
	dp1 *mm_appv1alpha.DeleteConversationRequest
}

// AppPublicServiceServerMockDeleteConversationParamPtrs contains pointers to parameters of the AppPublicServiceServer.DeleteConversation
type AppPublicServiceServerMockDeleteConversationParamPtrs struct {
	ctx *context.Context
	dp1 **mm_appv1alpha.DeleteConversationRequest
}

// AppPublicServiceServerMockDeleteConversationResults contains results of the AppPublicServiceServer.DeleteConversation
type AppPublicServiceServerMockDeleteConversationResults struct {
	dp2 *mm_appv1alpha.DeleteConversationResponse
	err error
}

// AppPublicServiceServerMockDeleteConversationOrigins contains origins of expectations of the AppPublicServiceServer.DeleteConversation
type AppPublicServiceServerMockDeleteConversationExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) Optional() *mAppPublicServiceServerMockDeleteConversation {
	mmDeleteConversation.optional = true
	return mmDeleteConversation
}

// Expect sets up expected params for AppPublicServiceServer.DeleteConversation
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) Expect(ctx context.Context, dp1 *mm_appv1alpha.DeleteConversationRequest) *mAppPublicServiceServerMockDeleteConversation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &AppPublicServiceServerMockDeleteConversationExpectation{}
	}

	if mmDeleteConversation.defaultExpectation.paramPtrs != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by ExpectParams functions")
	}

	mmDeleteConversation.defaultExpectation.params = &AppPublicServiceServerMockDeleteConversationParams{ctx, dp1}
	mmDeleteConversation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteConversation.expectations {
		if minimock.Equal(e.params, mmDeleteConversation.defaultExpectation.params) {
			mmDeleteConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteConversation.defaultExpectation.params)
		}
	}

	return mmDeleteConversation
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.DeleteConversation
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockDeleteConversation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &AppPublicServiceServerMockDeleteConversationExpectation{}
	}

	if mmDeleteConversation.defaultExpectation.params != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by Expect")
	}

	if mmDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmDeleteConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockDeleteConversationParamPtrs{}
	}
	mmDeleteConversation.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteConversation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteConversation
}

// ExpectDp1Param2 sets up expected param dp1 for AppPublicServiceServer.DeleteConversation
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) ExpectDp1Param2(dp1 *mm_appv1alpha.DeleteConversationRequest) *mAppPublicServiceServerMockDeleteConversation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &AppPublicServiceServerMockDeleteConversationExpectation{}
	}

	if mmDeleteConversation.defaultExpectation.params != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by Expect")
	}

	if mmDeleteConversation.defaultExpectation.paramPtrs == nil {
		mmDeleteConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockDeleteConversationParamPtrs{}
	}
	mmDeleteConversation.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteConversation.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteConversation
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.DeleteConversation
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) Inspect(f func(ctx context.Context, dp1 *mm_appv1alpha.DeleteConversationRequest)) *mAppPublicServiceServerMockDeleteConversation {
	if mmDeleteConversation.mock.inspectFuncDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.DeleteConversation")
	}

	mmDeleteConversation.mock.inspectFuncDeleteConversation = f

	return mmDeleteConversation
}

// Return sets up results that will be returned by AppPublicServiceServer.DeleteConversation
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) Return(dp2 *mm_appv1alpha.DeleteConversationResponse, err error) *AppPublicServiceServerMock {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by Set")
	}

	if mmDeleteConversation.defaultExpectation == nil {
		mmDeleteConversation.defaultExpectation = &AppPublicServiceServerMockDeleteConversationExpectation{mock: mmDeleteConversation.mock}
	}
	mmDeleteConversation.defaultExpectation.results = &AppPublicServiceServerMockDeleteConversationResults{dp2, err}
	mmDeleteConversation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteConversation.mock
}

// Set uses given function f to mock the AppPublicServiceServer.DeleteConversation method
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) Set(f func(ctx context.Context, dp1 *mm_appv1alpha.DeleteConversationRequest) (dp2 *mm_appv1alpha.DeleteConversationResponse, err error)) *AppPublicServiceServerMock {
	if mmDeleteConversation.defaultExpectation != nil {
		mmDeleteConversation.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.DeleteConversation method")
	}

	if len(mmDeleteConversation.expectations) > 0 {
		mmDeleteConversation.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.DeleteConversation method")
	}

	mmDeleteConversation.mock.funcDeleteConversation = f
	mmDeleteConversation.mock.funcDeleteConversationOrigin = minimock.CallerInfo(1)
	return mmDeleteConversation.mock
}

// When sets expectation for the AppPublicServiceServer.DeleteConversation which will trigger the result defined by the following
// Then helper
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) When(ctx context.Context, dp1 *mm_appv1alpha.DeleteConversationRequest) *AppPublicServiceServerMockDeleteConversationExpectation {
	if mmDeleteConversation.mock.funcDeleteConversation != nil {
		mmDeleteConversation.mock.t.Fatalf("AppPublicServiceServerMock.DeleteConversation mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockDeleteConversationExpectation{
		mock:               mmDeleteConversation.mock,
		params:             &AppPublicServiceServerMockDeleteConversationParams{ctx, dp1},
		expectationOrigins: AppPublicServiceServerMockDeleteConversationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteConversation.expectations = append(mmDeleteConversation.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.DeleteConversation return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockDeleteConversationExpectation) Then(dp2 *mm_appv1alpha.DeleteConversationResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockDeleteConversationResults{dp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.DeleteConversation should be invoked
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) Times(n uint64) *mAppPublicServiceServerMockDeleteConversation {
	if n == 0 {
		mmDeleteConversation.mock.t.Fatalf("Times of AppPublicServiceServerMock.DeleteConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteConversation.expectedInvocations, n)
	mmDeleteConversation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteConversation
}

func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) invocationsDone() bool {
	if len(mmDeleteConversation.expectations) == 0 && mmDeleteConversation.defaultExpectation == nil && mmDeleteConversation.mock.funcDeleteConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteConversation.mock.afterDeleteConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteConversation implements mm_appv1alpha.AppPublicServiceServer
func (mmDeleteConversation *AppPublicServiceServerMock) DeleteConversation(ctx context.Context, dp1 *mm_appv1alpha.DeleteConversationRequest) (dp2 *mm_appv1alpha.DeleteConversationResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteConversation.beforeDeleteConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteConversation.afterDeleteConversationCounter, 1)

	mmDeleteConversation.t.Helper()

	if mmDeleteConversation.inspectFuncDeleteConversation != nil {
		mmDeleteConversation.inspectFuncDeleteConversation(ctx, dp1)
	}

	mm_params := AppPublicServiceServerMockDeleteConversationParams{ctx, dp1}

	// Record call args
	mmDeleteConversation.DeleteConversationMock.mutex.Lock()
	mmDeleteConversation.DeleteConversationMock.callArgs = append(mmDeleteConversation.DeleteConversationMock.callArgs, &mm_params)
	mmDeleteConversation.DeleteConversationMock.mutex.Unlock()

	for _, e := range mmDeleteConversation.DeleteConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteConversation.DeleteConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteConversation.DeleteConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteConversation.DeleteConversationMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteConversation.DeleteConversationMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockDeleteConversationParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteConversation.t.Errorf("AppPublicServiceServerMock.DeleteConversation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConversation.DeleteConversationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteConversation.t.Errorf("AppPublicServiceServerMock.DeleteConversation got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteConversation.DeleteConversationMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteConversation.t.Errorf("AppPublicServiceServerMock.DeleteConversation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteConversation.DeleteConversationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteConversation.DeleteConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteConversation.t.Fatal("No results are set for the AppPublicServiceServerMock.DeleteConversation")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteConversation.funcDeleteConversation != nil {
		return mmDeleteConversation.funcDeleteConversation(ctx, dp1)
	}
	mmDeleteConversation.t.Fatalf("Unexpected call to AppPublicServiceServerMock.DeleteConversation. %v %v", ctx, dp1)
	return
}

// DeleteConversationAfterCounter returns a count of finished AppPublicServiceServerMock.DeleteConversation invocations
func (mmDeleteConversation *AppPublicServiceServerMock) DeleteConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConversation.afterDeleteConversationCounter)
}

// DeleteConversationBeforeCounter returns a count of AppPublicServiceServerMock.DeleteConversation invocations
func (mmDeleteConversation *AppPublicServiceServerMock) DeleteConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteConversation.beforeDeleteConversationCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.DeleteConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteConversation *mAppPublicServiceServerMockDeleteConversation) Calls() []*AppPublicServiceServerMockDeleteConversationParams {
	mmDeleteConversation.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockDeleteConversationParams, len(mmDeleteConversation.callArgs))
	copy(argCopy, mmDeleteConversation.callArgs)

	mmDeleteConversation.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteConversationDone returns true if the count of the DeleteConversation invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockDeleteConversationDone() bool {
	if m.DeleteConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteConversationMock.invocationsDone()
}

// MinimockDeleteConversationInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockDeleteConversationInspect() {
	for _, e := range m.DeleteConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteConversation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteConversationCounter := mm_atomic.LoadUint64(&m.afterDeleteConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteConversationMock.defaultExpectation != nil && afterDeleteConversationCounter < 1 {
		if m.DeleteConversationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteConversation at\n%s", m.DeleteConversationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteConversation at\n%s with params: %#v", m.DeleteConversationMock.defaultExpectation.expectationOrigins.origin, *m.DeleteConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteConversation != nil && afterDeleteConversationCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteConversation at\n%s", m.funcDeleteConversationOrigin)
	}

	if !m.DeleteConversationMock.invocationsDone() && afterDeleteConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.DeleteConversation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteConversationMock.expectedInvocations), m.DeleteConversationMock.expectedInvocationsOrigin, afterDeleteConversationCounter)
	}
}

type mAppPublicServiceServerMockDeleteMessage struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockDeleteMessageExpectation
	expectations       []*AppPublicServiceServerMockDeleteMessageExpectation

	callArgs []*AppPublicServiceServerMockDeleteMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockDeleteMessageExpectation specifies expectation struct of the AppPublicServiceServer.DeleteMessage
type AppPublicServiceServerMockDeleteMessageExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockDeleteMessageParams
	paramPtrs          *AppPublicServiceServerMockDeleteMessageParamPtrs
	expectationOrigins AppPublicServiceServerMockDeleteMessageExpectationOrigins
	results            *AppPublicServiceServerMockDeleteMessageResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockDeleteMessageParams contains parameters of the AppPublicServiceServer.DeleteMessage
type AppPublicServiceServerMockDeleteMessageParams struct {
	ctx context.Context
	dp1 *mm_appv1alpha.DeleteMessageRequest
}

// AppPublicServiceServerMockDeleteMessageParamPtrs contains pointers to parameters of the AppPublicServiceServer.DeleteMessage
type AppPublicServiceServerMockDeleteMessageParamPtrs struct {
	ctx *context.Context
	dp1 **mm_appv1alpha.DeleteMessageRequest
}

// AppPublicServiceServerMockDeleteMessageResults contains results of the AppPublicServiceServer.DeleteMessage
type AppPublicServiceServerMockDeleteMessageResults struct {
	dp2 *mm_appv1alpha.DeleteMessageResponse
	err error
}

// AppPublicServiceServerMockDeleteMessageOrigins contains origins of expectations of the AppPublicServiceServer.DeleteMessage
type AppPublicServiceServerMockDeleteMessageExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) Optional() *mAppPublicServiceServerMockDeleteMessage {
	mmDeleteMessage.optional = true
	return mmDeleteMessage
}

// Expect sets up expected params for AppPublicServiceServer.DeleteMessage
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) Expect(ctx context.Context, dp1 *mm_appv1alpha.DeleteMessageRequest) *mAppPublicServiceServerMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &AppPublicServiceServerMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by ExpectParams functions")
	}

	mmDeleteMessage.defaultExpectation.params = &AppPublicServiceServerMockDeleteMessageParams{ctx, dp1}
	mmDeleteMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteMessage.expectations {
		if minimock.Equal(e.params, mmDeleteMessage.defaultExpectation.params) {
			mmDeleteMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMessage.defaultExpectation.params)
		}
	}

	return mmDeleteMessage
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.DeleteMessage
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &AppPublicServiceServerMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &AppPublicServiceServerMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteMessage
}

// ExpectDp1Param2 sets up expected param dp1 for AppPublicServiceServer.DeleteMessage
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) ExpectDp1Param2(dp1 *mm_appv1alpha.DeleteMessageRequest) *mAppPublicServiceServerMockDeleteMessage {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &AppPublicServiceServerMockDeleteMessageExpectation{}
	}

	if mmDeleteMessage.defaultExpectation.params != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by Expect")
	}

	if mmDeleteMessage.defaultExpectation.paramPtrs == nil {
		mmDeleteMessage.defaultExpectation.paramPtrs = &AppPublicServiceServerMockDeleteMessageParamPtrs{}
	}
	mmDeleteMessage.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteMessage.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteMessage
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.DeleteMessage
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) Inspect(f func(ctx context.Context, dp1 *mm_appv1alpha.DeleteMessageRequest)) *mAppPublicServiceServerMockDeleteMessage {
	if mmDeleteMessage.mock.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.DeleteMessage")
	}

	mmDeleteMessage.mock.inspectFuncDeleteMessage = f

	return mmDeleteMessage
}

// Return sets up results that will be returned by AppPublicServiceServer.DeleteMessage
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) Return(dp2 *mm_appv1alpha.DeleteMessageResponse, err error) *AppPublicServiceServerMock {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by Set")
	}

	if mmDeleteMessage.defaultExpectation == nil {
		mmDeleteMessage.defaultExpectation = &AppPublicServiceServerMockDeleteMessageExpectation{mock: mmDeleteMessage.mock}
	}
	mmDeleteMessage.defaultExpectation.results = &AppPublicServiceServerMockDeleteMessageResults{dp2, err}
	mmDeleteMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteMessage.mock
}

// Set uses given function f to mock the AppPublicServiceServer.DeleteMessage method
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) Set(f func(ctx context.Context, dp1 *mm_appv1alpha.DeleteMessageRequest) (dp2 *mm_appv1alpha.DeleteMessageResponse, err error)) *AppPublicServiceServerMock {
	if mmDeleteMessage.defaultExpectation != nil {
		mmDeleteMessage.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.DeleteMessage method")
	}

	if len(mmDeleteMessage.expectations) > 0 {
		mmDeleteMessage.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.DeleteMessage method")
	}

	mmDeleteMessage.mock.funcDeleteMessage = f
	mmDeleteMessage.mock.funcDeleteMessageOrigin = minimock.CallerInfo(1)
	return mmDeleteMessage.mock
}

// When sets expectation for the AppPublicServiceServer.DeleteMessage which will trigger the result defined by the following
// Then helper
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) When(ctx context.Context, dp1 *mm_appv1alpha.DeleteMessageRequest) *AppPublicServiceServerMockDeleteMessageExpectation {
	if mmDeleteMessage.mock.funcDeleteMessage != nil {
		mmDeleteMessage.mock.t.Fatalf("AppPublicServiceServerMock.DeleteMessage mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockDeleteMessageExpectation{
		mock:               mmDeleteMessage.mock,
		params:             &AppPublicServiceServerMockDeleteMessageParams{ctx, dp1},
		expectationOrigins: AppPublicServiceServerMockDeleteMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteMessage.expectations = append(mmDeleteMessage.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.DeleteMessage return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockDeleteMessageExpectation) Then(dp2 *mm_appv1alpha.DeleteMessageResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockDeleteMessageResults{dp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.DeleteMessage should be invoked
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) Times(n uint64) *mAppPublicServiceServerMockDeleteMessage {
	if n == 0 {
		mmDeleteMessage.mock.t.Fatalf("Times of AppPublicServiceServerMock.DeleteMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteMessage.expectedInvocations, n)
	mmDeleteMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteMessage
}

func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) invocationsDone() bool {
	if len(mmDeleteMessage.expectations) == 0 && mmDeleteMessage.defaultExpectation == nil && mmDeleteMessage.mock.funcDeleteMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.mock.afterDeleteMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteMessage implements mm_appv1alpha.AppPublicServiceServer
func (mmDeleteMessage *AppPublicServiceServerMock) DeleteMessage(ctx context.Context, dp1 *mm_appv1alpha.DeleteMessageRequest) (dp2 *mm_appv1alpha.DeleteMessageResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteMessage.beforeDeleteMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMessage.afterDeleteMessageCounter, 1)

	mmDeleteMessage.t.Helper()

	if mmDeleteMessage.inspectFuncDeleteMessage != nil {
		mmDeleteMessage.inspectFuncDeleteMessage(ctx, dp1)
	}

	mm_params := AppPublicServiceServerMockDeleteMessageParams{ctx, dp1}

	// Record call args
	mmDeleteMessage.DeleteMessageMock.mutex.Lock()
	mmDeleteMessage.DeleteMessageMock.callArgs = append(mmDeleteMessage.DeleteMessageMock.callArgs, &mm_params)
	mmDeleteMessage.DeleteMessageMock.mutex.Unlock()

	for _, e := range mmDeleteMessage.DeleteMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteMessage.DeleteMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMessage.DeleteMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMessage.DeleteMessageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteMessage.DeleteMessageMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockDeleteMessageParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteMessage.t.Errorf("AppPublicServiceServerMock.DeleteMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteMessage.DeleteMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteMessage.t.Errorf("AppPublicServiceServerMock.DeleteMessage got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteMessage.DeleteMessageMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMessage.t.Errorf("AppPublicServiceServerMock.DeleteMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteMessage.DeleteMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMessage.DeleteMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMessage.t.Fatal("No results are set for the AppPublicServiceServerMock.DeleteMessage")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteMessage.funcDeleteMessage != nil {
		return mmDeleteMessage.funcDeleteMessage(ctx, dp1)
	}
	mmDeleteMessage.t.Fatalf("Unexpected call to AppPublicServiceServerMock.DeleteMessage. %v %v", ctx, dp1)
	return
}

// DeleteMessageAfterCounter returns a count of finished AppPublicServiceServerMock.DeleteMessage invocations
func (mmDeleteMessage *AppPublicServiceServerMock) DeleteMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.afterDeleteMessageCounter)
}

// DeleteMessageBeforeCounter returns a count of AppPublicServiceServerMock.DeleteMessage invocations
func (mmDeleteMessage *AppPublicServiceServerMock) DeleteMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMessage.beforeDeleteMessageCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.DeleteMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMessage *mAppPublicServiceServerMockDeleteMessage) Calls() []*AppPublicServiceServerMockDeleteMessageParams {
	mmDeleteMessage.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockDeleteMessageParams, len(mmDeleteMessage.callArgs))
	copy(argCopy, mmDeleteMessage.callArgs)

	mmDeleteMessage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMessageDone returns true if the count of the DeleteMessage invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockDeleteMessageDone() bool {
	if m.DeleteMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMessageMock.invocationsDone()
}

// MinimockDeleteMessageInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockDeleteMessageInspect() {
	for _, e := range m.DeleteMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteMessageCounter := mm_atomic.LoadUint64(&m.afterDeleteMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMessageMock.defaultExpectation != nil && afterDeleteMessageCounter < 1 {
		if m.DeleteMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteMessage at\n%s", m.DeleteMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteMessage at\n%s with params: %#v", m.DeleteMessageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMessage != nil && afterDeleteMessageCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.DeleteMessage at\n%s", m.funcDeleteMessageOrigin)
	}

	if !m.DeleteMessageMock.invocationsDone() && afterDeleteMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.DeleteMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMessageMock.expectedInvocations), m.DeleteMessageMock.expectedInvocationsOrigin, afterDeleteMessageCounter)
	}
}

type mAppPublicServiceServerMockGetPlaygroundConversation struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockGetPlaygroundConversationExpectation
	expectations       []*AppPublicServiceServerMockGetPlaygroundConversationExpectation

	callArgs []*AppPublicServiceServerMockGetPlaygroundConversationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockGetPlaygroundConversationExpectation specifies expectation struct of the AppPublicServiceServer.GetPlaygroundConversation
type AppPublicServiceServerMockGetPlaygroundConversationExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockGetPlaygroundConversationParams
	paramPtrs          *AppPublicServiceServerMockGetPlaygroundConversationParamPtrs
	expectationOrigins AppPublicServiceServerMockGetPlaygroundConversationExpectationOrigins
	results            *AppPublicServiceServerMockGetPlaygroundConversationResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockGetPlaygroundConversationParams contains parameters of the AppPublicServiceServer.GetPlaygroundConversation
type AppPublicServiceServerMockGetPlaygroundConversationParams struct {
	ctx context.Context
	gp1 *mm_appv1alpha.GetPlaygroundConversationRequest
}

// AppPublicServiceServerMockGetPlaygroundConversationParamPtrs contains pointers to parameters of the AppPublicServiceServer.GetPlaygroundConversation
type AppPublicServiceServerMockGetPlaygroundConversationParamPtrs struct {
	ctx *context.Context
	gp1 **mm_appv1alpha.GetPlaygroundConversationRequest
}

// AppPublicServiceServerMockGetPlaygroundConversationResults contains results of the AppPublicServiceServer.GetPlaygroundConversation
type AppPublicServiceServerMockGetPlaygroundConversationResults struct {
	gp2 *mm_appv1alpha.GetPlaygroundConversationResponse
	err error
}

// AppPublicServiceServerMockGetPlaygroundConversationOrigins contains origins of expectations of the AppPublicServiceServer.GetPlaygroundConversation
type AppPublicServiceServerMockGetPlaygroundConversationExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) Optional() *mAppPublicServiceServerMockGetPlaygroundConversation {
	mmGetPlaygroundConversation.optional = true
	return mmGetPlaygroundConversation
}

// Expect sets up expected params for AppPublicServiceServer.GetPlaygroundConversation
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) Expect(ctx context.Context, gp1 *mm_appv1alpha.GetPlaygroundConversationRequest) *mAppPublicServiceServerMockGetPlaygroundConversation {
	if mmGetPlaygroundConversation.mock.funcGetPlaygroundConversation != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by Set")
	}

	if mmGetPlaygroundConversation.defaultExpectation == nil {
		mmGetPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockGetPlaygroundConversationExpectation{}
	}

	if mmGetPlaygroundConversation.defaultExpectation.paramPtrs != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by ExpectParams functions")
	}

	mmGetPlaygroundConversation.defaultExpectation.params = &AppPublicServiceServerMockGetPlaygroundConversationParams{ctx, gp1}
	mmGetPlaygroundConversation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPlaygroundConversation.expectations {
		if minimock.Equal(e.params, mmGetPlaygroundConversation.defaultExpectation.params) {
			mmGetPlaygroundConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPlaygroundConversation.defaultExpectation.params)
		}
	}

	return mmGetPlaygroundConversation
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.GetPlaygroundConversation
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockGetPlaygroundConversation {
	if mmGetPlaygroundConversation.mock.funcGetPlaygroundConversation != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by Set")
	}

	if mmGetPlaygroundConversation.defaultExpectation == nil {
		mmGetPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockGetPlaygroundConversationExpectation{}
	}

	if mmGetPlaygroundConversation.defaultExpectation.params != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by Expect")
	}

	if mmGetPlaygroundConversation.defaultExpectation.paramPtrs == nil {
		mmGetPlaygroundConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockGetPlaygroundConversationParamPtrs{}
	}
	mmGetPlaygroundConversation.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPlaygroundConversation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPlaygroundConversation
}

// ExpectGp1Param2 sets up expected param gp1 for AppPublicServiceServer.GetPlaygroundConversation
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) ExpectGp1Param2(gp1 *mm_appv1alpha.GetPlaygroundConversationRequest) *mAppPublicServiceServerMockGetPlaygroundConversation {
	if mmGetPlaygroundConversation.mock.funcGetPlaygroundConversation != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by Set")
	}

	if mmGetPlaygroundConversation.defaultExpectation == nil {
		mmGetPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockGetPlaygroundConversationExpectation{}
	}

	if mmGetPlaygroundConversation.defaultExpectation.params != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by Expect")
	}

	if mmGetPlaygroundConversation.defaultExpectation.paramPtrs == nil {
		mmGetPlaygroundConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockGetPlaygroundConversationParamPtrs{}
	}
	mmGetPlaygroundConversation.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetPlaygroundConversation.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetPlaygroundConversation
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.GetPlaygroundConversation
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) Inspect(f func(ctx context.Context, gp1 *mm_appv1alpha.GetPlaygroundConversationRequest)) *mAppPublicServiceServerMockGetPlaygroundConversation {
	if mmGetPlaygroundConversation.mock.inspectFuncGetPlaygroundConversation != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.GetPlaygroundConversation")
	}

	mmGetPlaygroundConversation.mock.inspectFuncGetPlaygroundConversation = f

	return mmGetPlaygroundConversation
}

// Return sets up results that will be returned by AppPublicServiceServer.GetPlaygroundConversation
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) Return(gp2 *mm_appv1alpha.GetPlaygroundConversationResponse, err error) *AppPublicServiceServerMock {
	if mmGetPlaygroundConversation.mock.funcGetPlaygroundConversation != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by Set")
	}

	if mmGetPlaygroundConversation.defaultExpectation == nil {
		mmGetPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockGetPlaygroundConversationExpectation{mock: mmGetPlaygroundConversation.mock}
	}
	mmGetPlaygroundConversation.defaultExpectation.results = &AppPublicServiceServerMockGetPlaygroundConversationResults{gp2, err}
	mmGetPlaygroundConversation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPlaygroundConversation.mock
}

// Set uses given function f to mock the AppPublicServiceServer.GetPlaygroundConversation method
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) Set(f func(ctx context.Context, gp1 *mm_appv1alpha.GetPlaygroundConversationRequest) (gp2 *mm_appv1alpha.GetPlaygroundConversationResponse, err error)) *AppPublicServiceServerMock {
	if mmGetPlaygroundConversation.defaultExpectation != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.GetPlaygroundConversation method")
	}

	if len(mmGetPlaygroundConversation.expectations) > 0 {
		mmGetPlaygroundConversation.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.GetPlaygroundConversation method")
	}

	mmGetPlaygroundConversation.mock.funcGetPlaygroundConversation = f
	mmGetPlaygroundConversation.mock.funcGetPlaygroundConversationOrigin = minimock.CallerInfo(1)
	return mmGetPlaygroundConversation.mock
}

// When sets expectation for the AppPublicServiceServer.GetPlaygroundConversation which will trigger the result defined by the following
// Then helper
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) When(ctx context.Context, gp1 *mm_appv1alpha.GetPlaygroundConversationRequest) *AppPublicServiceServerMockGetPlaygroundConversationExpectation {
	if mmGetPlaygroundConversation.mock.funcGetPlaygroundConversation != nil {
		mmGetPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.GetPlaygroundConversation mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockGetPlaygroundConversationExpectation{
		mock:               mmGetPlaygroundConversation.mock,
		params:             &AppPublicServiceServerMockGetPlaygroundConversationParams{ctx, gp1},
		expectationOrigins: AppPublicServiceServerMockGetPlaygroundConversationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPlaygroundConversation.expectations = append(mmGetPlaygroundConversation.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.GetPlaygroundConversation return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockGetPlaygroundConversationExpectation) Then(gp2 *mm_appv1alpha.GetPlaygroundConversationResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockGetPlaygroundConversationResults{gp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.GetPlaygroundConversation should be invoked
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) Times(n uint64) *mAppPublicServiceServerMockGetPlaygroundConversation {
	if n == 0 {
		mmGetPlaygroundConversation.mock.t.Fatalf("Times of AppPublicServiceServerMock.GetPlaygroundConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPlaygroundConversation.expectedInvocations, n)
	mmGetPlaygroundConversation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPlaygroundConversation
}

func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) invocationsDone() bool {
	if len(mmGetPlaygroundConversation.expectations) == 0 && mmGetPlaygroundConversation.defaultExpectation == nil && mmGetPlaygroundConversation.mock.funcGetPlaygroundConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPlaygroundConversation.mock.afterGetPlaygroundConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPlaygroundConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPlaygroundConversation implements mm_appv1alpha.AppPublicServiceServer
func (mmGetPlaygroundConversation *AppPublicServiceServerMock) GetPlaygroundConversation(ctx context.Context, gp1 *mm_appv1alpha.GetPlaygroundConversationRequest) (gp2 *mm_appv1alpha.GetPlaygroundConversationResponse, err error) {
	mm_atomic.AddUint64(&mmGetPlaygroundConversation.beforeGetPlaygroundConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPlaygroundConversation.afterGetPlaygroundConversationCounter, 1)

	mmGetPlaygroundConversation.t.Helper()

	if mmGetPlaygroundConversation.inspectFuncGetPlaygroundConversation != nil {
		mmGetPlaygroundConversation.inspectFuncGetPlaygroundConversation(ctx, gp1)
	}

	mm_params := AppPublicServiceServerMockGetPlaygroundConversationParams{ctx, gp1}

	// Record call args
	mmGetPlaygroundConversation.GetPlaygroundConversationMock.mutex.Lock()
	mmGetPlaygroundConversation.GetPlaygroundConversationMock.callArgs = append(mmGetPlaygroundConversation.GetPlaygroundConversationMock.callArgs, &mm_params)
	mmGetPlaygroundConversation.GetPlaygroundConversationMock.mutex.Unlock()

	for _, e := range mmGetPlaygroundConversation.GetPlaygroundConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation.params
		mm_want_ptrs := mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockGetPlaygroundConversationParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPlaygroundConversation.t.Errorf("AppPublicServiceServerMock.GetPlaygroundConversation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetPlaygroundConversation.t.Errorf("AppPublicServiceServerMock.GetPlaygroundConversation got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPlaygroundConversation.t.Errorf("AppPublicServiceServerMock.GetPlaygroundConversation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPlaygroundConversation.GetPlaygroundConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPlaygroundConversation.t.Fatal("No results are set for the AppPublicServiceServerMock.GetPlaygroundConversation")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetPlaygroundConversation.funcGetPlaygroundConversation != nil {
		return mmGetPlaygroundConversation.funcGetPlaygroundConversation(ctx, gp1)
	}
	mmGetPlaygroundConversation.t.Fatalf("Unexpected call to AppPublicServiceServerMock.GetPlaygroundConversation. %v %v", ctx, gp1)
	return
}

// GetPlaygroundConversationAfterCounter returns a count of finished AppPublicServiceServerMock.GetPlaygroundConversation invocations
func (mmGetPlaygroundConversation *AppPublicServiceServerMock) GetPlaygroundConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPlaygroundConversation.afterGetPlaygroundConversationCounter)
}

// GetPlaygroundConversationBeforeCounter returns a count of AppPublicServiceServerMock.GetPlaygroundConversation invocations
func (mmGetPlaygroundConversation *AppPublicServiceServerMock) GetPlaygroundConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPlaygroundConversation.beforeGetPlaygroundConversationCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.GetPlaygroundConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPlaygroundConversation *mAppPublicServiceServerMockGetPlaygroundConversation) Calls() []*AppPublicServiceServerMockGetPlaygroundConversationParams {
	mmGetPlaygroundConversation.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockGetPlaygroundConversationParams, len(mmGetPlaygroundConversation.callArgs))
	copy(argCopy, mmGetPlaygroundConversation.callArgs)

	mmGetPlaygroundConversation.mutex.RUnlock()

	return argCopy
}

// MinimockGetPlaygroundConversationDone returns true if the count of the GetPlaygroundConversation invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockGetPlaygroundConversationDone() bool {
	if m.GetPlaygroundConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPlaygroundConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPlaygroundConversationMock.invocationsDone()
}

// MinimockGetPlaygroundConversationInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockGetPlaygroundConversationInspect() {
	for _, e := range m.GetPlaygroundConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.GetPlaygroundConversation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPlaygroundConversationCounter := mm_atomic.LoadUint64(&m.afterGetPlaygroundConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPlaygroundConversationMock.defaultExpectation != nil && afterGetPlaygroundConversationCounter < 1 {
		if m.GetPlaygroundConversationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.GetPlaygroundConversation at\n%s", m.GetPlaygroundConversationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.GetPlaygroundConversation at\n%s with params: %#v", m.GetPlaygroundConversationMock.defaultExpectation.expectationOrigins.origin, *m.GetPlaygroundConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPlaygroundConversation != nil && afterGetPlaygroundConversationCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.GetPlaygroundConversation at\n%s", m.funcGetPlaygroundConversationOrigin)
	}

	if !m.GetPlaygroundConversationMock.invocationsDone() && afterGetPlaygroundConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.GetPlaygroundConversation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPlaygroundConversationMock.expectedInvocations), m.GetPlaygroundConversationMock.expectedInvocationsOrigin, afterGetPlaygroundConversationCounter)
	}
}

type mAppPublicServiceServerMockListApps struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockListAppsExpectation
	expectations       []*AppPublicServiceServerMockListAppsExpectation

	callArgs []*AppPublicServiceServerMockListAppsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockListAppsExpectation specifies expectation struct of the AppPublicServiceServer.ListApps
type AppPublicServiceServerMockListAppsExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockListAppsParams
	paramPtrs          *AppPublicServiceServerMockListAppsParamPtrs
	expectationOrigins AppPublicServiceServerMockListAppsExpectationOrigins
	results            *AppPublicServiceServerMockListAppsResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockListAppsParams contains parameters of the AppPublicServiceServer.ListApps
type AppPublicServiceServerMockListAppsParams struct {
	ctx context.Context
	lp1 *mm_appv1alpha.ListAppsRequest
}

// AppPublicServiceServerMockListAppsParamPtrs contains pointers to parameters of the AppPublicServiceServer.ListApps
type AppPublicServiceServerMockListAppsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_appv1alpha.ListAppsRequest
}

// AppPublicServiceServerMockListAppsResults contains results of the AppPublicServiceServer.ListApps
type AppPublicServiceServerMockListAppsResults struct {
	lp2 *mm_appv1alpha.ListAppsResponse
	err error
}

// AppPublicServiceServerMockListAppsOrigins contains origins of expectations of the AppPublicServiceServer.ListApps
type AppPublicServiceServerMockListAppsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListApps *mAppPublicServiceServerMockListApps) Optional() *mAppPublicServiceServerMockListApps {
	mmListApps.optional = true
	return mmListApps
}

// Expect sets up expected params for AppPublicServiceServer.ListApps
func (mmListApps *mAppPublicServiceServerMockListApps) Expect(ctx context.Context, lp1 *mm_appv1alpha.ListAppsRequest) *mAppPublicServiceServerMockListApps {
	if mmListApps.mock.funcListApps != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by Set")
	}

	if mmListApps.defaultExpectation == nil {
		mmListApps.defaultExpectation = &AppPublicServiceServerMockListAppsExpectation{}
	}

	if mmListApps.defaultExpectation.paramPtrs != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by ExpectParams functions")
	}

	mmListApps.defaultExpectation.params = &AppPublicServiceServerMockListAppsParams{ctx, lp1}
	mmListApps.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListApps.expectations {
		if minimock.Equal(e.params, mmListApps.defaultExpectation.params) {
			mmListApps.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListApps.defaultExpectation.params)
		}
	}

	return mmListApps
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.ListApps
func (mmListApps *mAppPublicServiceServerMockListApps) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockListApps {
	if mmListApps.mock.funcListApps != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by Set")
	}

	if mmListApps.defaultExpectation == nil {
		mmListApps.defaultExpectation = &AppPublicServiceServerMockListAppsExpectation{}
	}

	if mmListApps.defaultExpectation.params != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by Expect")
	}

	if mmListApps.defaultExpectation.paramPtrs == nil {
		mmListApps.defaultExpectation.paramPtrs = &AppPublicServiceServerMockListAppsParamPtrs{}
	}
	mmListApps.defaultExpectation.paramPtrs.ctx = &ctx
	mmListApps.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListApps
}

// ExpectLp1Param2 sets up expected param lp1 for AppPublicServiceServer.ListApps
func (mmListApps *mAppPublicServiceServerMockListApps) ExpectLp1Param2(lp1 *mm_appv1alpha.ListAppsRequest) *mAppPublicServiceServerMockListApps {
	if mmListApps.mock.funcListApps != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by Set")
	}

	if mmListApps.defaultExpectation == nil {
		mmListApps.defaultExpectation = &AppPublicServiceServerMockListAppsExpectation{}
	}

	if mmListApps.defaultExpectation.params != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by Expect")
	}

	if mmListApps.defaultExpectation.paramPtrs == nil {
		mmListApps.defaultExpectation.paramPtrs = &AppPublicServiceServerMockListAppsParamPtrs{}
	}
	mmListApps.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListApps.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListApps
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.ListApps
func (mmListApps *mAppPublicServiceServerMockListApps) Inspect(f func(ctx context.Context, lp1 *mm_appv1alpha.ListAppsRequest)) *mAppPublicServiceServerMockListApps {
	if mmListApps.mock.inspectFuncListApps != nil {
		mmListApps.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.ListApps")
	}

	mmListApps.mock.inspectFuncListApps = f

	return mmListApps
}

// Return sets up results that will be returned by AppPublicServiceServer.ListApps
func (mmListApps *mAppPublicServiceServerMockListApps) Return(lp2 *mm_appv1alpha.ListAppsResponse, err error) *AppPublicServiceServerMock {
	if mmListApps.mock.funcListApps != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by Set")
	}

	if mmListApps.defaultExpectation == nil {
		mmListApps.defaultExpectation = &AppPublicServiceServerMockListAppsExpectation{mock: mmListApps.mock}
	}
	mmListApps.defaultExpectation.results = &AppPublicServiceServerMockListAppsResults{lp2, err}
	mmListApps.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListApps.mock
}

// Set uses given function f to mock the AppPublicServiceServer.ListApps method
func (mmListApps *mAppPublicServiceServerMockListApps) Set(f func(ctx context.Context, lp1 *mm_appv1alpha.ListAppsRequest) (lp2 *mm_appv1alpha.ListAppsResponse, err error)) *AppPublicServiceServerMock {
	if mmListApps.defaultExpectation != nil {
		mmListApps.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.ListApps method")
	}

	if len(mmListApps.expectations) > 0 {
		mmListApps.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.ListApps method")
	}

	mmListApps.mock.funcListApps = f
	mmListApps.mock.funcListAppsOrigin = minimock.CallerInfo(1)
	return mmListApps.mock
}

// When sets expectation for the AppPublicServiceServer.ListApps which will trigger the result defined by the following
// Then helper
func (mmListApps *mAppPublicServiceServerMockListApps) When(ctx context.Context, lp1 *mm_appv1alpha.ListAppsRequest) *AppPublicServiceServerMockListAppsExpectation {
	if mmListApps.mock.funcListApps != nil {
		mmListApps.mock.t.Fatalf("AppPublicServiceServerMock.ListApps mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockListAppsExpectation{
		mock:               mmListApps.mock,
		params:             &AppPublicServiceServerMockListAppsParams{ctx, lp1},
		expectationOrigins: AppPublicServiceServerMockListAppsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListApps.expectations = append(mmListApps.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.ListApps return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockListAppsExpectation) Then(lp2 *mm_appv1alpha.ListAppsResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockListAppsResults{lp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.ListApps should be invoked
func (mmListApps *mAppPublicServiceServerMockListApps) Times(n uint64) *mAppPublicServiceServerMockListApps {
	if n == 0 {
		mmListApps.mock.t.Fatalf("Times of AppPublicServiceServerMock.ListApps mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListApps.expectedInvocations, n)
	mmListApps.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListApps
}

func (mmListApps *mAppPublicServiceServerMockListApps) invocationsDone() bool {
	if len(mmListApps.expectations) == 0 && mmListApps.defaultExpectation == nil && mmListApps.mock.funcListApps == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListApps.mock.afterListAppsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListApps.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListApps implements mm_appv1alpha.AppPublicServiceServer
func (mmListApps *AppPublicServiceServerMock) ListApps(ctx context.Context, lp1 *mm_appv1alpha.ListAppsRequest) (lp2 *mm_appv1alpha.ListAppsResponse, err error) {
	mm_atomic.AddUint64(&mmListApps.beforeListAppsCounter, 1)
	defer mm_atomic.AddUint64(&mmListApps.afterListAppsCounter, 1)

	mmListApps.t.Helper()

	if mmListApps.inspectFuncListApps != nil {
		mmListApps.inspectFuncListApps(ctx, lp1)
	}

	mm_params := AppPublicServiceServerMockListAppsParams{ctx, lp1}

	// Record call args
	mmListApps.ListAppsMock.mutex.Lock()
	mmListApps.ListAppsMock.callArgs = append(mmListApps.ListAppsMock.callArgs, &mm_params)
	mmListApps.ListAppsMock.mutex.Unlock()

	for _, e := range mmListApps.ListAppsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListApps.ListAppsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListApps.ListAppsMock.defaultExpectation.Counter, 1)
		mm_want := mmListApps.ListAppsMock.defaultExpectation.params
		mm_want_ptrs := mmListApps.ListAppsMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockListAppsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListApps.t.Errorf("AppPublicServiceServerMock.ListApps got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListApps.ListAppsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListApps.t.Errorf("AppPublicServiceServerMock.ListApps got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListApps.ListAppsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListApps.t.Errorf("AppPublicServiceServerMock.ListApps got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListApps.ListAppsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListApps.ListAppsMock.defaultExpectation.results
		if mm_results == nil {
			mmListApps.t.Fatal("No results are set for the AppPublicServiceServerMock.ListApps")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListApps.funcListApps != nil {
		return mmListApps.funcListApps(ctx, lp1)
	}
	mmListApps.t.Fatalf("Unexpected call to AppPublicServiceServerMock.ListApps. %v %v", ctx, lp1)
	return
}

// ListAppsAfterCounter returns a count of finished AppPublicServiceServerMock.ListApps invocations
func (mmListApps *AppPublicServiceServerMock) ListAppsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListApps.afterListAppsCounter)
}

// ListAppsBeforeCounter returns a count of AppPublicServiceServerMock.ListApps invocations
func (mmListApps *AppPublicServiceServerMock) ListAppsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListApps.beforeListAppsCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.ListApps.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListApps *mAppPublicServiceServerMockListApps) Calls() []*AppPublicServiceServerMockListAppsParams {
	mmListApps.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockListAppsParams, len(mmListApps.callArgs))
	copy(argCopy, mmListApps.callArgs)

	mmListApps.mutex.RUnlock()

	return argCopy
}

// MinimockListAppsDone returns true if the count of the ListApps invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockListAppsDone() bool {
	if m.ListAppsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAppsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAppsMock.invocationsDone()
}

// MinimockListAppsInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockListAppsInspect() {
	for _, e := range m.ListAppsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListApps at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAppsCounter := mm_atomic.LoadUint64(&m.afterListAppsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAppsMock.defaultExpectation != nil && afterListAppsCounter < 1 {
		if m.ListAppsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListApps at\n%s", m.ListAppsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListApps at\n%s with params: %#v", m.ListAppsMock.defaultExpectation.expectationOrigins.origin, *m.ListAppsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListApps != nil && afterListAppsCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.ListApps at\n%s", m.funcListAppsOrigin)
	}

	if !m.ListAppsMock.invocationsDone() && afterListAppsCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.ListApps at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAppsMock.expectedInvocations), m.ListAppsMock.expectedInvocationsOrigin, afterListAppsCounter)
	}
}

type mAppPublicServiceServerMockListConversations struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockListConversationsExpectation
	expectations       []*AppPublicServiceServerMockListConversationsExpectation

	callArgs []*AppPublicServiceServerMockListConversationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockListConversationsExpectation specifies expectation struct of the AppPublicServiceServer.ListConversations
type AppPublicServiceServerMockListConversationsExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockListConversationsParams
	paramPtrs          *AppPublicServiceServerMockListConversationsParamPtrs
	expectationOrigins AppPublicServiceServerMockListConversationsExpectationOrigins
	results            *AppPublicServiceServerMockListConversationsResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockListConversationsParams contains parameters of the AppPublicServiceServer.ListConversations
type AppPublicServiceServerMockListConversationsParams struct {
	ctx context.Context
	lp1 *mm_appv1alpha.ListConversationsRequest
}

// AppPublicServiceServerMockListConversationsParamPtrs contains pointers to parameters of the AppPublicServiceServer.ListConversations
type AppPublicServiceServerMockListConversationsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_appv1alpha.ListConversationsRequest
}

// AppPublicServiceServerMockListConversationsResults contains results of the AppPublicServiceServer.ListConversations
type AppPublicServiceServerMockListConversationsResults struct {
	lp2 *mm_appv1alpha.ListConversationsResponse
	err error
}

// AppPublicServiceServerMockListConversationsOrigins contains origins of expectations of the AppPublicServiceServer.ListConversations
type AppPublicServiceServerMockListConversationsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListConversations *mAppPublicServiceServerMockListConversations) Optional() *mAppPublicServiceServerMockListConversations {
	mmListConversations.optional = true
	return mmListConversations
}

// Expect sets up expected params for AppPublicServiceServer.ListConversations
func (mmListConversations *mAppPublicServiceServerMockListConversations) Expect(ctx context.Context, lp1 *mm_appv1alpha.ListConversationsRequest) *mAppPublicServiceServerMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &AppPublicServiceServerMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.paramPtrs != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by ExpectParams functions")
	}

	mmListConversations.defaultExpectation.params = &AppPublicServiceServerMockListConversationsParams{ctx, lp1}
	mmListConversations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListConversations.expectations {
		if minimock.Equal(e.params, mmListConversations.defaultExpectation.params) {
			mmListConversations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListConversations.defaultExpectation.params)
		}
	}

	return mmListConversations
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.ListConversations
func (mmListConversations *mAppPublicServiceServerMockListConversations) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &AppPublicServiceServerMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &AppPublicServiceServerMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.ctx = &ctx
	mmListConversations.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListConversations
}

// ExpectLp1Param2 sets up expected param lp1 for AppPublicServiceServer.ListConversations
func (mmListConversations *mAppPublicServiceServerMockListConversations) ExpectLp1Param2(lp1 *mm_appv1alpha.ListConversationsRequest) *mAppPublicServiceServerMockListConversations {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &AppPublicServiceServerMockListConversationsExpectation{}
	}

	if mmListConversations.defaultExpectation.params != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by Expect")
	}

	if mmListConversations.defaultExpectation.paramPtrs == nil {
		mmListConversations.defaultExpectation.paramPtrs = &AppPublicServiceServerMockListConversationsParamPtrs{}
	}
	mmListConversations.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListConversations.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListConversations
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.ListConversations
func (mmListConversations *mAppPublicServiceServerMockListConversations) Inspect(f func(ctx context.Context, lp1 *mm_appv1alpha.ListConversationsRequest)) *mAppPublicServiceServerMockListConversations {
	if mmListConversations.mock.inspectFuncListConversations != nil {
		mmListConversations.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.ListConversations")
	}

	mmListConversations.mock.inspectFuncListConversations = f

	return mmListConversations
}

// Return sets up results that will be returned by AppPublicServiceServer.ListConversations
func (mmListConversations *mAppPublicServiceServerMockListConversations) Return(lp2 *mm_appv1alpha.ListConversationsResponse, err error) *AppPublicServiceServerMock {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by Set")
	}

	if mmListConversations.defaultExpectation == nil {
		mmListConversations.defaultExpectation = &AppPublicServiceServerMockListConversationsExpectation{mock: mmListConversations.mock}
	}
	mmListConversations.defaultExpectation.results = &AppPublicServiceServerMockListConversationsResults{lp2, err}
	mmListConversations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListConversations.mock
}

// Set uses given function f to mock the AppPublicServiceServer.ListConversations method
func (mmListConversations *mAppPublicServiceServerMockListConversations) Set(f func(ctx context.Context, lp1 *mm_appv1alpha.ListConversationsRequest) (lp2 *mm_appv1alpha.ListConversationsResponse, err error)) *AppPublicServiceServerMock {
	if mmListConversations.defaultExpectation != nil {
		mmListConversations.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.ListConversations method")
	}

	if len(mmListConversations.expectations) > 0 {
		mmListConversations.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.ListConversations method")
	}

	mmListConversations.mock.funcListConversations = f
	mmListConversations.mock.funcListConversationsOrigin = minimock.CallerInfo(1)
	return mmListConversations.mock
}

// When sets expectation for the AppPublicServiceServer.ListConversations which will trigger the result defined by the following
// Then helper
func (mmListConversations *mAppPublicServiceServerMockListConversations) When(ctx context.Context, lp1 *mm_appv1alpha.ListConversationsRequest) *AppPublicServiceServerMockListConversationsExpectation {
	if mmListConversations.mock.funcListConversations != nil {
		mmListConversations.mock.t.Fatalf("AppPublicServiceServerMock.ListConversations mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockListConversationsExpectation{
		mock:               mmListConversations.mock,
		params:             &AppPublicServiceServerMockListConversationsParams{ctx, lp1},
		expectationOrigins: AppPublicServiceServerMockListConversationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListConversations.expectations = append(mmListConversations.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.ListConversations return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockListConversationsExpectation) Then(lp2 *mm_appv1alpha.ListConversationsResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockListConversationsResults{lp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.ListConversations should be invoked
func (mmListConversations *mAppPublicServiceServerMockListConversations) Times(n uint64) *mAppPublicServiceServerMockListConversations {
	if n == 0 {
		mmListConversations.mock.t.Fatalf("Times of AppPublicServiceServerMock.ListConversations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListConversations.expectedInvocations, n)
	mmListConversations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListConversations
}

func (mmListConversations *mAppPublicServiceServerMockListConversations) invocationsDone() bool {
	if len(mmListConversations.expectations) == 0 && mmListConversations.defaultExpectation == nil && mmListConversations.mock.funcListConversations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListConversations.mock.afterListConversationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListConversations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListConversations implements mm_appv1alpha.AppPublicServiceServer
func (mmListConversations *AppPublicServiceServerMock) ListConversations(ctx context.Context, lp1 *mm_appv1alpha.ListConversationsRequest) (lp2 *mm_appv1alpha.ListConversationsResponse, err error) {
	mm_atomic.AddUint64(&mmListConversations.beforeListConversationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListConversations.afterListConversationsCounter, 1)

	mmListConversations.t.Helper()

	if mmListConversations.inspectFuncListConversations != nil {
		mmListConversations.inspectFuncListConversations(ctx, lp1)
	}

	mm_params := AppPublicServiceServerMockListConversationsParams{ctx, lp1}

	// Record call args
	mmListConversations.ListConversationsMock.mutex.Lock()
	mmListConversations.ListConversationsMock.callArgs = append(mmListConversations.ListConversationsMock.callArgs, &mm_params)
	mmListConversations.ListConversationsMock.mutex.Unlock()

	for _, e := range mmListConversations.ListConversationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListConversations.ListConversationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListConversations.ListConversationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListConversations.ListConversationsMock.defaultExpectation.params
		mm_want_ptrs := mmListConversations.ListConversationsMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockListConversationsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListConversations.t.Errorf("AppPublicServiceServerMock.ListConversations got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConversations.ListConversationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListConversations.t.Errorf("AppPublicServiceServerMock.ListConversations got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListConversations.ListConversationsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListConversations.t.Errorf("AppPublicServiceServerMock.ListConversations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListConversations.ListConversationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListConversations.ListConversationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListConversations.t.Fatal("No results are set for the AppPublicServiceServerMock.ListConversations")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListConversations.funcListConversations != nil {
		return mmListConversations.funcListConversations(ctx, lp1)
	}
	mmListConversations.t.Fatalf("Unexpected call to AppPublicServiceServerMock.ListConversations. %v %v", ctx, lp1)
	return
}

// ListConversationsAfterCounter returns a count of finished AppPublicServiceServerMock.ListConversations invocations
func (mmListConversations *AppPublicServiceServerMock) ListConversationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConversations.afterListConversationsCounter)
}

// ListConversationsBeforeCounter returns a count of AppPublicServiceServerMock.ListConversations invocations
func (mmListConversations *AppPublicServiceServerMock) ListConversationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListConversations.beforeListConversationsCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.ListConversations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListConversations *mAppPublicServiceServerMockListConversations) Calls() []*AppPublicServiceServerMockListConversationsParams {
	mmListConversations.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockListConversationsParams, len(mmListConversations.callArgs))
	copy(argCopy, mmListConversations.callArgs)

	mmListConversations.mutex.RUnlock()

	return argCopy
}

// MinimockListConversationsDone returns true if the count of the ListConversations invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockListConversationsDone() bool {
	if m.ListConversationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListConversationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListConversationsMock.invocationsDone()
}

// MinimockListConversationsInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockListConversationsInspect() {
	for _, e := range m.ListConversationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListConversations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListConversationsCounter := mm_atomic.LoadUint64(&m.afterListConversationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListConversationsMock.defaultExpectation != nil && afterListConversationsCounter < 1 {
		if m.ListConversationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListConversations at\n%s", m.ListConversationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListConversations at\n%s with params: %#v", m.ListConversationsMock.defaultExpectation.expectationOrigins.origin, *m.ListConversationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListConversations != nil && afterListConversationsCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.ListConversations at\n%s", m.funcListConversationsOrigin)
	}

	if !m.ListConversationsMock.invocationsDone() && afterListConversationsCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.ListConversations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListConversationsMock.expectedInvocations), m.ListConversationsMock.expectedInvocationsOrigin, afterListConversationsCounter)
	}
}

type mAppPublicServiceServerMockListMessages struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockListMessagesExpectation
	expectations       []*AppPublicServiceServerMockListMessagesExpectation

	callArgs []*AppPublicServiceServerMockListMessagesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockListMessagesExpectation specifies expectation struct of the AppPublicServiceServer.ListMessages
type AppPublicServiceServerMockListMessagesExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockListMessagesParams
	paramPtrs          *AppPublicServiceServerMockListMessagesParamPtrs
	expectationOrigins AppPublicServiceServerMockListMessagesExpectationOrigins
	results            *AppPublicServiceServerMockListMessagesResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockListMessagesParams contains parameters of the AppPublicServiceServer.ListMessages
type AppPublicServiceServerMockListMessagesParams struct {
	ctx context.Context
	lp1 *mm_appv1alpha.ListMessagesRequest
}

// AppPublicServiceServerMockListMessagesParamPtrs contains pointers to parameters of the AppPublicServiceServer.ListMessages
type AppPublicServiceServerMockListMessagesParamPtrs struct {
	ctx *context.Context
	lp1 **mm_appv1alpha.ListMessagesRequest
}

// AppPublicServiceServerMockListMessagesResults contains results of the AppPublicServiceServer.ListMessages
type AppPublicServiceServerMockListMessagesResults struct {
	lp2 *mm_appv1alpha.ListMessagesResponse
	err error
}

// AppPublicServiceServerMockListMessagesOrigins contains origins of expectations of the AppPublicServiceServer.ListMessages
type AppPublicServiceServerMockListMessagesExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListMessages *mAppPublicServiceServerMockListMessages) Optional() *mAppPublicServiceServerMockListMessages {
	mmListMessages.optional = true
	return mmListMessages
}

// Expect sets up expected params for AppPublicServiceServer.ListMessages
func (mmListMessages *mAppPublicServiceServerMockListMessages) Expect(ctx context.Context, lp1 *mm_appv1alpha.ListMessagesRequest) *mAppPublicServiceServerMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &AppPublicServiceServerMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.paramPtrs != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by ExpectParams functions")
	}

	mmListMessages.defaultExpectation.params = &AppPublicServiceServerMockListMessagesParams{ctx, lp1}
	mmListMessages.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListMessages.expectations {
		if minimock.Equal(e.params, mmListMessages.defaultExpectation.params) {
			mmListMessages.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListMessages.defaultExpectation.params)
		}
	}

	return mmListMessages
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.ListMessages
func (mmListMessages *mAppPublicServiceServerMockListMessages) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &AppPublicServiceServerMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &AppPublicServiceServerMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.ctx = &ctx
	mmListMessages.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListMessages
}

// ExpectLp1Param2 sets up expected param lp1 for AppPublicServiceServer.ListMessages
func (mmListMessages *mAppPublicServiceServerMockListMessages) ExpectLp1Param2(lp1 *mm_appv1alpha.ListMessagesRequest) *mAppPublicServiceServerMockListMessages {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &AppPublicServiceServerMockListMessagesExpectation{}
	}

	if mmListMessages.defaultExpectation.params != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by Expect")
	}

	if mmListMessages.defaultExpectation.paramPtrs == nil {
		mmListMessages.defaultExpectation.paramPtrs = &AppPublicServiceServerMockListMessagesParamPtrs{}
	}
	mmListMessages.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListMessages.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListMessages
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.ListMessages
func (mmListMessages *mAppPublicServiceServerMockListMessages) Inspect(f func(ctx context.Context, lp1 *mm_appv1alpha.ListMessagesRequest)) *mAppPublicServiceServerMockListMessages {
	if mmListMessages.mock.inspectFuncListMessages != nil {
		mmListMessages.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.ListMessages")
	}

	mmListMessages.mock.inspectFuncListMessages = f

	return mmListMessages
}

// Return sets up results that will be returned by AppPublicServiceServer.ListMessages
func (mmListMessages *mAppPublicServiceServerMockListMessages) Return(lp2 *mm_appv1alpha.ListMessagesResponse, err error) *AppPublicServiceServerMock {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by Set")
	}

	if mmListMessages.defaultExpectation == nil {
		mmListMessages.defaultExpectation = &AppPublicServiceServerMockListMessagesExpectation{mock: mmListMessages.mock}
	}
	mmListMessages.defaultExpectation.results = &AppPublicServiceServerMockListMessagesResults{lp2, err}
	mmListMessages.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListMessages.mock
}

// Set uses given function f to mock the AppPublicServiceServer.ListMessages method
func (mmListMessages *mAppPublicServiceServerMockListMessages) Set(f func(ctx context.Context, lp1 *mm_appv1alpha.ListMessagesRequest) (lp2 *mm_appv1alpha.ListMessagesResponse, err error)) *AppPublicServiceServerMock {
	if mmListMessages.defaultExpectation != nil {
		mmListMessages.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.ListMessages method")
	}

	if len(mmListMessages.expectations) > 0 {
		mmListMessages.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.ListMessages method")
	}

	mmListMessages.mock.funcListMessages = f
	mmListMessages.mock.funcListMessagesOrigin = minimock.CallerInfo(1)
	return mmListMessages.mock
}

// When sets expectation for the AppPublicServiceServer.ListMessages which will trigger the result defined by the following
// Then helper
func (mmListMessages *mAppPublicServiceServerMockListMessages) When(ctx context.Context, lp1 *mm_appv1alpha.ListMessagesRequest) *AppPublicServiceServerMockListMessagesExpectation {
	if mmListMessages.mock.funcListMessages != nil {
		mmListMessages.mock.t.Fatalf("AppPublicServiceServerMock.ListMessages mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockListMessagesExpectation{
		mock:               mmListMessages.mock,
		params:             &AppPublicServiceServerMockListMessagesParams{ctx, lp1},
		expectationOrigins: AppPublicServiceServerMockListMessagesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListMessages.expectations = append(mmListMessages.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.ListMessages return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockListMessagesExpectation) Then(lp2 *mm_appv1alpha.ListMessagesResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockListMessagesResults{lp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.ListMessages should be invoked
func (mmListMessages *mAppPublicServiceServerMockListMessages) Times(n uint64) *mAppPublicServiceServerMockListMessages {
	if n == 0 {
		mmListMessages.mock.t.Fatalf("Times of AppPublicServiceServerMock.ListMessages mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListMessages.expectedInvocations, n)
	mmListMessages.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListMessages
}

func (mmListMessages *mAppPublicServiceServerMockListMessages) invocationsDone() bool {
	if len(mmListMessages.expectations) == 0 && mmListMessages.defaultExpectation == nil && mmListMessages.mock.funcListMessages == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListMessages.mock.afterListMessagesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListMessages.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListMessages implements mm_appv1alpha.AppPublicServiceServer
func (mmListMessages *AppPublicServiceServerMock) ListMessages(ctx context.Context, lp1 *mm_appv1alpha.ListMessagesRequest) (lp2 *mm_appv1alpha.ListMessagesResponse, err error) {
	mm_atomic.AddUint64(&mmListMessages.beforeListMessagesCounter, 1)
	defer mm_atomic.AddUint64(&mmListMessages.afterListMessagesCounter, 1)

	mmListMessages.t.Helper()

	if mmListMessages.inspectFuncListMessages != nil {
		mmListMessages.inspectFuncListMessages(ctx, lp1)
	}

	mm_params := AppPublicServiceServerMockListMessagesParams{ctx, lp1}

	// Record call args
	mmListMessages.ListMessagesMock.mutex.Lock()
	mmListMessages.ListMessagesMock.callArgs = append(mmListMessages.ListMessagesMock.callArgs, &mm_params)
	mmListMessages.ListMessagesMock.mutex.Unlock()

	for _, e := range mmListMessages.ListMessagesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListMessages.ListMessagesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListMessages.ListMessagesMock.defaultExpectation.Counter, 1)
		mm_want := mmListMessages.ListMessagesMock.defaultExpectation.params
		mm_want_ptrs := mmListMessages.ListMessagesMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockListMessagesParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListMessages.t.Errorf("AppPublicServiceServerMock.ListMessages got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListMessages.ListMessagesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListMessages.t.Errorf("AppPublicServiceServerMock.ListMessages got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListMessages.ListMessagesMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListMessages.t.Errorf("AppPublicServiceServerMock.ListMessages got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListMessages.ListMessagesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListMessages.ListMessagesMock.defaultExpectation.results
		if mm_results == nil {
			mmListMessages.t.Fatal("No results are set for the AppPublicServiceServerMock.ListMessages")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListMessages.funcListMessages != nil {
		return mmListMessages.funcListMessages(ctx, lp1)
	}
	mmListMessages.t.Fatalf("Unexpected call to AppPublicServiceServerMock.ListMessages. %v %v", ctx, lp1)
	return
}

// ListMessagesAfterCounter returns a count of finished AppPublicServiceServerMock.ListMessages invocations
func (mmListMessages *AppPublicServiceServerMock) ListMessagesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.afterListMessagesCounter)
}

// ListMessagesBeforeCounter returns a count of AppPublicServiceServerMock.ListMessages invocations
func (mmListMessages *AppPublicServiceServerMock) ListMessagesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMessages.beforeListMessagesCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.ListMessages.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListMessages *mAppPublicServiceServerMockListMessages) Calls() []*AppPublicServiceServerMockListMessagesParams {
	mmListMessages.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockListMessagesParams, len(mmListMessages.callArgs))
	copy(argCopy, mmListMessages.callArgs)

	mmListMessages.mutex.RUnlock()

	return argCopy
}

// MinimockListMessagesDone returns true if the count of the ListMessages invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockListMessagesDone() bool {
	if m.ListMessagesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMessagesMock.invocationsDone()
}

// MinimockListMessagesInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockListMessagesInspect() {
	for _, e := range m.ListMessagesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListMessages at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListMessagesCounter := mm_atomic.LoadUint64(&m.afterListMessagesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMessagesMock.defaultExpectation != nil && afterListMessagesCounter < 1 {
		if m.ListMessagesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListMessages at\n%s", m.ListMessagesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.ListMessages at\n%s with params: %#v", m.ListMessagesMock.defaultExpectation.expectationOrigins.origin, *m.ListMessagesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMessages != nil && afterListMessagesCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.ListMessages at\n%s", m.funcListMessagesOrigin)
	}

	if !m.ListMessagesMock.invocationsDone() && afterListMessagesCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.ListMessages at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMessagesMock.expectedInvocations), m.ListMessagesMock.expectedInvocationsOrigin, afterListMessagesCounter)
	}
}

type mAppPublicServiceServerMockLiveness struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockLivenessExpectation
	expectations       []*AppPublicServiceServerMockLivenessExpectation

	callArgs []*AppPublicServiceServerMockLivenessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockLivenessExpectation specifies expectation struct of the AppPublicServiceServer.Liveness
type AppPublicServiceServerMockLivenessExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockLivenessParams
	paramPtrs          *AppPublicServiceServerMockLivenessParamPtrs
	expectationOrigins AppPublicServiceServerMockLivenessExpectationOrigins
	results            *AppPublicServiceServerMockLivenessResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockLivenessParams contains parameters of the AppPublicServiceServer.Liveness
type AppPublicServiceServerMockLivenessParams struct {
	ctx context.Context
	lp1 *mm_appv1alpha.LivenessRequest
}

// AppPublicServiceServerMockLivenessParamPtrs contains pointers to parameters of the AppPublicServiceServer.Liveness
type AppPublicServiceServerMockLivenessParamPtrs struct {
	ctx *context.Context
	lp1 **mm_appv1alpha.LivenessRequest
}

// AppPublicServiceServerMockLivenessResults contains results of the AppPublicServiceServer.Liveness
type AppPublicServiceServerMockLivenessResults struct {
	lp2 *mm_appv1alpha.LivenessResponse
	err error
}

// AppPublicServiceServerMockLivenessOrigins contains origins of expectations of the AppPublicServiceServer.Liveness
type AppPublicServiceServerMockLivenessExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLiveness *mAppPublicServiceServerMockLiveness) Optional() *mAppPublicServiceServerMockLiveness {
	mmLiveness.optional = true
	return mmLiveness
}

// Expect sets up expected params for AppPublicServiceServer.Liveness
func (mmLiveness *mAppPublicServiceServerMockLiveness) Expect(ctx context.Context, lp1 *mm_appv1alpha.LivenessRequest) *mAppPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &AppPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.paramPtrs != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by ExpectParams functions")
	}

	mmLiveness.defaultExpectation.params = &AppPublicServiceServerMockLivenessParams{ctx, lp1}
	mmLiveness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLiveness.expectations {
		if minimock.Equal(e.params, mmLiveness.defaultExpectation.params) {
			mmLiveness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLiveness.defaultExpectation.params)
		}
	}

	return mmLiveness
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.Liveness
func (mmLiveness *mAppPublicServiceServerMockLiveness) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &AppPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &AppPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.ctx = &ctx
	mmLiveness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectLp1Param2 sets up expected param lp1 for AppPublicServiceServer.Liveness
func (mmLiveness *mAppPublicServiceServerMockLiveness) ExpectLp1Param2(lp1 *mm_appv1alpha.LivenessRequest) *mAppPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &AppPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &AppPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.lp1 = &lp1
	mmLiveness.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmLiveness
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.Liveness
func (mmLiveness *mAppPublicServiceServerMockLiveness) Inspect(f func(ctx context.Context, lp1 *mm_appv1alpha.LivenessRequest)) *mAppPublicServiceServerMockLiveness {
	if mmLiveness.mock.inspectFuncLiveness != nil {
		mmLiveness.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.Liveness")
	}

	mmLiveness.mock.inspectFuncLiveness = f

	return mmLiveness
}

// Return sets up results that will be returned by AppPublicServiceServer.Liveness
func (mmLiveness *mAppPublicServiceServerMockLiveness) Return(lp2 *mm_appv1alpha.LivenessResponse, err error) *AppPublicServiceServerMock {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &AppPublicServiceServerMockLivenessExpectation{mock: mmLiveness.mock}
	}
	mmLiveness.defaultExpectation.results = &AppPublicServiceServerMockLivenessResults{lp2, err}
	mmLiveness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// Set uses given function f to mock the AppPublicServiceServer.Liveness method
func (mmLiveness *mAppPublicServiceServerMockLiveness) Set(f func(ctx context.Context, lp1 *mm_appv1alpha.LivenessRequest) (lp2 *mm_appv1alpha.LivenessResponse, err error)) *AppPublicServiceServerMock {
	if mmLiveness.defaultExpectation != nil {
		mmLiveness.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.Liveness method")
	}

	if len(mmLiveness.expectations) > 0 {
		mmLiveness.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.Liveness method")
	}

	mmLiveness.mock.funcLiveness = f
	mmLiveness.mock.funcLivenessOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// When sets expectation for the AppPublicServiceServer.Liveness which will trigger the result defined by the following
// Then helper
func (mmLiveness *mAppPublicServiceServerMockLiveness) When(ctx context.Context, lp1 *mm_appv1alpha.LivenessRequest) *AppPublicServiceServerMockLivenessExpectation {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("AppPublicServiceServerMock.Liveness mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockLivenessExpectation{
		mock:               mmLiveness.mock,
		params:             &AppPublicServiceServerMockLivenessParams{ctx, lp1},
		expectationOrigins: AppPublicServiceServerMockLivenessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLiveness.expectations = append(mmLiveness.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.Liveness return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockLivenessExpectation) Then(lp2 *mm_appv1alpha.LivenessResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockLivenessResults{lp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.Liveness should be invoked
func (mmLiveness *mAppPublicServiceServerMockLiveness) Times(n uint64) *mAppPublicServiceServerMockLiveness {
	if n == 0 {
		mmLiveness.mock.t.Fatalf("Times of AppPublicServiceServerMock.Liveness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLiveness.expectedInvocations, n)
	mmLiveness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLiveness
}

func (mmLiveness *mAppPublicServiceServerMockLiveness) invocationsDone() bool {
	if len(mmLiveness.expectations) == 0 && mmLiveness.defaultExpectation == nil && mmLiveness.mock.funcLiveness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLiveness.mock.afterLivenessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLiveness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Liveness implements mm_appv1alpha.AppPublicServiceServer
func (mmLiveness *AppPublicServiceServerMock) Liveness(ctx context.Context, lp1 *mm_appv1alpha.LivenessRequest) (lp2 *mm_appv1alpha.LivenessResponse, err error) {
	mm_atomic.AddUint64(&mmLiveness.beforeLivenessCounter, 1)
	defer mm_atomic.AddUint64(&mmLiveness.afterLivenessCounter, 1)

	mmLiveness.t.Helper()

	if mmLiveness.inspectFuncLiveness != nil {
		mmLiveness.inspectFuncLiveness(ctx, lp1)
	}

	mm_params := AppPublicServiceServerMockLivenessParams{ctx, lp1}

	// Record call args
	mmLiveness.LivenessMock.mutex.Lock()
	mmLiveness.LivenessMock.callArgs = append(mmLiveness.LivenessMock.callArgs, &mm_params)
	mmLiveness.LivenessMock.mutex.Unlock()

	for _, e := range mmLiveness.LivenessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmLiveness.LivenessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLiveness.LivenessMock.defaultExpectation.Counter, 1)
		mm_want := mmLiveness.LivenessMock.defaultExpectation.params
		mm_want_ptrs := mmLiveness.LivenessMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockLivenessParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLiveness.t.Errorf("AppPublicServiceServerMock.Liveness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmLiveness.t.Errorf("AppPublicServiceServerMock.Liveness got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLiveness.t.Errorf("AppPublicServiceServerMock.Liveness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLiveness.LivenessMock.defaultExpectation.results
		if mm_results == nil {
			mmLiveness.t.Fatal("No results are set for the AppPublicServiceServerMock.Liveness")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmLiveness.funcLiveness != nil {
		return mmLiveness.funcLiveness(ctx, lp1)
	}
	mmLiveness.t.Fatalf("Unexpected call to AppPublicServiceServerMock.Liveness. %v %v", ctx, lp1)
	return
}

// LivenessAfterCounter returns a count of finished AppPublicServiceServerMock.Liveness invocations
func (mmLiveness *AppPublicServiceServerMock) LivenessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.afterLivenessCounter)
}

// LivenessBeforeCounter returns a count of AppPublicServiceServerMock.Liveness invocations
func (mmLiveness *AppPublicServiceServerMock) LivenessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.beforeLivenessCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.Liveness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLiveness *mAppPublicServiceServerMockLiveness) Calls() []*AppPublicServiceServerMockLivenessParams {
	mmLiveness.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockLivenessParams, len(mmLiveness.callArgs))
	copy(argCopy, mmLiveness.callArgs)

	mmLiveness.mutex.RUnlock()

	return argCopy
}

// MinimockLivenessDone returns true if the count of the Liveness invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockLivenessDone() bool {
	if m.LivenessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LivenessMock.invocationsDone()
}

// MinimockLivenessInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockLivenessInspect() {
	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Liveness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLivenessCounter := mm_atomic.LoadUint64(&m.afterLivenessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LivenessMock.defaultExpectation != nil && afterLivenessCounter < 1 {
		if m.LivenessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Liveness at\n%s", m.LivenessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Liveness at\n%s with params: %#v", m.LivenessMock.defaultExpectation.expectationOrigins.origin, *m.LivenessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLiveness != nil && afterLivenessCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.Liveness at\n%s", m.funcLivenessOrigin)
	}

	if !m.LivenessMock.invocationsDone() && afterLivenessCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.Liveness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LivenessMock.expectedInvocations), m.LivenessMock.expectedInvocationsOrigin, afterLivenessCounter)
	}
}

type mAppPublicServiceServerMockReadiness struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockReadinessExpectation
	expectations       []*AppPublicServiceServerMockReadinessExpectation

	callArgs []*AppPublicServiceServerMockReadinessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockReadinessExpectation specifies expectation struct of the AppPublicServiceServer.Readiness
type AppPublicServiceServerMockReadinessExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockReadinessParams
	paramPtrs          *AppPublicServiceServerMockReadinessParamPtrs
	expectationOrigins AppPublicServiceServerMockReadinessExpectationOrigins
	results            *AppPublicServiceServerMockReadinessResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockReadinessParams contains parameters of the AppPublicServiceServer.Readiness
type AppPublicServiceServerMockReadinessParams struct {
	ctx context.Context
	rp1 *mm_appv1alpha.ReadinessRequest
}

// AppPublicServiceServerMockReadinessParamPtrs contains pointers to parameters of the AppPublicServiceServer.Readiness
type AppPublicServiceServerMockReadinessParamPtrs struct {
	ctx *context.Context
	rp1 **mm_appv1alpha.ReadinessRequest
}

// AppPublicServiceServerMockReadinessResults contains results of the AppPublicServiceServer.Readiness
type AppPublicServiceServerMockReadinessResults struct {
	rp2 *mm_appv1alpha.ReadinessResponse
	err error
}

// AppPublicServiceServerMockReadinessOrigins contains origins of expectations of the AppPublicServiceServer.Readiness
type AppPublicServiceServerMockReadinessExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadiness *mAppPublicServiceServerMockReadiness) Optional() *mAppPublicServiceServerMockReadiness {
	mmReadiness.optional = true
	return mmReadiness
}

// Expect sets up expected params for AppPublicServiceServer.Readiness
func (mmReadiness *mAppPublicServiceServerMockReadiness) Expect(ctx context.Context, rp1 *mm_appv1alpha.ReadinessRequest) *mAppPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &AppPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.paramPtrs != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by ExpectParams functions")
	}

	mmReadiness.defaultExpectation.params = &AppPublicServiceServerMockReadinessParams{ctx, rp1}
	mmReadiness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadiness.expectations {
		if minimock.Equal(e.params, mmReadiness.defaultExpectation.params) {
			mmReadiness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadiness.defaultExpectation.params)
		}
	}

	return mmReadiness
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.Readiness
func (mmReadiness *mAppPublicServiceServerMockReadiness) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &AppPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &AppPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadiness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectRp1Param2 sets up expected param rp1 for AppPublicServiceServer.Readiness
func (mmReadiness *mAppPublicServiceServerMockReadiness) ExpectRp1Param2(rp1 *mm_appv1alpha.ReadinessRequest) *mAppPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &AppPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &AppPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.rp1 = &rp1
	mmReadiness.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmReadiness
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.Readiness
func (mmReadiness *mAppPublicServiceServerMockReadiness) Inspect(f func(ctx context.Context, rp1 *mm_appv1alpha.ReadinessRequest)) *mAppPublicServiceServerMockReadiness {
	if mmReadiness.mock.inspectFuncReadiness != nil {
		mmReadiness.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.Readiness")
	}

	mmReadiness.mock.inspectFuncReadiness = f

	return mmReadiness
}

// Return sets up results that will be returned by AppPublicServiceServer.Readiness
func (mmReadiness *mAppPublicServiceServerMockReadiness) Return(rp2 *mm_appv1alpha.ReadinessResponse, err error) *AppPublicServiceServerMock {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &AppPublicServiceServerMockReadinessExpectation{mock: mmReadiness.mock}
	}
	mmReadiness.defaultExpectation.results = &AppPublicServiceServerMockReadinessResults{rp2, err}
	mmReadiness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// Set uses given function f to mock the AppPublicServiceServer.Readiness method
func (mmReadiness *mAppPublicServiceServerMockReadiness) Set(f func(ctx context.Context, rp1 *mm_appv1alpha.ReadinessRequest) (rp2 *mm_appv1alpha.ReadinessResponse, err error)) *AppPublicServiceServerMock {
	if mmReadiness.defaultExpectation != nil {
		mmReadiness.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.Readiness method")
	}

	if len(mmReadiness.expectations) > 0 {
		mmReadiness.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.Readiness method")
	}

	mmReadiness.mock.funcReadiness = f
	mmReadiness.mock.funcReadinessOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// When sets expectation for the AppPublicServiceServer.Readiness which will trigger the result defined by the following
// Then helper
func (mmReadiness *mAppPublicServiceServerMockReadiness) When(ctx context.Context, rp1 *mm_appv1alpha.ReadinessRequest) *AppPublicServiceServerMockReadinessExpectation {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("AppPublicServiceServerMock.Readiness mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockReadinessExpectation{
		mock:               mmReadiness.mock,
		params:             &AppPublicServiceServerMockReadinessParams{ctx, rp1},
		expectationOrigins: AppPublicServiceServerMockReadinessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadiness.expectations = append(mmReadiness.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.Readiness return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockReadinessExpectation) Then(rp2 *mm_appv1alpha.ReadinessResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockReadinessResults{rp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.Readiness should be invoked
func (mmReadiness *mAppPublicServiceServerMockReadiness) Times(n uint64) *mAppPublicServiceServerMockReadiness {
	if n == 0 {
		mmReadiness.mock.t.Fatalf("Times of AppPublicServiceServerMock.Readiness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadiness.expectedInvocations, n)
	mmReadiness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadiness
}

func (mmReadiness *mAppPublicServiceServerMockReadiness) invocationsDone() bool {
	if len(mmReadiness.expectations) == 0 && mmReadiness.defaultExpectation == nil && mmReadiness.mock.funcReadiness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadiness.mock.afterReadinessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadiness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Readiness implements mm_appv1alpha.AppPublicServiceServer
func (mmReadiness *AppPublicServiceServerMock) Readiness(ctx context.Context, rp1 *mm_appv1alpha.ReadinessRequest) (rp2 *mm_appv1alpha.ReadinessResponse, err error) {
	mm_atomic.AddUint64(&mmReadiness.beforeReadinessCounter, 1)
	defer mm_atomic.AddUint64(&mmReadiness.afterReadinessCounter, 1)

	mmReadiness.t.Helper()

	if mmReadiness.inspectFuncReadiness != nil {
		mmReadiness.inspectFuncReadiness(ctx, rp1)
	}

	mm_params := AppPublicServiceServerMockReadinessParams{ctx, rp1}

	// Record call args
	mmReadiness.ReadinessMock.mutex.Lock()
	mmReadiness.ReadinessMock.callArgs = append(mmReadiness.ReadinessMock.callArgs, &mm_params)
	mmReadiness.ReadinessMock.mutex.Unlock()

	for _, e := range mmReadiness.ReadinessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmReadiness.ReadinessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadiness.ReadinessMock.defaultExpectation.Counter, 1)
		mm_want := mmReadiness.ReadinessMock.defaultExpectation.params
		mm_want_ptrs := mmReadiness.ReadinessMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockReadinessParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadiness.t.Errorf("AppPublicServiceServerMock.Readiness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmReadiness.t.Errorf("AppPublicServiceServerMock.Readiness got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadiness.t.Errorf("AppPublicServiceServerMock.Readiness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadiness.ReadinessMock.defaultExpectation.results
		if mm_results == nil {
			mmReadiness.t.Fatal("No results are set for the AppPublicServiceServerMock.Readiness")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmReadiness.funcReadiness != nil {
		return mmReadiness.funcReadiness(ctx, rp1)
	}
	mmReadiness.t.Fatalf("Unexpected call to AppPublicServiceServerMock.Readiness. %v %v", ctx, rp1)
	return
}

// ReadinessAfterCounter returns a count of finished AppPublicServiceServerMock.Readiness invocations
func (mmReadiness *AppPublicServiceServerMock) ReadinessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.afterReadinessCounter)
}

// ReadinessBeforeCounter returns a count of AppPublicServiceServerMock.Readiness invocations
func (mmReadiness *AppPublicServiceServerMock) ReadinessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.beforeReadinessCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.Readiness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadiness *mAppPublicServiceServerMockReadiness) Calls() []*AppPublicServiceServerMockReadinessParams {
	mmReadiness.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockReadinessParams, len(mmReadiness.callArgs))
	copy(argCopy, mmReadiness.callArgs)

	mmReadiness.mutex.RUnlock()

	return argCopy
}

// MinimockReadinessDone returns true if the count of the Readiness invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockReadinessDone() bool {
	if m.ReadinessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadinessMock.invocationsDone()
}

// MinimockReadinessInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockReadinessInspect() {
	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Readiness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadinessCounter := mm_atomic.LoadUint64(&m.afterReadinessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadinessMock.defaultExpectation != nil && afterReadinessCounter < 1 {
		if m.ReadinessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Readiness at\n%s", m.ReadinessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.Readiness at\n%s with params: %#v", m.ReadinessMock.defaultExpectation.expectationOrigins.origin, *m.ReadinessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadiness != nil && afterReadinessCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.Readiness at\n%s", m.funcReadinessOrigin)
	}

	if !m.ReadinessMock.invocationsDone() && afterReadinessCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.Readiness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadinessMock.expectedInvocations), m.ReadinessMock.expectedInvocationsOrigin, afterReadinessCounter)
	}
}

type mAppPublicServiceServerMockRestartPlaygroundConversation struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockRestartPlaygroundConversationExpectation
	expectations       []*AppPublicServiceServerMockRestartPlaygroundConversationExpectation

	callArgs []*AppPublicServiceServerMockRestartPlaygroundConversationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockRestartPlaygroundConversationExpectation specifies expectation struct of the AppPublicServiceServer.RestartPlaygroundConversation
type AppPublicServiceServerMockRestartPlaygroundConversationExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockRestartPlaygroundConversationParams
	paramPtrs          *AppPublicServiceServerMockRestartPlaygroundConversationParamPtrs
	expectationOrigins AppPublicServiceServerMockRestartPlaygroundConversationExpectationOrigins
	results            *AppPublicServiceServerMockRestartPlaygroundConversationResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockRestartPlaygroundConversationParams contains parameters of the AppPublicServiceServer.RestartPlaygroundConversation
type AppPublicServiceServerMockRestartPlaygroundConversationParams struct {
	ctx context.Context
	rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest
}

// AppPublicServiceServerMockRestartPlaygroundConversationParamPtrs contains pointers to parameters of the AppPublicServiceServer.RestartPlaygroundConversation
type AppPublicServiceServerMockRestartPlaygroundConversationParamPtrs struct {
	ctx *context.Context
	rp1 **mm_appv1alpha.RestartPlaygroundConversationRequest
}

// AppPublicServiceServerMockRestartPlaygroundConversationResults contains results of the AppPublicServiceServer.RestartPlaygroundConversation
type AppPublicServiceServerMockRestartPlaygroundConversationResults struct {
	rp2 *mm_appv1alpha.RestartPlaygroundConversationResponse
	err error
}

// AppPublicServiceServerMockRestartPlaygroundConversationOrigins contains origins of expectations of the AppPublicServiceServer.RestartPlaygroundConversation
type AppPublicServiceServerMockRestartPlaygroundConversationExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) Optional() *mAppPublicServiceServerMockRestartPlaygroundConversation {
	mmRestartPlaygroundConversation.optional = true
	return mmRestartPlaygroundConversation
}

// Expect sets up expected params for AppPublicServiceServer.RestartPlaygroundConversation
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) Expect(ctx context.Context, rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest) *mAppPublicServiceServerMockRestartPlaygroundConversation {
	if mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversation != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by Set")
	}

	if mmRestartPlaygroundConversation.defaultExpectation == nil {
		mmRestartPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockRestartPlaygroundConversationExpectation{}
	}

	if mmRestartPlaygroundConversation.defaultExpectation.paramPtrs != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by ExpectParams functions")
	}

	mmRestartPlaygroundConversation.defaultExpectation.params = &AppPublicServiceServerMockRestartPlaygroundConversationParams{ctx, rp1}
	mmRestartPlaygroundConversation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRestartPlaygroundConversation.expectations {
		if minimock.Equal(e.params, mmRestartPlaygroundConversation.defaultExpectation.params) {
			mmRestartPlaygroundConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRestartPlaygroundConversation.defaultExpectation.params)
		}
	}

	return mmRestartPlaygroundConversation
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.RestartPlaygroundConversation
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockRestartPlaygroundConversation {
	if mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversation != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by Set")
	}

	if mmRestartPlaygroundConversation.defaultExpectation == nil {
		mmRestartPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockRestartPlaygroundConversationExpectation{}
	}

	if mmRestartPlaygroundConversation.defaultExpectation.params != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by Expect")
	}

	if mmRestartPlaygroundConversation.defaultExpectation.paramPtrs == nil {
		mmRestartPlaygroundConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockRestartPlaygroundConversationParamPtrs{}
	}
	mmRestartPlaygroundConversation.defaultExpectation.paramPtrs.ctx = &ctx
	mmRestartPlaygroundConversation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRestartPlaygroundConversation
}

// ExpectRp1Param2 sets up expected param rp1 for AppPublicServiceServer.RestartPlaygroundConversation
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) ExpectRp1Param2(rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest) *mAppPublicServiceServerMockRestartPlaygroundConversation {
	if mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversation != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by Set")
	}

	if mmRestartPlaygroundConversation.defaultExpectation == nil {
		mmRestartPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockRestartPlaygroundConversationExpectation{}
	}

	if mmRestartPlaygroundConversation.defaultExpectation.params != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by Expect")
	}

	if mmRestartPlaygroundConversation.defaultExpectation.paramPtrs == nil {
		mmRestartPlaygroundConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockRestartPlaygroundConversationParamPtrs{}
	}
	mmRestartPlaygroundConversation.defaultExpectation.paramPtrs.rp1 = &rp1
	mmRestartPlaygroundConversation.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmRestartPlaygroundConversation
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.RestartPlaygroundConversation
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) Inspect(f func(ctx context.Context, rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest)) *mAppPublicServiceServerMockRestartPlaygroundConversation {
	if mmRestartPlaygroundConversation.mock.inspectFuncRestartPlaygroundConversation != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.RestartPlaygroundConversation")
	}

	mmRestartPlaygroundConversation.mock.inspectFuncRestartPlaygroundConversation = f

	return mmRestartPlaygroundConversation
}

// Return sets up results that will be returned by AppPublicServiceServer.RestartPlaygroundConversation
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) Return(rp2 *mm_appv1alpha.RestartPlaygroundConversationResponse, err error) *AppPublicServiceServerMock {
	if mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversation != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by Set")
	}

	if mmRestartPlaygroundConversation.defaultExpectation == nil {
		mmRestartPlaygroundConversation.defaultExpectation = &AppPublicServiceServerMockRestartPlaygroundConversationExpectation{mock: mmRestartPlaygroundConversation.mock}
	}
	mmRestartPlaygroundConversation.defaultExpectation.results = &AppPublicServiceServerMockRestartPlaygroundConversationResults{rp2, err}
	mmRestartPlaygroundConversation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRestartPlaygroundConversation.mock
}

// Set uses given function f to mock the AppPublicServiceServer.RestartPlaygroundConversation method
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) Set(f func(ctx context.Context, rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest) (rp2 *mm_appv1alpha.RestartPlaygroundConversationResponse, err error)) *AppPublicServiceServerMock {
	if mmRestartPlaygroundConversation.defaultExpectation != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.RestartPlaygroundConversation method")
	}

	if len(mmRestartPlaygroundConversation.expectations) > 0 {
		mmRestartPlaygroundConversation.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.RestartPlaygroundConversation method")
	}

	mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversation = f
	mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversationOrigin = minimock.CallerInfo(1)
	return mmRestartPlaygroundConversation.mock
}

// When sets expectation for the AppPublicServiceServer.RestartPlaygroundConversation which will trigger the result defined by the following
// Then helper
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) When(ctx context.Context, rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest) *AppPublicServiceServerMockRestartPlaygroundConversationExpectation {
	if mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversation != nil {
		mmRestartPlaygroundConversation.mock.t.Fatalf("AppPublicServiceServerMock.RestartPlaygroundConversation mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockRestartPlaygroundConversationExpectation{
		mock:               mmRestartPlaygroundConversation.mock,
		params:             &AppPublicServiceServerMockRestartPlaygroundConversationParams{ctx, rp1},
		expectationOrigins: AppPublicServiceServerMockRestartPlaygroundConversationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRestartPlaygroundConversation.expectations = append(mmRestartPlaygroundConversation.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.RestartPlaygroundConversation return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockRestartPlaygroundConversationExpectation) Then(rp2 *mm_appv1alpha.RestartPlaygroundConversationResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockRestartPlaygroundConversationResults{rp2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.RestartPlaygroundConversation should be invoked
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) Times(n uint64) *mAppPublicServiceServerMockRestartPlaygroundConversation {
	if n == 0 {
		mmRestartPlaygroundConversation.mock.t.Fatalf("Times of AppPublicServiceServerMock.RestartPlaygroundConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRestartPlaygroundConversation.expectedInvocations, n)
	mmRestartPlaygroundConversation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRestartPlaygroundConversation
}

func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) invocationsDone() bool {
	if len(mmRestartPlaygroundConversation.expectations) == 0 && mmRestartPlaygroundConversation.defaultExpectation == nil && mmRestartPlaygroundConversation.mock.funcRestartPlaygroundConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRestartPlaygroundConversation.mock.afterRestartPlaygroundConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRestartPlaygroundConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RestartPlaygroundConversation implements mm_appv1alpha.AppPublicServiceServer
func (mmRestartPlaygroundConversation *AppPublicServiceServerMock) RestartPlaygroundConversation(ctx context.Context, rp1 *mm_appv1alpha.RestartPlaygroundConversationRequest) (rp2 *mm_appv1alpha.RestartPlaygroundConversationResponse, err error) {
	mm_atomic.AddUint64(&mmRestartPlaygroundConversation.beforeRestartPlaygroundConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmRestartPlaygroundConversation.afterRestartPlaygroundConversationCounter, 1)

	mmRestartPlaygroundConversation.t.Helper()

	if mmRestartPlaygroundConversation.inspectFuncRestartPlaygroundConversation != nil {
		mmRestartPlaygroundConversation.inspectFuncRestartPlaygroundConversation(ctx, rp1)
	}

	mm_params := AppPublicServiceServerMockRestartPlaygroundConversationParams{ctx, rp1}

	// Record call args
	mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.mutex.Lock()
	mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.callArgs = append(mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.callArgs, &mm_params)
	mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.mutex.Unlock()

	for _, e := range mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation.params
		mm_want_ptrs := mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockRestartPlaygroundConversationParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRestartPlaygroundConversation.t.Errorf("AppPublicServiceServerMock.RestartPlaygroundConversation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmRestartPlaygroundConversation.t.Errorf("AppPublicServiceServerMock.RestartPlaygroundConversation got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRestartPlaygroundConversation.t.Errorf("AppPublicServiceServerMock.RestartPlaygroundConversation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRestartPlaygroundConversation.RestartPlaygroundConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmRestartPlaygroundConversation.t.Fatal("No results are set for the AppPublicServiceServerMock.RestartPlaygroundConversation")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmRestartPlaygroundConversation.funcRestartPlaygroundConversation != nil {
		return mmRestartPlaygroundConversation.funcRestartPlaygroundConversation(ctx, rp1)
	}
	mmRestartPlaygroundConversation.t.Fatalf("Unexpected call to AppPublicServiceServerMock.RestartPlaygroundConversation. %v %v", ctx, rp1)
	return
}

// RestartPlaygroundConversationAfterCounter returns a count of finished AppPublicServiceServerMock.RestartPlaygroundConversation invocations
func (mmRestartPlaygroundConversation *AppPublicServiceServerMock) RestartPlaygroundConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestartPlaygroundConversation.afterRestartPlaygroundConversationCounter)
}

// RestartPlaygroundConversationBeforeCounter returns a count of AppPublicServiceServerMock.RestartPlaygroundConversation invocations
func (mmRestartPlaygroundConversation *AppPublicServiceServerMock) RestartPlaygroundConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRestartPlaygroundConversation.beforeRestartPlaygroundConversationCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.RestartPlaygroundConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRestartPlaygroundConversation *mAppPublicServiceServerMockRestartPlaygroundConversation) Calls() []*AppPublicServiceServerMockRestartPlaygroundConversationParams {
	mmRestartPlaygroundConversation.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockRestartPlaygroundConversationParams, len(mmRestartPlaygroundConversation.callArgs))
	copy(argCopy, mmRestartPlaygroundConversation.callArgs)

	mmRestartPlaygroundConversation.mutex.RUnlock()

	return argCopy
}

// MinimockRestartPlaygroundConversationDone returns true if the count of the RestartPlaygroundConversation invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockRestartPlaygroundConversationDone() bool {
	if m.RestartPlaygroundConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RestartPlaygroundConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RestartPlaygroundConversationMock.invocationsDone()
}

// MinimockRestartPlaygroundConversationInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockRestartPlaygroundConversationInspect() {
	for _, e := range m.RestartPlaygroundConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.RestartPlaygroundConversation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRestartPlaygroundConversationCounter := mm_atomic.LoadUint64(&m.afterRestartPlaygroundConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RestartPlaygroundConversationMock.defaultExpectation != nil && afterRestartPlaygroundConversationCounter < 1 {
		if m.RestartPlaygroundConversationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.RestartPlaygroundConversation at\n%s", m.RestartPlaygroundConversationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.RestartPlaygroundConversation at\n%s with params: %#v", m.RestartPlaygroundConversationMock.defaultExpectation.expectationOrigins.origin, *m.RestartPlaygroundConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRestartPlaygroundConversation != nil && afterRestartPlaygroundConversationCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.RestartPlaygroundConversation at\n%s", m.funcRestartPlaygroundConversationOrigin)
	}

	if !m.RestartPlaygroundConversationMock.invocationsDone() && afterRestartPlaygroundConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.RestartPlaygroundConversation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RestartPlaygroundConversationMock.expectedInvocations), m.RestartPlaygroundConversationMock.expectedInvocationsOrigin, afterRestartPlaygroundConversationCounter)
	}
}

type mAppPublicServiceServerMockUpdateApp struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockUpdateAppExpectation
	expectations       []*AppPublicServiceServerMockUpdateAppExpectation

	callArgs []*AppPublicServiceServerMockUpdateAppParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockUpdateAppExpectation specifies expectation struct of the AppPublicServiceServer.UpdateApp
type AppPublicServiceServerMockUpdateAppExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockUpdateAppParams
	paramPtrs          *AppPublicServiceServerMockUpdateAppParamPtrs
	expectationOrigins AppPublicServiceServerMockUpdateAppExpectationOrigins
	results            *AppPublicServiceServerMockUpdateAppResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockUpdateAppParams contains parameters of the AppPublicServiceServer.UpdateApp
type AppPublicServiceServerMockUpdateAppParams struct {
	ctx context.Context
	up1 *mm_appv1alpha.UpdateAppRequest
}

// AppPublicServiceServerMockUpdateAppParamPtrs contains pointers to parameters of the AppPublicServiceServer.UpdateApp
type AppPublicServiceServerMockUpdateAppParamPtrs struct {
	ctx *context.Context
	up1 **mm_appv1alpha.UpdateAppRequest
}

// AppPublicServiceServerMockUpdateAppResults contains results of the AppPublicServiceServer.UpdateApp
type AppPublicServiceServerMockUpdateAppResults struct {
	up2 *mm_appv1alpha.UpdateAppResponse
	err error
}

// AppPublicServiceServerMockUpdateAppOrigins contains origins of expectations of the AppPublicServiceServer.UpdateApp
type AppPublicServiceServerMockUpdateAppExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) Optional() *mAppPublicServiceServerMockUpdateApp {
	mmUpdateApp.optional = true
	return mmUpdateApp
}

// Expect sets up expected params for AppPublicServiceServer.UpdateApp
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) Expect(ctx context.Context, up1 *mm_appv1alpha.UpdateAppRequest) *mAppPublicServiceServerMockUpdateApp {
	if mmUpdateApp.mock.funcUpdateApp != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by Set")
	}

	if mmUpdateApp.defaultExpectation == nil {
		mmUpdateApp.defaultExpectation = &AppPublicServiceServerMockUpdateAppExpectation{}
	}

	if mmUpdateApp.defaultExpectation.paramPtrs != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by ExpectParams functions")
	}

	mmUpdateApp.defaultExpectation.params = &AppPublicServiceServerMockUpdateAppParams{ctx, up1}
	mmUpdateApp.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateApp.expectations {
		if minimock.Equal(e.params, mmUpdateApp.defaultExpectation.params) {
			mmUpdateApp.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateApp.defaultExpectation.params)
		}
	}

	return mmUpdateApp
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.UpdateApp
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockUpdateApp {
	if mmUpdateApp.mock.funcUpdateApp != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by Set")
	}

	if mmUpdateApp.defaultExpectation == nil {
		mmUpdateApp.defaultExpectation = &AppPublicServiceServerMockUpdateAppExpectation{}
	}

	if mmUpdateApp.defaultExpectation.params != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by Expect")
	}

	if mmUpdateApp.defaultExpectation.paramPtrs == nil {
		mmUpdateApp.defaultExpectation.paramPtrs = &AppPublicServiceServerMockUpdateAppParamPtrs{}
	}
	mmUpdateApp.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateApp.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateApp
}

// ExpectUp1Param2 sets up expected param up1 for AppPublicServiceServer.UpdateApp
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) ExpectUp1Param2(up1 *mm_appv1alpha.UpdateAppRequest) *mAppPublicServiceServerMockUpdateApp {
	if mmUpdateApp.mock.funcUpdateApp != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by Set")
	}

	if mmUpdateApp.defaultExpectation == nil {
		mmUpdateApp.defaultExpectation = &AppPublicServiceServerMockUpdateAppExpectation{}
	}

	if mmUpdateApp.defaultExpectation.params != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by Expect")
	}

	if mmUpdateApp.defaultExpectation.paramPtrs == nil {
		mmUpdateApp.defaultExpectation.paramPtrs = &AppPublicServiceServerMockUpdateAppParamPtrs{}
	}
	mmUpdateApp.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateApp.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateApp
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.UpdateApp
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) Inspect(f func(ctx context.Context, up1 *mm_appv1alpha.UpdateAppRequest)) *mAppPublicServiceServerMockUpdateApp {
	if mmUpdateApp.mock.inspectFuncUpdateApp != nil {
		mmUpdateApp.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.UpdateApp")
	}

	mmUpdateApp.mock.inspectFuncUpdateApp = f

	return mmUpdateApp
}

// Return sets up results that will be returned by AppPublicServiceServer.UpdateApp
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) Return(up2 *mm_appv1alpha.UpdateAppResponse, err error) *AppPublicServiceServerMock {
	if mmUpdateApp.mock.funcUpdateApp != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by Set")
	}

	if mmUpdateApp.defaultExpectation == nil {
		mmUpdateApp.defaultExpectation = &AppPublicServiceServerMockUpdateAppExpectation{mock: mmUpdateApp.mock}
	}
	mmUpdateApp.defaultExpectation.results = &AppPublicServiceServerMockUpdateAppResults{up2, err}
	mmUpdateApp.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateApp.mock
}

// Set uses given function f to mock the AppPublicServiceServer.UpdateApp method
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) Set(f func(ctx context.Context, up1 *mm_appv1alpha.UpdateAppRequest) (up2 *mm_appv1alpha.UpdateAppResponse, err error)) *AppPublicServiceServerMock {
	if mmUpdateApp.defaultExpectation != nil {
		mmUpdateApp.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.UpdateApp method")
	}

	if len(mmUpdateApp.expectations) > 0 {
		mmUpdateApp.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.UpdateApp method")
	}

	mmUpdateApp.mock.funcUpdateApp = f
	mmUpdateApp.mock.funcUpdateAppOrigin = minimock.CallerInfo(1)
	return mmUpdateApp.mock
}

// When sets expectation for the AppPublicServiceServer.UpdateApp which will trigger the result defined by the following
// Then helper
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) When(ctx context.Context, up1 *mm_appv1alpha.UpdateAppRequest) *AppPublicServiceServerMockUpdateAppExpectation {
	if mmUpdateApp.mock.funcUpdateApp != nil {
		mmUpdateApp.mock.t.Fatalf("AppPublicServiceServerMock.UpdateApp mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockUpdateAppExpectation{
		mock:               mmUpdateApp.mock,
		params:             &AppPublicServiceServerMockUpdateAppParams{ctx, up1},
		expectationOrigins: AppPublicServiceServerMockUpdateAppExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateApp.expectations = append(mmUpdateApp.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.UpdateApp return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockUpdateAppExpectation) Then(up2 *mm_appv1alpha.UpdateAppResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockUpdateAppResults{up2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.UpdateApp should be invoked
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) Times(n uint64) *mAppPublicServiceServerMockUpdateApp {
	if n == 0 {
		mmUpdateApp.mock.t.Fatalf("Times of AppPublicServiceServerMock.UpdateApp mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateApp.expectedInvocations, n)
	mmUpdateApp.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateApp
}

func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) invocationsDone() bool {
	if len(mmUpdateApp.expectations) == 0 && mmUpdateApp.defaultExpectation == nil && mmUpdateApp.mock.funcUpdateApp == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateApp.mock.afterUpdateAppCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateApp.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateApp implements mm_appv1alpha.AppPublicServiceServer
func (mmUpdateApp *AppPublicServiceServerMock) UpdateApp(ctx context.Context, up1 *mm_appv1alpha.UpdateAppRequest) (up2 *mm_appv1alpha.UpdateAppResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateApp.beforeUpdateAppCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateApp.afterUpdateAppCounter, 1)

	mmUpdateApp.t.Helper()

	if mmUpdateApp.inspectFuncUpdateApp != nil {
		mmUpdateApp.inspectFuncUpdateApp(ctx, up1)
	}

	mm_params := AppPublicServiceServerMockUpdateAppParams{ctx, up1}

	// Record call args
	mmUpdateApp.UpdateAppMock.mutex.Lock()
	mmUpdateApp.UpdateAppMock.callArgs = append(mmUpdateApp.UpdateAppMock.callArgs, &mm_params)
	mmUpdateApp.UpdateAppMock.mutex.Unlock()

	for _, e := range mmUpdateApp.UpdateAppMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateApp.UpdateAppMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateApp.UpdateAppMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateApp.UpdateAppMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateApp.UpdateAppMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockUpdateAppParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateApp.t.Errorf("AppPublicServiceServerMock.UpdateApp got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateApp.UpdateAppMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateApp.t.Errorf("AppPublicServiceServerMock.UpdateApp got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateApp.UpdateAppMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateApp.t.Errorf("AppPublicServiceServerMock.UpdateApp got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateApp.UpdateAppMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateApp.UpdateAppMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateApp.t.Fatal("No results are set for the AppPublicServiceServerMock.UpdateApp")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateApp.funcUpdateApp != nil {
		return mmUpdateApp.funcUpdateApp(ctx, up1)
	}
	mmUpdateApp.t.Fatalf("Unexpected call to AppPublicServiceServerMock.UpdateApp. %v %v", ctx, up1)
	return
}

// UpdateAppAfterCounter returns a count of finished AppPublicServiceServerMock.UpdateApp invocations
func (mmUpdateApp *AppPublicServiceServerMock) UpdateAppAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateApp.afterUpdateAppCounter)
}

// UpdateAppBeforeCounter returns a count of AppPublicServiceServerMock.UpdateApp invocations
func (mmUpdateApp *AppPublicServiceServerMock) UpdateAppBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateApp.beforeUpdateAppCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.UpdateApp.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateApp *mAppPublicServiceServerMockUpdateApp) Calls() []*AppPublicServiceServerMockUpdateAppParams {
	mmUpdateApp.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockUpdateAppParams, len(mmUpdateApp.callArgs))
	copy(argCopy, mmUpdateApp.callArgs)

	mmUpdateApp.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAppDone returns true if the count of the UpdateApp invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockUpdateAppDone() bool {
	if m.UpdateAppMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateAppMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateAppMock.invocationsDone()
}

// MinimockUpdateAppInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockUpdateAppInspect() {
	for _, e := range m.UpdateAppMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateApp at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateAppCounter := mm_atomic.LoadUint64(&m.afterUpdateAppCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAppMock.defaultExpectation != nil && afterUpdateAppCounter < 1 {
		if m.UpdateAppMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateApp at\n%s", m.UpdateAppMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateApp at\n%s with params: %#v", m.UpdateAppMock.defaultExpectation.expectationOrigins.origin, *m.UpdateAppMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateApp != nil && afterUpdateAppCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateApp at\n%s", m.funcUpdateAppOrigin)
	}

	if !m.UpdateAppMock.invocationsDone() && afterUpdateAppCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.UpdateApp at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateAppMock.expectedInvocations), m.UpdateAppMock.expectedInvocationsOrigin, afterUpdateAppCounter)
	}
}

type mAppPublicServiceServerMockUpdateConversation struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockUpdateConversationExpectation
	expectations       []*AppPublicServiceServerMockUpdateConversationExpectation

	callArgs []*AppPublicServiceServerMockUpdateConversationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockUpdateConversationExpectation specifies expectation struct of the AppPublicServiceServer.UpdateConversation
type AppPublicServiceServerMockUpdateConversationExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockUpdateConversationParams
	paramPtrs          *AppPublicServiceServerMockUpdateConversationParamPtrs
	expectationOrigins AppPublicServiceServerMockUpdateConversationExpectationOrigins
	results            *AppPublicServiceServerMockUpdateConversationResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockUpdateConversationParams contains parameters of the AppPublicServiceServer.UpdateConversation
type AppPublicServiceServerMockUpdateConversationParams struct {
	ctx context.Context
	up1 *mm_appv1alpha.UpdateConversationRequest
}

// AppPublicServiceServerMockUpdateConversationParamPtrs contains pointers to parameters of the AppPublicServiceServer.UpdateConversation
type AppPublicServiceServerMockUpdateConversationParamPtrs struct {
	ctx *context.Context
	up1 **mm_appv1alpha.UpdateConversationRequest
}

// AppPublicServiceServerMockUpdateConversationResults contains results of the AppPublicServiceServer.UpdateConversation
type AppPublicServiceServerMockUpdateConversationResults struct {
	up2 *mm_appv1alpha.UpdateConversationResponse
	err error
}

// AppPublicServiceServerMockUpdateConversationOrigins contains origins of expectations of the AppPublicServiceServer.UpdateConversation
type AppPublicServiceServerMockUpdateConversationExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) Optional() *mAppPublicServiceServerMockUpdateConversation {
	mmUpdateConversation.optional = true
	return mmUpdateConversation
}

// Expect sets up expected params for AppPublicServiceServer.UpdateConversation
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) Expect(ctx context.Context, up1 *mm_appv1alpha.UpdateConversationRequest) *mAppPublicServiceServerMockUpdateConversation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &AppPublicServiceServerMockUpdateConversationExpectation{}
	}

	if mmUpdateConversation.defaultExpectation.paramPtrs != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by ExpectParams functions")
	}

	mmUpdateConversation.defaultExpectation.params = &AppPublicServiceServerMockUpdateConversationParams{ctx, up1}
	mmUpdateConversation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateConversation.expectations {
		if minimock.Equal(e.params, mmUpdateConversation.defaultExpectation.params) {
			mmUpdateConversation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateConversation.defaultExpectation.params)
		}
	}

	return mmUpdateConversation
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.UpdateConversation
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockUpdateConversation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &AppPublicServiceServerMockUpdateConversationExpectation{}
	}

	if mmUpdateConversation.defaultExpectation.params != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by Expect")
	}

	if mmUpdateConversation.defaultExpectation.paramPtrs == nil {
		mmUpdateConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockUpdateConversationParamPtrs{}
	}
	mmUpdateConversation.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateConversation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateConversation
}

// ExpectUp1Param2 sets up expected param up1 for AppPublicServiceServer.UpdateConversation
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) ExpectUp1Param2(up1 *mm_appv1alpha.UpdateConversationRequest) *mAppPublicServiceServerMockUpdateConversation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &AppPublicServiceServerMockUpdateConversationExpectation{}
	}

	if mmUpdateConversation.defaultExpectation.params != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by Expect")
	}

	if mmUpdateConversation.defaultExpectation.paramPtrs == nil {
		mmUpdateConversation.defaultExpectation.paramPtrs = &AppPublicServiceServerMockUpdateConversationParamPtrs{}
	}
	mmUpdateConversation.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateConversation.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateConversation
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.UpdateConversation
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) Inspect(f func(ctx context.Context, up1 *mm_appv1alpha.UpdateConversationRequest)) *mAppPublicServiceServerMockUpdateConversation {
	if mmUpdateConversation.mock.inspectFuncUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.UpdateConversation")
	}

	mmUpdateConversation.mock.inspectFuncUpdateConversation = f

	return mmUpdateConversation
}

// Return sets up results that will be returned by AppPublicServiceServer.UpdateConversation
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) Return(up2 *mm_appv1alpha.UpdateConversationResponse, err error) *AppPublicServiceServerMock {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by Set")
	}

	if mmUpdateConversation.defaultExpectation == nil {
		mmUpdateConversation.defaultExpectation = &AppPublicServiceServerMockUpdateConversationExpectation{mock: mmUpdateConversation.mock}
	}
	mmUpdateConversation.defaultExpectation.results = &AppPublicServiceServerMockUpdateConversationResults{up2, err}
	mmUpdateConversation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateConversation.mock
}

// Set uses given function f to mock the AppPublicServiceServer.UpdateConversation method
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) Set(f func(ctx context.Context, up1 *mm_appv1alpha.UpdateConversationRequest) (up2 *mm_appv1alpha.UpdateConversationResponse, err error)) *AppPublicServiceServerMock {
	if mmUpdateConversation.defaultExpectation != nil {
		mmUpdateConversation.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.UpdateConversation method")
	}

	if len(mmUpdateConversation.expectations) > 0 {
		mmUpdateConversation.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.UpdateConversation method")
	}

	mmUpdateConversation.mock.funcUpdateConversation = f
	mmUpdateConversation.mock.funcUpdateConversationOrigin = minimock.CallerInfo(1)
	return mmUpdateConversation.mock
}

// When sets expectation for the AppPublicServiceServer.UpdateConversation which will trigger the result defined by the following
// Then helper
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) When(ctx context.Context, up1 *mm_appv1alpha.UpdateConversationRequest) *AppPublicServiceServerMockUpdateConversationExpectation {
	if mmUpdateConversation.mock.funcUpdateConversation != nil {
		mmUpdateConversation.mock.t.Fatalf("AppPublicServiceServerMock.UpdateConversation mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockUpdateConversationExpectation{
		mock:               mmUpdateConversation.mock,
		params:             &AppPublicServiceServerMockUpdateConversationParams{ctx, up1},
		expectationOrigins: AppPublicServiceServerMockUpdateConversationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateConversation.expectations = append(mmUpdateConversation.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.UpdateConversation return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockUpdateConversationExpectation) Then(up2 *mm_appv1alpha.UpdateConversationResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockUpdateConversationResults{up2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.UpdateConversation should be invoked
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) Times(n uint64) *mAppPublicServiceServerMockUpdateConversation {
	if n == 0 {
		mmUpdateConversation.mock.t.Fatalf("Times of AppPublicServiceServerMock.UpdateConversation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateConversation.expectedInvocations, n)
	mmUpdateConversation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateConversation
}

func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) invocationsDone() bool {
	if len(mmUpdateConversation.expectations) == 0 && mmUpdateConversation.defaultExpectation == nil && mmUpdateConversation.mock.funcUpdateConversation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateConversation.mock.afterUpdateConversationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateConversation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateConversation implements mm_appv1alpha.AppPublicServiceServer
func (mmUpdateConversation *AppPublicServiceServerMock) UpdateConversation(ctx context.Context, up1 *mm_appv1alpha.UpdateConversationRequest) (up2 *mm_appv1alpha.UpdateConversationResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateConversation.beforeUpdateConversationCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateConversation.afterUpdateConversationCounter, 1)

	mmUpdateConversation.t.Helper()

	if mmUpdateConversation.inspectFuncUpdateConversation != nil {
		mmUpdateConversation.inspectFuncUpdateConversation(ctx, up1)
	}

	mm_params := AppPublicServiceServerMockUpdateConversationParams{ctx, up1}

	// Record call args
	mmUpdateConversation.UpdateConversationMock.mutex.Lock()
	mmUpdateConversation.UpdateConversationMock.callArgs = append(mmUpdateConversation.UpdateConversationMock.callArgs, &mm_params)
	mmUpdateConversation.UpdateConversationMock.mutex.Unlock()

	for _, e := range mmUpdateConversation.UpdateConversationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateConversation.UpdateConversationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateConversation.UpdateConversationMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateConversation.UpdateConversationMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateConversation.UpdateConversationMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockUpdateConversationParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateConversation.t.Errorf("AppPublicServiceServerMock.UpdateConversation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConversation.UpdateConversationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateConversation.t.Errorf("AppPublicServiceServerMock.UpdateConversation got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateConversation.UpdateConversationMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateConversation.t.Errorf("AppPublicServiceServerMock.UpdateConversation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateConversation.UpdateConversationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateConversation.UpdateConversationMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateConversation.t.Fatal("No results are set for the AppPublicServiceServerMock.UpdateConversation")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateConversation.funcUpdateConversation != nil {
		return mmUpdateConversation.funcUpdateConversation(ctx, up1)
	}
	mmUpdateConversation.t.Fatalf("Unexpected call to AppPublicServiceServerMock.UpdateConversation. %v %v", ctx, up1)
	return
}

// UpdateConversationAfterCounter returns a count of finished AppPublicServiceServerMock.UpdateConversation invocations
func (mmUpdateConversation *AppPublicServiceServerMock) UpdateConversationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConversation.afterUpdateConversationCounter)
}

// UpdateConversationBeforeCounter returns a count of AppPublicServiceServerMock.UpdateConversation invocations
func (mmUpdateConversation *AppPublicServiceServerMock) UpdateConversationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateConversation.beforeUpdateConversationCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.UpdateConversation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateConversation *mAppPublicServiceServerMockUpdateConversation) Calls() []*AppPublicServiceServerMockUpdateConversationParams {
	mmUpdateConversation.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockUpdateConversationParams, len(mmUpdateConversation.callArgs))
	copy(argCopy, mmUpdateConversation.callArgs)

	mmUpdateConversation.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateConversationDone returns true if the count of the UpdateConversation invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockUpdateConversationDone() bool {
	if m.UpdateConversationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateConversationMock.invocationsDone()
}

// MinimockUpdateConversationInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockUpdateConversationInspect() {
	for _, e := range m.UpdateConversationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateConversation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateConversationCounter := mm_atomic.LoadUint64(&m.afterUpdateConversationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateConversationMock.defaultExpectation != nil && afterUpdateConversationCounter < 1 {
		if m.UpdateConversationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateConversation at\n%s", m.UpdateConversationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateConversation at\n%s with params: %#v", m.UpdateConversationMock.defaultExpectation.expectationOrigins.origin, *m.UpdateConversationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateConversation != nil && afterUpdateConversationCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateConversation at\n%s", m.funcUpdateConversationOrigin)
	}

	if !m.UpdateConversationMock.invocationsDone() && afterUpdateConversationCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.UpdateConversation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateConversationMock.expectedInvocations), m.UpdateConversationMock.expectedInvocationsOrigin, afterUpdateConversationCounter)
	}
}

type mAppPublicServiceServerMockUpdateMessage struct {
	optional           bool
	mock               *AppPublicServiceServerMock
	defaultExpectation *AppPublicServiceServerMockUpdateMessageExpectation
	expectations       []*AppPublicServiceServerMockUpdateMessageExpectation

	callArgs []*AppPublicServiceServerMockUpdateMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AppPublicServiceServerMockUpdateMessageExpectation specifies expectation struct of the AppPublicServiceServer.UpdateMessage
type AppPublicServiceServerMockUpdateMessageExpectation struct {
	mock               *AppPublicServiceServerMock
	params             *AppPublicServiceServerMockUpdateMessageParams
	paramPtrs          *AppPublicServiceServerMockUpdateMessageParamPtrs
	expectationOrigins AppPublicServiceServerMockUpdateMessageExpectationOrigins
	results            *AppPublicServiceServerMockUpdateMessageResults
	returnOrigin       string
	Counter            uint64
}

// AppPublicServiceServerMockUpdateMessageParams contains parameters of the AppPublicServiceServer.UpdateMessage
type AppPublicServiceServerMockUpdateMessageParams struct {
	ctx context.Context
	up1 *mm_appv1alpha.UpdateMessageRequest
}

// AppPublicServiceServerMockUpdateMessageParamPtrs contains pointers to parameters of the AppPublicServiceServer.UpdateMessage
type AppPublicServiceServerMockUpdateMessageParamPtrs struct {
	ctx *context.Context
	up1 **mm_appv1alpha.UpdateMessageRequest
}

// AppPublicServiceServerMockUpdateMessageResults contains results of the AppPublicServiceServer.UpdateMessage
type AppPublicServiceServerMockUpdateMessageResults struct {
	up2 *mm_appv1alpha.UpdateMessageResponse
	err error
}

// AppPublicServiceServerMockUpdateMessageOrigins contains origins of expectations of the AppPublicServiceServer.UpdateMessage
type AppPublicServiceServerMockUpdateMessageExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) Optional() *mAppPublicServiceServerMockUpdateMessage {
	mmUpdateMessage.optional = true
	return mmUpdateMessage
}

// Expect sets up expected params for AppPublicServiceServer.UpdateMessage
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) Expect(ctx context.Context, up1 *mm_appv1alpha.UpdateMessageRequest) *mAppPublicServiceServerMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &AppPublicServiceServerMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by ExpectParams functions")
	}

	mmUpdateMessage.defaultExpectation.params = &AppPublicServiceServerMockUpdateMessageParams{ctx, up1}
	mmUpdateMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateMessage.expectations {
		if minimock.Equal(e.params, mmUpdateMessage.defaultExpectation.params) {
			mmUpdateMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateMessage.defaultExpectation.params)
		}
	}

	return mmUpdateMessage
}

// ExpectCtxParam1 sets up expected param ctx for AppPublicServiceServer.UpdateMessage
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) ExpectCtxParam1(ctx context.Context) *mAppPublicServiceServerMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &AppPublicServiceServerMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.params != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by Expect")
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs == nil {
		mmUpdateMessage.defaultExpectation.paramPtrs = &AppPublicServiceServerMockUpdateMessageParamPtrs{}
	}
	mmUpdateMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateMessage
}

// ExpectUp1Param2 sets up expected param up1 for AppPublicServiceServer.UpdateMessage
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) ExpectUp1Param2(up1 *mm_appv1alpha.UpdateMessageRequest) *mAppPublicServiceServerMockUpdateMessage {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &AppPublicServiceServerMockUpdateMessageExpectation{}
	}

	if mmUpdateMessage.defaultExpectation.params != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by Expect")
	}

	if mmUpdateMessage.defaultExpectation.paramPtrs == nil {
		mmUpdateMessage.defaultExpectation.paramPtrs = &AppPublicServiceServerMockUpdateMessageParamPtrs{}
	}
	mmUpdateMessage.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateMessage.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateMessage
}

// Inspect accepts an inspector function that has same arguments as the AppPublicServiceServer.UpdateMessage
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) Inspect(f func(ctx context.Context, up1 *mm_appv1alpha.UpdateMessageRequest)) *mAppPublicServiceServerMockUpdateMessage {
	if mmUpdateMessage.mock.inspectFuncUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("Inspect function is already set for AppPublicServiceServerMock.UpdateMessage")
	}

	mmUpdateMessage.mock.inspectFuncUpdateMessage = f

	return mmUpdateMessage
}

// Return sets up results that will be returned by AppPublicServiceServer.UpdateMessage
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) Return(up2 *mm_appv1alpha.UpdateMessageResponse, err error) *AppPublicServiceServerMock {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by Set")
	}

	if mmUpdateMessage.defaultExpectation == nil {
		mmUpdateMessage.defaultExpectation = &AppPublicServiceServerMockUpdateMessageExpectation{mock: mmUpdateMessage.mock}
	}
	mmUpdateMessage.defaultExpectation.results = &AppPublicServiceServerMockUpdateMessageResults{up2, err}
	mmUpdateMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateMessage.mock
}

// Set uses given function f to mock the AppPublicServiceServer.UpdateMessage method
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) Set(f func(ctx context.Context, up1 *mm_appv1alpha.UpdateMessageRequest) (up2 *mm_appv1alpha.UpdateMessageResponse, err error)) *AppPublicServiceServerMock {
	if mmUpdateMessage.defaultExpectation != nil {
		mmUpdateMessage.mock.t.Fatalf("Default expectation is already set for the AppPublicServiceServer.UpdateMessage method")
	}

	if len(mmUpdateMessage.expectations) > 0 {
		mmUpdateMessage.mock.t.Fatalf("Some expectations are already set for the AppPublicServiceServer.UpdateMessage method")
	}

	mmUpdateMessage.mock.funcUpdateMessage = f
	mmUpdateMessage.mock.funcUpdateMessageOrigin = minimock.CallerInfo(1)
	return mmUpdateMessage.mock
}

// When sets expectation for the AppPublicServiceServer.UpdateMessage which will trigger the result defined by the following
// Then helper
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) When(ctx context.Context, up1 *mm_appv1alpha.UpdateMessageRequest) *AppPublicServiceServerMockUpdateMessageExpectation {
	if mmUpdateMessage.mock.funcUpdateMessage != nil {
		mmUpdateMessage.mock.t.Fatalf("AppPublicServiceServerMock.UpdateMessage mock is already set by Set")
	}

	expectation := &AppPublicServiceServerMockUpdateMessageExpectation{
		mock:               mmUpdateMessage.mock,
		params:             &AppPublicServiceServerMockUpdateMessageParams{ctx, up1},
		expectationOrigins: AppPublicServiceServerMockUpdateMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateMessage.expectations = append(mmUpdateMessage.expectations, expectation)
	return expectation
}

// Then sets up AppPublicServiceServer.UpdateMessage return parameters for the expectation previously defined by the When method
func (e *AppPublicServiceServerMockUpdateMessageExpectation) Then(up2 *mm_appv1alpha.UpdateMessageResponse, err error) *AppPublicServiceServerMock {
	e.results = &AppPublicServiceServerMockUpdateMessageResults{up2, err}
	return e.mock
}

// Times sets number of times AppPublicServiceServer.UpdateMessage should be invoked
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) Times(n uint64) *mAppPublicServiceServerMockUpdateMessage {
	if n == 0 {
		mmUpdateMessage.mock.t.Fatalf("Times of AppPublicServiceServerMock.UpdateMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateMessage.expectedInvocations, n)
	mmUpdateMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateMessage
}

func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) invocationsDone() bool {
	if len(mmUpdateMessage.expectations) == 0 && mmUpdateMessage.defaultExpectation == nil && mmUpdateMessage.mock.funcUpdateMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateMessage.mock.afterUpdateMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateMessage implements mm_appv1alpha.AppPublicServiceServer
func (mmUpdateMessage *AppPublicServiceServerMock) UpdateMessage(ctx context.Context, up1 *mm_appv1alpha.UpdateMessageRequest) (up2 *mm_appv1alpha.UpdateMessageResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateMessage.beforeUpdateMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateMessage.afterUpdateMessageCounter, 1)

	mmUpdateMessage.t.Helper()

	if mmUpdateMessage.inspectFuncUpdateMessage != nil {
		mmUpdateMessage.inspectFuncUpdateMessage(ctx, up1)
	}

	mm_params := AppPublicServiceServerMockUpdateMessageParams{ctx, up1}

	// Record call args
	mmUpdateMessage.UpdateMessageMock.mutex.Lock()
	mmUpdateMessage.UpdateMessageMock.callArgs = append(mmUpdateMessage.UpdateMessageMock.callArgs, &mm_params)
	mmUpdateMessage.UpdateMessageMock.mutex.Unlock()

	for _, e := range mmUpdateMessage.UpdateMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateMessage.UpdateMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateMessage.UpdateMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateMessage.UpdateMessageMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateMessage.UpdateMessageMock.defaultExpectation.paramPtrs

		mm_got := AppPublicServiceServerMockUpdateMessageParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateMessage.t.Errorf("AppPublicServiceServerMock.UpdateMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateMessage.UpdateMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateMessage.t.Errorf("AppPublicServiceServerMock.UpdateMessage got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateMessage.UpdateMessageMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateMessage.t.Errorf("AppPublicServiceServerMock.UpdateMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateMessage.UpdateMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateMessage.UpdateMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateMessage.t.Fatal("No results are set for the AppPublicServiceServerMock.UpdateMessage")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateMessage.funcUpdateMessage != nil {
		return mmUpdateMessage.funcUpdateMessage(ctx, up1)
	}
	mmUpdateMessage.t.Fatalf("Unexpected call to AppPublicServiceServerMock.UpdateMessage. %v %v", ctx, up1)
	return
}

// UpdateMessageAfterCounter returns a count of finished AppPublicServiceServerMock.UpdateMessage invocations
func (mmUpdateMessage *AppPublicServiceServerMock) UpdateMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessage.afterUpdateMessageCounter)
}

// UpdateMessageBeforeCounter returns a count of AppPublicServiceServerMock.UpdateMessage invocations
func (mmUpdateMessage *AppPublicServiceServerMock) UpdateMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMessage.beforeUpdateMessageCounter)
}

// Calls returns a list of arguments used in each call to AppPublicServiceServerMock.UpdateMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateMessage *mAppPublicServiceServerMockUpdateMessage) Calls() []*AppPublicServiceServerMockUpdateMessageParams {
	mmUpdateMessage.mutex.RLock()

	argCopy := make([]*AppPublicServiceServerMockUpdateMessageParams, len(mmUpdateMessage.callArgs))
	copy(argCopy, mmUpdateMessage.callArgs)

	mmUpdateMessage.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateMessageDone returns true if the count of the UpdateMessage invocations corresponds
// the number of defined expectations
func (m *AppPublicServiceServerMock) MinimockUpdateMessageDone() bool {
	if m.UpdateMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMessageMock.invocationsDone()
}

// MinimockUpdateMessageInspect logs each unmet expectation
func (m *AppPublicServiceServerMock) MinimockUpdateMessageInspect() {
	for _, e := range m.UpdateMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateMessageCounter := mm_atomic.LoadUint64(&m.afterUpdateMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMessageMock.defaultExpectation != nil && afterUpdateMessageCounter < 1 {
		if m.UpdateMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateMessage at\n%s", m.UpdateMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateMessage at\n%s with params: %#v", m.UpdateMessageMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMessage != nil && afterUpdateMessageCounter < 1 {
		m.t.Errorf("Expected call to AppPublicServiceServerMock.UpdateMessage at\n%s", m.funcUpdateMessageOrigin)
	}

	if !m.UpdateMessageMock.invocationsDone() && afterUpdateMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to AppPublicServiceServerMock.UpdateMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMessageMock.expectedInvocations), m.UpdateMessageMock.expectedInvocationsOrigin, afterUpdateMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AppPublicServiceServerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChatInspect()

			m.MinimockCreateAppInspect()

			m.MinimockCreateConversationInspect()

			m.MinimockCreateMessageInspect()

			m.MinimockDeleteAppInspect()

			m.MinimockDeleteConversationInspect()

			m.MinimockDeleteMessageInspect()

			m.MinimockGetPlaygroundConversationInspect()

			m.MinimockListAppsInspect()

			m.MinimockListConversationsInspect()

			m.MinimockListMessagesInspect()

			m.MinimockLivenessInspect()

			m.MinimockReadinessInspect()

			m.MinimockRestartPlaygroundConversationInspect()

			m.MinimockUpdateAppInspect()

			m.MinimockUpdateConversationInspect()

			m.MinimockUpdateMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AppPublicServiceServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AppPublicServiceServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChatDone() &&
		m.MinimockCreateAppDone() &&
		m.MinimockCreateConversationDone() &&
		m.MinimockCreateMessageDone() &&
		m.MinimockDeleteAppDone() &&
		m.MinimockDeleteConversationDone() &&
		m.MinimockDeleteMessageDone() &&
		m.MinimockGetPlaygroundConversationDone() &&
		m.MinimockListAppsDone() &&
		m.MinimockListConversationsDone() &&
		m.MinimockListMessagesDone() &&
		m.MinimockLivenessDone() &&
		m.MinimockReadinessDone() &&
		m.MinimockRestartPlaygroundConversationDone() &&
		m.MinimockUpdateAppDone() &&
		m.MinimockUpdateConversationDone() &&
		m.MinimockUpdateMessageDone()
}
