// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_artifactv1alpha "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
)

// ArtifactPublicServiceServerMock implements mm_artifactv1alpha.ArtifactPublicServiceServer
type ArtifactPublicServiceServerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateCatalog          func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateCatalogRequest) (cp2 *mm_artifactv1alpha.CreateCatalogResponse, err error)
	funcCreateCatalogOrigin    string
	inspectFuncCreateCatalog   func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateCatalogRequest)
	afterCreateCatalogCounter  uint64
	beforeCreateCatalogCounter uint64
	CreateCatalogMock          mArtifactPublicServiceServerMockCreateCatalog

	funcDeleteCatalog          func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogRequest) (dp2 *mm_artifactv1alpha.DeleteCatalogResponse, err error)
	funcDeleteCatalogOrigin    string
	inspectFuncDeleteCatalog   func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogRequest)
	afterDeleteCatalogCounter  uint64
	beforeDeleteCatalogCounter uint64
	DeleteCatalogMock          mArtifactPublicServiceServerMockDeleteCatalog

	funcDeleteCatalogFile          func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest) (dp2 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error)
	funcDeleteCatalogFileOrigin    string
	inspectFuncDeleteCatalogFile   func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest)
	afterDeleteCatalogFileCounter  uint64
	beforeDeleteCatalogFileCounter uint64
	DeleteCatalogFileMock          mArtifactPublicServiceServerMockDeleteCatalogFile

	funcGetFileCatalog          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileCatalogRequest) (gp2 *mm_artifactv1alpha.GetFileCatalogResponse, err error)
	funcGetFileCatalogOrigin    string
	inspectFuncGetFileCatalog   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileCatalogRequest)
	afterGetFileCatalogCounter  uint64
	beforeGetFileCatalogCounter uint64
	GetFileCatalogMock          mArtifactPublicServiceServerMockGetFileCatalog

	funcGetObjectDownloadURL          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)
	funcGetObjectDownloadURLOrigin    string
	inspectFuncGetObjectDownloadURL   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest)
	afterGetObjectDownloadURLCounter  uint64
	beforeGetObjectDownloadURLCounter uint64
	GetObjectDownloadURLMock          mArtifactPublicServiceServerMockGetObjectDownloadURL

	funcGetObjectUploadURL          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)
	funcGetObjectUploadURLOrigin    string
	inspectFuncGetObjectUploadURL   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest)
	afterGetObjectUploadURLCounter  uint64
	beforeGetObjectUploadURLCounter uint64
	GetObjectUploadURLMock          mArtifactPublicServiceServerMockGetObjectUploadURL

	funcGetSourceFile          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetSourceFileRequest) (gp2 *mm_artifactv1alpha.GetSourceFileResponse, err error)
	funcGetSourceFileOrigin    string
	inspectFuncGetSourceFile   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetSourceFileRequest)
	afterGetSourceFileCounter  uint64
	beforeGetSourceFileCounter uint64
	GetSourceFileMock          mArtifactPublicServiceServerMockGetSourceFile

	funcListCatalogFiles          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogFilesRequest) (lp2 *mm_artifactv1alpha.ListCatalogFilesResponse, err error)
	funcListCatalogFilesOrigin    string
	inspectFuncListCatalogFiles   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogFilesRequest)
	afterListCatalogFilesCounter  uint64
	beforeListCatalogFilesCounter uint64
	ListCatalogFilesMock          mArtifactPublicServiceServerMockListCatalogFiles

	funcListCatalogRuns          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogRunsRequest) (lp2 *mm_artifactv1alpha.ListCatalogRunsResponse, err error)
	funcListCatalogRunsOrigin    string
	inspectFuncListCatalogRuns   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogRunsRequest)
	afterListCatalogRunsCounter  uint64
	beforeListCatalogRunsCounter uint64
	ListCatalogRunsMock          mArtifactPublicServiceServerMockListCatalogRuns

	funcListCatalogs          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogsRequest) (lp2 *mm_artifactv1alpha.ListCatalogsResponse, err error)
	funcListCatalogsOrigin    string
	inspectFuncListCatalogs   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogsRequest)
	afterListCatalogsCounter  uint64
	beforeListCatalogsCounter uint64
	ListCatalogsMock          mArtifactPublicServiceServerMockListCatalogs

	funcListChunks          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) (lp2 *mm_artifactv1alpha.ListChunksResponse, err error)
	funcListChunksOrigin    string
	inspectFuncListChunks   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest)
	afterListChunksCounter  uint64
	beforeListChunksCounter uint64
	ListChunksMock          mArtifactPublicServiceServerMockListChunks

	funcLiveness          func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) (lp2 *mm_artifactv1alpha.LivenessResponse, err error)
	funcLivenessOrigin    string
	inspectFuncLiveness   func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest)
	afterLivenessCounter  uint64
	beforeLivenessCounter uint64
	LivenessMock          mArtifactPublicServiceServerMockLiveness

	funcProcessCatalogFiles          func(ctx context.Context, pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest) (pp2 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error)
	funcProcessCatalogFilesOrigin    string
	inspectFuncProcessCatalogFiles   func(ctx context.Context, pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest)
	afterProcessCatalogFilesCounter  uint64
	beforeProcessCatalogFilesCounter uint64
	ProcessCatalogFilesMock          mArtifactPublicServiceServerMockProcessCatalogFiles

	funcQuestionAnswering          func(ctx context.Context, qp1 *mm_artifactv1alpha.QuestionAnsweringRequest) (qp2 *mm_artifactv1alpha.QuestionAnsweringResponse, err error)
	funcQuestionAnsweringOrigin    string
	inspectFuncQuestionAnswering   func(ctx context.Context, qp1 *mm_artifactv1alpha.QuestionAnsweringRequest)
	afterQuestionAnsweringCounter  uint64
	beforeQuestionAnsweringCounter uint64
	QuestionAnsweringMock          mArtifactPublicServiceServerMockQuestionAnswering

	funcReadiness          func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) (rp2 *mm_artifactv1alpha.ReadinessResponse, err error)
	funcReadinessOrigin    string
	inspectFuncReadiness   func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest)
	afterReadinessCounter  uint64
	beforeReadinessCounter uint64
	ReadinessMock          mArtifactPublicServiceServerMockReadiness

	funcSimilarityChunksSearch          func(ctx context.Context, sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest) (sp2 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error)
	funcSimilarityChunksSearchOrigin    string
	inspectFuncSimilarityChunksSearch   func(ctx context.Context, sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest)
	afterSimilarityChunksSearchCounter  uint64
	beforeSimilarityChunksSearchCounter uint64
	SimilarityChunksSearchMock          mArtifactPublicServiceServerMockSimilarityChunksSearch

	funcUpdateCatalog          func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateCatalogRequest) (up2 *mm_artifactv1alpha.UpdateCatalogResponse, err error)
	funcUpdateCatalogOrigin    string
	inspectFuncUpdateCatalog   func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateCatalogRequest)
	afterUpdateCatalogCounter  uint64
	beforeUpdateCatalogCounter uint64
	UpdateCatalogMock          mArtifactPublicServiceServerMockUpdateCatalog

	funcUpdateChunk          func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) (up2 *mm_artifactv1alpha.UpdateChunkResponse, err error)
	funcUpdateChunkOrigin    string
	inspectFuncUpdateChunk   func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest)
	afterUpdateChunkCounter  uint64
	beforeUpdateChunkCounter uint64
	UpdateChunkMock          mArtifactPublicServiceServerMockUpdateChunk

	funcUploadCatalogFile          func(ctx context.Context, up1 *mm_artifactv1alpha.UploadCatalogFileRequest) (up2 *mm_artifactv1alpha.UploadCatalogFileResponse, err error)
	funcUploadCatalogFileOrigin    string
	inspectFuncUploadCatalogFile   func(ctx context.Context, up1 *mm_artifactv1alpha.UploadCatalogFileRequest)
	afterUploadCatalogFileCounter  uint64
	beforeUploadCatalogFileCounter uint64
	UploadCatalogFileMock          mArtifactPublicServiceServerMockUploadCatalogFile
}

// NewArtifactPublicServiceServerMock returns a mock for mm_artifactv1alpha.ArtifactPublicServiceServer
func NewArtifactPublicServiceServerMock(t minimock.Tester) *ArtifactPublicServiceServerMock {
	m := &ArtifactPublicServiceServerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCatalogMock = mArtifactPublicServiceServerMockCreateCatalog{mock: m}
	m.CreateCatalogMock.callArgs = []*ArtifactPublicServiceServerMockCreateCatalogParams{}

	m.DeleteCatalogMock = mArtifactPublicServiceServerMockDeleteCatalog{mock: m}
	m.DeleteCatalogMock.callArgs = []*ArtifactPublicServiceServerMockDeleteCatalogParams{}

	m.DeleteCatalogFileMock = mArtifactPublicServiceServerMockDeleteCatalogFile{mock: m}
	m.DeleteCatalogFileMock.callArgs = []*ArtifactPublicServiceServerMockDeleteCatalogFileParams{}

	m.GetFileCatalogMock = mArtifactPublicServiceServerMockGetFileCatalog{mock: m}
	m.GetFileCatalogMock.callArgs = []*ArtifactPublicServiceServerMockGetFileCatalogParams{}

	m.GetObjectDownloadURLMock = mArtifactPublicServiceServerMockGetObjectDownloadURL{mock: m}
	m.GetObjectDownloadURLMock.callArgs = []*ArtifactPublicServiceServerMockGetObjectDownloadURLParams{}

	m.GetObjectUploadURLMock = mArtifactPublicServiceServerMockGetObjectUploadURL{mock: m}
	m.GetObjectUploadURLMock.callArgs = []*ArtifactPublicServiceServerMockGetObjectUploadURLParams{}

	m.GetSourceFileMock = mArtifactPublicServiceServerMockGetSourceFile{mock: m}
	m.GetSourceFileMock.callArgs = []*ArtifactPublicServiceServerMockGetSourceFileParams{}

	m.ListCatalogFilesMock = mArtifactPublicServiceServerMockListCatalogFiles{mock: m}
	m.ListCatalogFilesMock.callArgs = []*ArtifactPublicServiceServerMockListCatalogFilesParams{}

	m.ListCatalogRunsMock = mArtifactPublicServiceServerMockListCatalogRuns{mock: m}
	m.ListCatalogRunsMock.callArgs = []*ArtifactPublicServiceServerMockListCatalogRunsParams{}

	m.ListCatalogsMock = mArtifactPublicServiceServerMockListCatalogs{mock: m}
	m.ListCatalogsMock.callArgs = []*ArtifactPublicServiceServerMockListCatalogsParams{}

	m.ListChunksMock = mArtifactPublicServiceServerMockListChunks{mock: m}
	m.ListChunksMock.callArgs = []*ArtifactPublicServiceServerMockListChunksParams{}

	m.LivenessMock = mArtifactPublicServiceServerMockLiveness{mock: m}
	m.LivenessMock.callArgs = []*ArtifactPublicServiceServerMockLivenessParams{}

	m.ProcessCatalogFilesMock = mArtifactPublicServiceServerMockProcessCatalogFiles{mock: m}
	m.ProcessCatalogFilesMock.callArgs = []*ArtifactPublicServiceServerMockProcessCatalogFilesParams{}

	m.QuestionAnsweringMock = mArtifactPublicServiceServerMockQuestionAnswering{mock: m}
	m.QuestionAnsweringMock.callArgs = []*ArtifactPublicServiceServerMockQuestionAnsweringParams{}

	m.ReadinessMock = mArtifactPublicServiceServerMockReadiness{mock: m}
	m.ReadinessMock.callArgs = []*ArtifactPublicServiceServerMockReadinessParams{}

	m.SimilarityChunksSearchMock = mArtifactPublicServiceServerMockSimilarityChunksSearch{mock: m}
	m.SimilarityChunksSearchMock.callArgs = []*ArtifactPublicServiceServerMockSimilarityChunksSearchParams{}

	m.UpdateCatalogMock = mArtifactPublicServiceServerMockUpdateCatalog{mock: m}
	m.UpdateCatalogMock.callArgs = []*ArtifactPublicServiceServerMockUpdateCatalogParams{}

	m.UpdateChunkMock = mArtifactPublicServiceServerMockUpdateChunk{mock: m}
	m.UpdateChunkMock.callArgs = []*ArtifactPublicServiceServerMockUpdateChunkParams{}

	m.UploadCatalogFileMock = mArtifactPublicServiceServerMockUploadCatalogFile{mock: m}
	m.UploadCatalogFileMock.callArgs = []*ArtifactPublicServiceServerMockUploadCatalogFileParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mArtifactPublicServiceServerMockCreateCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockCreateCatalogExpectation
	expectations       []*ArtifactPublicServiceServerMockCreateCatalogExpectation

	callArgs []*ArtifactPublicServiceServerMockCreateCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockCreateCatalogExpectation specifies expectation struct of the ArtifactPublicServiceServer.CreateCatalog
type ArtifactPublicServiceServerMockCreateCatalogExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockCreateCatalogParams
	paramPtrs          *ArtifactPublicServiceServerMockCreateCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockCreateCatalogExpectationOrigins
	results            *ArtifactPublicServiceServerMockCreateCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockCreateCatalogParams contains parameters of the ArtifactPublicServiceServer.CreateCatalog
type ArtifactPublicServiceServerMockCreateCatalogParams struct {
	ctx context.Context
	cp1 *mm_artifactv1alpha.CreateCatalogRequest
}

// ArtifactPublicServiceServerMockCreateCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.CreateCatalog
type ArtifactPublicServiceServerMockCreateCatalogParamPtrs struct {
	ctx *context.Context
	cp1 **mm_artifactv1alpha.CreateCatalogRequest
}

// ArtifactPublicServiceServerMockCreateCatalogResults contains results of the ArtifactPublicServiceServer.CreateCatalog
type ArtifactPublicServiceServerMockCreateCatalogResults struct {
	cp2 *mm_artifactv1alpha.CreateCatalogResponse
	err error
}

// ArtifactPublicServiceServerMockCreateCatalogOrigins contains origins of expectations of the ArtifactPublicServiceServer.CreateCatalog
type ArtifactPublicServiceServerMockCreateCatalogExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) Optional() *mArtifactPublicServiceServerMockCreateCatalog {
	mmCreateCatalog.optional = true
	return mmCreateCatalog
}

// Expect sets up expected params for ArtifactPublicServiceServer.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) Expect(ctx context.Context, cp1 *mm_artifactv1alpha.CreateCatalogRequest) *mArtifactPublicServiceServerMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by ExpectParams functions")
	}

	mmCreateCatalog.defaultExpectation.params = &ArtifactPublicServiceServerMockCreateCatalogParams{ctx, cp1}
	mmCreateCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCatalog.expectations {
		if minimock.Equal(e.params, mmCreateCatalog.defaultExpectation.params) {
			mmCreateCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCatalog.defaultExpectation.params)
		}
	}

	return mmCreateCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCatalog
}

// ExpectCp1Param2 sets up expected param cp1 for ArtifactPublicServiceServer.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) ExpectCp1Param2(cp1 *mm_artifactv1alpha.CreateCatalogRequest) *mArtifactPublicServiceServerMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateCatalog.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) Inspect(f func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateCatalogRequest)) *mArtifactPublicServiceServerMockCreateCatalog {
	if mmCreateCatalog.mock.inspectFuncCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.CreateCatalog")
	}

	mmCreateCatalog.mock.inspectFuncCreateCatalog = f

	return mmCreateCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) Return(cp2 *mm_artifactv1alpha.CreateCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockCreateCatalogExpectation{mock: mmCreateCatalog.mock}
	}
	mmCreateCatalog.defaultExpectation.results = &ArtifactPublicServiceServerMockCreateCatalogResults{cp2, err}
	mmCreateCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.CreateCatalog method
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) Set(f func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateCatalogRequest) (cp2 *mm_artifactv1alpha.CreateCatalogResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmCreateCatalog.defaultExpectation != nil {
		mmCreateCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.CreateCatalog method")
	}

	if len(mmCreateCatalog.expectations) > 0 {
		mmCreateCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.CreateCatalog method")
	}

	mmCreateCatalog.mock.funcCreateCatalog = f
	mmCreateCatalog.mock.funcCreateCatalogOrigin = minimock.CallerInfo(1)
	return mmCreateCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceServer.CreateCatalog which will trigger the result defined by the following
// Then helper
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) When(ctx context.Context, cp1 *mm_artifactv1alpha.CreateCatalogRequest) *ArtifactPublicServiceServerMockCreateCatalogExpectation {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockCreateCatalogExpectation{
		mock:               mmCreateCatalog.mock,
		params:             &ArtifactPublicServiceServerMockCreateCatalogParams{ctx, cp1},
		expectationOrigins: ArtifactPublicServiceServerMockCreateCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCatalog.expectations = append(mmCreateCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.CreateCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockCreateCatalogExpectation) Then(cp2 *mm_artifactv1alpha.CreateCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockCreateCatalogResults{cp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.CreateCatalog should be invoked
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) Times(n uint64) *mArtifactPublicServiceServerMockCreateCatalog {
	if n == 0 {
		mmCreateCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.CreateCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCatalog.expectedInvocations, n)
	mmCreateCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCatalog
}

func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) invocationsDone() bool {
	if len(mmCreateCatalog.expectations) == 0 && mmCreateCatalog.defaultExpectation == nil && mmCreateCatalog.mock.funcCreateCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCatalog.mock.afterCreateCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCatalog implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmCreateCatalog *ArtifactPublicServiceServerMock) CreateCatalog(ctx context.Context, cp1 *mm_artifactv1alpha.CreateCatalogRequest) (cp2 *mm_artifactv1alpha.CreateCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmCreateCatalog.beforeCreateCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCatalog.afterCreateCatalogCounter, 1)

	mmCreateCatalog.t.Helper()

	if mmCreateCatalog.inspectFuncCreateCatalog != nil {
		mmCreateCatalog.inspectFuncCreateCatalog(ctx, cp1)
	}

	mm_params := ArtifactPublicServiceServerMockCreateCatalogParams{ctx, cp1}

	// Record call args
	mmCreateCatalog.CreateCatalogMock.mutex.Lock()
	mmCreateCatalog.CreateCatalogMock.callArgs = append(mmCreateCatalog.CreateCatalogMock.callArgs, &mm_params)
	mmCreateCatalog.CreateCatalogMock.mutex.Unlock()

	for _, e := range mmCreateCatalog.CreateCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateCatalog.CreateCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCatalog.CreateCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCatalog.CreateCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCatalog.CreateCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockCreateCatalogParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceServerMock.CreateCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCatalog.CreateCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceServerMock.CreateCatalog got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCatalog.CreateCatalogMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCatalog.t.Errorf("ArtifactPublicServiceServerMock.CreateCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCatalog.CreateCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCatalog.CreateCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCatalog.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.CreateCatalog")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateCatalog.funcCreateCatalog != nil {
		return mmCreateCatalog.funcCreateCatalog(ctx, cp1)
	}
	mmCreateCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.CreateCatalog. %v %v", ctx, cp1)
	return
}

// CreateCatalogAfterCounter returns a count of finished ArtifactPublicServiceServerMock.CreateCatalog invocations
func (mmCreateCatalog *ArtifactPublicServiceServerMock) CreateCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalog.afterCreateCatalogCounter)
}

// CreateCatalogBeforeCounter returns a count of ArtifactPublicServiceServerMock.CreateCatalog invocations
func (mmCreateCatalog *ArtifactPublicServiceServerMock) CreateCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalog.beforeCreateCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.CreateCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCatalog *mArtifactPublicServiceServerMockCreateCatalog) Calls() []*ArtifactPublicServiceServerMockCreateCatalogParams {
	mmCreateCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockCreateCatalogParams, len(mmCreateCatalog.callArgs))
	copy(argCopy, mmCreateCatalog.callArgs)

	mmCreateCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCatalogDone returns true if the count of the CreateCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockCreateCatalogDone() bool {
	if m.CreateCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCatalogMock.invocationsDone()
}

// MinimockCreateCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockCreateCatalogInspect() {
	for _, e := range m.CreateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCatalogCounter := mm_atomic.LoadUint64(&m.afterCreateCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCatalogMock.defaultExpectation != nil && afterCreateCatalogCounter < 1 {
		if m.CreateCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateCatalog at\n%s", m.CreateCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateCatalog at\n%s with params: %#v", m.CreateCatalogMock.defaultExpectation.expectationOrigins.origin, *m.CreateCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCatalog != nil && afterCreateCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateCatalog at\n%s", m.funcCreateCatalogOrigin)
	}

	if !m.CreateCatalogMock.invocationsDone() && afterCreateCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.CreateCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCatalogMock.expectedInvocations), m.CreateCatalogMock.expectedInvocationsOrigin, afterCreateCatalogCounter)
	}
}

type mArtifactPublicServiceServerMockDeleteCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockDeleteCatalogExpectation
	expectations       []*ArtifactPublicServiceServerMockDeleteCatalogExpectation

	callArgs []*ArtifactPublicServiceServerMockDeleteCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockDeleteCatalogExpectation specifies expectation struct of the ArtifactPublicServiceServer.DeleteCatalog
type ArtifactPublicServiceServerMockDeleteCatalogExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockDeleteCatalogParams
	paramPtrs          *ArtifactPublicServiceServerMockDeleteCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockDeleteCatalogExpectationOrigins
	results            *ArtifactPublicServiceServerMockDeleteCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockDeleteCatalogParams contains parameters of the ArtifactPublicServiceServer.DeleteCatalog
type ArtifactPublicServiceServerMockDeleteCatalogParams struct {
	ctx context.Context
	dp1 *mm_artifactv1alpha.DeleteCatalogRequest
}

// ArtifactPublicServiceServerMockDeleteCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.DeleteCatalog
type ArtifactPublicServiceServerMockDeleteCatalogParamPtrs struct {
	ctx *context.Context
	dp1 **mm_artifactv1alpha.DeleteCatalogRequest
}

// ArtifactPublicServiceServerMockDeleteCatalogResults contains results of the ArtifactPublicServiceServer.DeleteCatalog
type ArtifactPublicServiceServerMockDeleteCatalogResults struct {
	dp2 *mm_artifactv1alpha.DeleteCatalogResponse
	err error
}

// ArtifactPublicServiceServerMockDeleteCatalogOrigins contains origins of expectations of the ArtifactPublicServiceServer.DeleteCatalog
type ArtifactPublicServiceServerMockDeleteCatalogExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) Optional() *mArtifactPublicServiceServerMockDeleteCatalog {
	mmDeleteCatalog.optional = true
	return mmDeleteCatalog
}

// Expect sets up expected params for ArtifactPublicServiceServer.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) Expect(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogRequest) *mArtifactPublicServiceServerMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by ExpectParams functions")
	}

	mmDeleteCatalog.defaultExpectation.params = &ArtifactPublicServiceServerMockDeleteCatalogParams{ctx, dp1}
	mmDeleteCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCatalog.expectations {
		if minimock.Equal(e.params, mmDeleteCatalog.defaultExpectation.params) {
			mmDeleteCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCatalog.defaultExpectation.params)
		}
	}

	return mmDeleteCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCatalog
}

// ExpectDp1Param2 sets up expected param dp1 for ArtifactPublicServiceServer.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) ExpectDp1Param2(dp1 *mm_artifactv1alpha.DeleteCatalogRequest) *mArtifactPublicServiceServerMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteCatalog.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) Inspect(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogRequest)) *mArtifactPublicServiceServerMockDeleteCatalog {
	if mmDeleteCatalog.mock.inspectFuncDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.DeleteCatalog")
	}

	mmDeleteCatalog.mock.inspectFuncDeleteCatalog = f

	return mmDeleteCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) Return(dp2 *mm_artifactv1alpha.DeleteCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogExpectation{mock: mmDeleteCatalog.mock}
	}
	mmDeleteCatalog.defaultExpectation.results = &ArtifactPublicServiceServerMockDeleteCatalogResults{dp2, err}
	mmDeleteCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.DeleteCatalog method
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) Set(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogRequest) (dp2 *mm_artifactv1alpha.DeleteCatalogResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmDeleteCatalog.defaultExpectation != nil {
		mmDeleteCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.DeleteCatalog method")
	}

	if len(mmDeleteCatalog.expectations) > 0 {
		mmDeleteCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.DeleteCatalog method")
	}

	mmDeleteCatalog.mock.funcDeleteCatalog = f
	mmDeleteCatalog.mock.funcDeleteCatalogOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceServer.DeleteCatalog which will trigger the result defined by the following
// Then helper
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) When(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogRequest) *ArtifactPublicServiceServerMockDeleteCatalogExpectation {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockDeleteCatalogExpectation{
		mock:               mmDeleteCatalog.mock,
		params:             &ArtifactPublicServiceServerMockDeleteCatalogParams{ctx, dp1},
		expectationOrigins: ArtifactPublicServiceServerMockDeleteCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCatalog.expectations = append(mmDeleteCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.DeleteCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockDeleteCatalogExpectation) Then(dp2 *mm_artifactv1alpha.DeleteCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockDeleteCatalogResults{dp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.DeleteCatalog should be invoked
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) Times(n uint64) *mArtifactPublicServiceServerMockDeleteCatalog {
	if n == 0 {
		mmDeleteCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.DeleteCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCatalog.expectedInvocations, n)
	mmDeleteCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalog
}

func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) invocationsDone() bool {
	if len(mmDeleteCatalog.expectations) == 0 && mmDeleteCatalog.defaultExpectation == nil && mmDeleteCatalog.mock.funcDeleteCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCatalog.mock.afterDeleteCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCatalog implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmDeleteCatalog *ArtifactPublicServiceServerMock) DeleteCatalog(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogRequest) (dp2 *mm_artifactv1alpha.DeleteCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteCatalog.beforeDeleteCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCatalog.afterDeleteCatalogCounter, 1)

	mmDeleteCatalog.t.Helper()

	if mmDeleteCatalog.inspectFuncDeleteCatalog != nil {
		mmDeleteCatalog.inspectFuncDeleteCatalog(ctx, dp1)
	}

	mm_params := ArtifactPublicServiceServerMockDeleteCatalogParams{ctx, dp1}

	// Record call args
	mmDeleteCatalog.DeleteCatalogMock.mutex.Lock()
	mmDeleteCatalog.DeleteCatalogMock.callArgs = append(mmDeleteCatalog.DeleteCatalogMock.callArgs, &mm_params)
	mmDeleteCatalog.DeleteCatalogMock.mutex.Unlock()

	for _, e := range mmDeleteCatalog.DeleteCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteCatalog.DeleteCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockDeleteCatalogParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceServerMock.DeleteCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceServerMock.DeleteCatalog got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCatalog.t.Errorf("ArtifactPublicServiceServerMock.DeleteCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCatalog.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.DeleteCatalog")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteCatalog.funcDeleteCatalog != nil {
		return mmDeleteCatalog.funcDeleteCatalog(ctx, dp1)
	}
	mmDeleteCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.DeleteCatalog. %v %v", ctx, dp1)
	return
}

// DeleteCatalogAfterCounter returns a count of finished ArtifactPublicServiceServerMock.DeleteCatalog invocations
func (mmDeleteCatalog *ArtifactPublicServiceServerMock) DeleteCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalog.afterDeleteCatalogCounter)
}

// DeleteCatalogBeforeCounter returns a count of ArtifactPublicServiceServerMock.DeleteCatalog invocations
func (mmDeleteCatalog *ArtifactPublicServiceServerMock) DeleteCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalog.beforeDeleteCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.DeleteCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCatalog *mArtifactPublicServiceServerMockDeleteCatalog) Calls() []*ArtifactPublicServiceServerMockDeleteCatalogParams {
	mmDeleteCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockDeleteCatalogParams, len(mmDeleteCatalog.callArgs))
	copy(argCopy, mmDeleteCatalog.callArgs)

	mmDeleteCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCatalogDone returns true if the count of the DeleteCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockDeleteCatalogDone() bool {
	if m.DeleteCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCatalogMock.invocationsDone()
}

// MinimockDeleteCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockDeleteCatalogInspect() {
	for _, e := range m.DeleteCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCatalogCounter := mm_atomic.LoadUint64(&m.afterDeleteCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCatalogMock.defaultExpectation != nil && afterDeleteCatalogCounter < 1 {
		if m.DeleteCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalog at\n%s", m.DeleteCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalog at\n%s with params: %#v", m.DeleteCatalogMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCatalog != nil && afterDeleteCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalog at\n%s", m.funcDeleteCatalogOrigin)
	}

	if !m.DeleteCatalogMock.invocationsDone() && afterDeleteCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.DeleteCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCatalogMock.expectedInvocations), m.DeleteCatalogMock.expectedInvocationsOrigin, afterDeleteCatalogCounter)
	}
}

type mArtifactPublicServiceServerMockDeleteCatalogFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockDeleteCatalogFileExpectation
	expectations       []*ArtifactPublicServiceServerMockDeleteCatalogFileExpectation

	callArgs []*ArtifactPublicServiceServerMockDeleteCatalogFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockDeleteCatalogFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.DeleteCatalogFile
type ArtifactPublicServiceServerMockDeleteCatalogFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockDeleteCatalogFileParams
	paramPtrs          *ArtifactPublicServiceServerMockDeleteCatalogFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockDeleteCatalogFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockDeleteCatalogFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockDeleteCatalogFileParams contains parameters of the ArtifactPublicServiceServer.DeleteCatalogFile
type ArtifactPublicServiceServerMockDeleteCatalogFileParams struct {
	ctx context.Context
	dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest
}

// ArtifactPublicServiceServerMockDeleteCatalogFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.DeleteCatalogFile
type ArtifactPublicServiceServerMockDeleteCatalogFileParamPtrs struct {
	ctx *context.Context
	dp1 **mm_artifactv1alpha.DeleteCatalogFileRequest
}

// ArtifactPublicServiceServerMockDeleteCatalogFileResults contains results of the ArtifactPublicServiceServer.DeleteCatalogFile
type ArtifactPublicServiceServerMockDeleteCatalogFileResults struct {
	dp2 *mm_artifactv1alpha.DeleteCatalogFileResponse
	err error
}

// ArtifactPublicServiceServerMockDeleteCatalogFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.DeleteCatalogFile
type ArtifactPublicServiceServerMockDeleteCatalogFileExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) Optional() *mArtifactPublicServiceServerMockDeleteCatalogFile {
	mmDeleteCatalogFile.optional = true
	return mmDeleteCatalogFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) Expect(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest) *mArtifactPublicServiceServerMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by ExpectParams functions")
	}

	mmDeleteCatalogFile.defaultExpectation.params = &ArtifactPublicServiceServerMockDeleteCatalogFileParams{ctx, dp1}
	mmDeleteCatalogFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCatalogFile.expectations {
		if minimock.Equal(e.params, mmDeleteCatalogFile.defaultExpectation.params) {
			mmDeleteCatalogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCatalogFile.defaultExpectation.params)
		}
	}

	return mmDeleteCatalogFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCatalogFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCatalogFile
}

// ExpectDp1Param2 sets up expected param dp1 for ArtifactPublicServiceServer.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) ExpectDp1Param2(dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest) *mArtifactPublicServiceServerMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteCatalogFile.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteCatalogFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) Inspect(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest)) *mArtifactPublicServiceServerMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.inspectFuncDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.DeleteCatalogFile")
	}

	mmDeleteCatalogFile.mock.inspectFuncDeleteCatalogFile = f

	return mmDeleteCatalogFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) Return(dp2 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteCatalogFileExpectation{mock: mmDeleteCatalogFile.mock}
	}
	mmDeleteCatalogFile.defaultExpectation.results = &ArtifactPublicServiceServerMockDeleteCatalogFileResults{dp2, err}
	mmDeleteCatalogFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalogFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.DeleteCatalogFile method
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) Set(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest) (dp2 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmDeleteCatalogFile.defaultExpectation != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.DeleteCatalogFile method")
	}

	if len(mmDeleteCatalogFile.expectations) > 0 {
		mmDeleteCatalogFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.DeleteCatalogFile method")
	}

	mmDeleteCatalogFile.mock.funcDeleteCatalogFile = f
	mmDeleteCatalogFile.mock.funcDeleteCatalogFileOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalogFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.DeleteCatalogFile which will trigger the result defined by the following
// Then helper
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) When(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest) *ArtifactPublicServiceServerMockDeleteCatalogFileExpectation {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteCatalogFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockDeleteCatalogFileExpectation{
		mock:               mmDeleteCatalogFile.mock,
		params:             &ArtifactPublicServiceServerMockDeleteCatalogFileParams{ctx, dp1},
		expectationOrigins: ArtifactPublicServiceServerMockDeleteCatalogFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCatalogFile.expectations = append(mmDeleteCatalogFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.DeleteCatalogFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockDeleteCatalogFileExpectation) Then(dp2 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockDeleteCatalogFileResults{dp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.DeleteCatalogFile should be invoked
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) Times(n uint64) *mArtifactPublicServiceServerMockDeleteCatalogFile {
	if n == 0 {
		mmDeleteCatalogFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.DeleteCatalogFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCatalogFile.expectedInvocations, n)
	mmDeleteCatalogFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalogFile
}

func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) invocationsDone() bool {
	if len(mmDeleteCatalogFile.expectations) == 0 && mmDeleteCatalogFile.defaultExpectation == nil && mmDeleteCatalogFile.mock.funcDeleteCatalogFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCatalogFile.mock.afterDeleteCatalogFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCatalogFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCatalogFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmDeleteCatalogFile *ArtifactPublicServiceServerMock) DeleteCatalogFile(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteCatalogFileRequest) (dp2 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteCatalogFile.beforeDeleteCatalogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCatalogFile.afterDeleteCatalogFileCounter, 1)

	mmDeleteCatalogFile.t.Helper()

	if mmDeleteCatalogFile.inspectFuncDeleteCatalogFile != nil {
		mmDeleteCatalogFile.inspectFuncDeleteCatalogFile(ctx, dp1)
	}

	mm_params := ArtifactPublicServiceServerMockDeleteCatalogFileParams{ctx, dp1}

	// Record call args
	mmDeleteCatalogFile.DeleteCatalogFileMock.mutex.Lock()
	mmDeleteCatalogFile.DeleteCatalogFileMock.callArgs = append(mmDeleteCatalogFile.DeleteCatalogFileMock.callArgs, &mm_params)
	mmDeleteCatalogFile.DeleteCatalogFileMock.mutex.Unlock()

	for _, e := range mmDeleteCatalogFile.DeleteCatalogFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockDeleteCatalogFileParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceServerMock.DeleteCatalogFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceServerMock.DeleteCatalogFile got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceServerMock.DeleteCatalogFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCatalogFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.DeleteCatalogFile")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteCatalogFile.funcDeleteCatalogFile != nil {
		return mmDeleteCatalogFile.funcDeleteCatalogFile(ctx, dp1)
	}
	mmDeleteCatalogFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.DeleteCatalogFile. %v %v", ctx, dp1)
	return
}

// DeleteCatalogFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.DeleteCatalogFile invocations
func (mmDeleteCatalogFile *ArtifactPublicServiceServerMock) DeleteCatalogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalogFile.afterDeleteCatalogFileCounter)
}

// DeleteCatalogFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.DeleteCatalogFile invocations
func (mmDeleteCatalogFile *ArtifactPublicServiceServerMock) DeleteCatalogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalogFile.beforeDeleteCatalogFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.DeleteCatalogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCatalogFile *mArtifactPublicServiceServerMockDeleteCatalogFile) Calls() []*ArtifactPublicServiceServerMockDeleteCatalogFileParams {
	mmDeleteCatalogFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockDeleteCatalogFileParams, len(mmDeleteCatalogFile.callArgs))
	copy(argCopy, mmDeleteCatalogFile.callArgs)

	mmDeleteCatalogFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCatalogFileDone returns true if the count of the DeleteCatalogFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockDeleteCatalogFileDone() bool {
	if m.DeleteCatalogFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCatalogFileMock.invocationsDone()
}

// MinimockDeleteCatalogFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockDeleteCatalogFileInspect() {
	for _, e := range m.DeleteCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalogFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCatalogFileCounter := mm_atomic.LoadUint64(&m.afterDeleteCatalogFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCatalogFileMock.defaultExpectation != nil && afterDeleteCatalogFileCounter < 1 {
		if m.DeleteCatalogFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalogFile at\n%s", m.DeleteCatalogFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalogFile at\n%s with params: %#v", m.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCatalogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCatalogFile != nil && afterDeleteCatalogFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteCatalogFile at\n%s", m.funcDeleteCatalogFileOrigin)
	}

	if !m.DeleteCatalogFileMock.invocationsDone() && afterDeleteCatalogFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.DeleteCatalogFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCatalogFileMock.expectedInvocations), m.DeleteCatalogFileMock.expectedInvocationsOrigin, afterDeleteCatalogFileCounter)
	}
}

type mArtifactPublicServiceServerMockGetFileCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetFileCatalogExpectation
	expectations       []*ArtifactPublicServiceServerMockGetFileCatalogExpectation

	callArgs []*ArtifactPublicServiceServerMockGetFileCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetFileCatalogExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetFileCatalog
type ArtifactPublicServiceServerMockGetFileCatalogExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetFileCatalogParams
	paramPtrs          *ArtifactPublicServiceServerMockGetFileCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetFileCatalogExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetFileCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetFileCatalogParams contains parameters of the ArtifactPublicServiceServer.GetFileCatalog
type ArtifactPublicServiceServerMockGetFileCatalogParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetFileCatalogRequest
}

// ArtifactPublicServiceServerMockGetFileCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetFileCatalog
type ArtifactPublicServiceServerMockGetFileCatalogParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetFileCatalogRequest
}

// ArtifactPublicServiceServerMockGetFileCatalogResults contains results of the ArtifactPublicServiceServer.GetFileCatalog
type ArtifactPublicServiceServerMockGetFileCatalogResults struct {
	gp2 *mm_artifactv1alpha.GetFileCatalogResponse
	err error
}

// ArtifactPublicServiceServerMockGetFileCatalogOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetFileCatalog
type ArtifactPublicServiceServerMockGetFileCatalogExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) Optional() *mArtifactPublicServiceServerMockGetFileCatalog {
	mmGetFileCatalog.optional = true
	return mmGetFileCatalog
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileCatalogRequest) *mArtifactPublicServiceServerMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceServerMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by ExpectParams functions")
	}

	mmGetFileCatalog.defaultExpectation.params = &ArtifactPublicServiceServerMockGetFileCatalogParams{ctx, gp1}
	mmGetFileCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileCatalog.expectations {
		if minimock.Equal(e.params, mmGetFileCatalog.defaultExpectation.params) {
			mmGetFileCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileCatalog.defaultExpectation.params)
		}
	}

	return mmGetFileCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceServerMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileCatalog
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetFileCatalogRequest) *mArtifactPublicServiceServerMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceServerMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetFileCatalog.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetFileCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileCatalogRequest)) *mArtifactPublicServiceServerMockGetFileCatalog {
	if mmGetFileCatalog.mock.inspectFuncGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetFileCatalog")
	}

	mmGetFileCatalog.mock.inspectFuncGetFileCatalog = f

	return mmGetFileCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) Return(gp2 *mm_artifactv1alpha.GetFileCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceServerMockGetFileCatalogExpectation{mock: mmGetFileCatalog.mock}
	}
	mmGetFileCatalog.defaultExpectation.results = &ArtifactPublicServiceServerMockGetFileCatalogResults{gp2, err}
	mmGetFileCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetFileCatalog method
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileCatalogRequest) (gp2 *mm_artifactv1alpha.GetFileCatalogResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetFileCatalog.defaultExpectation != nil {
		mmGetFileCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetFileCatalog method")
	}

	if len(mmGetFileCatalog.expectations) > 0 {
		mmGetFileCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetFileCatalog method")
	}

	mmGetFileCatalog.mock.funcGetFileCatalog = f
	mmGetFileCatalog.mock.funcGetFileCatalogOrigin = minimock.CallerInfo(1)
	return mmGetFileCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetFileCatalog which will trigger the result defined by the following
// Then helper
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileCatalogRequest) *ArtifactPublicServiceServerMockGetFileCatalogExpectation {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFileCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetFileCatalogExpectation{
		mock:               mmGetFileCatalog.mock,
		params:             &ArtifactPublicServiceServerMockGetFileCatalogParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetFileCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileCatalog.expectations = append(mmGetFileCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetFileCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetFileCatalogExpectation) Then(gp2 *mm_artifactv1alpha.GetFileCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetFileCatalogResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetFileCatalog should be invoked
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) Times(n uint64) *mArtifactPublicServiceServerMockGetFileCatalog {
	if n == 0 {
		mmGetFileCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetFileCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileCatalog.expectedInvocations, n)
	mmGetFileCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileCatalog
}

func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) invocationsDone() bool {
	if len(mmGetFileCatalog.expectations) == 0 && mmGetFileCatalog.defaultExpectation == nil && mmGetFileCatalog.mock.funcGetFileCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileCatalog.mock.afterGetFileCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileCatalog implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetFileCatalog *ArtifactPublicServiceServerMock) GetFileCatalog(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileCatalogRequest) (gp2 *mm_artifactv1alpha.GetFileCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmGetFileCatalog.beforeGetFileCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileCatalog.afterGetFileCatalogCounter, 1)

	mmGetFileCatalog.t.Helper()

	if mmGetFileCatalog.inspectFuncGetFileCatalog != nil {
		mmGetFileCatalog.inspectFuncGetFileCatalog(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetFileCatalogParams{ctx, gp1}

	// Record call args
	mmGetFileCatalog.GetFileCatalogMock.mutex.Lock()
	mmGetFileCatalog.GetFileCatalogMock.callArgs = append(mmGetFileCatalog.GetFileCatalogMock.callArgs, &mm_params)
	mmGetFileCatalog.GetFileCatalogMock.mutex.Unlock()

	for _, e := range mmGetFileCatalog.GetFileCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetFileCatalog.GetFileCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetFileCatalogParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceServerMock.GetFileCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceServerMock.GetFileCatalog got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileCatalog.t.Errorf("ArtifactPublicServiceServerMock.GetFileCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileCatalog.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetFileCatalog")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetFileCatalog.funcGetFileCatalog != nil {
		return mmGetFileCatalog.funcGetFileCatalog(ctx, gp1)
	}
	mmGetFileCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetFileCatalog. %v %v", ctx, gp1)
	return
}

// GetFileCatalogAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetFileCatalog invocations
func (mmGetFileCatalog *ArtifactPublicServiceServerMock) GetFileCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCatalog.afterGetFileCatalogCounter)
}

// GetFileCatalogBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetFileCatalog invocations
func (mmGetFileCatalog *ArtifactPublicServiceServerMock) GetFileCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCatalog.beforeGetFileCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetFileCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileCatalog *mArtifactPublicServiceServerMockGetFileCatalog) Calls() []*ArtifactPublicServiceServerMockGetFileCatalogParams {
	mmGetFileCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetFileCatalogParams, len(mmGetFileCatalog.callArgs))
	copy(argCopy, mmGetFileCatalog.callArgs)

	mmGetFileCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileCatalogDone returns true if the count of the GetFileCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetFileCatalogDone() bool {
	if m.GetFileCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileCatalogMock.invocationsDone()
}

// MinimockGetFileCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetFileCatalogInspect() {
	for _, e := range m.GetFileCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFileCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCatalogCounter := mm_atomic.LoadUint64(&m.afterGetFileCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileCatalogMock.defaultExpectation != nil && afterGetFileCatalogCounter < 1 {
		if m.GetFileCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFileCatalog at\n%s", m.GetFileCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFileCatalog at\n%s with params: %#v", m.GetFileCatalogMock.defaultExpectation.expectationOrigins.origin, *m.GetFileCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileCatalog != nil && afterGetFileCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFileCatalog at\n%s", m.funcGetFileCatalogOrigin)
	}

	if !m.GetFileCatalogMock.invocationsDone() && afterGetFileCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetFileCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileCatalogMock.expectedInvocations), m.GetFileCatalogMock.expectedInvocationsOrigin, afterGetFileCatalogCounter)
	}
}

type mArtifactPublicServiceServerMockGetObjectDownloadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation
	expectations       []*ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation

	callArgs []*ArtifactPublicServiceServerMockGetObjectDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetObjectDownloadURLParams
	paramPtrs          *ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetObjectDownloadURLExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetObjectDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLParams contains parameters of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetObjectDownloadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLResults contains results of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLResults struct {
	gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse
	err error
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Optional() *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	mmGetObjectDownloadURL.optional = true
	return mmGetObjectDownloadURL
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectDownloadURL.defaultExpectation.params = &ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1}
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectDownloadURL.defaultExpectation.params) {
			mmGetObjectDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest)) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetObjectDownloadURL")
	}

	mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL = f

	return mmGetObjectDownloadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Return(gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{mock: mmGetObjectDownloadURL.mock}
	}
	mmGetObjectDownloadURL.defaultExpectation.results = &ArtifactPublicServiceServerMockGetObjectDownloadURLResults{gp2, err}
	mmGetObjectDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetObjectDownloadURL method
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetObjectDownloadURL.defaultExpectation != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetObjectDownloadURL method")
	}

	if len(mmGetObjectDownloadURL.expectations) > 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetObjectDownloadURL method")
	}

	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL = f
	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetObjectDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) *ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{
		mock:               mmGetObjectDownloadURL.mock,
		params:             &ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetObjectDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectDownloadURL.expectations = append(mmGetObjectDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetObjectDownloadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation) Then(gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetObjectDownloadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetObjectDownloadURL should be invoked
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Times(n uint64) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if n == 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetObjectDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectDownloadURL.expectedInvocations, n)
	mmGetObjectDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL
}

func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) invocationsDone() bool {
	if len(mmGetObjectDownloadURL.expectations) == 0 && mmGetObjectDownloadURL.defaultExpectation == nil && mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.mock.afterGetObjectDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectDownloadURL implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetObjectDownloadURL *ArtifactPublicServiceServerMock) GetObjectDownloadURL(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter, 1)

	mmGetObjectDownloadURL.t.Helper()

	if mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1}

	// Record call args
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Lock()
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs = append(mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs, &mm_params)
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectDownloadURL.GetObjectDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectDownloadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectDownloadURL.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetObjectDownloadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetObjectDownloadURL.funcGetObjectDownloadURL != nil {
		return mmGetObjectDownloadURL.funcGetObjectDownloadURL(ctx, gp1)
	}
	mmGetObjectDownloadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL. %v %v", ctx, gp1)
	return
}

// GetObjectDownloadURLAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceServerMock) GetObjectDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter)
}

// GetObjectDownloadURLBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceServerMock) GetObjectDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetObjectDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Calls() []*ArtifactPublicServiceServerMockGetObjectDownloadURLParams {
	mmGetObjectDownloadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetObjectDownloadURLParams, len(mmGetObjectDownloadURL.callArgs))
	copy(argCopy, mmGetObjectDownloadURL.callArgs)

	mmGetObjectDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDownloadURLDone returns true if the count of the GetObjectDownloadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectDownloadURLDone() bool {
	if m.GetObjectDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectDownloadURLMock.invocationsDone()
}

// MinimockGetObjectDownloadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectDownloadURLInspect() {
	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectDownloadURLMock.defaultExpectation != nil && afterGetObjectDownloadURLCounter < 1 {
		if m.GetObjectDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s", m.GetObjectDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s with params: %#v", m.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectDownloadURL != nil && afterGetObjectDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s", m.funcGetObjectDownloadURLOrigin)
	}

	if !m.GetObjectDownloadURLMock.invocationsDone() && afterGetObjectDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectDownloadURLMock.expectedInvocations), m.GetObjectDownloadURLMock.expectedInvocationsOrigin, afterGetObjectDownloadURLCounter)
	}
}

type mArtifactPublicServiceServerMockGetObjectUploadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetObjectUploadURLExpectation
	expectations       []*ArtifactPublicServiceServerMockGetObjectUploadURLExpectation

	callArgs []*ArtifactPublicServiceServerMockGetObjectUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetObjectUploadURLExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetObjectUploadURLParams
	paramPtrs          *ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetObjectUploadURLExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetObjectUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetObjectUploadURLParams contains parameters of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetObjectUploadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectUploadURLResults contains results of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLResults struct {
	gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse
	err error
}

// ArtifactPublicServiceServerMockGetObjectUploadURLOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Optional() *mArtifactPublicServiceServerMockGetObjectUploadURL {
	mmGetObjectUploadURL.optional = true
	return mmGetObjectUploadURL
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectUploadURL.defaultExpectation.params = &ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1}
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectUploadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectUploadURL.defaultExpectation.params) {
			mmGetObjectUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectUploadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest)) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetObjectUploadURL")
	}

	mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL = f

	return mmGetObjectUploadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Return(gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{mock: mmGetObjectUploadURL.mock}
	}
	mmGetObjectUploadURL.defaultExpectation.results = &ArtifactPublicServiceServerMockGetObjectUploadURLResults{gp2, err}
	mmGetObjectUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetObjectUploadURL method
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetObjectUploadURL.defaultExpectation != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetObjectUploadURL method")
	}

	if len(mmGetObjectUploadURL.expectations) > 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetObjectUploadURL method")
	}

	mmGetObjectUploadURL.mock.funcGetObjectUploadURL = f
	mmGetObjectUploadURL.mock.funcGetObjectUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetObjectUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) *ArtifactPublicServiceServerMockGetObjectUploadURLExpectation {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{
		mock:               mmGetObjectUploadURL.mock,
		params:             &ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetObjectUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectUploadURL.expectations = append(mmGetObjectUploadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetObjectUploadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetObjectUploadURLExpectation) Then(gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetObjectUploadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetObjectUploadURL should be invoked
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Times(n uint64) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if n == 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetObjectUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectUploadURL.expectedInvocations, n)
	mmGetObjectUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL
}

func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) invocationsDone() bool {
	if len(mmGetObjectUploadURL.expectations) == 0 && mmGetObjectUploadURL.defaultExpectation == nil && mmGetObjectUploadURL.mock.funcGetObjectUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.mock.afterGetObjectUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectUploadURL implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetObjectUploadURL *ArtifactPublicServiceServerMock) GetObjectUploadURL(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter, 1)

	mmGetObjectUploadURL.t.Helper()

	if mmGetObjectUploadURL.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.inspectFuncGetObjectUploadURL(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1}

	// Record call args
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Lock()
	mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs = append(mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs, &mm_params)
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectUploadURL.GetObjectUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectUploadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectUploadURL.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetObjectUploadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetObjectUploadURL.funcGetObjectUploadURL != nil {
		return mmGetObjectUploadURL.funcGetObjectUploadURL(ctx, gp1)
	}
	mmGetObjectUploadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetObjectUploadURL. %v %v", ctx, gp1)
	return
}

// GetObjectUploadURLAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceServerMock) GetObjectUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter)
}

// GetObjectUploadURLBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceServerMock) GetObjectUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetObjectUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Calls() []*ArtifactPublicServiceServerMockGetObjectUploadURLParams {
	mmGetObjectUploadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetObjectUploadURLParams, len(mmGetObjectUploadURL.callArgs))
	copy(argCopy, mmGetObjectUploadURL.callArgs)

	mmGetObjectUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectUploadURLDone returns true if the count of the GetObjectUploadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectUploadURLDone() bool {
	if m.GetObjectUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectUploadURLMock.invocationsDone()
}

// MinimockGetObjectUploadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectUploadURLInspect() {
	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectUploadURLMock.defaultExpectation != nil && afterGetObjectUploadURLCounter < 1 {
		if m.GetObjectUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s", m.GetObjectUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s with params: %#v", m.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectUploadURL != nil && afterGetObjectUploadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s", m.funcGetObjectUploadURLOrigin)
	}

	if !m.GetObjectUploadURLMock.invocationsDone() && afterGetObjectUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectUploadURLMock.expectedInvocations), m.GetObjectUploadURLMock.expectedInvocationsOrigin, afterGetObjectUploadURLCounter)
	}
}

type mArtifactPublicServiceServerMockGetSourceFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetSourceFileExpectation
	expectations       []*ArtifactPublicServiceServerMockGetSourceFileExpectation

	callArgs []*ArtifactPublicServiceServerMockGetSourceFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetSourceFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetSourceFile
type ArtifactPublicServiceServerMockGetSourceFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetSourceFileParams
	paramPtrs          *ArtifactPublicServiceServerMockGetSourceFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetSourceFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetSourceFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetSourceFileParams contains parameters of the ArtifactPublicServiceServer.GetSourceFile
type ArtifactPublicServiceServerMockGetSourceFileParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetSourceFileRequest
}

// ArtifactPublicServiceServerMockGetSourceFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetSourceFile
type ArtifactPublicServiceServerMockGetSourceFileParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetSourceFileRequest
}

// ArtifactPublicServiceServerMockGetSourceFileResults contains results of the ArtifactPublicServiceServer.GetSourceFile
type ArtifactPublicServiceServerMockGetSourceFileResults struct {
	gp2 *mm_artifactv1alpha.GetSourceFileResponse
	err error
}

// ArtifactPublicServiceServerMockGetSourceFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetSourceFile
type ArtifactPublicServiceServerMockGetSourceFileExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) Optional() *mArtifactPublicServiceServerMockGetSourceFile {
	mmGetSourceFile.optional = true
	return mmGetSourceFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetSourceFileRequest) *mArtifactPublicServiceServerMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceServerMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by ExpectParams functions")
	}

	mmGetSourceFile.defaultExpectation.params = &ArtifactPublicServiceServerMockGetSourceFileParams{ctx, gp1}
	mmGetSourceFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSourceFile.expectations {
		if minimock.Equal(e.params, mmGetSourceFile.defaultExpectation.params) {
			mmGetSourceFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceFile.defaultExpectation.params)
		}
	}

	return mmGetSourceFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceServerMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSourceFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSourceFile
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetSourceFileRequest) *mArtifactPublicServiceServerMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceServerMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetSourceFile.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetSourceFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetSourceFileRequest)) *mArtifactPublicServiceServerMockGetSourceFile {
	if mmGetSourceFile.mock.inspectFuncGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetSourceFile")
	}

	mmGetSourceFile.mock.inspectFuncGetSourceFile = f

	return mmGetSourceFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) Return(gp2 *mm_artifactv1alpha.GetSourceFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceServerMockGetSourceFileExpectation{mock: mmGetSourceFile.mock}
	}
	mmGetSourceFile.defaultExpectation.results = &ArtifactPublicServiceServerMockGetSourceFileResults{gp2, err}
	mmGetSourceFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSourceFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetSourceFile method
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetSourceFileRequest) (gp2 *mm_artifactv1alpha.GetSourceFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetSourceFile.defaultExpectation != nil {
		mmGetSourceFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetSourceFile method")
	}

	if len(mmGetSourceFile.expectations) > 0 {
		mmGetSourceFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetSourceFile method")
	}

	mmGetSourceFile.mock.funcGetSourceFile = f
	mmGetSourceFile.mock.funcGetSourceFileOrigin = minimock.CallerInfo(1)
	return mmGetSourceFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetSourceFile which will trigger the result defined by the following
// Then helper
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetSourceFileRequest) *ArtifactPublicServiceServerMockGetSourceFileExpectation {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetSourceFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetSourceFileExpectation{
		mock:               mmGetSourceFile.mock,
		params:             &ArtifactPublicServiceServerMockGetSourceFileParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetSourceFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSourceFile.expectations = append(mmGetSourceFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetSourceFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetSourceFileExpectation) Then(gp2 *mm_artifactv1alpha.GetSourceFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetSourceFileResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetSourceFile should be invoked
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) Times(n uint64) *mArtifactPublicServiceServerMockGetSourceFile {
	if n == 0 {
		mmGetSourceFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetSourceFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceFile.expectedInvocations, n)
	mmGetSourceFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSourceFile
}

func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) invocationsDone() bool {
	if len(mmGetSourceFile.expectations) == 0 && mmGetSourceFile.defaultExpectation == nil && mmGetSourceFile.mock.funcGetSourceFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceFile.mock.afterGetSourceFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetSourceFile *ArtifactPublicServiceServerMock) GetSourceFile(ctx context.Context, gp1 *mm_artifactv1alpha.GetSourceFileRequest) (gp2 *mm_artifactv1alpha.GetSourceFileResponse, err error) {
	mm_atomic.AddUint64(&mmGetSourceFile.beforeGetSourceFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceFile.afterGetSourceFileCounter, 1)

	mmGetSourceFile.t.Helper()

	if mmGetSourceFile.inspectFuncGetSourceFile != nil {
		mmGetSourceFile.inspectFuncGetSourceFile(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetSourceFileParams{ctx, gp1}

	// Record call args
	mmGetSourceFile.GetSourceFileMock.mutex.Lock()
	mmGetSourceFile.GetSourceFileMock.callArgs = append(mmGetSourceFile.GetSourceFileMock.callArgs, &mm_params)
	mmGetSourceFile.GetSourceFileMock.mutex.Unlock()

	for _, e := range mmGetSourceFile.GetSourceFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetSourceFile.GetSourceFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceFile.GetSourceFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceFile.GetSourceFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceFile.GetSourceFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetSourceFileParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceServerMock.GetSourceFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceFile.GetSourceFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceServerMock.GetSourceFile got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceFile.GetSourceFileMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceFile.t.Errorf("ArtifactPublicServiceServerMock.GetSourceFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSourceFile.GetSourceFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceFile.GetSourceFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetSourceFile")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetSourceFile.funcGetSourceFile != nil {
		return mmGetSourceFile.funcGetSourceFile(ctx, gp1)
	}
	mmGetSourceFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetSourceFile. %v %v", ctx, gp1)
	return
}

// GetSourceFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetSourceFile invocations
func (mmGetSourceFile *ArtifactPublicServiceServerMock) GetSourceFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceFile.afterGetSourceFileCounter)
}

// GetSourceFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetSourceFile invocations
func (mmGetSourceFile *ArtifactPublicServiceServerMock) GetSourceFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceFile.beforeGetSourceFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetSourceFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceFile *mArtifactPublicServiceServerMockGetSourceFile) Calls() []*ArtifactPublicServiceServerMockGetSourceFileParams {
	mmGetSourceFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetSourceFileParams, len(mmGetSourceFile.callArgs))
	copy(argCopy, mmGetSourceFile.callArgs)

	mmGetSourceFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceFileDone returns true if the count of the GetSourceFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetSourceFileDone() bool {
	if m.GetSourceFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSourceFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceFileMock.invocationsDone()
}

// MinimockGetSourceFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetSourceFileInspect() {
	for _, e := range m.GetSourceFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetSourceFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSourceFileCounter := mm_atomic.LoadUint64(&m.afterGetSourceFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceFileMock.defaultExpectation != nil && afterGetSourceFileCounter < 1 {
		if m.GetSourceFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetSourceFile at\n%s", m.GetSourceFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetSourceFile at\n%s with params: %#v", m.GetSourceFileMock.defaultExpectation.expectationOrigins.origin, *m.GetSourceFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceFile != nil && afterGetSourceFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetSourceFile at\n%s", m.funcGetSourceFileOrigin)
	}

	if !m.GetSourceFileMock.invocationsDone() && afterGetSourceFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetSourceFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceFileMock.expectedInvocations), m.GetSourceFileMock.expectedInvocationsOrigin, afterGetSourceFileCounter)
	}
}

type mArtifactPublicServiceServerMockListCatalogFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListCatalogFilesExpectation
	expectations       []*ArtifactPublicServiceServerMockListCatalogFilesExpectation

	callArgs []*ArtifactPublicServiceServerMockListCatalogFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListCatalogFilesExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListCatalogFiles
type ArtifactPublicServiceServerMockListCatalogFilesExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListCatalogFilesParams
	paramPtrs          *ArtifactPublicServiceServerMockListCatalogFilesParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListCatalogFilesExpectationOrigins
	results            *ArtifactPublicServiceServerMockListCatalogFilesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListCatalogFilesParams contains parameters of the ArtifactPublicServiceServer.ListCatalogFiles
type ArtifactPublicServiceServerMockListCatalogFilesParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListCatalogFilesRequest
}

// ArtifactPublicServiceServerMockListCatalogFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListCatalogFiles
type ArtifactPublicServiceServerMockListCatalogFilesParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListCatalogFilesRequest
}

// ArtifactPublicServiceServerMockListCatalogFilesResults contains results of the ArtifactPublicServiceServer.ListCatalogFiles
type ArtifactPublicServiceServerMockListCatalogFilesResults struct {
	lp2 *mm_artifactv1alpha.ListCatalogFilesResponse
	err error
}

// ArtifactPublicServiceServerMockListCatalogFilesOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListCatalogFiles
type ArtifactPublicServiceServerMockListCatalogFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) Optional() *mArtifactPublicServiceServerMockListCatalogFiles {
	mmListCatalogFiles.optional = true
	return mmListCatalogFiles
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogFilesRequest) *mArtifactPublicServiceServerMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by ExpectParams functions")
	}

	mmListCatalogFiles.defaultExpectation.params = &ArtifactPublicServiceServerMockListCatalogFilesParams{ctx, lp1}
	mmListCatalogFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCatalogFiles.expectations {
		if minimock.Equal(e.params, mmListCatalogFiles.defaultExpectation.params) {
			mmListCatalogFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogFiles.defaultExpectation.params)
		}
	}

	return mmListCatalogFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCatalogFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCatalogFiles
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListCatalogFilesRequest) *mArtifactPublicServiceServerMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListCatalogFiles.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListCatalogFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogFilesRequest)) *mArtifactPublicServiceServerMockListCatalogFiles {
	if mmListCatalogFiles.mock.inspectFuncListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListCatalogFiles")
	}

	mmListCatalogFiles.mock.inspectFuncListCatalogFiles = f

	return mmListCatalogFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) Return(lp2 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogFilesExpectation{mock: mmListCatalogFiles.mock}
	}
	mmListCatalogFiles.defaultExpectation.results = &ArtifactPublicServiceServerMockListCatalogFilesResults{lp2, err}
	mmListCatalogFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCatalogFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListCatalogFiles method
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogFilesRequest) (lp2 *mm_artifactv1alpha.ListCatalogFilesResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListCatalogFiles.defaultExpectation != nil {
		mmListCatalogFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListCatalogFiles method")
	}

	if len(mmListCatalogFiles.expectations) > 0 {
		mmListCatalogFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListCatalogFiles method")
	}

	mmListCatalogFiles.mock.funcListCatalogFiles = f
	mmListCatalogFiles.mock.funcListCatalogFilesOrigin = minimock.CallerInfo(1)
	return mmListCatalogFiles.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListCatalogFiles which will trigger the result defined by the following
// Then helper
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogFilesRequest) *ArtifactPublicServiceServerMockListCatalogFilesExpectation {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListCatalogFilesExpectation{
		mock:               mmListCatalogFiles.mock,
		params:             &ArtifactPublicServiceServerMockListCatalogFilesParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListCatalogFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCatalogFiles.expectations = append(mmListCatalogFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListCatalogFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListCatalogFilesExpectation) Then(lp2 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListCatalogFilesResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListCatalogFiles should be invoked
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) Times(n uint64) *mArtifactPublicServiceServerMockListCatalogFiles {
	if n == 0 {
		mmListCatalogFiles.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListCatalogFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogFiles.expectedInvocations, n)
	mmListCatalogFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCatalogFiles
}

func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) invocationsDone() bool {
	if len(mmListCatalogFiles.expectations) == 0 && mmListCatalogFiles.defaultExpectation == nil && mmListCatalogFiles.mock.funcListCatalogFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogFiles.mock.afterListCatalogFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogFiles implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListCatalogFiles *ArtifactPublicServiceServerMock) ListCatalogFiles(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogFilesRequest) (lp2 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogFiles.beforeListCatalogFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogFiles.afterListCatalogFilesCounter, 1)

	mmListCatalogFiles.t.Helper()

	if mmListCatalogFiles.inspectFuncListCatalogFiles != nil {
		mmListCatalogFiles.inspectFuncListCatalogFiles(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListCatalogFilesParams{ctx, lp1}

	// Record call args
	mmListCatalogFiles.ListCatalogFilesMock.mutex.Lock()
	mmListCatalogFiles.ListCatalogFilesMock.callArgs = append(mmListCatalogFiles.ListCatalogFilesMock.callArgs, &mm_params)
	mmListCatalogFiles.ListCatalogFilesMock.mutex.Unlock()

	for _, e := range mmListCatalogFiles.ListCatalogFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListCatalogFilesParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogFiles got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogFiles.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogFiles.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListCatalogFiles")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListCatalogFiles.funcListCatalogFiles != nil {
		return mmListCatalogFiles.funcListCatalogFiles(ctx, lp1)
	}
	mmListCatalogFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListCatalogFiles. %v %v", ctx, lp1)
	return
}

// ListCatalogFilesAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListCatalogFiles invocations
func (mmListCatalogFiles *ArtifactPublicServiceServerMock) ListCatalogFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogFiles.afterListCatalogFilesCounter)
}

// ListCatalogFilesBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListCatalogFiles invocations
func (mmListCatalogFiles *ArtifactPublicServiceServerMock) ListCatalogFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogFiles.beforeListCatalogFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListCatalogFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogFiles *mArtifactPublicServiceServerMockListCatalogFiles) Calls() []*ArtifactPublicServiceServerMockListCatalogFilesParams {
	mmListCatalogFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListCatalogFilesParams, len(mmListCatalogFiles.callArgs))
	copy(argCopy, mmListCatalogFiles.callArgs)

	mmListCatalogFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogFilesDone returns true if the count of the ListCatalogFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListCatalogFilesDone() bool {
	if m.ListCatalogFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogFilesMock.invocationsDone()
}

// MinimockListCatalogFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListCatalogFilesInspect() {
	for _, e := range m.ListCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCatalogFilesCounter := mm_atomic.LoadUint64(&m.afterListCatalogFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogFilesMock.defaultExpectation != nil && afterListCatalogFilesCounter < 1 {
		if m.ListCatalogFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogFiles at\n%s", m.ListCatalogFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogFiles at\n%s with params: %#v", m.ListCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *m.ListCatalogFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogFiles != nil && afterListCatalogFilesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogFiles at\n%s", m.funcListCatalogFilesOrigin)
	}

	if !m.ListCatalogFilesMock.invocationsDone() && afterListCatalogFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListCatalogFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogFilesMock.expectedInvocations), m.ListCatalogFilesMock.expectedInvocationsOrigin, afterListCatalogFilesCounter)
	}
}

type mArtifactPublicServiceServerMockListCatalogRuns struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListCatalogRunsExpectation
	expectations       []*ArtifactPublicServiceServerMockListCatalogRunsExpectation

	callArgs []*ArtifactPublicServiceServerMockListCatalogRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListCatalogRunsExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListCatalogRuns
type ArtifactPublicServiceServerMockListCatalogRunsExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListCatalogRunsParams
	paramPtrs          *ArtifactPublicServiceServerMockListCatalogRunsParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListCatalogRunsExpectationOrigins
	results            *ArtifactPublicServiceServerMockListCatalogRunsResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListCatalogRunsParams contains parameters of the ArtifactPublicServiceServer.ListCatalogRuns
type ArtifactPublicServiceServerMockListCatalogRunsParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListCatalogRunsRequest
}

// ArtifactPublicServiceServerMockListCatalogRunsParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListCatalogRuns
type ArtifactPublicServiceServerMockListCatalogRunsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListCatalogRunsRequest
}

// ArtifactPublicServiceServerMockListCatalogRunsResults contains results of the ArtifactPublicServiceServer.ListCatalogRuns
type ArtifactPublicServiceServerMockListCatalogRunsResults struct {
	lp2 *mm_artifactv1alpha.ListCatalogRunsResponse
	err error
}

// ArtifactPublicServiceServerMockListCatalogRunsOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListCatalogRuns
type ArtifactPublicServiceServerMockListCatalogRunsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) Optional() *mArtifactPublicServiceServerMockListCatalogRuns {
	mmListCatalogRuns.optional = true
	return mmListCatalogRuns
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogRunsRequest) *mArtifactPublicServiceServerMockListCatalogRuns {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogRunsExpectation{}
	}

	if mmListCatalogRuns.defaultExpectation.paramPtrs != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by ExpectParams functions")
	}

	mmListCatalogRuns.defaultExpectation.params = &ArtifactPublicServiceServerMockListCatalogRunsParams{ctx, lp1}
	mmListCatalogRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCatalogRuns.expectations {
		if minimock.Equal(e.params, mmListCatalogRuns.defaultExpectation.params) {
			mmListCatalogRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogRuns.defaultExpectation.params)
		}
	}

	return mmListCatalogRuns
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListCatalogRuns {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogRunsExpectation{}
	}

	if mmListCatalogRuns.defaultExpectation.params != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by Expect")
	}

	if mmListCatalogRuns.defaultExpectation.paramPtrs == nil {
		mmListCatalogRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListCatalogRunsParamPtrs{}
	}
	mmListCatalogRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCatalogRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCatalogRuns
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListCatalogRunsRequest) *mArtifactPublicServiceServerMockListCatalogRuns {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogRunsExpectation{}
	}

	if mmListCatalogRuns.defaultExpectation.params != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by Expect")
	}

	if mmListCatalogRuns.defaultExpectation.paramPtrs == nil {
		mmListCatalogRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListCatalogRunsParamPtrs{}
	}
	mmListCatalogRuns.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListCatalogRuns.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListCatalogRuns
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogRunsRequest)) *mArtifactPublicServiceServerMockListCatalogRuns {
	if mmListCatalogRuns.mock.inspectFuncListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListCatalogRuns")
	}

	mmListCatalogRuns.mock.inspectFuncListCatalogRuns = f

	return mmListCatalogRuns
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) Return(lp2 *mm_artifactv1alpha.ListCatalogRunsResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogRunsExpectation{mock: mmListCatalogRuns.mock}
	}
	mmListCatalogRuns.defaultExpectation.results = &ArtifactPublicServiceServerMockListCatalogRunsResults{lp2, err}
	mmListCatalogRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCatalogRuns.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListCatalogRuns method
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogRunsRequest) (lp2 *mm_artifactv1alpha.ListCatalogRunsResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListCatalogRuns.defaultExpectation != nil {
		mmListCatalogRuns.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListCatalogRuns method")
	}

	if len(mmListCatalogRuns.expectations) > 0 {
		mmListCatalogRuns.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListCatalogRuns method")
	}

	mmListCatalogRuns.mock.funcListCatalogRuns = f
	mmListCatalogRuns.mock.funcListCatalogRunsOrigin = minimock.CallerInfo(1)
	return mmListCatalogRuns.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListCatalogRuns which will trigger the result defined by the following
// Then helper
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogRunsRequest) *ArtifactPublicServiceServerMockListCatalogRunsExpectation {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogRuns mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListCatalogRunsExpectation{
		mock:               mmListCatalogRuns.mock,
		params:             &ArtifactPublicServiceServerMockListCatalogRunsParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListCatalogRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCatalogRuns.expectations = append(mmListCatalogRuns.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListCatalogRuns return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListCatalogRunsExpectation) Then(lp2 *mm_artifactv1alpha.ListCatalogRunsResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListCatalogRunsResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListCatalogRuns should be invoked
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) Times(n uint64) *mArtifactPublicServiceServerMockListCatalogRuns {
	if n == 0 {
		mmListCatalogRuns.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListCatalogRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogRuns.expectedInvocations, n)
	mmListCatalogRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCatalogRuns
}

func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) invocationsDone() bool {
	if len(mmListCatalogRuns.expectations) == 0 && mmListCatalogRuns.defaultExpectation == nil && mmListCatalogRuns.mock.funcListCatalogRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogRuns.mock.afterListCatalogRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogRuns implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListCatalogRuns *ArtifactPublicServiceServerMock) ListCatalogRuns(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogRunsRequest) (lp2 *mm_artifactv1alpha.ListCatalogRunsResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogRuns.beforeListCatalogRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogRuns.afterListCatalogRunsCounter, 1)

	mmListCatalogRuns.t.Helper()

	if mmListCatalogRuns.inspectFuncListCatalogRuns != nil {
		mmListCatalogRuns.inspectFuncListCatalogRuns(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListCatalogRunsParams{ctx, lp1}

	// Record call args
	mmListCatalogRuns.ListCatalogRunsMock.mutex.Lock()
	mmListCatalogRuns.ListCatalogRunsMock.callArgs = append(mmListCatalogRuns.ListCatalogRunsMock.callArgs, &mm_params)
	mmListCatalogRuns.ListCatalogRunsMock.mutex.Unlock()

	for _, e := range mmListCatalogRuns.ListCatalogRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListCatalogRunsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogRuns.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListCatalogRuns.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogRuns got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogRuns.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogRuns.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListCatalogRuns")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListCatalogRuns.funcListCatalogRuns != nil {
		return mmListCatalogRuns.funcListCatalogRuns(ctx, lp1)
	}
	mmListCatalogRuns.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListCatalogRuns. %v %v", ctx, lp1)
	return
}

// ListCatalogRunsAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListCatalogRuns invocations
func (mmListCatalogRuns *ArtifactPublicServiceServerMock) ListCatalogRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogRuns.afterListCatalogRunsCounter)
}

// ListCatalogRunsBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListCatalogRuns invocations
func (mmListCatalogRuns *ArtifactPublicServiceServerMock) ListCatalogRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogRuns.beforeListCatalogRunsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListCatalogRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogRuns *mArtifactPublicServiceServerMockListCatalogRuns) Calls() []*ArtifactPublicServiceServerMockListCatalogRunsParams {
	mmListCatalogRuns.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListCatalogRunsParams, len(mmListCatalogRuns.callArgs))
	copy(argCopy, mmListCatalogRuns.callArgs)

	mmListCatalogRuns.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogRunsDone returns true if the count of the ListCatalogRuns invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListCatalogRunsDone() bool {
	if m.ListCatalogRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogRunsMock.invocationsDone()
}

// MinimockListCatalogRunsInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListCatalogRunsInspect() {
	for _, e := range m.ListCatalogRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCatalogRunsCounter := mm_atomic.LoadUint64(&m.afterListCatalogRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogRunsMock.defaultExpectation != nil && afterListCatalogRunsCounter < 1 {
		if m.ListCatalogRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogRuns at\n%s", m.ListCatalogRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogRuns at\n%s with params: %#v", m.ListCatalogRunsMock.defaultExpectation.expectationOrigins.origin, *m.ListCatalogRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogRuns != nil && afterListCatalogRunsCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogRuns at\n%s", m.funcListCatalogRunsOrigin)
	}

	if !m.ListCatalogRunsMock.invocationsDone() && afterListCatalogRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListCatalogRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogRunsMock.expectedInvocations), m.ListCatalogRunsMock.expectedInvocationsOrigin, afterListCatalogRunsCounter)
	}
}

type mArtifactPublicServiceServerMockListCatalogs struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListCatalogsExpectation
	expectations       []*ArtifactPublicServiceServerMockListCatalogsExpectation

	callArgs []*ArtifactPublicServiceServerMockListCatalogsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListCatalogsExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListCatalogs
type ArtifactPublicServiceServerMockListCatalogsExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListCatalogsParams
	paramPtrs          *ArtifactPublicServiceServerMockListCatalogsParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListCatalogsExpectationOrigins
	results            *ArtifactPublicServiceServerMockListCatalogsResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListCatalogsParams contains parameters of the ArtifactPublicServiceServer.ListCatalogs
type ArtifactPublicServiceServerMockListCatalogsParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListCatalogsRequest
}

// ArtifactPublicServiceServerMockListCatalogsParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListCatalogs
type ArtifactPublicServiceServerMockListCatalogsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListCatalogsRequest
}

// ArtifactPublicServiceServerMockListCatalogsResults contains results of the ArtifactPublicServiceServer.ListCatalogs
type ArtifactPublicServiceServerMockListCatalogsResults struct {
	lp2 *mm_artifactv1alpha.ListCatalogsResponse
	err error
}

// ArtifactPublicServiceServerMockListCatalogsOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListCatalogs
type ArtifactPublicServiceServerMockListCatalogsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) Optional() *mArtifactPublicServiceServerMockListCatalogs {
	mmListCatalogs.optional = true
	return mmListCatalogs
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogsRequest) *mArtifactPublicServiceServerMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.paramPtrs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by ExpectParams functions")
	}

	mmListCatalogs.defaultExpectation.params = &ArtifactPublicServiceServerMockListCatalogsParams{ctx, lp1}
	mmListCatalogs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCatalogs.expectations {
		if minimock.Equal(e.params, mmListCatalogs.defaultExpectation.params) {
			mmListCatalogs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogs.defaultExpectation.params)
		}
	}

	return mmListCatalogs
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCatalogs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCatalogs
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListCatalogsRequest) *mArtifactPublicServiceServerMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListCatalogs.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListCatalogs
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogsRequest)) *mArtifactPublicServiceServerMockListCatalogs {
	if mmListCatalogs.mock.inspectFuncListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListCatalogs")
	}

	mmListCatalogs.mock.inspectFuncListCatalogs = f

	return mmListCatalogs
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) Return(lp2 *mm_artifactv1alpha.ListCatalogsResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceServerMockListCatalogsExpectation{mock: mmListCatalogs.mock}
	}
	mmListCatalogs.defaultExpectation.results = &ArtifactPublicServiceServerMockListCatalogsResults{lp2, err}
	mmListCatalogs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCatalogs.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListCatalogs method
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogsRequest) (lp2 *mm_artifactv1alpha.ListCatalogsResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListCatalogs.defaultExpectation != nil {
		mmListCatalogs.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListCatalogs method")
	}

	if len(mmListCatalogs.expectations) > 0 {
		mmListCatalogs.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListCatalogs method")
	}

	mmListCatalogs.mock.funcListCatalogs = f
	mmListCatalogs.mock.funcListCatalogsOrigin = minimock.CallerInfo(1)
	return mmListCatalogs.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListCatalogs which will trigger the result defined by the following
// Then helper
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogsRequest) *ArtifactPublicServiceServerMockListCatalogsExpectation {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListCatalogs mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListCatalogsExpectation{
		mock:               mmListCatalogs.mock,
		params:             &ArtifactPublicServiceServerMockListCatalogsParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListCatalogsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCatalogs.expectations = append(mmListCatalogs.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListCatalogs return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListCatalogsExpectation) Then(lp2 *mm_artifactv1alpha.ListCatalogsResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListCatalogsResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListCatalogs should be invoked
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) Times(n uint64) *mArtifactPublicServiceServerMockListCatalogs {
	if n == 0 {
		mmListCatalogs.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListCatalogs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogs.expectedInvocations, n)
	mmListCatalogs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCatalogs
}

func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) invocationsDone() bool {
	if len(mmListCatalogs.expectations) == 0 && mmListCatalogs.defaultExpectation == nil && mmListCatalogs.mock.funcListCatalogs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogs.mock.afterListCatalogsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogs implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListCatalogs *ArtifactPublicServiceServerMock) ListCatalogs(ctx context.Context, lp1 *mm_artifactv1alpha.ListCatalogsRequest) (lp2 *mm_artifactv1alpha.ListCatalogsResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogs.beforeListCatalogsCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogs.afterListCatalogsCounter, 1)

	mmListCatalogs.t.Helper()

	if mmListCatalogs.inspectFuncListCatalogs != nil {
		mmListCatalogs.inspectFuncListCatalogs(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListCatalogsParams{ctx, lp1}

	// Record call args
	mmListCatalogs.ListCatalogsMock.mutex.Lock()
	mmListCatalogs.ListCatalogsMock.callArgs = append(mmListCatalogs.ListCatalogsMock.callArgs, &mm_params)
	mmListCatalogs.ListCatalogsMock.mutex.Unlock()

	for _, e := range mmListCatalogs.ListCatalogsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListCatalogs.ListCatalogsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogs.ListCatalogsMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogs.ListCatalogsMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogs.ListCatalogsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListCatalogsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogs.ListCatalogsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogs got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogs.ListCatalogsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogs.t.Errorf("ArtifactPublicServiceServerMock.ListCatalogs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCatalogs.ListCatalogsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogs.ListCatalogsMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogs.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListCatalogs")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListCatalogs.funcListCatalogs != nil {
		return mmListCatalogs.funcListCatalogs(ctx, lp1)
	}
	mmListCatalogs.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListCatalogs. %v %v", ctx, lp1)
	return
}

// ListCatalogsAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListCatalogs invocations
func (mmListCatalogs *ArtifactPublicServiceServerMock) ListCatalogsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogs.afterListCatalogsCounter)
}

// ListCatalogsBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListCatalogs invocations
func (mmListCatalogs *ArtifactPublicServiceServerMock) ListCatalogsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogs.beforeListCatalogsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListCatalogs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogs *mArtifactPublicServiceServerMockListCatalogs) Calls() []*ArtifactPublicServiceServerMockListCatalogsParams {
	mmListCatalogs.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListCatalogsParams, len(mmListCatalogs.callArgs))
	copy(argCopy, mmListCatalogs.callArgs)

	mmListCatalogs.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogsDone returns true if the count of the ListCatalogs invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListCatalogsDone() bool {
	if m.ListCatalogsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogsMock.invocationsDone()
}

// MinimockListCatalogsInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListCatalogsInspect() {
	for _, e := range m.ListCatalogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCatalogsCounter := mm_atomic.LoadUint64(&m.afterListCatalogsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogsMock.defaultExpectation != nil && afterListCatalogsCounter < 1 {
		if m.ListCatalogsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogs at\n%s", m.ListCatalogsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogs at\n%s with params: %#v", m.ListCatalogsMock.defaultExpectation.expectationOrigins.origin, *m.ListCatalogsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogs != nil && afterListCatalogsCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListCatalogs at\n%s", m.funcListCatalogsOrigin)
	}

	if !m.ListCatalogsMock.invocationsDone() && afterListCatalogsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListCatalogs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogsMock.expectedInvocations), m.ListCatalogsMock.expectedInvocationsOrigin, afterListCatalogsCounter)
	}
}

type mArtifactPublicServiceServerMockListChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListChunksExpectation
	expectations       []*ArtifactPublicServiceServerMockListChunksExpectation

	callArgs []*ArtifactPublicServiceServerMockListChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListChunksExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListChunksParams
	paramPtrs          *ArtifactPublicServiceServerMockListChunksParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListChunksExpectationOrigins
	results            *ArtifactPublicServiceServerMockListChunksResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListChunksParams contains parameters of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListChunksRequest
}

// ArtifactPublicServiceServerMockListChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListChunksRequest
}

// ArtifactPublicServiceServerMockListChunksResults contains results of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksResults struct {
	lp2 *mm_artifactv1alpha.ListChunksResponse
	err error
}

// ArtifactPublicServiceServerMockListChunksOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Optional() *mArtifactPublicServiceServerMockListChunks {
	mmListChunks.optional = true
	return mmListChunks
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.paramPtrs != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by ExpectParams functions")
	}

	mmListChunks.defaultExpectation.params = &ArtifactPublicServiceServerMockListChunksParams{ctx, lp1}
	mmListChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListChunks.expectations {
		if minimock.Equal(e.params, mmListChunks.defaultExpectation.params) {
			mmListChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListChunks.defaultExpectation.params)
		}
	}

	return mmListChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmListChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListChunks
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListChunksRequest) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListChunks.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest)) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.inspectFuncListChunks != nil {
		mmListChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListChunks")
	}

	mmListChunks.mock.inspectFuncListChunks = f

	return mmListChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Return(lp2 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{mock: mmListChunks.mock}
	}
	mmListChunks.defaultExpectation.results = &ArtifactPublicServiceServerMockListChunksResults{lp2, err}
	mmListChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListChunks method
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) (lp2 *mm_artifactv1alpha.ListChunksResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListChunks.defaultExpectation != nil {
		mmListChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListChunks method")
	}

	if len(mmListChunks.expectations) > 0 {
		mmListChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListChunks method")
	}

	mmListChunks.mock.funcListChunks = f
	mmListChunks.mock.funcListChunksOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListChunks which will trigger the result defined by the following
// Then helper
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) *ArtifactPublicServiceServerMockListChunksExpectation {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListChunksExpectation{
		mock:               mmListChunks.mock,
		params:             &ArtifactPublicServiceServerMockListChunksParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListChunks.expectations = append(mmListChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListChunksExpectation) Then(lp2 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListChunksResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListChunks should be invoked
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Times(n uint64) *mArtifactPublicServiceServerMockListChunks {
	if n == 0 {
		mmListChunks.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListChunks.expectedInvocations, n)
	mmListChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListChunks
}

func (mmListChunks *mArtifactPublicServiceServerMockListChunks) invocationsDone() bool {
	if len(mmListChunks.expectations) == 0 && mmListChunks.defaultExpectation == nil && mmListChunks.mock.funcListChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListChunks.mock.afterListChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListChunks implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListChunks *ArtifactPublicServiceServerMock) ListChunks(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) (lp2 *mm_artifactv1alpha.ListChunksResponse, err error) {
	mm_atomic.AddUint64(&mmListChunks.beforeListChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmListChunks.afterListChunksCounter, 1)

	mmListChunks.t.Helper()

	if mmListChunks.inspectFuncListChunks != nil {
		mmListChunks.inspectFuncListChunks(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListChunksParams{ctx, lp1}

	// Record call args
	mmListChunks.ListChunksMock.mutex.Lock()
	mmListChunks.ListChunksMock.callArgs = append(mmListChunks.ListChunksMock.callArgs, &mm_params)
	mmListChunks.ListChunksMock.mutex.Unlock()

	for _, e := range mmListChunks.ListChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListChunks.ListChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListChunks.ListChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmListChunks.ListChunksMock.defaultExpectation.params
		mm_want_ptrs := mmListChunks.ListChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListChunksParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListChunks.t.Errorf("ArtifactPublicServiceServerMock.ListChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListChunks.t.Errorf("ArtifactPublicServiceServerMock.ListChunks got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListChunks.t.Errorf("ArtifactPublicServiceServerMock.ListChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListChunks.ListChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmListChunks.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListChunks")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListChunks.funcListChunks != nil {
		return mmListChunks.funcListChunks(ctx, lp1)
	}
	mmListChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListChunks. %v %v", ctx, lp1)
	return
}

// ListChunksAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceServerMock) ListChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.afterListChunksCounter)
}

// ListChunksBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceServerMock) ListChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.beforeListChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Calls() []*ArtifactPublicServiceServerMockListChunksParams {
	mmListChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListChunksParams, len(mmListChunks.callArgs))
	copy(argCopy, mmListChunks.callArgs)

	mmListChunks.mutex.RUnlock()

	return argCopy
}

// MinimockListChunksDone returns true if the count of the ListChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListChunksDone() bool {
	if m.ListChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListChunksMock.invocationsDone()
}

// MinimockListChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListChunksInspect() {
	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListChunksCounter := mm_atomic.LoadUint64(&m.afterListChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListChunksMock.defaultExpectation != nil && afterListChunksCounter < 1 {
		if m.ListChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s", m.ListChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s with params: %#v", m.ListChunksMock.defaultExpectation.expectationOrigins.origin, *m.ListChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListChunks != nil && afterListChunksCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s", m.funcListChunksOrigin)
	}

	if !m.ListChunksMock.invocationsDone() && afterListChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListChunksMock.expectedInvocations), m.ListChunksMock.expectedInvocationsOrigin, afterListChunksCounter)
	}
}

type mArtifactPublicServiceServerMockLiveness struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockLivenessExpectation
	expectations       []*ArtifactPublicServiceServerMockLivenessExpectation

	callArgs []*ArtifactPublicServiceServerMockLivenessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockLivenessExpectation specifies expectation struct of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockLivenessParams
	paramPtrs          *ArtifactPublicServiceServerMockLivenessParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockLivenessExpectationOrigins
	results            *ArtifactPublicServiceServerMockLivenessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockLivenessParams contains parameters of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.LivenessRequest
}

// ArtifactPublicServiceServerMockLivenessParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.LivenessRequest
}

// ArtifactPublicServiceServerMockLivenessResults contains results of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessResults struct {
	lp2 *mm_artifactv1alpha.LivenessResponse
	err error
}

// ArtifactPublicServiceServerMockLivenessOrigins contains origins of expectations of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Optional() *mArtifactPublicServiceServerMockLiveness {
	mmLiveness.optional = true
	return mmLiveness
}

// Expect sets up expected params for ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.paramPtrs != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by ExpectParams functions")
	}

	mmLiveness.defaultExpectation.params = &ArtifactPublicServiceServerMockLivenessParams{ctx, lp1}
	mmLiveness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLiveness.expectations {
		if minimock.Equal(e.params, mmLiveness.defaultExpectation.params) {
			mmLiveness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLiveness.defaultExpectation.params)
		}
	}

	return mmLiveness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.ctx = &ctx
	mmLiveness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) ExpectLp1Param2(lp1 *mm_artifactv1alpha.LivenessRequest) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.lp1 = &lp1
	mmLiveness.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmLiveness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest)) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.inspectFuncLiveness != nil {
		mmLiveness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.Liveness")
	}

	mmLiveness.mock.inspectFuncLiveness = f

	return mmLiveness
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Return(lp2 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceServerMock {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{mock: mmLiveness.mock}
	}
	mmLiveness.defaultExpectation.results = &ArtifactPublicServiceServerMockLivenessResults{lp2, err}
	mmLiveness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.Liveness method
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) (lp2 *mm_artifactv1alpha.LivenessResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmLiveness.defaultExpectation != nil {
		mmLiveness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.Liveness method")
	}

	if len(mmLiveness.expectations) > 0 {
		mmLiveness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.Liveness method")
	}

	mmLiveness.mock.funcLiveness = f
	mmLiveness.mock.funcLivenessOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// When sets expectation for the ArtifactPublicServiceServer.Liveness which will trigger the result defined by the following
// Then helper
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) When(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) *ArtifactPublicServiceServerMockLivenessExpectation {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockLivenessExpectation{
		mock:               mmLiveness.mock,
		params:             &ArtifactPublicServiceServerMockLivenessParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockLivenessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLiveness.expectations = append(mmLiveness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.Liveness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockLivenessExpectation) Then(lp2 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockLivenessResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.Liveness should be invoked
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Times(n uint64) *mArtifactPublicServiceServerMockLiveness {
	if n == 0 {
		mmLiveness.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.Liveness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLiveness.expectedInvocations, n)
	mmLiveness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLiveness
}

func (mmLiveness *mArtifactPublicServiceServerMockLiveness) invocationsDone() bool {
	if len(mmLiveness.expectations) == 0 && mmLiveness.defaultExpectation == nil && mmLiveness.mock.funcLiveness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLiveness.mock.afterLivenessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLiveness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Liveness implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmLiveness *ArtifactPublicServiceServerMock) Liveness(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) (lp2 *mm_artifactv1alpha.LivenessResponse, err error) {
	mm_atomic.AddUint64(&mmLiveness.beforeLivenessCounter, 1)
	defer mm_atomic.AddUint64(&mmLiveness.afterLivenessCounter, 1)

	mmLiveness.t.Helper()

	if mmLiveness.inspectFuncLiveness != nil {
		mmLiveness.inspectFuncLiveness(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockLivenessParams{ctx, lp1}

	// Record call args
	mmLiveness.LivenessMock.mutex.Lock()
	mmLiveness.LivenessMock.callArgs = append(mmLiveness.LivenessMock.callArgs, &mm_params)
	mmLiveness.LivenessMock.mutex.Unlock()

	for _, e := range mmLiveness.LivenessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmLiveness.LivenessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLiveness.LivenessMock.defaultExpectation.Counter, 1)
		mm_want := mmLiveness.LivenessMock.defaultExpectation.params
		mm_want_ptrs := mmLiveness.LivenessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockLivenessParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLiveness.t.Errorf("ArtifactPublicServiceServerMock.Liveness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmLiveness.t.Errorf("ArtifactPublicServiceServerMock.Liveness got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLiveness.t.Errorf("ArtifactPublicServiceServerMock.Liveness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLiveness.LivenessMock.defaultExpectation.results
		if mm_results == nil {
			mmLiveness.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.Liveness")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmLiveness.funcLiveness != nil {
		return mmLiveness.funcLiveness(ctx, lp1)
	}
	mmLiveness.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.Liveness. %v %v", ctx, lp1)
	return
}

// LivenessAfterCounter returns a count of finished ArtifactPublicServiceServerMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceServerMock) LivenessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.afterLivenessCounter)
}

// LivenessBeforeCounter returns a count of ArtifactPublicServiceServerMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceServerMock) LivenessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.beforeLivenessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.Liveness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Calls() []*ArtifactPublicServiceServerMockLivenessParams {
	mmLiveness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockLivenessParams, len(mmLiveness.callArgs))
	copy(argCopy, mmLiveness.callArgs)

	mmLiveness.mutex.RUnlock()

	return argCopy
}

// MinimockLivenessDone returns true if the count of the Liveness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockLivenessDone() bool {
	if m.LivenessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LivenessMock.invocationsDone()
}

// MinimockLivenessInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockLivenessInspect() {
	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLivenessCounter := mm_atomic.LoadUint64(&m.afterLivenessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LivenessMock.defaultExpectation != nil && afterLivenessCounter < 1 {
		if m.LivenessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s", m.LivenessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s with params: %#v", m.LivenessMock.defaultExpectation.expectationOrigins.origin, *m.LivenessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLiveness != nil && afterLivenessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s", m.funcLivenessOrigin)
	}

	if !m.LivenessMock.invocationsDone() && afterLivenessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.Liveness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LivenessMock.expectedInvocations), m.LivenessMock.expectedInvocationsOrigin, afterLivenessCounter)
	}
}

type mArtifactPublicServiceServerMockProcessCatalogFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockProcessCatalogFilesExpectation
	expectations       []*ArtifactPublicServiceServerMockProcessCatalogFilesExpectation

	callArgs []*ArtifactPublicServiceServerMockProcessCatalogFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockProcessCatalogFilesExpectation specifies expectation struct of the ArtifactPublicServiceServer.ProcessCatalogFiles
type ArtifactPublicServiceServerMockProcessCatalogFilesExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockProcessCatalogFilesParams
	paramPtrs          *ArtifactPublicServiceServerMockProcessCatalogFilesParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockProcessCatalogFilesExpectationOrigins
	results            *ArtifactPublicServiceServerMockProcessCatalogFilesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockProcessCatalogFilesParams contains parameters of the ArtifactPublicServiceServer.ProcessCatalogFiles
type ArtifactPublicServiceServerMockProcessCatalogFilesParams struct {
	ctx context.Context
	pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest
}

// ArtifactPublicServiceServerMockProcessCatalogFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ProcessCatalogFiles
type ArtifactPublicServiceServerMockProcessCatalogFilesParamPtrs struct {
	ctx *context.Context
	pp1 **mm_artifactv1alpha.ProcessCatalogFilesRequest
}

// ArtifactPublicServiceServerMockProcessCatalogFilesResults contains results of the ArtifactPublicServiceServer.ProcessCatalogFiles
type ArtifactPublicServiceServerMockProcessCatalogFilesResults struct {
	pp2 *mm_artifactv1alpha.ProcessCatalogFilesResponse
	err error
}

// ArtifactPublicServiceServerMockProcessCatalogFilesOrigins contains origins of expectations of the ArtifactPublicServiceServer.ProcessCatalogFiles
type ArtifactPublicServiceServerMockProcessCatalogFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) Optional() *mArtifactPublicServiceServerMockProcessCatalogFiles {
	mmProcessCatalogFiles.optional = true
	return mmProcessCatalogFiles
}

// Expect sets up expected params for ArtifactPublicServiceServer.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) Expect(ctx context.Context, pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest) *mArtifactPublicServiceServerMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by ExpectParams functions")
	}

	mmProcessCatalogFiles.defaultExpectation.params = &ArtifactPublicServiceServerMockProcessCatalogFilesParams{ctx, pp1}
	mmProcessCatalogFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessCatalogFiles.expectations {
		if minimock.Equal(e.params, mmProcessCatalogFiles.defaultExpectation.params) {
			mmProcessCatalogFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessCatalogFiles.defaultExpectation.params)
		}
	}

	return mmProcessCatalogFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessCatalogFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessCatalogFiles
}

// ExpectPp1Param2 sets up expected param pp1 for ArtifactPublicServiceServer.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) ExpectPp1Param2(pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest) *mArtifactPublicServiceServerMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.pp1 = &pp1
	mmProcessCatalogFiles.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmProcessCatalogFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) Inspect(f func(ctx context.Context, pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest)) *mArtifactPublicServiceServerMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.inspectFuncProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ProcessCatalogFiles")
	}

	mmProcessCatalogFiles.mock.inspectFuncProcessCatalogFiles = f

	return mmProcessCatalogFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) Return(pp2 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) *ArtifactPublicServiceServerMock {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceServerMockProcessCatalogFilesExpectation{mock: mmProcessCatalogFiles.mock}
	}
	mmProcessCatalogFiles.defaultExpectation.results = &ArtifactPublicServiceServerMockProcessCatalogFilesResults{pp2, err}
	mmProcessCatalogFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessCatalogFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ProcessCatalogFiles method
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) Set(f func(ctx context.Context, pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest) (pp2 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmProcessCatalogFiles.defaultExpectation != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ProcessCatalogFiles method")
	}

	if len(mmProcessCatalogFiles.expectations) > 0 {
		mmProcessCatalogFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ProcessCatalogFiles method")
	}

	mmProcessCatalogFiles.mock.funcProcessCatalogFiles = f
	mmProcessCatalogFiles.mock.funcProcessCatalogFilesOrigin = minimock.CallerInfo(1)
	return mmProcessCatalogFiles.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ProcessCatalogFiles which will trigger the result defined by the following
// Then helper
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) When(ctx context.Context, pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest) *ArtifactPublicServiceServerMockProcessCatalogFilesExpectation {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ProcessCatalogFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockProcessCatalogFilesExpectation{
		mock:               mmProcessCatalogFiles.mock,
		params:             &ArtifactPublicServiceServerMockProcessCatalogFilesParams{ctx, pp1},
		expectationOrigins: ArtifactPublicServiceServerMockProcessCatalogFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessCatalogFiles.expectations = append(mmProcessCatalogFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ProcessCatalogFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockProcessCatalogFilesExpectation) Then(pp2 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockProcessCatalogFilesResults{pp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ProcessCatalogFiles should be invoked
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) Times(n uint64) *mArtifactPublicServiceServerMockProcessCatalogFiles {
	if n == 0 {
		mmProcessCatalogFiles.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ProcessCatalogFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessCatalogFiles.expectedInvocations, n)
	mmProcessCatalogFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessCatalogFiles
}

func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) invocationsDone() bool {
	if len(mmProcessCatalogFiles.expectations) == 0 && mmProcessCatalogFiles.defaultExpectation == nil && mmProcessCatalogFiles.mock.funcProcessCatalogFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessCatalogFiles.mock.afterProcessCatalogFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessCatalogFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessCatalogFiles implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmProcessCatalogFiles *ArtifactPublicServiceServerMock) ProcessCatalogFiles(ctx context.Context, pp1 *mm_artifactv1alpha.ProcessCatalogFilesRequest) (pp2 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) {
	mm_atomic.AddUint64(&mmProcessCatalogFiles.beforeProcessCatalogFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessCatalogFiles.afterProcessCatalogFilesCounter, 1)

	mmProcessCatalogFiles.t.Helper()

	if mmProcessCatalogFiles.inspectFuncProcessCatalogFiles != nil {
		mmProcessCatalogFiles.inspectFuncProcessCatalogFiles(ctx, pp1)
	}

	mm_params := ArtifactPublicServiceServerMockProcessCatalogFilesParams{ctx, pp1}

	// Record call args
	mmProcessCatalogFiles.ProcessCatalogFilesMock.mutex.Lock()
	mmProcessCatalogFiles.ProcessCatalogFilesMock.callArgs = append(mmProcessCatalogFiles.ProcessCatalogFilesMock.callArgs, &mm_params)
	mmProcessCatalogFiles.ProcessCatalogFilesMock.mutex.Unlock()

	for _, e := range mmProcessCatalogFiles.ProcessCatalogFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockProcessCatalogFilesParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceServerMock.ProcessCatalogFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceServerMock.ProcessCatalogFiles got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceServerMock.ProcessCatalogFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessCatalogFiles.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ProcessCatalogFiles")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmProcessCatalogFiles.funcProcessCatalogFiles != nil {
		return mmProcessCatalogFiles.funcProcessCatalogFiles(ctx, pp1)
	}
	mmProcessCatalogFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ProcessCatalogFiles. %v %v", ctx, pp1)
	return
}

// ProcessCatalogFilesAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ProcessCatalogFiles invocations
func (mmProcessCatalogFiles *ArtifactPublicServiceServerMock) ProcessCatalogFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessCatalogFiles.afterProcessCatalogFilesCounter)
}

// ProcessCatalogFilesBeforeCounter returns a count of ArtifactPublicServiceServerMock.ProcessCatalogFiles invocations
func (mmProcessCatalogFiles *ArtifactPublicServiceServerMock) ProcessCatalogFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessCatalogFiles.beforeProcessCatalogFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ProcessCatalogFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessCatalogFiles *mArtifactPublicServiceServerMockProcessCatalogFiles) Calls() []*ArtifactPublicServiceServerMockProcessCatalogFilesParams {
	mmProcessCatalogFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockProcessCatalogFilesParams, len(mmProcessCatalogFiles.callArgs))
	copy(argCopy, mmProcessCatalogFiles.callArgs)

	mmProcessCatalogFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessCatalogFilesDone returns true if the count of the ProcessCatalogFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockProcessCatalogFilesDone() bool {
	if m.ProcessCatalogFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessCatalogFilesMock.invocationsDone()
}

// MinimockProcessCatalogFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockProcessCatalogFilesInspect() {
	for _, e := range m.ProcessCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ProcessCatalogFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessCatalogFilesCounter := mm_atomic.LoadUint64(&m.afterProcessCatalogFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessCatalogFilesMock.defaultExpectation != nil && afterProcessCatalogFilesCounter < 1 {
		if m.ProcessCatalogFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ProcessCatalogFiles at\n%s", m.ProcessCatalogFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ProcessCatalogFiles at\n%s with params: %#v", m.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *m.ProcessCatalogFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessCatalogFiles != nil && afterProcessCatalogFilesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ProcessCatalogFiles at\n%s", m.funcProcessCatalogFilesOrigin)
	}

	if !m.ProcessCatalogFilesMock.invocationsDone() && afterProcessCatalogFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ProcessCatalogFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessCatalogFilesMock.expectedInvocations), m.ProcessCatalogFilesMock.expectedInvocationsOrigin, afterProcessCatalogFilesCounter)
	}
}

type mArtifactPublicServiceServerMockQuestionAnswering struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockQuestionAnsweringExpectation
	expectations       []*ArtifactPublicServiceServerMockQuestionAnsweringExpectation

	callArgs []*ArtifactPublicServiceServerMockQuestionAnsweringParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockQuestionAnsweringExpectation specifies expectation struct of the ArtifactPublicServiceServer.QuestionAnswering
type ArtifactPublicServiceServerMockQuestionAnsweringExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockQuestionAnsweringParams
	paramPtrs          *ArtifactPublicServiceServerMockQuestionAnsweringParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockQuestionAnsweringExpectationOrigins
	results            *ArtifactPublicServiceServerMockQuestionAnsweringResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockQuestionAnsweringParams contains parameters of the ArtifactPublicServiceServer.QuestionAnswering
type ArtifactPublicServiceServerMockQuestionAnsweringParams struct {
	ctx context.Context
	qp1 *mm_artifactv1alpha.QuestionAnsweringRequest
}

// ArtifactPublicServiceServerMockQuestionAnsweringParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.QuestionAnswering
type ArtifactPublicServiceServerMockQuestionAnsweringParamPtrs struct {
	ctx *context.Context
	qp1 **mm_artifactv1alpha.QuestionAnsweringRequest
}

// ArtifactPublicServiceServerMockQuestionAnsweringResults contains results of the ArtifactPublicServiceServer.QuestionAnswering
type ArtifactPublicServiceServerMockQuestionAnsweringResults struct {
	qp2 *mm_artifactv1alpha.QuestionAnsweringResponse
	err error
}

// ArtifactPublicServiceServerMockQuestionAnsweringOrigins contains origins of expectations of the ArtifactPublicServiceServer.QuestionAnswering
type ArtifactPublicServiceServerMockQuestionAnsweringExpectationOrigins struct {
	origin    string
	originCtx string
	originQp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) Optional() *mArtifactPublicServiceServerMockQuestionAnswering {
	mmQuestionAnswering.optional = true
	return mmQuestionAnswering
}

// Expect sets up expected params for ArtifactPublicServiceServer.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) Expect(ctx context.Context, qp1 *mm_artifactv1alpha.QuestionAnsweringRequest) *mArtifactPublicServiceServerMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceServerMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by ExpectParams functions")
	}

	mmQuestionAnswering.defaultExpectation.params = &ArtifactPublicServiceServerMockQuestionAnsweringParams{ctx, qp1}
	mmQuestionAnswering.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQuestionAnswering.expectations {
		if minimock.Equal(e.params, mmQuestionAnswering.defaultExpectation.params) {
			mmQuestionAnswering.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuestionAnswering.defaultExpectation.params)
		}
	}

	return mmQuestionAnswering
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceServerMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.ctx = &ctx
	mmQuestionAnswering.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQuestionAnswering
}

// ExpectQp1Param2 sets up expected param qp1 for ArtifactPublicServiceServer.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) ExpectQp1Param2(qp1 *mm_artifactv1alpha.QuestionAnsweringRequest) *mArtifactPublicServiceServerMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceServerMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.qp1 = &qp1
	mmQuestionAnswering.defaultExpectation.expectationOrigins.originQp1 = minimock.CallerInfo(1)

	return mmQuestionAnswering
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) Inspect(f func(ctx context.Context, qp1 *mm_artifactv1alpha.QuestionAnsweringRequest)) *mArtifactPublicServiceServerMockQuestionAnswering {
	if mmQuestionAnswering.mock.inspectFuncQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.QuestionAnswering")
	}

	mmQuestionAnswering.mock.inspectFuncQuestionAnswering = f

	return mmQuestionAnswering
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) Return(qp2 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) *ArtifactPublicServiceServerMock {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceServerMockQuestionAnsweringExpectation{mock: mmQuestionAnswering.mock}
	}
	mmQuestionAnswering.defaultExpectation.results = &ArtifactPublicServiceServerMockQuestionAnsweringResults{qp2, err}
	mmQuestionAnswering.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQuestionAnswering.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.QuestionAnswering method
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) Set(f func(ctx context.Context, qp1 *mm_artifactv1alpha.QuestionAnsweringRequest) (qp2 *mm_artifactv1alpha.QuestionAnsweringResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmQuestionAnswering.defaultExpectation != nil {
		mmQuestionAnswering.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.QuestionAnswering method")
	}

	if len(mmQuestionAnswering.expectations) > 0 {
		mmQuestionAnswering.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.QuestionAnswering method")
	}

	mmQuestionAnswering.mock.funcQuestionAnswering = f
	mmQuestionAnswering.mock.funcQuestionAnsweringOrigin = minimock.CallerInfo(1)
	return mmQuestionAnswering.mock
}

// When sets expectation for the ArtifactPublicServiceServer.QuestionAnswering which will trigger the result defined by the following
// Then helper
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) When(ctx context.Context, qp1 *mm_artifactv1alpha.QuestionAnsweringRequest) *ArtifactPublicServiceServerMockQuestionAnsweringExpectation {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceServerMock.QuestionAnswering mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockQuestionAnsweringExpectation{
		mock:               mmQuestionAnswering.mock,
		params:             &ArtifactPublicServiceServerMockQuestionAnsweringParams{ctx, qp1},
		expectationOrigins: ArtifactPublicServiceServerMockQuestionAnsweringExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQuestionAnswering.expectations = append(mmQuestionAnswering.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.QuestionAnswering return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockQuestionAnsweringExpectation) Then(qp2 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockQuestionAnsweringResults{qp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.QuestionAnswering should be invoked
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) Times(n uint64) *mArtifactPublicServiceServerMockQuestionAnswering {
	if n == 0 {
		mmQuestionAnswering.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.QuestionAnswering mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuestionAnswering.expectedInvocations, n)
	mmQuestionAnswering.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQuestionAnswering
}

func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) invocationsDone() bool {
	if len(mmQuestionAnswering.expectations) == 0 && mmQuestionAnswering.defaultExpectation == nil && mmQuestionAnswering.mock.funcQuestionAnswering == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuestionAnswering.mock.afterQuestionAnsweringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuestionAnswering.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QuestionAnswering implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmQuestionAnswering *ArtifactPublicServiceServerMock) QuestionAnswering(ctx context.Context, qp1 *mm_artifactv1alpha.QuestionAnsweringRequest) (qp2 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) {
	mm_atomic.AddUint64(&mmQuestionAnswering.beforeQuestionAnsweringCounter, 1)
	defer mm_atomic.AddUint64(&mmQuestionAnswering.afterQuestionAnsweringCounter, 1)

	mmQuestionAnswering.t.Helper()

	if mmQuestionAnswering.inspectFuncQuestionAnswering != nil {
		mmQuestionAnswering.inspectFuncQuestionAnswering(ctx, qp1)
	}

	mm_params := ArtifactPublicServiceServerMockQuestionAnsweringParams{ctx, qp1}

	// Record call args
	mmQuestionAnswering.QuestionAnsweringMock.mutex.Lock()
	mmQuestionAnswering.QuestionAnsweringMock.callArgs = append(mmQuestionAnswering.QuestionAnsweringMock.callArgs, &mm_params)
	mmQuestionAnswering.QuestionAnsweringMock.mutex.Unlock()

	for _, e := range mmQuestionAnswering.QuestionAnsweringMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qp2, e.results.err
		}
	}

	if mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.Counter, 1)
		mm_want := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.params
		mm_want_ptrs := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockQuestionAnsweringParams{ctx, qp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceServerMock.QuestionAnswering got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.qp1 != nil && !minimock.Equal(*mm_want_ptrs.qp1, mm_got.qp1) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceServerMock.QuestionAnswering got unexpected parameter qp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.expectationOrigins.originQp1, *mm_want_ptrs.qp1, mm_got.qp1, minimock.Diff(*mm_want_ptrs.qp1, mm_got.qp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuestionAnswering.t.Errorf("ArtifactPublicServiceServerMock.QuestionAnswering got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.results
		if mm_results == nil {
			mmQuestionAnswering.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.QuestionAnswering")
		}
		return (*mm_results).qp2, (*mm_results).err
	}
	if mmQuestionAnswering.funcQuestionAnswering != nil {
		return mmQuestionAnswering.funcQuestionAnswering(ctx, qp1)
	}
	mmQuestionAnswering.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.QuestionAnswering. %v %v", ctx, qp1)
	return
}

// QuestionAnsweringAfterCounter returns a count of finished ArtifactPublicServiceServerMock.QuestionAnswering invocations
func (mmQuestionAnswering *ArtifactPublicServiceServerMock) QuestionAnsweringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnswering.afterQuestionAnsweringCounter)
}

// QuestionAnsweringBeforeCounter returns a count of ArtifactPublicServiceServerMock.QuestionAnswering invocations
func (mmQuestionAnswering *ArtifactPublicServiceServerMock) QuestionAnsweringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnswering.beforeQuestionAnsweringCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.QuestionAnswering.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuestionAnswering *mArtifactPublicServiceServerMockQuestionAnswering) Calls() []*ArtifactPublicServiceServerMockQuestionAnsweringParams {
	mmQuestionAnswering.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockQuestionAnsweringParams, len(mmQuestionAnswering.callArgs))
	copy(argCopy, mmQuestionAnswering.callArgs)

	mmQuestionAnswering.mutex.RUnlock()

	return argCopy
}

// MinimockQuestionAnsweringDone returns true if the count of the QuestionAnswering invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockQuestionAnsweringDone() bool {
	if m.QuestionAnsweringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QuestionAnsweringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QuestionAnsweringMock.invocationsDone()
}

// MinimockQuestionAnsweringInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockQuestionAnsweringInspect() {
	for _, e := range m.QuestionAnsweringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.QuestionAnswering at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQuestionAnsweringCounter := mm_atomic.LoadUint64(&m.afterQuestionAnsweringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QuestionAnsweringMock.defaultExpectation != nil && afterQuestionAnsweringCounter < 1 {
		if m.QuestionAnsweringMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.QuestionAnswering at\n%s", m.QuestionAnsweringMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.QuestionAnswering at\n%s with params: %#v", m.QuestionAnsweringMock.defaultExpectation.expectationOrigins.origin, *m.QuestionAnsweringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuestionAnswering != nil && afterQuestionAnsweringCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.QuestionAnswering at\n%s", m.funcQuestionAnsweringOrigin)
	}

	if !m.QuestionAnsweringMock.invocationsDone() && afterQuestionAnsweringCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.QuestionAnswering at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QuestionAnsweringMock.expectedInvocations), m.QuestionAnsweringMock.expectedInvocationsOrigin, afterQuestionAnsweringCounter)
	}
}

type mArtifactPublicServiceServerMockReadiness struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockReadinessExpectation
	expectations       []*ArtifactPublicServiceServerMockReadinessExpectation

	callArgs []*ArtifactPublicServiceServerMockReadinessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockReadinessExpectation specifies expectation struct of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockReadinessParams
	paramPtrs          *ArtifactPublicServiceServerMockReadinessParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockReadinessExpectationOrigins
	results            *ArtifactPublicServiceServerMockReadinessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockReadinessParams contains parameters of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessParams struct {
	ctx context.Context
	rp1 *mm_artifactv1alpha.ReadinessRequest
}

// ArtifactPublicServiceServerMockReadinessParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessParamPtrs struct {
	ctx *context.Context
	rp1 **mm_artifactv1alpha.ReadinessRequest
}

// ArtifactPublicServiceServerMockReadinessResults contains results of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessResults struct {
	rp2 *mm_artifactv1alpha.ReadinessResponse
	err error
}

// ArtifactPublicServiceServerMockReadinessOrigins contains origins of expectations of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Optional() *mArtifactPublicServiceServerMockReadiness {
	mmReadiness.optional = true
	return mmReadiness
}

// Expect sets up expected params for ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Expect(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.paramPtrs != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by ExpectParams functions")
	}

	mmReadiness.defaultExpectation.params = &ArtifactPublicServiceServerMockReadinessParams{ctx, rp1}
	mmReadiness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadiness.expectations {
		if minimock.Equal(e.params, mmReadiness.defaultExpectation.params) {
			mmReadiness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadiness.defaultExpectation.params)
		}
	}

	return mmReadiness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadiness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectRp1Param2 sets up expected param rp1 for ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) ExpectRp1Param2(rp1 *mm_artifactv1alpha.ReadinessRequest) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.rp1 = &rp1
	mmReadiness.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmReadiness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Inspect(f func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest)) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.inspectFuncReadiness != nil {
		mmReadiness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.Readiness")
	}

	mmReadiness.mock.inspectFuncReadiness = f

	return mmReadiness
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Return(rp2 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceServerMock {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{mock: mmReadiness.mock}
	}
	mmReadiness.defaultExpectation.results = &ArtifactPublicServiceServerMockReadinessResults{rp2, err}
	mmReadiness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.Readiness method
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Set(f func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) (rp2 *mm_artifactv1alpha.ReadinessResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmReadiness.defaultExpectation != nil {
		mmReadiness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.Readiness method")
	}

	if len(mmReadiness.expectations) > 0 {
		mmReadiness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.Readiness method")
	}

	mmReadiness.mock.funcReadiness = f
	mmReadiness.mock.funcReadinessOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// When sets expectation for the ArtifactPublicServiceServer.Readiness which will trigger the result defined by the following
// Then helper
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) When(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) *ArtifactPublicServiceServerMockReadinessExpectation {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockReadinessExpectation{
		mock:               mmReadiness.mock,
		params:             &ArtifactPublicServiceServerMockReadinessParams{ctx, rp1},
		expectationOrigins: ArtifactPublicServiceServerMockReadinessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadiness.expectations = append(mmReadiness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.Readiness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockReadinessExpectation) Then(rp2 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockReadinessResults{rp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.Readiness should be invoked
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Times(n uint64) *mArtifactPublicServiceServerMockReadiness {
	if n == 0 {
		mmReadiness.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.Readiness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadiness.expectedInvocations, n)
	mmReadiness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadiness
}

func (mmReadiness *mArtifactPublicServiceServerMockReadiness) invocationsDone() bool {
	if len(mmReadiness.expectations) == 0 && mmReadiness.defaultExpectation == nil && mmReadiness.mock.funcReadiness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadiness.mock.afterReadinessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadiness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Readiness implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmReadiness *ArtifactPublicServiceServerMock) Readiness(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) (rp2 *mm_artifactv1alpha.ReadinessResponse, err error) {
	mm_atomic.AddUint64(&mmReadiness.beforeReadinessCounter, 1)
	defer mm_atomic.AddUint64(&mmReadiness.afterReadinessCounter, 1)

	mmReadiness.t.Helper()

	if mmReadiness.inspectFuncReadiness != nil {
		mmReadiness.inspectFuncReadiness(ctx, rp1)
	}

	mm_params := ArtifactPublicServiceServerMockReadinessParams{ctx, rp1}

	// Record call args
	mmReadiness.ReadinessMock.mutex.Lock()
	mmReadiness.ReadinessMock.callArgs = append(mmReadiness.ReadinessMock.callArgs, &mm_params)
	mmReadiness.ReadinessMock.mutex.Unlock()

	for _, e := range mmReadiness.ReadinessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmReadiness.ReadinessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadiness.ReadinessMock.defaultExpectation.Counter, 1)
		mm_want := mmReadiness.ReadinessMock.defaultExpectation.params
		mm_want_ptrs := mmReadiness.ReadinessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockReadinessParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadiness.t.Errorf("ArtifactPublicServiceServerMock.Readiness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmReadiness.t.Errorf("ArtifactPublicServiceServerMock.Readiness got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadiness.t.Errorf("ArtifactPublicServiceServerMock.Readiness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadiness.ReadinessMock.defaultExpectation.results
		if mm_results == nil {
			mmReadiness.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.Readiness")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmReadiness.funcReadiness != nil {
		return mmReadiness.funcReadiness(ctx, rp1)
	}
	mmReadiness.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.Readiness. %v %v", ctx, rp1)
	return
}

// ReadinessAfterCounter returns a count of finished ArtifactPublicServiceServerMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceServerMock) ReadinessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.afterReadinessCounter)
}

// ReadinessBeforeCounter returns a count of ArtifactPublicServiceServerMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceServerMock) ReadinessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.beforeReadinessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.Readiness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Calls() []*ArtifactPublicServiceServerMockReadinessParams {
	mmReadiness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockReadinessParams, len(mmReadiness.callArgs))
	copy(argCopy, mmReadiness.callArgs)

	mmReadiness.mutex.RUnlock()

	return argCopy
}

// MinimockReadinessDone returns true if the count of the Readiness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockReadinessDone() bool {
	if m.ReadinessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadinessMock.invocationsDone()
}

// MinimockReadinessInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockReadinessInspect() {
	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadinessCounter := mm_atomic.LoadUint64(&m.afterReadinessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadinessMock.defaultExpectation != nil && afterReadinessCounter < 1 {
		if m.ReadinessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s", m.ReadinessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s with params: %#v", m.ReadinessMock.defaultExpectation.expectationOrigins.origin, *m.ReadinessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadiness != nil && afterReadinessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s", m.funcReadinessOrigin)
	}

	if !m.ReadinessMock.invocationsDone() && afterReadinessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.Readiness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadinessMock.expectedInvocations), m.ReadinessMock.expectedInvocationsOrigin, afterReadinessCounter)
	}
}

type mArtifactPublicServiceServerMockSimilarityChunksSearch struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation
	expectations       []*ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation

	callArgs []*ArtifactPublicServiceServerMockSimilarityChunksSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation specifies expectation struct of the ArtifactPublicServiceServer.SimilarityChunksSearch
type ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockSimilarityChunksSearchParams
	paramPtrs          *ArtifactPublicServiceServerMockSimilarityChunksSearchParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockSimilarityChunksSearchExpectationOrigins
	results            *ArtifactPublicServiceServerMockSimilarityChunksSearchResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockSimilarityChunksSearchParams contains parameters of the ArtifactPublicServiceServer.SimilarityChunksSearch
type ArtifactPublicServiceServerMockSimilarityChunksSearchParams struct {
	ctx context.Context
	sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest
}

// ArtifactPublicServiceServerMockSimilarityChunksSearchParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.SimilarityChunksSearch
type ArtifactPublicServiceServerMockSimilarityChunksSearchParamPtrs struct {
	ctx *context.Context
	sp1 **mm_artifactv1alpha.SimilarityChunksSearchRequest
}

// ArtifactPublicServiceServerMockSimilarityChunksSearchResults contains results of the ArtifactPublicServiceServer.SimilarityChunksSearch
type ArtifactPublicServiceServerMockSimilarityChunksSearchResults struct {
	sp2 *mm_artifactv1alpha.SimilarityChunksSearchResponse
	err error
}

// ArtifactPublicServiceServerMockSimilarityChunksSearchOrigins contains origins of expectations of the ArtifactPublicServiceServer.SimilarityChunksSearch
type ArtifactPublicServiceServerMockSimilarityChunksSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originSp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) Optional() *mArtifactPublicServiceServerMockSimilarityChunksSearch {
	mmSimilarityChunksSearch.optional = true
	return mmSimilarityChunksSearch
}

// Expect sets up expected params for ArtifactPublicServiceServer.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) Expect(ctx context.Context, sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest) *mArtifactPublicServiceServerMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by ExpectParams functions")
	}

	mmSimilarityChunksSearch.defaultExpectation.params = &ArtifactPublicServiceServerMockSimilarityChunksSearchParams{ctx, sp1}
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSimilarityChunksSearch.expectations {
		if minimock.Equal(e.params, mmSimilarityChunksSearch.defaultExpectation.params) {
			mmSimilarityChunksSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarityChunksSearch.defaultExpectation.params)
		}
	}

	return mmSimilarityChunksSearch
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectSp1Param2 sets up expected param sp1 for ArtifactPublicServiceServer.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) ExpectSp1Param2(sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest) *mArtifactPublicServiceServerMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.sp1 = &sp1
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originSp1 = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) Inspect(f func(ctx context.Context, sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest)) *mArtifactPublicServiceServerMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.SimilarityChunksSearch")
	}

	mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch = f

	return mmSimilarityChunksSearch
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) Return(sp2 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) *ArtifactPublicServiceServerMock {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation{mock: mmSimilarityChunksSearch.mock}
	}
	mmSimilarityChunksSearch.defaultExpectation.results = &ArtifactPublicServiceServerMockSimilarityChunksSearchResults{sp2, err}
	mmSimilarityChunksSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.SimilarityChunksSearch method
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) Set(f func(ctx context.Context, sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest) (sp2 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmSimilarityChunksSearch.defaultExpectation != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.SimilarityChunksSearch method")
	}

	if len(mmSimilarityChunksSearch.expectations) > 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.SimilarityChunksSearch method")
	}

	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch = f
	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearchOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// When sets expectation for the ArtifactPublicServiceServer.SimilarityChunksSearch which will trigger the result defined by the following
// Then helper
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) When(ctx context.Context, sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest) *ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceServerMock.SimilarityChunksSearch mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation{
		mock:               mmSimilarityChunksSearch.mock,
		params:             &ArtifactPublicServiceServerMockSimilarityChunksSearchParams{ctx, sp1},
		expectationOrigins: ArtifactPublicServiceServerMockSimilarityChunksSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSimilarityChunksSearch.expectations = append(mmSimilarityChunksSearch.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.SimilarityChunksSearch return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockSimilarityChunksSearchExpectation) Then(sp2 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockSimilarityChunksSearchResults{sp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.SimilarityChunksSearch should be invoked
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) Times(n uint64) *mArtifactPublicServiceServerMockSimilarityChunksSearch {
	if n == 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.SimilarityChunksSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarityChunksSearch.expectedInvocations, n)
	mmSimilarityChunksSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch
}

func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) invocationsDone() bool {
	if len(mmSimilarityChunksSearch.expectations) == 0 && mmSimilarityChunksSearch.defaultExpectation == nil && mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.mock.afterSimilarityChunksSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarityChunksSearch implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmSimilarityChunksSearch *ArtifactPublicServiceServerMock) SimilarityChunksSearch(ctx context.Context, sp1 *mm_artifactv1alpha.SimilarityChunksSearchRequest) (sp2 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) {
	mm_atomic.AddUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter, 1)

	mmSimilarityChunksSearch.t.Helper()

	if mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch(ctx, sp1)
	}

	mm_params := ArtifactPublicServiceServerMockSimilarityChunksSearchParams{ctx, sp1}

	// Record call args
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Lock()
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs = append(mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs, &mm_params)
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Unlock()

	for _, e := range mmSimilarityChunksSearch.SimilarityChunksSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp2, e.results.err
		}
	}

	if mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockSimilarityChunksSearchParams{ctx, sp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceServerMock.SimilarityChunksSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sp1 != nil && !minimock.Equal(*mm_want_ptrs.sp1, mm_got.sp1) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceServerMock.SimilarityChunksSearch got unexpected parameter sp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originSp1, *mm_want_ptrs.sp1, mm_got.sp1, minimock.Diff(*mm_want_ptrs.sp1, mm_got.sp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceServerMock.SimilarityChunksSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarityChunksSearch.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.SimilarityChunksSearch")
		}
		return (*mm_results).sp2, (*mm_results).err
	}
	if mmSimilarityChunksSearch.funcSimilarityChunksSearch != nil {
		return mmSimilarityChunksSearch.funcSimilarityChunksSearch(ctx, sp1)
	}
	mmSimilarityChunksSearch.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.SimilarityChunksSearch. %v %v", ctx, sp1)
	return
}

// SimilarityChunksSearchAfterCounter returns a count of finished ArtifactPublicServiceServerMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ArtifactPublicServiceServerMock) SimilarityChunksSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter)
}

// SimilarityChunksSearchBeforeCounter returns a count of ArtifactPublicServiceServerMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ArtifactPublicServiceServerMock) SimilarityChunksSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.SimilarityChunksSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarityChunksSearch *mArtifactPublicServiceServerMockSimilarityChunksSearch) Calls() []*ArtifactPublicServiceServerMockSimilarityChunksSearchParams {
	mmSimilarityChunksSearch.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockSimilarityChunksSearchParams, len(mmSimilarityChunksSearch.callArgs))
	copy(argCopy, mmSimilarityChunksSearch.callArgs)

	mmSimilarityChunksSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarityChunksSearchDone returns true if the count of the SimilarityChunksSearch invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockSimilarityChunksSearchDone() bool {
	if m.SimilarityChunksSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarityChunksSearchMock.invocationsDone()
}

// MinimockSimilarityChunksSearchInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockSimilarityChunksSearchInspect() {
	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SimilarityChunksSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSimilarityChunksSearchCounter := mm_atomic.LoadUint64(&m.afterSimilarityChunksSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarityChunksSearchMock.defaultExpectation != nil && afterSimilarityChunksSearchCounter < 1 {
		if m.SimilarityChunksSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SimilarityChunksSearch at\n%s", m.SimilarityChunksSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SimilarityChunksSearch at\n%s with params: %#v", m.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *m.SimilarityChunksSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarityChunksSearch != nil && afterSimilarityChunksSearchCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SimilarityChunksSearch at\n%s", m.funcSimilarityChunksSearchOrigin)
	}

	if !m.SimilarityChunksSearchMock.invocationsDone() && afterSimilarityChunksSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.SimilarityChunksSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarityChunksSearchMock.expectedInvocations), m.SimilarityChunksSearchMock.expectedInvocationsOrigin, afterSimilarityChunksSearchCounter)
	}
}

type mArtifactPublicServiceServerMockUpdateCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockUpdateCatalogExpectation
	expectations       []*ArtifactPublicServiceServerMockUpdateCatalogExpectation

	callArgs []*ArtifactPublicServiceServerMockUpdateCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockUpdateCatalogExpectation specifies expectation struct of the ArtifactPublicServiceServer.UpdateCatalog
type ArtifactPublicServiceServerMockUpdateCatalogExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockUpdateCatalogParams
	paramPtrs          *ArtifactPublicServiceServerMockUpdateCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockUpdateCatalogExpectationOrigins
	results            *ArtifactPublicServiceServerMockUpdateCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockUpdateCatalogParams contains parameters of the ArtifactPublicServiceServer.UpdateCatalog
type ArtifactPublicServiceServerMockUpdateCatalogParams struct {
	ctx context.Context
	up1 *mm_artifactv1alpha.UpdateCatalogRequest
}

// ArtifactPublicServiceServerMockUpdateCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.UpdateCatalog
type ArtifactPublicServiceServerMockUpdateCatalogParamPtrs struct {
	ctx *context.Context
	up1 **mm_artifactv1alpha.UpdateCatalogRequest
}

// ArtifactPublicServiceServerMockUpdateCatalogResults contains results of the ArtifactPublicServiceServer.UpdateCatalog
type ArtifactPublicServiceServerMockUpdateCatalogResults struct {
	up2 *mm_artifactv1alpha.UpdateCatalogResponse
	err error
}

// ArtifactPublicServiceServerMockUpdateCatalogOrigins contains origins of expectations of the ArtifactPublicServiceServer.UpdateCatalog
type ArtifactPublicServiceServerMockUpdateCatalogExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) Optional() *mArtifactPublicServiceServerMockUpdateCatalog {
	mmUpdateCatalog.optional = true
	return mmUpdateCatalog
}

// Expect sets up expected params for ArtifactPublicServiceServer.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) Expect(ctx context.Context, up1 *mm_artifactv1alpha.UpdateCatalogRequest) *mArtifactPublicServiceServerMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by ExpectParams functions")
	}

	mmUpdateCatalog.defaultExpectation.params = &ArtifactPublicServiceServerMockUpdateCatalogParams{ctx, up1}
	mmUpdateCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateCatalog.expectations {
		if minimock.Equal(e.params, mmUpdateCatalog.defaultExpectation.params) {
			mmUpdateCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCatalog.defaultExpectation.params)
		}
	}

	return mmUpdateCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateCatalog
}

// ExpectUp1Param2 sets up expected param up1 for ArtifactPublicServiceServer.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) ExpectUp1Param2(up1 *mm_artifactv1alpha.UpdateCatalogRequest) *mArtifactPublicServiceServerMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateCatalog.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) Inspect(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateCatalogRequest)) *mArtifactPublicServiceServerMockUpdateCatalog {
	if mmUpdateCatalog.mock.inspectFuncUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.UpdateCatalog")
	}

	mmUpdateCatalog.mock.inspectFuncUpdateCatalog = f

	return mmUpdateCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) Return(up2 *mm_artifactv1alpha.UpdateCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceServerMockUpdateCatalogExpectation{mock: mmUpdateCatalog.mock}
	}
	mmUpdateCatalog.defaultExpectation.results = &ArtifactPublicServiceServerMockUpdateCatalogResults{up2, err}
	mmUpdateCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.UpdateCatalog method
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) Set(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateCatalogRequest) (up2 *mm_artifactv1alpha.UpdateCatalogResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmUpdateCatalog.defaultExpectation != nil {
		mmUpdateCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.UpdateCatalog method")
	}

	if len(mmUpdateCatalog.expectations) > 0 {
		mmUpdateCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.UpdateCatalog method")
	}

	mmUpdateCatalog.mock.funcUpdateCatalog = f
	mmUpdateCatalog.mock.funcUpdateCatalogOrigin = minimock.CallerInfo(1)
	return mmUpdateCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceServer.UpdateCatalog which will trigger the result defined by the following
// Then helper
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) When(ctx context.Context, up1 *mm_artifactv1alpha.UpdateCatalogRequest) *ArtifactPublicServiceServerMockUpdateCatalogExpectation {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockUpdateCatalogExpectation{
		mock:               mmUpdateCatalog.mock,
		params:             &ArtifactPublicServiceServerMockUpdateCatalogParams{ctx, up1},
		expectationOrigins: ArtifactPublicServiceServerMockUpdateCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateCatalog.expectations = append(mmUpdateCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.UpdateCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockUpdateCatalogExpectation) Then(up2 *mm_artifactv1alpha.UpdateCatalogResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockUpdateCatalogResults{up2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.UpdateCatalog should be invoked
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) Times(n uint64) *mArtifactPublicServiceServerMockUpdateCatalog {
	if n == 0 {
		mmUpdateCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.UpdateCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCatalog.expectedInvocations, n)
	mmUpdateCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateCatalog
}

func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) invocationsDone() bool {
	if len(mmUpdateCatalog.expectations) == 0 && mmUpdateCatalog.defaultExpectation == nil && mmUpdateCatalog.mock.funcUpdateCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCatalog.mock.afterUpdateCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCatalog implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmUpdateCatalog *ArtifactPublicServiceServerMock) UpdateCatalog(ctx context.Context, up1 *mm_artifactv1alpha.UpdateCatalogRequest) (up2 *mm_artifactv1alpha.UpdateCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateCatalog.beforeUpdateCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCatalog.afterUpdateCatalogCounter, 1)

	mmUpdateCatalog.t.Helper()

	if mmUpdateCatalog.inspectFuncUpdateCatalog != nil {
		mmUpdateCatalog.inspectFuncUpdateCatalog(ctx, up1)
	}

	mm_params := ArtifactPublicServiceServerMockUpdateCatalogParams{ctx, up1}

	// Record call args
	mmUpdateCatalog.UpdateCatalogMock.mutex.Lock()
	mmUpdateCatalog.UpdateCatalogMock.callArgs = append(mmUpdateCatalog.UpdateCatalogMock.callArgs, &mm_params)
	mmUpdateCatalog.UpdateCatalogMock.mutex.Unlock()

	for _, e := range mmUpdateCatalog.UpdateCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateCatalog.UpdateCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockUpdateCatalogParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceServerMock.UpdateCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceServerMock.UpdateCatalog got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCatalog.t.Errorf("ArtifactPublicServiceServerMock.UpdateCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCatalog.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.UpdateCatalog")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateCatalog.funcUpdateCatalog != nil {
		return mmUpdateCatalog.funcUpdateCatalog(ctx, up1)
	}
	mmUpdateCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.UpdateCatalog. %v %v", ctx, up1)
	return
}

// UpdateCatalogAfterCounter returns a count of finished ArtifactPublicServiceServerMock.UpdateCatalog invocations
func (mmUpdateCatalog *ArtifactPublicServiceServerMock) UpdateCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCatalog.afterUpdateCatalogCounter)
}

// UpdateCatalogBeforeCounter returns a count of ArtifactPublicServiceServerMock.UpdateCatalog invocations
func (mmUpdateCatalog *ArtifactPublicServiceServerMock) UpdateCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCatalog.beforeUpdateCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.UpdateCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCatalog *mArtifactPublicServiceServerMockUpdateCatalog) Calls() []*ArtifactPublicServiceServerMockUpdateCatalogParams {
	mmUpdateCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockUpdateCatalogParams, len(mmUpdateCatalog.callArgs))
	copy(argCopy, mmUpdateCatalog.callArgs)

	mmUpdateCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCatalogDone returns true if the count of the UpdateCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockUpdateCatalogDone() bool {
	if m.UpdateCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCatalogMock.invocationsDone()
}

// MinimockUpdateCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockUpdateCatalogInspect() {
	for _, e := range m.UpdateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCatalogCounter := mm_atomic.LoadUint64(&m.afterUpdateCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCatalogMock.defaultExpectation != nil && afterUpdateCatalogCounter < 1 {
		if m.UpdateCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateCatalog at\n%s", m.UpdateCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateCatalog at\n%s with params: %#v", m.UpdateCatalogMock.defaultExpectation.expectationOrigins.origin, *m.UpdateCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCatalog != nil && afterUpdateCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateCatalog at\n%s", m.funcUpdateCatalogOrigin)
	}

	if !m.UpdateCatalogMock.invocationsDone() && afterUpdateCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.UpdateCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCatalogMock.expectedInvocations), m.UpdateCatalogMock.expectedInvocationsOrigin, afterUpdateCatalogCounter)
	}
}

type mArtifactPublicServiceServerMockUpdateChunk struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockUpdateChunkExpectation
	expectations       []*ArtifactPublicServiceServerMockUpdateChunkExpectation

	callArgs []*ArtifactPublicServiceServerMockUpdateChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockUpdateChunkExpectation specifies expectation struct of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockUpdateChunkParams
	paramPtrs          *ArtifactPublicServiceServerMockUpdateChunkParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockUpdateChunkExpectationOrigins
	results            *ArtifactPublicServiceServerMockUpdateChunkResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockUpdateChunkParams contains parameters of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkParams struct {
	ctx context.Context
	up1 *mm_artifactv1alpha.UpdateChunkRequest
}

// ArtifactPublicServiceServerMockUpdateChunkParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkParamPtrs struct {
	ctx *context.Context
	up1 **mm_artifactv1alpha.UpdateChunkRequest
}

// ArtifactPublicServiceServerMockUpdateChunkResults contains results of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkResults struct {
	up2 *mm_artifactv1alpha.UpdateChunkResponse
	err error
}

// ArtifactPublicServiceServerMockUpdateChunkOrigins contains origins of expectations of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Optional() *mArtifactPublicServiceServerMockUpdateChunk {
	mmUpdateChunk.optional = true
	return mmUpdateChunk
}

// Expect sets up expected params for ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Expect(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by ExpectParams functions")
	}

	mmUpdateChunk.defaultExpectation.params = &ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1}
	mmUpdateChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateChunk.expectations {
		if minimock.Equal(e.params, mmUpdateChunk.defaultExpectation.params) {
			mmUpdateChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateChunk.defaultExpectation.params)
		}
	}

	return mmUpdateChunk
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// ExpectUp1Param2 sets up expected param up1 for ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) ExpectUp1Param2(up1 *mm_artifactv1alpha.UpdateChunkRequest) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateChunk.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Inspect(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest)) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.UpdateChunk")
	}

	mmUpdateChunk.mock.inspectFuncUpdateChunk = f

	return mmUpdateChunk
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Return(up2 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceServerMock {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{mock: mmUpdateChunk.mock}
	}
	mmUpdateChunk.defaultExpectation.results = &ArtifactPublicServiceServerMockUpdateChunkResults{up2, err}
	mmUpdateChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.UpdateChunk method
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Set(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) (up2 *mm_artifactv1alpha.UpdateChunkResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmUpdateChunk.defaultExpectation != nil {
		mmUpdateChunk.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.UpdateChunk method")
	}

	if len(mmUpdateChunk.expectations) > 0 {
		mmUpdateChunk.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.UpdateChunk method")
	}

	mmUpdateChunk.mock.funcUpdateChunk = f
	mmUpdateChunk.mock.funcUpdateChunkOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// When sets expectation for the ArtifactPublicServiceServer.UpdateChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) When(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) *ArtifactPublicServiceServerMockUpdateChunkExpectation {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockUpdateChunkExpectation{
		mock:               mmUpdateChunk.mock,
		params:             &ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1},
		expectationOrigins: ArtifactPublicServiceServerMockUpdateChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateChunk.expectations = append(mmUpdateChunk.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.UpdateChunk return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockUpdateChunkExpectation) Then(up2 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockUpdateChunkResults{up2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.UpdateChunk should be invoked
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Times(n uint64) *mArtifactPublicServiceServerMockUpdateChunk {
	if n == 0 {
		mmUpdateChunk.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.UpdateChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateChunk.expectedInvocations, n)
	mmUpdateChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk
}

func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) invocationsDone() bool {
	if len(mmUpdateChunk.expectations) == 0 && mmUpdateChunk.defaultExpectation == nil && mmUpdateChunk.mock.funcUpdateChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.mock.afterUpdateChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateChunk implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmUpdateChunk *ArtifactPublicServiceServerMock) UpdateChunk(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) (up2 *mm_artifactv1alpha.UpdateChunkResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateChunk.beforeUpdateChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateChunk.afterUpdateChunkCounter, 1)

	mmUpdateChunk.t.Helper()

	if mmUpdateChunk.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.inspectFuncUpdateChunk(ctx, up1)
	}

	mm_params := ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1}

	// Record call args
	mmUpdateChunk.UpdateChunkMock.mutex.Lock()
	mmUpdateChunk.UpdateChunkMock.callArgs = append(mmUpdateChunk.UpdateChunkMock.callArgs, &mm_params)
	mmUpdateChunk.UpdateChunkMock.mutex.Unlock()

	for _, e := range mmUpdateChunk.UpdateChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateChunk.UpdateChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateChunk.UpdateChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateChunk.UpdateChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateChunk.UpdateChunkMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceServerMock.UpdateChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceServerMock.UpdateChunk got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateChunk.t.Errorf("ArtifactPublicServiceServerMock.UpdateChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateChunk.UpdateChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateChunk.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.UpdateChunk")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateChunk.funcUpdateChunk != nil {
		return mmUpdateChunk.funcUpdateChunk(ctx, up1)
	}
	mmUpdateChunk.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.UpdateChunk. %v %v", ctx, up1)
	return
}

// UpdateChunkAfterCounter returns a count of finished ArtifactPublicServiceServerMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceServerMock) UpdateChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.afterUpdateChunkCounter)
}

// UpdateChunkBeforeCounter returns a count of ArtifactPublicServiceServerMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceServerMock) UpdateChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.beforeUpdateChunkCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.UpdateChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Calls() []*ArtifactPublicServiceServerMockUpdateChunkParams {
	mmUpdateChunk.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockUpdateChunkParams, len(mmUpdateChunk.callArgs))
	copy(argCopy, mmUpdateChunk.callArgs)

	mmUpdateChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateChunkDone returns true if the count of the UpdateChunk invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockUpdateChunkDone() bool {
	if m.UpdateChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateChunkMock.invocationsDone()
}

// MinimockUpdateChunkInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockUpdateChunkInspect() {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateChunkMock.defaultExpectation != nil && afterUpdateChunkCounter < 1 {
		if m.UpdateChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s", m.UpdateChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s with params: %#v", m.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *m.UpdateChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateChunk != nil && afterUpdateChunkCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s", m.funcUpdateChunkOrigin)
	}

	if !m.UpdateChunkMock.invocationsDone() && afterUpdateChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.UpdateChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateChunkMock.expectedInvocations), m.UpdateChunkMock.expectedInvocationsOrigin, afterUpdateChunkCounter)
	}
}

type mArtifactPublicServiceServerMockUploadCatalogFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockUploadCatalogFileExpectation
	expectations       []*ArtifactPublicServiceServerMockUploadCatalogFileExpectation

	callArgs []*ArtifactPublicServiceServerMockUploadCatalogFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockUploadCatalogFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.UploadCatalogFile
type ArtifactPublicServiceServerMockUploadCatalogFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockUploadCatalogFileParams
	paramPtrs          *ArtifactPublicServiceServerMockUploadCatalogFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockUploadCatalogFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockUploadCatalogFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockUploadCatalogFileParams contains parameters of the ArtifactPublicServiceServer.UploadCatalogFile
type ArtifactPublicServiceServerMockUploadCatalogFileParams struct {
	ctx context.Context
	up1 *mm_artifactv1alpha.UploadCatalogFileRequest
}

// ArtifactPublicServiceServerMockUploadCatalogFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.UploadCatalogFile
type ArtifactPublicServiceServerMockUploadCatalogFileParamPtrs struct {
	ctx *context.Context
	up1 **mm_artifactv1alpha.UploadCatalogFileRequest
}

// ArtifactPublicServiceServerMockUploadCatalogFileResults contains results of the ArtifactPublicServiceServer.UploadCatalogFile
type ArtifactPublicServiceServerMockUploadCatalogFileResults struct {
	up2 *mm_artifactv1alpha.UploadCatalogFileResponse
	err error
}

// ArtifactPublicServiceServerMockUploadCatalogFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.UploadCatalogFile
type ArtifactPublicServiceServerMockUploadCatalogFileExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) Optional() *mArtifactPublicServiceServerMockUploadCatalogFile {
	mmUploadCatalogFile.optional = true
	return mmUploadCatalogFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) Expect(ctx context.Context, up1 *mm_artifactv1alpha.UploadCatalogFileRequest) *mArtifactPublicServiceServerMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by ExpectParams functions")
	}

	mmUploadCatalogFile.defaultExpectation.params = &ArtifactPublicServiceServerMockUploadCatalogFileParams{ctx, up1}
	mmUploadCatalogFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadCatalogFile.expectations {
		if minimock.Equal(e.params, mmUploadCatalogFile.defaultExpectation.params) {
			mmUploadCatalogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadCatalogFile.defaultExpectation.params)
		}
	}

	return mmUploadCatalogFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadCatalogFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadCatalogFile
}

// ExpectUp1Param2 sets up expected param up1 for ArtifactPublicServiceServer.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) ExpectUp1Param2(up1 *mm_artifactv1alpha.UploadCatalogFileRequest) *mArtifactPublicServiceServerMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.up1 = &up1
	mmUploadCatalogFile.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUploadCatalogFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) Inspect(f func(ctx context.Context, up1 *mm_artifactv1alpha.UploadCatalogFileRequest)) *mArtifactPublicServiceServerMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.inspectFuncUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.UploadCatalogFile")
	}

	mmUploadCatalogFile.mock.inspectFuncUploadCatalogFile = f

	return mmUploadCatalogFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) Return(up2 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceServerMockUploadCatalogFileExpectation{mock: mmUploadCatalogFile.mock}
	}
	mmUploadCatalogFile.defaultExpectation.results = &ArtifactPublicServiceServerMockUploadCatalogFileResults{up2, err}
	mmUploadCatalogFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadCatalogFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.UploadCatalogFile method
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) Set(f func(ctx context.Context, up1 *mm_artifactv1alpha.UploadCatalogFileRequest) (up2 *mm_artifactv1alpha.UploadCatalogFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmUploadCatalogFile.defaultExpectation != nil {
		mmUploadCatalogFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.UploadCatalogFile method")
	}

	if len(mmUploadCatalogFile.expectations) > 0 {
		mmUploadCatalogFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.UploadCatalogFile method")
	}

	mmUploadCatalogFile.mock.funcUploadCatalogFile = f
	mmUploadCatalogFile.mock.funcUploadCatalogFileOrigin = minimock.CallerInfo(1)
	return mmUploadCatalogFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.UploadCatalogFile which will trigger the result defined by the following
// Then helper
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) When(ctx context.Context, up1 *mm_artifactv1alpha.UploadCatalogFileRequest) *ArtifactPublicServiceServerMockUploadCatalogFileExpectation {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UploadCatalogFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockUploadCatalogFileExpectation{
		mock:               mmUploadCatalogFile.mock,
		params:             &ArtifactPublicServiceServerMockUploadCatalogFileParams{ctx, up1},
		expectationOrigins: ArtifactPublicServiceServerMockUploadCatalogFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadCatalogFile.expectations = append(mmUploadCatalogFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.UploadCatalogFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockUploadCatalogFileExpectation) Then(up2 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockUploadCatalogFileResults{up2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.UploadCatalogFile should be invoked
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) Times(n uint64) *mArtifactPublicServiceServerMockUploadCatalogFile {
	if n == 0 {
		mmUploadCatalogFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.UploadCatalogFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadCatalogFile.expectedInvocations, n)
	mmUploadCatalogFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadCatalogFile
}

func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) invocationsDone() bool {
	if len(mmUploadCatalogFile.expectations) == 0 && mmUploadCatalogFile.defaultExpectation == nil && mmUploadCatalogFile.mock.funcUploadCatalogFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadCatalogFile.mock.afterUploadCatalogFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadCatalogFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadCatalogFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmUploadCatalogFile *ArtifactPublicServiceServerMock) UploadCatalogFile(ctx context.Context, up1 *mm_artifactv1alpha.UploadCatalogFileRequest) (up2 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) {
	mm_atomic.AddUint64(&mmUploadCatalogFile.beforeUploadCatalogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadCatalogFile.afterUploadCatalogFileCounter, 1)

	mmUploadCatalogFile.t.Helper()

	if mmUploadCatalogFile.inspectFuncUploadCatalogFile != nil {
		mmUploadCatalogFile.inspectFuncUploadCatalogFile(ctx, up1)
	}

	mm_params := ArtifactPublicServiceServerMockUploadCatalogFileParams{ctx, up1}

	// Record call args
	mmUploadCatalogFile.UploadCatalogFileMock.mutex.Lock()
	mmUploadCatalogFile.UploadCatalogFileMock.callArgs = append(mmUploadCatalogFile.UploadCatalogFileMock.callArgs, &mm_params)
	mmUploadCatalogFile.UploadCatalogFileMock.mutex.Unlock()

	for _, e := range mmUploadCatalogFile.UploadCatalogFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockUploadCatalogFileParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceServerMock.UploadCatalogFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceServerMock.UploadCatalogFile got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceServerMock.UploadCatalogFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadCatalogFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.UploadCatalogFile")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUploadCatalogFile.funcUploadCatalogFile != nil {
		return mmUploadCatalogFile.funcUploadCatalogFile(ctx, up1)
	}
	mmUploadCatalogFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.UploadCatalogFile. %v %v", ctx, up1)
	return
}

// UploadCatalogFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.UploadCatalogFile invocations
func (mmUploadCatalogFile *ArtifactPublicServiceServerMock) UploadCatalogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadCatalogFile.afterUploadCatalogFileCounter)
}

// UploadCatalogFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.UploadCatalogFile invocations
func (mmUploadCatalogFile *ArtifactPublicServiceServerMock) UploadCatalogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadCatalogFile.beforeUploadCatalogFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.UploadCatalogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadCatalogFile *mArtifactPublicServiceServerMockUploadCatalogFile) Calls() []*ArtifactPublicServiceServerMockUploadCatalogFileParams {
	mmUploadCatalogFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockUploadCatalogFileParams, len(mmUploadCatalogFile.callArgs))
	copy(argCopy, mmUploadCatalogFile.callArgs)

	mmUploadCatalogFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadCatalogFileDone returns true if the count of the UploadCatalogFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockUploadCatalogFileDone() bool {
	if m.UploadCatalogFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadCatalogFileMock.invocationsDone()
}

// MinimockUploadCatalogFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockUploadCatalogFileInspect() {
	for _, e := range m.UploadCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UploadCatalogFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadCatalogFileCounter := mm_atomic.LoadUint64(&m.afterUploadCatalogFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadCatalogFileMock.defaultExpectation != nil && afterUploadCatalogFileCounter < 1 {
		if m.UploadCatalogFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UploadCatalogFile at\n%s", m.UploadCatalogFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UploadCatalogFile at\n%s with params: %#v", m.UploadCatalogFileMock.defaultExpectation.expectationOrigins.origin, *m.UploadCatalogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadCatalogFile != nil && afterUploadCatalogFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UploadCatalogFile at\n%s", m.funcUploadCatalogFileOrigin)
	}

	if !m.UploadCatalogFileMock.invocationsDone() && afterUploadCatalogFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.UploadCatalogFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadCatalogFileMock.expectedInvocations), m.UploadCatalogFileMock.expectedInvocationsOrigin, afterUploadCatalogFileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ArtifactPublicServiceServerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateCatalogInspect()

			m.MinimockDeleteCatalogInspect()

			m.MinimockDeleteCatalogFileInspect()

			m.MinimockGetFileCatalogInspect()

			m.MinimockGetObjectDownloadURLInspect()

			m.MinimockGetObjectUploadURLInspect()

			m.MinimockGetSourceFileInspect()

			m.MinimockListCatalogFilesInspect()

			m.MinimockListCatalogRunsInspect()

			m.MinimockListCatalogsInspect()

			m.MinimockListChunksInspect()

			m.MinimockLivenessInspect()

			m.MinimockProcessCatalogFilesInspect()

			m.MinimockQuestionAnsweringInspect()

			m.MinimockReadinessInspect()

			m.MinimockSimilarityChunksSearchInspect()

			m.MinimockUpdateCatalogInspect()

			m.MinimockUpdateChunkInspect()

			m.MinimockUploadCatalogFileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ArtifactPublicServiceServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ArtifactPublicServiceServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCatalogDone() &&
		m.MinimockDeleteCatalogDone() &&
		m.MinimockDeleteCatalogFileDone() &&
		m.MinimockGetFileCatalogDone() &&
		m.MinimockGetObjectDownloadURLDone() &&
		m.MinimockGetObjectUploadURLDone() &&
		m.MinimockGetSourceFileDone() &&
		m.MinimockListCatalogFilesDone() &&
		m.MinimockListCatalogRunsDone() &&
		m.MinimockListCatalogsDone() &&
		m.MinimockListChunksDone() &&
		m.MinimockLivenessDone() &&
		m.MinimockProcessCatalogFilesDone() &&
		m.MinimockQuestionAnsweringDone() &&
		m.MinimockReadinessDone() &&
		m.MinimockSimilarityChunksSearchDone() &&
		m.MinimockUpdateCatalogDone() &&
		m.MinimockUpdateChunkDone() &&
		m.MinimockUploadCatalogFileDone()
}
