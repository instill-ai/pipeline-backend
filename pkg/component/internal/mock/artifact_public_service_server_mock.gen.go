// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_artifactv1alpha "github.com/instill-ai/protogen-go/artifact/v1alpha"
)

// ArtifactPublicServiceServerMock implements mm_artifactv1alpha.ArtifactPublicServiceServer
type ArtifactPublicServiceServerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateFile          func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateFileRequest) (cp2 *mm_artifactv1alpha.CreateFileResponse, err error)
	funcCreateFileOrigin    string
	inspectFuncCreateFile   func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateFileRequest)
	afterCreateFileCounter  uint64
	beforeCreateFileCounter uint64
	CreateFileMock          mArtifactPublicServiceServerMockCreateFile

	funcCreateKnowledgeBase          func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest) (cp2 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error)
	funcCreateKnowledgeBaseOrigin    string
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mArtifactPublicServiceServerMockCreateKnowledgeBase

	funcDeleteFile          func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteFileRequest) (dp2 *mm_artifactv1alpha.DeleteFileResponse, err error)
	funcDeleteFileOrigin    string
	inspectFuncDeleteFile   func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteFileRequest)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mArtifactPublicServiceServerMockDeleteFile

	funcDeleteKnowledgeBase          func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest) (dp2 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error)
	funcDeleteKnowledgeBaseOrigin    string
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mArtifactPublicServiceServerMockDeleteKnowledgeBase

	funcDeleteObject          func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteObjectRequest) (dp2 *mm_artifactv1alpha.DeleteObjectResponse, err error)
	funcDeleteObjectOrigin    string
	inspectFuncDeleteObject   func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteObjectRequest)
	afterDeleteObjectCounter  uint64
	beforeDeleteObjectCounter uint64
	DeleteObjectMock          mArtifactPublicServiceServerMockDeleteObject

	funcGetChunk          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetChunkRequest) (gp2 *mm_artifactv1alpha.GetChunkResponse, err error)
	funcGetChunkOrigin    string
	inspectFuncGetChunk   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetChunkRequest)
	afterGetChunkCounter  uint64
	beforeGetChunkCounter uint64
	GetChunkMock          mArtifactPublicServiceServerMockGetChunk

	funcGetFile          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileRequest) (gp2 *mm_artifactv1alpha.GetFileResponse, err error)
	funcGetFileOrigin    string
	inspectFuncGetFile   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileRequest)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mArtifactPublicServiceServerMockGetFile

	funcGetKnowledgeBase          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest) (gp2 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error)
	funcGetKnowledgeBaseOrigin    string
	inspectFuncGetKnowledgeBase   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest)
	afterGetKnowledgeBaseCounter  uint64
	beforeGetKnowledgeBaseCounter uint64
	GetKnowledgeBaseMock          mArtifactPublicServiceServerMockGetKnowledgeBase

	funcGetObject          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectRequest) (gp2 *mm_artifactv1alpha.GetObjectResponse, err error)
	funcGetObjectOrigin    string
	inspectFuncGetObject   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectRequest)
	afterGetObjectCounter  uint64
	beforeGetObjectCounter uint64
	GetObjectMock          mArtifactPublicServiceServerMockGetObject

	funcGetObjectDownloadURL          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)
	funcGetObjectDownloadURLOrigin    string
	inspectFuncGetObjectDownloadURL   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest)
	afterGetObjectDownloadURLCounter  uint64
	beforeGetObjectDownloadURLCounter uint64
	GetObjectDownloadURLMock          mArtifactPublicServiceServerMockGetObjectDownloadURL

	funcGetObjectUploadURL          func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)
	funcGetObjectUploadURLOrigin    string
	inspectFuncGetObjectUploadURL   func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest)
	afterGetObjectUploadURLCounter  uint64
	beforeGetObjectUploadURLCounter uint64
	GetObjectUploadURLMock          mArtifactPublicServiceServerMockGetObjectUploadURL

	funcListChunks          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) (lp2 *mm_artifactv1alpha.ListChunksResponse, err error)
	funcListChunksOrigin    string
	inspectFuncListChunks   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest)
	afterListChunksCounter  uint64
	beforeListChunksCounter uint64
	ListChunksMock          mArtifactPublicServiceServerMockListChunks

	funcListFiles          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListFilesRequest) (lp2 *mm_artifactv1alpha.ListFilesResponse, err error)
	funcListFilesOrigin    string
	inspectFuncListFiles   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListFilesRequest)
	afterListFilesCounter  uint64
	beforeListFilesCounter uint64
	ListFilesMock          mArtifactPublicServiceServerMockListFiles

	funcListKnowledgeBaseRuns          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest) (lp2 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error)
	funcListKnowledgeBaseRunsOrigin    string
	inspectFuncListKnowledgeBaseRuns   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest)
	afterListKnowledgeBaseRunsCounter  uint64
	beforeListKnowledgeBaseRunsCounter uint64
	ListKnowledgeBaseRunsMock          mArtifactPublicServiceServerMockListKnowledgeBaseRuns

	funcListKnowledgeBases          func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest) (lp2 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error)
	funcListKnowledgeBasesOrigin    string
	inspectFuncListKnowledgeBases   func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest)
	afterListKnowledgeBasesCounter  uint64
	beforeListKnowledgeBasesCounter uint64
	ListKnowledgeBasesMock          mArtifactPublicServiceServerMockListKnowledgeBases

	funcLiveness          func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) (lp2 *mm_artifactv1alpha.LivenessResponse, err error)
	funcLivenessOrigin    string
	inspectFuncLiveness   func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest)
	afterLivenessCounter  uint64
	beforeLivenessCounter uint64
	LivenessMock          mArtifactPublicServiceServerMockLiveness

	funcReadiness          func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) (rp2 *mm_artifactv1alpha.ReadinessResponse, err error)
	funcReadinessOrigin    string
	inspectFuncReadiness   func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest)
	afterReadinessCounter  uint64
	beforeReadinessCounter uint64
	ReadinessMock          mArtifactPublicServiceServerMockReadiness

	funcReprocessFile          func(ctx context.Context, rp1 *mm_artifactv1alpha.ReprocessFileRequest) (rp2 *mm_artifactv1alpha.ReprocessFileResponse, err error)
	funcReprocessFileOrigin    string
	inspectFuncReprocessFile   func(ctx context.Context, rp1 *mm_artifactv1alpha.ReprocessFileRequest)
	afterReprocessFileCounter  uint64
	beforeReprocessFileCounter uint64
	ReprocessFileMock          mArtifactPublicServiceServerMockReprocessFile

	funcSearchChunks          func(ctx context.Context, sp1 *mm_artifactv1alpha.SearchChunksRequest) (sp2 *mm_artifactv1alpha.SearchChunksResponse, err error)
	funcSearchChunksOrigin    string
	inspectFuncSearchChunks   func(ctx context.Context, sp1 *mm_artifactv1alpha.SearchChunksRequest)
	afterSearchChunksCounter  uint64
	beforeSearchChunksCounter uint64
	SearchChunksMock          mArtifactPublicServiceServerMockSearchChunks

	funcUpdateChunk          func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) (up2 *mm_artifactv1alpha.UpdateChunkResponse, err error)
	funcUpdateChunkOrigin    string
	inspectFuncUpdateChunk   func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest)
	afterUpdateChunkCounter  uint64
	beforeUpdateChunkCounter uint64
	UpdateChunkMock          mArtifactPublicServiceServerMockUpdateChunk

	funcUpdateFile          func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateFileRequest) (up2 *mm_artifactv1alpha.UpdateFileResponse, err error)
	funcUpdateFileOrigin    string
	inspectFuncUpdateFile   func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateFileRequest)
	afterUpdateFileCounter  uint64
	beforeUpdateFileCounter uint64
	UpdateFileMock          mArtifactPublicServiceServerMockUpdateFile

	funcUpdateKnowledgeBase          func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest) (up2 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error)
	funcUpdateKnowledgeBaseOrigin    string
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mArtifactPublicServiceServerMockUpdateKnowledgeBase

	funcUpdateObject          func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateObjectRequest) (up2 *mm_artifactv1alpha.UpdateObjectResponse, err error)
	funcUpdateObjectOrigin    string
	inspectFuncUpdateObject   func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateObjectRequest)
	afterUpdateObjectCounter  uint64
	beforeUpdateObjectCounter uint64
	UpdateObjectMock          mArtifactPublicServiceServerMockUpdateObject
}

// NewArtifactPublicServiceServerMock returns a mock for mm_artifactv1alpha.ArtifactPublicServiceServer
func NewArtifactPublicServiceServerMock(t minimock.Tester) *ArtifactPublicServiceServerMock {
	m := &ArtifactPublicServiceServerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateFileMock = mArtifactPublicServiceServerMockCreateFile{mock: m}
	m.CreateFileMock.callArgs = []*ArtifactPublicServiceServerMockCreateFileParams{}

	m.CreateKnowledgeBaseMock = mArtifactPublicServiceServerMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceServerMockCreateKnowledgeBaseParams{}

	m.DeleteFileMock = mArtifactPublicServiceServerMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*ArtifactPublicServiceServerMockDeleteFileParams{}

	m.DeleteKnowledgeBaseMock = mArtifactPublicServiceServerMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams{}

	m.DeleteObjectMock = mArtifactPublicServiceServerMockDeleteObject{mock: m}
	m.DeleteObjectMock.callArgs = []*ArtifactPublicServiceServerMockDeleteObjectParams{}

	m.GetChunkMock = mArtifactPublicServiceServerMockGetChunk{mock: m}
	m.GetChunkMock.callArgs = []*ArtifactPublicServiceServerMockGetChunkParams{}

	m.GetFileMock = mArtifactPublicServiceServerMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*ArtifactPublicServiceServerMockGetFileParams{}

	m.GetKnowledgeBaseMock = mArtifactPublicServiceServerMockGetKnowledgeBase{mock: m}
	m.GetKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceServerMockGetKnowledgeBaseParams{}

	m.GetObjectMock = mArtifactPublicServiceServerMockGetObject{mock: m}
	m.GetObjectMock.callArgs = []*ArtifactPublicServiceServerMockGetObjectParams{}

	m.GetObjectDownloadURLMock = mArtifactPublicServiceServerMockGetObjectDownloadURL{mock: m}
	m.GetObjectDownloadURLMock.callArgs = []*ArtifactPublicServiceServerMockGetObjectDownloadURLParams{}

	m.GetObjectUploadURLMock = mArtifactPublicServiceServerMockGetObjectUploadURL{mock: m}
	m.GetObjectUploadURLMock.callArgs = []*ArtifactPublicServiceServerMockGetObjectUploadURLParams{}

	m.ListChunksMock = mArtifactPublicServiceServerMockListChunks{mock: m}
	m.ListChunksMock.callArgs = []*ArtifactPublicServiceServerMockListChunksParams{}

	m.ListFilesMock = mArtifactPublicServiceServerMockListFiles{mock: m}
	m.ListFilesMock.callArgs = []*ArtifactPublicServiceServerMockListFilesParams{}

	m.ListKnowledgeBaseRunsMock = mArtifactPublicServiceServerMockListKnowledgeBaseRuns{mock: m}
	m.ListKnowledgeBaseRunsMock.callArgs = []*ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams{}

	m.ListKnowledgeBasesMock = mArtifactPublicServiceServerMockListKnowledgeBases{mock: m}
	m.ListKnowledgeBasesMock.callArgs = []*ArtifactPublicServiceServerMockListKnowledgeBasesParams{}

	m.LivenessMock = mArtifactPublicServiceServerMockLiveness{mock: m}
	m.LivenessMock.callArgs = []*ArtifactPublicServiceServerMockLivenessParams{}

	m.ReadinessMock = mArtifactPublicServiceServerMockReadiness{mock: m}
	m.ReadinessMock.callArgs = []*ArtifactPublicServiceServerMockReadinessParams{}

	m.ReprocessFileMock = mArtifactPublicServiceServerMockReprocessFile{mock: m}
	m.ReprocessFileMock.callArgs = []*ArtifactPublicServiceServerMockReprocessFileParams{}

	m.SearchChunksMock = mArtifactPublicServiceServerMockSearchChunks{mock: m}
	m.SearchChunksMock.callArgs = []*ArtifactPublicServiceServerMockSearchChunksParams{}

	m.UpdateChunkMock = mArtifactPublicServiceServerMockUpdateChunk{mock: m}
	m.UpdateChunkMock.callArgs = []*ArtifactPublicServiceServerMockUpdateChunkParams{}

	m.UpdateFileMock = mArtifactPublicServiceServerMockUpdateFile{mock: m}
	m.UpdateFileMock.callArgs = []*ArtifactPublicServiceServerMockUpdateFileParams{}

	m.UpdateKnowledgeBaseMock = mArtifactPublicServiceServerMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams{}

	m.UpdateObjectMock = mArtifactPublicServiceServerMockUpdateObject{mock: m}
	m.UpdateObjectMock.callArgs = []*ArtifactPublicServiceServerMockUpdateObjectParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mArtifactPublicServiceServerMockCreateFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockCreateFileExpectation
	expectations       []*ArtifactPublicServiceServerMockCreateFileExpectation

	callArgs []*ArtifactPublicServiceServerMockCreateFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockCreateFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.CreateFile
type ArtifactPublicServiceServerMockCreateFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockCreateFileParams
	paramPtrs          *ArtifactPublicServiceServerMockCreateFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockCreateFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockCreateFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockCreateFileParams contains parameters of the ArtifactPublicServiceServer.CreateFile
type ArtifactPublicServiceServerMockCreateFileParams struct {
	ctx context.Context
	cp1 *mm_artifactv1alpha.CreateFileRequest
}

// ArtifactPublicServiceServerMockCreateFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.CreateFile
type ArtifactPublicServiceServerMockCreateFileParamPtrs struct {
	ctx *context.Context
	cp1 **mm_artifactv1alpha.CreateFileRequest
}

// ArtifactPublicServiceServerMockCreateFileResults contains results of the ArtifactPublicServiceServer.CreateFile
type ArtifactPublicServiceServerMockCreateFileResults struct {
	cp2 *mm_artifactv1alpha.CreateFileResponse
	err error
}

// ArtifactPublicServiceServerMockCreateFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.CreateFile
type ArtifactPublicServiceServerMockCreateFileExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) Optional() *mArtifactPublicServiceServerMockCreateFile {
	mmCreateFile.optional = true
	return mmCreateFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.CreateFile
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) Expect(ctx context.Context, cp1 *mm_artifactv1alpha.CreateFileRequest) *mArtifactPublicServiceServerMockCreateFile {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceServerMockCreateFileExpectation{}
	}

	if mmCreateFile.defaultExpectation.paramPtrs != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by ExpectParams functions")
	}

	mmCreateFile.defaultExpectation.params = &ArtifactPublicServiceServerMockCreateFileParams{ctx, cp1}
	mmCreateFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateFile.expectations {
		if minimock.Equal(e.params, mmCreateFile.defaultExpectation.params) {
			mmCreateFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateFile.defaultExpectation.params)
		}
	}

	return mmCreateFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.CreateFile
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockCreateFile {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceServerMockCreateFileExpectation{}
	}

	if mmCreateFile.defaultExpectation.params != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by Expect")
	}

	if mmCreateFile.defaultExpectation.paramPtrs == nil {
		mmCreateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockCreateFileParamPtrs{}
	}
	mmCreateFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateFile
}

// ExpectCp1Param2 sets up expected param cp1 for ArtifactPublicServiceServer.CreateFile
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) ExpectCp1Param2(cp1 *mm_artifactv1alpha.CreateFileRequest) *mArtifactPublicServiceServerMockCreateFile {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceServerMockCreateFileExpectation{}
	}

	if mmCreateFile.defaultExpectation.params != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by Expect")
	}

	if mmCreateFile.defaultExpectation.paramPtrs == nil {
		mmCreateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockCreateFileParamPtrs{}
	}
	mmCreateFile.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateFile.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.CreateFile
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) Inspect(f func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateFileRequest)) *mArtifactPublicServiceServerMockCreateFile {
	if mmCreateFile.mock.inspectFuncCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.CreateFile")
	}

	mmCreateFile.mock.inspectFuncCreateFile = f

	return mmCreateFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.CreateFile
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) Return(cp2 *mm_artifactv1alpha.CreateFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceServerMockCreateFileExpectation{mock: mmCreateFile.mock}
	}
	mmCreateFile.defaultExpectation.results = &ArtifactPublicServiceServerMockCreateFileResults{cp2, err}
	mmCreateFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.CreateFile method
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) Set(f func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateFileRequest) (cp2 *mm_artifactv1alpha.CreateFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmCreateFile.defaultExpectation != nil {
		mmCreateFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.CreateFile method")
	}

	if len(mmCreateFile.expectations) > 0 {
		mmCreateFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.CreateFile method")
	}

	mmCreateFile.mock.funcCreateFile = f
	mmCreateFile.mock.funcCreateFileOrigin = minimock.CallerInfo(1)
	return mmCreateFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.CreateFile which will trigger the result defined by the following
// Then helper
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) When(ctx context.Context, cp1 *mm_artifactv1alpha.CreateFileRequest) *ArtifactPublicServiceServerMockCreateFileExpectation {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockCreateFileExpectation{
		mock:               mmCreateFile.mock,
		params:             &ArtifactPublicServiceServerMockCreateFileParams{ctx, cp1},
		expectationOrigins: ArtifactPublicServiceServerMockCreateFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateFile.expectations = append(mmCreateFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.CreateFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockCreateFileExpectation) Then(cp2 *mm_artifactv1alpha.CreateFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockCreateFileResults{cp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.CreateFile should be invoked
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) Times(n uint64) *mArtifactPublicServiceServerMockCreateFile {
	if n == 0 {
		mmCreateFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.CreateFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateFile.expectedInvocations, n)
	mmCreateFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateFile
}

func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) invocationsDone() bool {
	if len(mmCreateFile.expectations) == 0 && mmCreateFile.defaultExpectation == nil && mmCreateFile.mock.funcCreateFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateFile.mock.afterCreateFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmCreateFile *ArtifactPublicServiceServerMock) CreateFile(ctx context.Context, cp1 *mm_artifactv1alpha.CreateFileRequest) (cp2 *mm_artifactv1alpha.CreateFileResponse, err error) {
	mm_atomic.AddUint64(&mmCreateFile.beforeCreateFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateFile.afterCreateFileCounter, 1)

	mmCreateFile.t.Helper()

	if mmCreateFile.inspectFuncCreateFile != nil {
		mmCreateFile.inspectFuncCreateFile(ctx, cp1)
	}

	mm_params := ArtifactPublicServiceServerMockCreateFileParams{ctx, cp1}

	// Record call args
	mmCreateFile.CreateFileMock.mutex.Lock()
	mmCreateFile.CreateFileMock.callArgs = append(mmCreateFile.CreateFileMock.callArgs, &mm_params)
	mmCreateFile.CreateFileMock.mutex.Unlock()

	for _, e := range mmCreateFile.CreateFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateFile.CreateFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateFile.CreateFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateFile.CreateFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateFile.CreateFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockCreateFileParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateFile.t.Errorf("ArtifactPublicServiceServerMock.CreateFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateFile.CreateFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateFile.t.Errorf("ArtifactPublicServiceServerMock.CreateFile got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateFile.CreateFileMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateFile.t.Errorf("ArtifactPublicServiceServerMock.CreateFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateFile.CreateFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateFile.CreateFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.CreateFile")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateFile.funcCreateFile != nil {
		return mmCreateFile.funcCreateFile(ctx, cp1)
	}
	mmCreateFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.CreateFile. %v %v", ctx, cp1)
	return
}

// CreateFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.CreateFile invocations
func (mmCreateFile *ArtifactPublicServiceServerMock) CreateFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateFile.afterCreateFileCounter)
}

// CreateFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.CreateFile invocations
func (mmCreateFile *ArtifactPublicServiceServerMock) CreateFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateFile.beforeCreateFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.CreateFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateFile *mArtifactPublicServiceServerMockCreateFile) Calls() []*ArtifactPublicServiceServerMockCreateFileParams {
	mmCreateFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockCreateFileParams, len(mmCreateFile.callArgs))
	copy(argCopy, mmCreateFile.callArgs)

	mmCreateFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateFileDone returns true if the count of the CreateFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockCreateFileDone() bool {
	if m.CreateFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateFileMock.invocationsDone()
}

// MinimockCreateFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockCreateFileInspect() {
	for _, e := range m.CreateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateFileCounter := mm_atomic.LoadUint64(&m.afterCreateFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateFileMock.defaultExpectation != nil && afterCreateFileCounter < 1 {
		if m.CreateFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateFile at\n%s", m.CreateFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateFile at\n%s with params: %#v", m.CreateFileMock.defaultExpectation.expectationOrigins.origin, *m.CreateFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateFile != nil && afterCreateFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateFile at\n%s", m.funcCreateFileOrigin)
	}

	if !m.CreateFileMock.invocationsDone() && afterCreateFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.CreateFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateFileMock.expectedInvocations), m.CreateFileMock.expectedInvocationsOrigin, afterCreateFileCounter)
	}
}

type mArtifactPublicServiceServerMockCreateKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceServerMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceServer.CreateKnowledgeBase
type ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockCreateKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceServerMockCreateKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceServerMockCreateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockCreateKnowledgeBaseParams contains parameters of the ArtifactPublicServiceServer.CreateKnowledgeBase
type ArtifactPublicServiceServerMockCreateKnowledgeBaseParams struct {
	ctx context.Context
	cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.CreateKnowledgeBase
type ArtifactPublicServiceServerMockCreateKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	cp1 **mm_artifactv1alpha.CreateKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockCreateKnowledgeBaseResults contains results of the ArtifactPublicServiceServer.CreateKnowledgeBase
type ArtifactPublicServiceServerMockCreateKnowledgeBaseResults struct {
	cp2 *mm_artifactv1alpha.CreateKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceServerMockCreateKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceServer.CreateKnowledgeBase
type ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) Optional() *mArtifactPublicServiceServerMockCreateKnowledgeBase {
	mmCreateKnowledgeBase.optional = true
	return mmCreateKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceServer.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) Expect(ctx context.Context, cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest) *mArtifactPublicServiceServerMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceServerMockCreateKnowledgeBaseParams{ctx, cp1}
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// ExpectCp1Param2 sets up expected param cp1 for ArtifactPublicServiceServer.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) ExpectCp1Param2(cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest) *mArtifactPublicServiceServerMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest)) *mArtifactPublicServiceServerMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) Return(cp2 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceServerMockCreateKnowledgeBaseResults{cp2, err}
	mmCreateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) Set(f func(ctx context.Context, cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest) (cp2 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceServer.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) When(ctx context.Context, cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest) *ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation{
		mock:               mmCreateKnowledgeBase.mock,
		params:             &ArtifactPublicServiceServerMockCreateKnowledgeBaseParams{ctx, cp1},
		expectationOrigins: ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockCreateKnowledgeBaseExpectation) Then(cp2 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockCreateKnowledgeBaseResults{cp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) Times(n uint64) *mArtifactPublicServiceServerMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	mmCreateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmCreateKnowledgeBase *ArtifactPublicServiceServerMock) CreateKnowledgeBase(ctx context.Context, cp1 *mm_artifactv1alpha.CreateKnowledgeBaseRequest) (cp2 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	mmCreateKnowledgeBase.t.Helper()

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, cp1)
	}

	mm_params := ArtifactPublicServiceServerMockCreateKnowledgeBaseParams{ctx, cp1}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockCreateKnowledgeBaseParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.CreateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.CreateKnowledgeBase got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.CreateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.CreateKnowledgeBase")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, cp1)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.CreateKnowledgeBase. %v %v", ctx, cp1)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceServerMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *ArtifactPublicServiceServerMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceServerMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *ArtifactPublicServiceServerMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mArtifactPublicServiceServerMockCreateKnowledgeBase) Calls() []*ArtifactPublicServiceServerMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockCreateKnowledgeBaseDone() bool {
	if m.CreateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateKnowledgeBase at\n%s", m.CreateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateKnowledgeBase at\n%s with params: %#v", m.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.CreateKnowledgeBase at\n%s", m.funcCreateKnowledgeBaseOrigin)
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.CreateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), m.CreateKnowledgeBaseMock.expectedInvocationsOrigin, afterCreateKnowledgeBaseCounter)
	}
}

type mArtifactPublicServiceServerMockDeleteFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockDeleteFileExpectation
	expectations       []*ArtifactPublicServiceServerMockDeleteFileExpectation

	callArgs []*ArtifactPublicServiceServerMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockDeleteFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.DeleteFile
type ArtifactPublicServiceServerMockDeleteFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockDeleteFileParams
	paramPtrs          *ArtifactPublicServiceServerMockDeleteFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockDeleteFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockDeleteFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockDeleteFileParams contains parameters of the ArtifactPublicServiceServer.DeleteFile
type ArtifactPublicServiceServerMockDeleteFileParams struct {
	ctx context.Context
	dp1 *mm_artifactv1alpha.DeleteFileRequest
}

// ArtifactPublicServiceServerMockDeleteFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.DeleteFile
type ArtifactPublicServiceServerMockDeleteFileParamPtrs struct {
	ctx *context.Context
	dp1 **mm_artifactv1alpha.DeleteFileRequest
}

// ArtifactPublicServiceServerMockDeleteFileResults contains results of the ArtifactPublicServiceServer.DeleteFile
type ArtifactPublicServiceServerMockDeleteFileResults struct {
	dp2 *mm_artifactv1alpha.DeleteFileResponse
	err error
}

// ArtifactPublicServiceServerMockDeleteFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.DeleteFile
type ArtifactPublicServiceServerMockDeleteFileExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) Optional() *mArtifactPublicServiceServerMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) Expect(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteFileRequest) *mArtifactPublicServiceServerMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &ArtifactPublicServiceServerMockDeleteFileParams{ctx, dp1}
	mmDeleteFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectDp1Param2 sets up expected param dp1 for ArtifactPublicServiceServer.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) ExpectDp1Param2(dp1 *mm_artifactv1alpha.DeleteFileRequest) *mArtifactPublicServiceServerMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteFile.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) Inspect(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteFileRequest)) *mArtifactPublicServiceServerMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) Return(dp2 *mm_artifactv1alpha.DeleteFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceServerMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &ArtifactPublicServiceServerMockDeleteFileResults{dp2, err}
	mmDeleteFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.DeleteFile method
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) Set(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteFileRequest) (dp2 *mm_artifactv1alpha.DeleteFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	mmDeleteFile.mock.funcDeleteFileOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) When(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteFileRequest) *ArtifactPublicServiceServerMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockDeleteFileExpectation{
		mock:               mmDeleteFile.mock,
		params:             &ArtifactPublicServiceServerMockDeleteFileParams{ctx, dp1},
		expectationOrigins: ArtifactPublicServiceServerMockDeleteFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.DeleteFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockDeleteFileExpectation) Then(dp2 *mm_artifactv1alpha.DeleteFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockDeleteFileResults{dp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.DeleteFile should be invoked
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) Times(n uint64) *mArtifactPublicServiceServerMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	mmDeleteFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFile
}

func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmDeleteFile *ArtifactPublicServiceServerMock) DeleteFile(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteFileRequest) (dp2 *mm_artifactv1alpha.DeleteFileResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	mmDeleteFile.t.Helper()

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, dp1)
	}

	mm_params := ArtifactPublicServiceServerMockDeleteFileParams{ctx, dp1}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockDeleteFileParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("ArtifactPublicServiceServerMock.DeleteFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteFile.t.Errorf("ArtifactPublicServiceServerMock.DeleteFile got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("ArtifactPublicServiceServerMock.DeleteFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.DeleteFile")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, dp1)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.DeleteFile. %v %v", ctx, dp1)
	return
}

// DeleteFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.DeleteFile invocations
func (mmDeleteFile *ArtifactPublicServiceServerMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.DeleteFile invocations
func (mmDeleteFile *ArtifactPublicServiceServerMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mArtifactPublicServiceServerMockDeleteFile) Calls() []*ArtifactPublicServiceServerMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteFile at\n%s", m.DeleteFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteFile at\n%s with params: %#v", m.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteFile at\n%s", m.funcDeleteFileOrigin)
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.DeleteFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), m.DeleteFileMock.expectedInvocationsOrigin, afterDeleteFileCounter)
	}
}

type mArtifactPublicServiceServerMockDeleteKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceServer.DeleteKnowledgeBase
type ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceServerMockDeleteKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceServerMockDeleteKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams contains parameters of the ArtifactPublicServiceServer.DeleteKnowledgeBase
type ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams struct {
	ctx context.Context
	dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.DeleteKnowledgeBase
type ArtifactPublicServiceServerMockDeleteKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	dp1 **mm_artifactv1alpha.DeleteKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockDeleteKnowledgeBaseResults contains results of the ArtifactPublicServiceServer.DeleteKnowledgeBase
type ArtifactPublicServiceServerMockDeleteKnowledgeBaseResults struct {
	dp2 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceServerMockDeleteKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceServer.DeleteKnowledgeBase
type ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) Optional() *mArtifactPublicServiceServerMockDeleteKnowledgeBase {
	mmDeleteKnowledgeBase.optional = true
	return mmDeleteKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceServer.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) Expect(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest) *mArtifactPublicServiceServerMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams{ctx, dp1}
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectDp1Param2 sets up expected param dp1 for ArtifactPublicServiceServer.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) ExpectDp1Param2(dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest) *mArtifactPublicServiceServerMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest)) *mArtifactPublicServiceServerMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) Return(dp2 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseResults{dp2, err}
	mmDeleteKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) Set(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest) (dp2 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceServer.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) When(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest) *ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation{
		mock:               mmDeleteKnowledgeBase.mock,
		params:             &ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams{ctx, dp1},
		expectationOrigins: ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockDeleteKnowledgeBaseExpectation) Then(dp2 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockDeleteKnowledgeBaseResults{dp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) Times(n uint64) *mArtifactPublicServiceServerMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	mmDeleteKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmDeleteKnowledgeBase *ArtifactPublicServiceServerMock) DeleteKnowledgeBase(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseRequest) (dp2 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	mmDeleteKnowledgeBase.t.Helper()

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, dp1)
	}

	mm_params := ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams{ctx, dp1}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.DeleteKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.DeleteKnowledgeBase")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, dp1)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.DeleteKnowledgeBase. %v %v", ctx, dp1)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceServerMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *ArtifactPublicServiceServerMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceServerMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *ArtifactPublicServiceServerMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mArtifactPublicServiceServerMockDeleteKnowledgeBase) Calls() []*ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockDeleteKnowledgeBaseDone() bool {
	if m.DeleteKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteKnowledgeBase at\n%s", m.DeleteKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteKnowledgeBase at\n%s with params: %#v", m.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteKnowledgeBase at\n%s", m.funcDeleteKnowledgeBaseOrigin)
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.DeleteKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), m.DeleteKnowledgeBaseMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseCounter)
	}
}

type mArtifactPublicServiceServerMockDeleteObject struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockDeleteObjectExpectation
	expectations       []*ArtifactPublicServiceServerMockDeleteObjectExpectation

	callArgs []*ArtifactPublicServiceServerMockDeleteObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockDeleteObjectExpectation specifies expectation struct of the ArtifactPublicServiceServer.DeleteObject
type ArtifactPublicServiceServerMockDeleteObjectExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockDeleteObjectParams
	paramPtrs          *ArtifactPublicServiceServerMockDeleteObjectParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockDeleteObjectExpectationOrigins
	results            *ArtifactPublicServiceServerMockDeleteObjectResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockDeleteObjectParams contains parameters of the ArtifactPublicServiceServer.DeleteObject
type ArtifactPublicServiceServerMockDeleteObjectParams struct {
	ctx context.Context
	dp1 *mm_artifactv1alpha.DeleteObjectRequest
}

// ArtifactPublicServiceServerMockDeleteObjectParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.DeleteObject
type ArtifactPublicServiceServerMockDeleteObjectParamPtrs struct {
	ctx *context.Context
	dp1 **mm_artifactv1alpha.DeleteObjectRequest
}

// ArtifactPublicServiceServerMockDeleteObjectResults contains results of the ArtifactPublicServiceServer.DeleteObject
type ArtifactPublicServiceServerMockDeleteObjectResults struct {
	dp2 *mm_artifactv1alpha.DeleteObjectResponse
	err error
}

// ArtifactPublicServiceServerMockDeleteObjectOrigins contains origins of expectations of the ArtifactPublicServiceServer.DeleteObject
type ArtifactPublicServiceServerMockDeleteObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originDp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) Optional() *mArtifactPublicServiceServerMockDeleteObject {
	mmDeleteObject.optional = true
	return mmDeleteObject
}

// Expect sets up expected params for ArtifactPublicServiceServer.DeleteObject
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) Expect(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteObjectRequest) *mArtifactPublicServiceServerMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &ArtifactPublicServiceServerMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.paramPtrs != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by ExpectParams functions")
	}

	mmDeleteObject.defaultExpectation.params = &ArtifactPublicServiceServerMockDeleteObjectParams{ctx, dp1}
	mmDeleteObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteObject.expectations {
		if minimock.Equal(e.params, mmDeleteObject.defaultExpectation.params) {
			mmDeleteObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteObject.defaultExpectation.params)
		}
	}

	return mmDeleteObject
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.DeleteObject
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &ArtifactPublicServiceServerMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteObject
}

// ExpectDp1Param2 sets up expected param dp1 for ArtifactPublicServiceServer.DeleteObject
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) ExpectDp1Param2(dp1 *mm_artifactv1alpha.DeleteObjectRequest) *mArtifactPublicServiceServerMockDeleteObject {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &ArtifactPublicServiceServerMockDeleteObjectExpectation{}
	}

	if mmDeleteObject.defaultExpectation.params != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by Expect")
	}

	if mmDeleteObject.defaultExpectation.paramPtrs == nil {
		mmDeleteObject.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockDeleteObjectParamPtrs{}
	}
	mmDeleteObject.defaultExpectation.paramPtrs.dp1 = &dp1
	mmDeleteObject.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmDeleteObject
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.DeleteObject
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) Inspect(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteObjectRequest)) *mArtifactPublicServiceServerMockDeleteObject {
	if mmDeleteObject.mock.inspectFuncDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.DeleteObject")
	}

	mmDeleteObject.mock.inspectFuncDeleteObject = f

	return mmDeleteObject
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.DeleteObject
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) Return(dp2 *mm_artifactv1alpha.DeleteObjectResponse, err error) *ArtifactPublicServiceServerMock {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by Set")
	}

	if mmDeleteObject.defaultExpectation == nil {
		mmDeleteObject.defaultExpectation = &ArtifactPublicServiceServerMockDeleteObjectExpectation{mock: mmDeleteObject.mock}
	}
	mmDeleteObject.defaultExpectation.results = &ArtifactPublicServiceServerMockDeleteObjectResults{dp2, err}
	mmDeleteObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteObject.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.DeleteObject method
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) Set(f func(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteObjectRequest) (dp2 *mm_artifactv1alpha.DeleteObjectResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmDeleteObject.defaultExpectation != nil {
		mmDeleteObject.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.DeleteObject method")
	}

	if len(mmDeleteObject.expectations) > 0 {
		mmDeleteObject.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.DeleteObject method")
	}

	mmDeleteObject.mock.funcDeleteObject = f
	mmDeleteObject.mock.funcDeleteObjectOrigin = minimock.CallerInfo(1)
	return mmDeleteObject.mock
}

// When sets expectation for the ArtifactPublicServiceServer.DeleteObject which will trigger the result defined by the following
// Then helper
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) When(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteObjectRequest) *ArtifactPublicServiceServerMockDeleteObjectExpectation {
	if mmDeleteObject.mock.funcDeleteObject != nil {
		mmDeleteObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.DeleteObject mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockDeleteObjectExpectation{
		mock:               mmDeleteObject.mock,
		params:             &ArtifactPublicServiceServerMockDeleteObjectParams{ctx, dp1},
		expectationOrigins: ArtifactPublicServiceServerMockDeleteObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteObject.expectations = append(mmDeleteObject.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.DeleteObject return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockDeleteObjectExpectation) Then(dp2 *mm_artifactv1alpha.DeleteObjectResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockDeleteObjectResults{dp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.DeleteObject should be invoked
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) Times(n uint64) *mArtifactPublicServiceServerMockDeleteObject {
	if n == 0 {
		mmDeleteObject.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.DeleteObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteObject.expectedInvocations, n)
	mmDeleteObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteObject
}

func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) invocationsDone() bool {
	if len(mmDeleteObject.expectations) == 0 && mmDeleteObject.defaultExpectation == nil && mmDeleteObject.mock.funcDeleteObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteObject.mock.afterDeleteObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteObject implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmDeleteObject *ArtifactPublicServiceServerMock) DeleteObject(ctx context.Context, dp1 *mm_artifactv1alpha.DeleteObjectRequest) (dp2 *mm_artifactv1alpha.DeleteObjectResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteObject.beforeDeleteObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteObject.afterDeleteObjectCounter, 1)

	mmDeleteObject.t.Helper()

	if mmDeleteObject.inspectFuncDeleteObject != nil {
		mmDeleteObject.inspectFuncDeleteObject(ctx, dp1)
	}

	mm_params := ArtifactPublicServiceServerMockDeleteObjectParams{ctx, dp1}

	// Record call args
	mmDeleteObject.DeleteObjectMock.mutex.Lock()
	mmDeleteObject.DeleteObjectMock.callArgs = append(mmDeleteObject.DeleteObjectMock.callArgs, &mm_params)
	mmDeleteObject.DeleteObjectMock.mutex.Unlock()

	for _, e := range mmDeleteObject.DeleteObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2, e.results.err
		}
	}

	if mmDeleteObject.DeleteObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteObject.DeleteObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteObject.DeleteObjectMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteObject.DeleteObjectMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockDeleteObjectParams{ctx, dp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteObject.t.Errorf("ArtifactPublicServiceServerMock.DeleteObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmDeleteObject.t.Errorf("ArtifactPublicServiceServerMock.DeleteObject got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteObject.t.Errorf("ArtifactPublicServiceServerMock.DeleteObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteObject.DeleteObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteObject.DeleteObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteObject.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.DeleteObject")
		}
		return (*mm_results).dp2, (*mm_results).err
	}
	if mmDeleteObject.funcDeleteObject != nil {
		return mmDeleteObject.funcDeleteObject(ctx, dp1)
	}
	mmDeleteObject.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.DeleteObject. %v %v", ctx, dp1)
	return
}

// DeleteObjectAfterCounter returns a count of finished ArtifactPublicServiceServerMock.DeleteObject invocations
func (mmDeleteObject *ArtifactPublicServiceServerMock) DeleteObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.afterDeleteObjectCounter)
}

// DeleteObjectBeforeCounter returns a count of ArtifactPublicServiceServerMock.DeleteObject invocations
func (mmDeleteObject *ArtifactPublicServiceServerMock) DeleteObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteObject.beforeDeleteObjectCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.DeleteObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteObject *mArtifactPublicServiceServerMockDeleteObject) Calls() []*ArtifactPublicServiceServerMockDeleteObjectParams {
	mmDeleteObject.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockDeleteObjectParams, len(mmDeleteObject.callArgs))
	copy(argCopy, mmDeleteObject.callArgs)

	mmDeleteObject.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteObjectDone returns true if the count of the DeleteObject invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockDeleteObjectDone() bool {
	if m.DeleteObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteObjectMock.invocationsDone()
}

// MinimockDeleteObjectInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockDeleteObjectInspect() {
	for _, e := range m.DeleteObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteObjectCounter := mm_atomic.LoadUint64(&m.afterDeleteObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteObjectMock.defaultExpectation != nil && afterDeleteObjectCounter < 1 {
		if m.DeleteObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteObject at\n%s", m.DeleteObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteObject at\n%s with params: %#v", m.DeleteObjectMock.defaultExpectation.expectationOrigins.origin, *m.DeleteObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteObject != nil && afterDeleteObjectCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.DeleteObject at\n%s", m.funcDeleteObjectOrigin)
	}

	if !m.DeleteObjectMock.invocationsDone() && afterDeleteObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.DeleteObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteObjectMock.expectedInvocations), m.DeleteObjectMock.expectedInvocationsOrigin, afterDeleteObjectCounter)
	}
}

type mArtifactPublicServiceServerMockGetChunk struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetChunkExpectation
	expectations       []*ArtifactPublicServiceServerMockGetChunkExpectation

	callArgs []*ArtifactPublicServiceServerMockGetChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetChunkExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetChunk
type ArtifactPublicServiceServerMockGetChunkExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetChunkParams
	paramPtrs          *ArtifactPublicServiceServerMockGetChunkParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetChunkExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetChunkResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetChunkParams contains parameters of the ArtifactPublicServiceServer.GetChunk
type ArtifactPublicServiceServerMockGetChunkParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetChunkRequest
}

// ArtifactPublicServiceServerMockGetChunkParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetChunk
type ArtifactPublicServiceServerMockGetChunkParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetChunkRequest
}

// ArtifactPublicServiceServerMockGetChunkResults contains results of the ArtifactPublicServiceServer.GetChunk
type ArtifactPublicServiceServerMockGetChunkResults struct {
	gp2 *mm_artifactv1alpha.GetChunkResponse
	err error
}

// ArtifactPublicServiceServerMockGetChunkOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetChunk
type ArtifactPublicServiceServerMockGetChunkExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) Optional() *mArtifactPublicServiceServerMockGetChunk {
	mmGetChunk.optional = true
	return mmGetChunk
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetChunk
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetChunkRequest) *mArtifactPublicServiceServerMockGetChunk {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceServerMockGetChunkExpectation{}
	}

	if mmGetChunk.defaultExpectation.paramPtrs != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by ExpectParams functions")
	}

	mmGetChunk.defaultExpectation.params = &ArtifactPublicServiceServerMockGetChunkParams{ctx, gp1}
	mmGetChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChunk.expectations {
		if minimock.Equal(e.params, mmGetChunk.defaultExpectation.params) {
			mmGetChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunk.defaultExpectation.params)
		}
	}

	return mmGetChunk
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetChunk
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetChunk {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceServerMockGetChunkExpectation{}
	}

	if mmGetChunk.defaultExpectation.params != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by Expect")
	}

	if mmGetChunk.defaultExpectation.paramPtrs == nil {
		mmGetChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetChunkParamPtrs{}
	}
	mmGetChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChunk
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetChunk
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetChunkRequest) *mArtifactPublicServiceServerMockGetChunk {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceServerMockGetChunkExpectation{}
	}

	if mmGetChunk.defaultExpectation.params != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by Expect")
	}

	if mmGetChunk.defaultExpectation.paramPtrs == nil {
		mmGetChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetChunkParamPtrs{}
	}
	mmGetChunk.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetChunk.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetChunk
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetChunk
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetChunkRequest)) *mArtifactPublicServiceServerMockGetChunk {
	if mmGetChunk.mock.inspectFuncGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetChunk")
	}

	mmGetChunk.mock.inspectFuncGetChunk = f

	return mmGetChunk
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetChunk
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) Return(gp2 *mm_artifactv1alpha.GetChunkResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceServerMockGetChunkExpectation{mock: mmGetChunk.mock}
	}
	mmGetChunk.defaultExpectation.results = &ArtifactPublicServiceServerMockGetChunkResults{gp2, err}
	mmGetChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChunk.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetChunk method
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetChunkRequest) (gp2 *mm_artifactv1alpha.GetChunkResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetChunk.defaultExpectation != nil {
		mmGetChunk.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetChunk method")
	}

	if len(mmGetChunk.expectations) > 0 {
		mmGetChunk.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetChunk method")
	}

	mmGetChunk.mock.funcGetChunk = f
	mmGetChunk.mock.funcGetChunkOrigin = minimock.CallerInfo(1)
	return mmGetChunk.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetChunk which will trigger the result defined by the following
// Then helper
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetChunkRequest) *ArtifactPublicServiceServerMockGetChunkExpectation {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetChunk mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetChunkExpectation{
		mock:               mmGetChunk.mock,
		params:             &ArtifactPublicServiceServerMockGetChunkParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChunk.expectations = append(mmGetChunk.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetChunk return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetChunkExpectation) Then(gp2 *mm_artifactv1alpha.GetChunkResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetChunkResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetChunk should be invoked
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) Times(n uint64) *mArtifactPublicServiceServerMockGetChunk {
	if n == 0 {
		mmGetChunk.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunk.expectedInvocations, n)
	mmGetChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChunk
}

func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) invocationsDone() bool {
	if len(mmGetChunk.expectations) == 0 && mmGetChunk.defaultExpectation == nil && mmGetChunk.mock.funcGetChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunk.mock.afterGetChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunk implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetChunk *ArtifactPublicServiceServerMock) GetChunk(ctx context.Context, gp1 *mm_artifactv1alpha.GetChunkRequest) (gp2 *mm_artifactv1alpha.GetChunkResponse, err error) {
	mm_atomic.AddUint64(&mmGetChunk.beforeGetChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunk.afterGetChunkCounter, 1)

	mmGetChunk.t.Helper()

	if mmGetChunk.inspectFuncGetChunk != nil {
		mmGetChunk.inspectFuncGetChunk(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetChunkParams{ctx, gp1}

	// Record call args
	mmGetChunk.GetChunkMock.mutex.Lock()
	mmGetChunk.GetChunkMock.callArgs = append(mmGetChunk.GetChunkMock.callArgs, &mm_params)
	mmGetChunk.GetChunkMock.mutex.Unlock()

	for _, e := range mmGetChunk.GetChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetChunk.GetChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunk.GetChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunk.GetChunkMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunk.GetChunkMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetChunkParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunk.t.Errorf("ArtifactPublicServiceServerMock.GetChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunk.GetChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetChunk.t.Errorf("ArtifactPublicServiceServerMock.GetChunk got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunk.GetChunkMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunk.t.Errorf("ArtifactPublicServiceServerMock.GetChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChunk.GetChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunk.GetChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunk.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetChunk")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetChunk.funcGetChunk != nil {
		return mmGetChunk.funcGetChunk(ctx, gp1)
	}
	mmGetChunk.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetChunk. %v %v", ctx, gp1)
	return
}

// GetChunkAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetChunk invocations
func (mmGetChunk *ArtifactPublicServiceServerMock) GetChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunk.afterGetChunkCounter)
}

// GetChunkBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetChunk invocations
func (mmGetChunk *ArtifactPublicServiceServerMock) GetChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunk.beforeGetChunkCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunk *mArtifactPublicServiceServerMockGetChunk) Calls() []*ArtifactPublicServiceServerMockGetChunkParams {
	mmGetChunk.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetChunkParams, len(mmGetChunk.callArgs))
	copy(argCopy, mmGetChunk.callArgs)

	mmGetChunk.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunkDone returns true if the count of the GetChunk invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetChunkDone() bool {
	if m.GetChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunkMock.invocationsDone()
}

// MinimockGetChunkInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetChunkInspect() {
	for _, e := range m.GetChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChunkCounter := mm_atomic.LoadUint64(&m.afterGetChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunkMock.defaultExpectation != nil && afterGetChunkCounter < 1 {
		if m.GetChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetChunk at\n%s", m.GetChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetChunk at\n%s with params: %#v", m.GetChunkMock.defaultExpectation.expectationOrigins.origin, *m.GetChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunk != nil && afterGetChunkCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetChunk at\n%s", m.funcGetChunkOrigin)
	}

	if !m.GetChunkMock.invocationsDone() && afterGetChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunkMock.expectedInvocations), m.GetChunkMock.expectedInvocationsOrigin, afterGetChunkCounter)
	}
}

type mArtifactPublicServiceServerMockGetFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetFileExpectation
	expectations       []*ArtifactPublicServiceServerMockGetFileExpectation

	callArgs []*ArtifactPublicServiceServerMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetFile
type ArtifactPublicServiceServerMockGetFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetFileParams
	paramPtrs          *ArtifactPublicServiceServerMockGetFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetFileParams contains parameters of the ArtifactPublicServiceServer.GetFile
type ArtifactPublicServiceServerMockGetFileParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetFileRequest
}

// ArtifactPublicServiceServerMockGetFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetFile
type ArtifactPublicServiceServerMockGetFileParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetFileRequest
}

// ArtifactPublicServiceServerMockGetFileResults contains results of the ArtifactPublicServiceServer.GetFile
type ArtifactPublicServiceServerMockGetFileResults struct {
	gp2 *mm_artifactv1alpha.GetFileResponse
	err error
}

// ArtifactPublicServiceServerMockGetFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetFile
type ArtifactPublicServiceServerMockGetFileExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) Optional() *mArtifactPublicServiceServerMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetFile
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileRequest) *mArtifactPublicServiceServerMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceServerMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &ArtifactPublicServiceServerMockGetFileParams{ctx, gp1}
	mmGetFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetFile
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceServerMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetFile
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetFileRequest) *mArtifactPublicServiceServerMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceServerMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetFile.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetFile
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileRequest)) *mArtifactPublicServiceServerMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetFile
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) Return(gp2 *mm_artifactv1alpha.GetFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceServerMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &ArtifactPublicServiceServerMockGetFileResults{gp2, err}
	mmGetFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetFile method
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileRequest) (gp2 *mm_artifactv1alpha.GetFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	mmGetFile.mock.funcGetFileOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileRequest) *ArtifactPublicServiceServerMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetFileExpectation{
		mock:               mmGetFile.mock,
		params:             &ArtifactPublicServiceServerMockGetFileParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetFileExpectation) Then(gp2 *mm_artifactv1alpha.GetFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetFileResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetFile should be invoked
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) Times(n uint64) *mArtifactPublicServiceServerMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	mmGetFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFile
}

func (mmGetFile *mArtifactPublicServiceServerMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetFile *ArtifactPublicServiceServerMock) GetFile(ctx context.Context, gp1 *mm_artifactv1alpha.GetFileRequest) (gp2 *mm_artifactv1alpha.GetFileResponse, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	mmGetFile.t.Helper()

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetFileParams{ctx, gp1}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetFileParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("ArtifactPublicServiceServerMock.GetFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetFile.t.Errorf("ArtifactPublicServiceServerMock.GetFile got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("ArtifactPublicServiceServerMock.GetFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetFile")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, gp1)
	}
	mmGetFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetFile. %v %v", ctx, gp1)
	return
}

// GetFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetFile invocations
func (mmGetFile *ArtifactPublicServiceServerMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetFile invocations
func (mmGetFile *ArtifactPublicServiceServerMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mArtifactPublicServiceServerMockGetFile) Calls() []*ArtifactPublicServiceServerMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFile at\n%s", m.GetFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFile at\n%s with params: %#v", m.GetFileMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetFile at\n%s", m.funcGetFileOrigin)
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), m.GetFileMock.expectedInvocationsOrigin, afterGetFileCounter)
	}
}

type mArtifactPublicServiceServerMockGetKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceServerMockGetKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetKnowledgeBase
type ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceServerMockGetKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetKnowledgeBaseParams contains parameters of the ArtifactPublicServiceServer.GetKnowledgeBase
type ArtifactPublicServiceServerMockGetKnowledgeBaseParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockGetKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetKnowledgeBase
type ArtifactPublicServiceServerMockGetKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockGetKnowledgeBaseResults contains results of the ArtifactPublicServiceServer.GetKnowledgeBase
type ArtifactPublicServiceServerMockGetKnowledgeBaseResults struct {
	gp2 *mm_artifactv1alpha.GetKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceServerMockGetKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetKnowledgeBase
type ArtifactPublicServiceServerMockGetKnowledgeBaseExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) Optional() *mArtifactPublicServiceServerMockGetKnowledgeBase {
	mmGetKnowledgeBase.optional = true
	return mmGetKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest) *mArtifactPublicServiceServerMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceServerMockGetKnowledgeBaseParams{ctx, gp1}
	mmGetKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBase.defaultExpectation.params) {
			mmGetKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.params != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by Expect")
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetKnowledgeBaseParamPtrs{}
	}
	mmGetKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBase
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest) *mArtifactPublicServiceServerMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.params != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by Expect")
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetKnowledgeBaseParamPtrs{}
	}
	mmGetKnowledgeBase.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetKnowledgeBase.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest)) *mArtifactPublicServiceServerMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetKnowledgeBase")
	}

	mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase = f

	return mmGetKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) Return(gp2 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation{mock: mmGetKnowledgeBase.mock}
	}
	mmGetKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceServerMockGetKnowledgeBaseResults{gp2, err}
	mmGetKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetKnowledgeBase method
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest) (gp2 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetKnowledgeBase.defaultExpectation != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetKnowledgeBase method")
	}

	if len(mmGetKnowledgeBase.expectations) > 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetKnowledgeBase method")
	}

	mmGetKnowledgeBase.mock.funcGetKnowledgeBase = f
	mmGetKnowledgeBase.mock.funcGetKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest) *ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation{
		mock:               mmGetKnowledgeBase.mock,
		params:             &ArtifactPublicServiceServerMockGetKnowledgeBaseParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBase.expectations = append(mmGetKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetKnowledgeBaseExpectation) Then(gp2 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetKnowledgeBaseResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetKnowledgeBase should be invoked
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) Times(n uint64) *mArtifactPublicServiceServerMockGetKnowledgeBase {
	if n == 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBase.expectedInvocations, n)
	mmGetKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBase
}

func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) invocationsDone() bool {
	if len(mmGetKnowledgeBase.expectations) == 0 && mmGetKnowledgeBase.defaultExpectation == nil && mmGetKnowledgeBase.mock.funcGetKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.mock.afterGetKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetKnowledgeBase *ArtifactPublicServiceServerMock) GetKnowledgeBase(ctx context.Context, gp1 *mm_artifactv1alpha.GetKnowledgeBaseRequest) (gp2 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter, 1)

	mmGetKnowledgeBase.t.Helper()

	if mmGetKnowledgeBase.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.inspectFuncGetKnowledgeBase(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetKnowledgeBaseParams{ctx, gp1}

	// Record call args
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Lock()
	mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs = append(mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs, &mm_params)
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBase.GetKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetKnowledgeBaseParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.GetKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.GetKnowledgeBase got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.GetKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetKnowledgeBase")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetKnowledgeBase.funcGetKnowledgeBase != nil {
		return mmGetKnowledgeBase.funcGetKnowledgeBase(ctx, gp1)
	}
	mmGetKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetKnowledgeBase. %v %v", ctx, gp1)
	return
}

// GetKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *ArtifactPublicServiceServerMock) GetKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter)
}

// GetKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *ArtifactPublicServiceServerMock) GetKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBase *mArtifactPublicServiceServerMockGetKnowledgeBase) Calls() []*ArtifactPublicServiceServerMockGetKnowledgeBaseParams {
	mmGetKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetKnowledgeBaseParams, len(mmGetKnowledgeBase.callArgs))
	copy(argCopy, mmGetKnowledgeBase.callArgs)

	mmGetKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseDone returns true if the count of the GetKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetKnowledgeBaseDone() bool {
	if m.GetKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseMock.invocationsDone()
}

// MinimockGetKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetKnowledgeBaseInspect() {
	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseMock.defaultExpectation != nil && afterGetKnowledgeBaseCounter < 1 {
		if m.GetKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetKnowledgeBase at\n%s", m.GetKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetKnowledgeBase at\n%s with params: %#v", m.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBase != nil && afterGetKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetKnowledgeBase at\n%s", m.funcGetKnowledgeBaseOrigin)
	}

	if !m.GetKnowledgeBaseMock.invocationsDone() && afterGetKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseMock.expectedInvocations), m.GetKnowledgeBaseMock.expectedInvocationsOrigin, afterGetKnowledgeBaseCounter)
	}
}

type mArtifactPublicServiceServerMockGetObject struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetObjectExpectation
	expectations       []*ArtifactPublicServiceServerMockGetObjectExpectation

	callArgs []*ArtifactPublicServiceServerMockGetObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetObjectExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetObject
type ArtifactPublicServiceServerMockGetObjectExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetObjectParams
	paramPtrs          *ArtifactPublicServiceServerMockGetObjectParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetObjectExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetObjectResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetObjectParams contains parameters of the ArtifactPublicServiceServer.GetObject
type ArtifactPublicServiceServerMockGetObjectParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetObjectRequest
}

// ArtifactPublicServiceServerMockGetObjectParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetObject
type ArtifactPublicServiceServerMockGetObjectParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetObjectRequest
}

// ArtifactPublicServiceServerMockGetObjectResults contains results of the ArtifactPublicServiceServer.GetObject
type ArtifactPublicServiceServerMockGetObjectResults struct {
	gp2 *mm_artifactv1alpha.GetObjectResponse
	err error
}

// ArtifactPublicServiceServerMockGetObjectOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetObject
type ArtifactPublicServiceServerMockGetObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) Optional() *mArtifactPublicServiceServerMockGetObject {
	mmGetObject.optional = true
	return mmGetObject
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetObject
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectRequest) *mArtifactPublicServiceServerMockGetObject {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectExpectation{}
	}

	if mmGetObject.defaultExpectation.paramPtrs != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by ExpectParams functions")
	}

	mmGetObject.defaultExpectation.params = &ArtifactPublicServiceServerMockGetObjectParams{ctx, gp1}
	mmGetObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObject.expectations {
		if minimock.Equal(e.params, mmGetObject.defaultExpectation.params) {
			mmGetObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObject.defaultExpectation.params)
		}
	}

	return mmGetObject
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetObject
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetObject {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectExpectation{}
	}

	if mmGetObject.defaultExpectation.params != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by Expect")
	}

	if mmGetObject.defaultExpectation.paramPtrs == nil {
		mmGetObject.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectParamPtrs{}
	}
	mmGetObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObject
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetObject
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetObjectRequest) *mArtifactPublicServiceServerMockGetObject {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectExpectation{}
	}

	if mmGetObject.defaultExpectation.params != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by Expect")
	}

	if mmGetObject.defaultExpectation.paramPtrs == nil {
		mmGetObject.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectParamPtrs{}
	}
	mmGetObject.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetObject.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetObject
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetObject
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectRequest)) *mArtifactPublicServiceServerMockGetObject {
	if mmGetObject.mock.inspectFuncGetObject != nil {
		mmGetObject.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetObject")
	}

	mmGetObject.mock.inspectFuncGetObject = f

	return mmGetObject
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetObject
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) Return(gp2 *mm_artifactv1alpha.GetObjectResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by Set")
	}

	if mmGetObject.defaultExpectation == nil {
		mmGetObject.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectExpectation{mock: mmGetObject.mock}
	}
	mmGetObject.defaultExpectation.results = &ArtifactPublicServiceServerMockGetObjectResults{gp2, err}
	mmGetObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObject.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetObject method
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectRequest) (gp2 *mm_artifactv1alpha.GetObjectResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetObject.defaultExpectation != nil {
		mmGetObject.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetObject method")
	}

	if len(mmGetObject.expectations) > 0 {
		mmGetObject.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetObject method")
	}

	mmGetObject.mock.funcGetObject = f
	mmGetObject.mock.funcGetObjectOrigin = minimock.CallerInfo(1)
	return mmGetObject.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetObject which will trigger the result defined by the following
// Then helper
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectRequest) *ArtifactPublicServiceServerMockGetObjectExpectation {
	if mmGetObject.mock.funcGetObject != nil {
		mmGetObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObject mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetObjectExpectation{
		mock:               mmGetObject.mock,
		params:             &ArtifactPublicServiceServerMockGetObjectParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObject.expectations = append(mmGetObject.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetObject return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetObjectExpectation) Then(gp2 *mm_artifactv1alpha.GetObjectResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetObjectResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetObject should be invoked
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) Times(n uint64) *mArtifactPublicServiceServerMockGetObject {
	if n == 0 {
		mmGetObject.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObject.expectedInvocations, n)
	mmGetObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObject
}

func (mmGetObject *mArtifactPublicServiceServerMockGetObject) invocationsDone() bool {
	if len(mmGetObject.expectations) == 0 && mmGetObject.defaultExpectation == nil && mmGetObject.mock.funcGetObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObject.mock.afterGetObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObject implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetObject *ArtifactPublicServiceServerMock) GetObject(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectRequest) (gp2 *mm_artifactv1alpha.GetObjectResponse, err error) {
	mm_atomic.AddUint64(&mmGetObject.beforeGetObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObject.afterGetObjectCounter, 1)

	mmGetObject.t.Helper()

	if mmGetObject.inspectFuncGetObject != nil {
		mmGetObject.inspectFuncGetObject(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetObjectParams{ctx, gp1}

	// Record call args
	mmGetObject.GetObjectMock.mutex.Lock()
	mmGetObject.GetObjectMock.callArgs = append(mmGetObject.GetObjectMock.callArgs, &mm_params)
	mmGetObject.GetObjectMock.mutex.Unlock()

	for _, e := range mmGetObject.GetObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetObject.GetObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObject.GetObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObject.GetObjectMock.defaultExpectation.params
		mm_want_ptrs := mmGetObject.GetObjectMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetObjectParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObject.t.Errorf("ArtifactPublicServiceServerMock.GetObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObject.GetObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetObject.t.Errorf("ArtifactPublicServiceServerMock.GetObject got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObject.GetObjectMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObject.t.Errorf("ArtifactPublicServiceServerMock.GetObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObject.GetObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObject.GetObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObject.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetObject")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetObject.funcGetObject != nil {
		return mmGetObject.funcGetObject(ctx, gp1)
	}
	mmGetObject.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetObject. %v %v", ctx, gp1)
	return
}

// GetObjectAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetObject invocations
func (mmGetObject *ArtifactPublicServiceServerMock) GetObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.afterGetObjectCounter)
}

// GetObjectBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetObject invocations
func (mmGetObject *ArtifactPublicServiceServerMock) GetObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObject.beforeGetObjectCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObject *mArtifactPublicServiceServerMockGetObject) Calls() []*ArtifactPublicServiceServerMockGetObjectParams {
	mmGetObject.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetObjectParams, len(mmGetObject.callArgs))
	copy(argCopy, mmGetObject.callArgs)

	mmGetObject.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDone returns true if the count of the GetObject invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectDone() bool {
	if m.GetObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectMock.invocationsDone()
}

// MinimockGetObjectInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectInspect() {
	for _, e := range m.GetObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectCounter := mm_atomic.LoadUint64(&m.afterGetObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectMock.defaultExpectation != nil && afterGetObjectCounter < 1 {
		if m.GetObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObject at\n%s", m.GetObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObject at\n%s with params: %#v", m.GetObjectMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObject != nil && afterGetObjectCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObject at\n%s", m.funcGetObjectOrigin)
	}

	if !m.GetObjectMock.invocationsDone() && afterGetObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectMock.expectedInvocations), m.GetObjectMock.expectedInvocationsOrigin, afterGetObjectCounter)
	}
}

type mArtifactPublicServiceServerMockGetObjectDownloadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation
	expectations       []*ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation

	callArgs []*ArtifactPublicServiceServerMockGetObjectDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetObjectDownloadURLParams
	paramPtrs          *ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetObjectDownloadURLExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetObjectDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLParams contains parameters of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetObjectDownloadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLResults contains results of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLResults struct {
	gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse
	err error
}

// ArtifactPublicServiceServerMockGetObjectDownloadURLOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetObjectDownloadURL
type ArtifactPublicServiceServerMockGetObjectDownloadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Optional() *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	mmGetObjectDownloadURL.optional = true
	return mmGetObjectDownloadURL
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectDownloadURL.defaultExpectation.params = &ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1}
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectDownloadURL.defaultExpectation.params) {
			mmGetObjectDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest)) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetObjectDownloadURL")
	}

	mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL = f

	return mmGetObjectDownloadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Return(gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{mock: mmGetObjectDownloadURL.mock}
	}
	mmGetObjectDownloadURL.defaultExpectation.results = &ArtifactPublicServiceServerMockGetObjectDownloadURLResults{gp2, err}
	mmGetObjectDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetObjectDownloadURL method
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetObjectDownloadURL.defaultExpectation != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetObjectDownloadURL method")
	}

	if len(mmGetObjectDownloadURL.expectations) > 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetObjectDownloadURL method")
	}

	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL = f
	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetObjectDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) *ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectDownloadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation{
		mock:               mmGetObjectDownloadURL.mock,
		params:             &ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetObjectDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectDownloadURL.expectations = append(mmGetObjectDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetObjectDownloadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetObjectDownloadURLExpectation) Then(gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetObjectDownloadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetObjectDownloadURL should be invoked
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Times(n uint64) *mArtifactPublicServiceServerMockGetObjectDownloadURL {
	if n == 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetObjectDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectDownloadURL.expectedInvocations, n)
	mmGetObjectDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL
}

func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) invocationsDone() bool {
	if len(mmGetObjectDownloadURL.expectations) == 0 && mmGetObjectDownloadURL.defaultExpectation == nil && mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.mock.afterGetObjectDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectDownloadURL implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetObjectDownloadURL *ArtifactPublicServiceServerMock) GetObjectDownloadURL(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectDownloadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter, 1)

	mmGetObjectDownloadURL.t.Helper()

	if mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1}

	// Record call args
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Lock()
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs = append(mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs, &mm_params)
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectDownloadURL.GetObjectDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetObjectDownloadURLParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectDownloadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectDownloadURL.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetObjectDownloadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetObjectDownloadURL.funcGetObjectDownloadURL != nil {
		return mmGetObjectDownloadURL.funcGetObjectDownloadURL(ctx, gp1)
	}
	mmGetObjectDownloadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL. %v %v", ctx, gp1)
	return
}

// GetObjectDownloadURLAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceServerMock) GetObjectDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter)
}

// GetObjectDownloadURLBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceServerMock) GetObjectDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetObjectDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectDownloadURL *mArtifactPublicServiceServerMockGetObjectDownloadURL) Calls() []*ArtifactPublicServiceServerMockGetObjectDownloadURLParams {
	mmGetObjectDownloadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetObjectDownloadURLParams, len(mmGetObjectDownloadURL.callArgs))
	copy(argCopy, mmGetObjectDownloadURL.callArgs)

	mmGetObjectDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDownloadURLDone returns true if the count of the GetObjectDownloadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectDownloadURLDone() bool {
	if m.GetObjectDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectDownloadURLMock.invocationsDone()
}

// MinimockGetObjectDownloadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectDownloadURLInspect() {
	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectDownloadURLMock.defaultExpectation != nil && afterGetObjectDownloadURLCounter < 1 {
		if m.GetObjectDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s", m.GetObjectDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s with params: %#v", m.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectDownloadURL != nil && afterGetObjectDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s", m.funcGetObjectDownloadURLOrigin)
	}

	if !m.GetObjectDownloadURLMock.invocationsDone() && afterGetObjectDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetObjectDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectDownloadURLMock.expectedInvocations), m.GetObjectDownloadURLMock.expectedInvocationsOrigin, afterGetObjectDownloadURLCounter)
	}
}

type mArtifactPublicServiceServerMockGetObjectUploadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockGetObjectUploadURLExpectation
	expectations       []*ArtifactPublicServiceServerMockGetObjectUploadURLExpectation

	callArgs []*ArtifactPublicServiceServerMockGetObjectUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockGetObjectUploadURLExpectation specifies expectation struct of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockGetObjectUploadURLParams
	paramPtrs          *ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockGetObjectUploadURLExpectationOrigins
	results            *ArtifactPublicServiceServerMockGetObjectUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockGetObjectUploadURLParams contains parameters of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLParams struct {
	ctx context.Context
	gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs struct {
	ctx *context.Context
	gp1 **mm_artifactv1alpha.GetObjectUploadURLRequest
}

// ArtifactPublicServiceServerMockGetObjectUploadURLResults contains results of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLResults struct {
	gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse
	err error
}

// ArtifactPublicServiceServerMockGetObjectUploadURLOrigins contains origins of expectations of the ArtifactPublicServiceServer.GetObjectUploadURL
type ArtifactPublicServiceServerMockGetObjectUploadURLExpectationOrigins struct {
	origin    string
	originCtx string
	originGp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Optional() *mArtifactPublicServiceServerMockGetObjectUploadURL {
	mmGetObjectUploadURL.optional = true
	return mmGetObjectUploadURL
}

// Expect sets up expected params for ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Expect(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectUploadURL.defaultExpectation.params = &ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1}
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectUploadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectUploadURL.defaultExpectation.params) {
			mmGetObjectUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectUploadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// ExpectGp1Param2 sets up expected param gp1 for ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) ExpectGp1Param2(gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.gp1 = &gp1
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originGp1 = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Inspect(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest)) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.GetObjectUploadURL")
	}

	mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL = f

	return mmGetObjectUploadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Return(gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceServerMock {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{mock: mmGetObjectUploadURL.mock}
	}
	mmGetObjectUploadURL.defaultExpectation.results = &ArtifactPublicServiceServerMockGetObjectUploadURLResults{gp2, err}
	mmGetObjectUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.GetObjectUploadURL method
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Set(f func(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmGetObjectUploadURL.defaultExpectation != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.GetObjectUploadURL method")
	}

	if len(mmGetObjectUploadURL.expectations) > 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.GetObjectUploadURL method")
	}

	mmGetObjectUploadURL.mock.funcGetObjectUploadURL = f
	mmGetObjectUploadURL.mock.funcGetObjectUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// When sets expectation for the ArtifactPublicServiceServer.GetObjectUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) When(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) *ArtifactPublicServiceServerMockGetObjectUploadURLExpectation {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceServerMock.GetObjectUploadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockGetObjectUploadURLExpectation{
		mock:               mmGetObjectUploadURL.mock,
		params:             &ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1},
		expectationOrigins: ArtifactPublicServiceServerMockGetObjectUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectUploadURL.expectations = append(mmGetObjectUploadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.GetObjectUploadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockGetObjectUploadURLExpectation) Then(gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockGetObjectUploadURLResults{gp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.GetObjectUploadURL should be invoked
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Times(n uint64) *mArtifactPublicServiceServerMockGetObjectUploadURL {
	if n == 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.GetObjectUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectUploadURL.expectedInvocations, n)
	mmGetObjectUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL
}

func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) invocationsDone() bool {
	if len(mmGetObjectUploadURL.expectations) == 0 && mmGetObjectUploadURL.defaultExpectation == nil && mmGetObjectUploadURL.mock.funcGetObjectUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.mock.afterGetObjectUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectUploadURL implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmGetObjectUploadURL *ArtifactPublicServiceServerMock) GetObjectUploadURL(ctx context.Context, gp1 *mm_artifactv1alpha.GetObjectUploadURLRequest) (gp2 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter, 1)

	mmGetObjectUploadURL.t.Helper()

	if mmGetObjectUploadURL.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.inspectFuncGetObjectUploadURL(ctx, gp1)
	}

	mm_params := ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1}

	// Record call args
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Lock()
	mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs = append(mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs, &mm_params)
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectUploadURL.GetObjectUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockGetObjectUploadURLParams{ctx, gp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.gp1 != nil && !minimock.Equal(*mm_want_ptrs.gp1, mm_got.gp1) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectUploadURL got unexpected parameter gp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originGp1, *mm_want_ptrs.gp1, mm_got.gp1, minimock.Diff(*mm_want_ptrs.gp1, mm_got.gp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceServerMock.GetObjectUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectUploadURL.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.GetObjectUploadURL")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetObjectUploadURL.funcGetObjectUploadURL != nil {
		return mmGetObjectUploadURL.funcGetObjectUploadURL(ctx, gp1)
	}
	mmGetObjectUploadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.GetObjectUploadURL. %v %v", ctx, gp1)
	return
}

// GetObjectUploadURLAfterCounter returns a count of finished ArtifactPublicServiceServerMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceServerMock) GetObjectUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter)
}

// GetObjectUploadURLBeforeCounter returns a count of ArtifactPublicServiceServerMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceServerMock) GetObjectUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.GetObjectUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectUploadURL *mArtifactPublicServiceServerMockGetObjectUploadURL) Calls() []*ArtifactPublicServiceServerMockGetObjectUploadURLParams {
	mmGetObjectUploadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockGetObjectUploadURLParams, len(mmGetObjectUploadURL.callArgs))
	copy(argCopy, mmGetObjectUploadURL.callArgs)

	mmGetObjectUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectUploadURLDone returns true if the count of the GetObjectUploadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectUploadURLDone() bool {
	if m.GetObjectUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectUploadURLMock.invocationsDone()
}

// MinimockGetObjectUploadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockGetObjectUploadURLInspect() {
	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectUploadURLMock.defaultExpectation != nil && afterGetObjectUploadURLCounter < 1 {
		if m.GetObjectUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s", m.GetObjectUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s with params: %#v", m.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectUploadURL != nil && afterGetObjectUploadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s", m.funcGetObjectUploadURLOrigin)
	}

	if !m.GetObjectUploadURLMock.invocationsDone() && afterGetObjectUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.GetObjectUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectUploadURLMock.expectedInvocations), m.GetObjectUploadURLMock.expectedInvocationsOrigin, afterGetObjectUploadURLCounter)
	}
}

type mArtifactPublicServiceServerMockListChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListChunksExpectation
	expectations       []*ArtifactPublicServiceServerMockListChunksExpectation

	callArgs []*ArtifactPublicServiceServerMockListChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListChunksExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListChunksParams
	paramPtrs          *ArtifactPublicServiceServerMockListChunksParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListChunksExpectationOrigins
	results            *ArtifactPublicServiceServerMockListChunksResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListChunksParams contains parameters of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListChunksRequest
}

// ArtifactPublicServiceServerMockListChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListChunksRequest
}

// ArtifactPublicServiceServerMockListChunksResults contains results of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksResults struct {
	lp2 *mm_artifactv1alpha.ListChunksResponse
	err error
}

// ArtifactPublicServiceServerMockListChunksOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListChunks
type ArtifactPublicServiceServerMockListChunksExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Optional() *mArtifactPublicServiceServerMockListChunks {
	mmListChunks.optional = true
	return mmListChunks
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.paramPtrs != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by ExpectParams functions")
	}

	mmListChunks.defaultExpectation.params = &ArtifactPublicServiceServerMockListChunksParams{ctx, lp1}
	mmListChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListChunks.expectations {
		if minimock.Equal(e.params, mmListChunks.defaultExpectation.params) {
			mmListChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListChunks.defaultExpectation.params)
		}
	}

	return mmListChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmListChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListChunks
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListChunksRequest) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListChunks.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest)) *mArtifactPublicServiceServerMockListChunks {
	if mmListChunks.mock.inspectFuncListChunks != nil {
		mmListChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListChunks")
	}

	mmListChunks.mock.inspectFuncListChunks = f

	return mmListChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListChunks
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Return(lp2 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceServerMockListChunksExpectation{mock: mmListChunks.mock}
	}
	mmListChunks.defaultExpectation.results = &ArtifactPublicServiceServerMockListChunksResults{lp2, err}
	mmListChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListChunks method
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) (lp2 *mm_artifactv1alpha.ListChunksResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListChunks.defaultExpectation != nil {
		mmListChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListChunks method")
	}

	if len(mmListChunks.expectations) > 0 {
		mmListChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListChunks method")
	}

	mmListChunks.mock.funcListChunks = f
	mmListChunks.mock.funcListChunksOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListChunks which will trigger the result defined by the following
// Then helper
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) *ArtifactPublicServiceServerMockListChunksExpectation {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListChunksExpectation{
		mock:               mmListChunks.mock,
		params:             &ArtifactPublicServiceServerMockListChunksParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListChunks.expectations = append(mmListChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListChunksExpectation) Then(lp2 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListChunksResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListChunks should be invoked
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Times(n uint64) *mArtifactPublicServiceServerMockListChunks {
	if n == 0 {
		mmListChunks.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListChunks.expectedInvocations, n)
	mmListChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListChunks
}

func (mmListChunks *mArtifactPublicServiceServerMockListChunks) invocationsDone() bool {
	if len(mmListChunks.expectations) == 0 && mmListChunks.defaultExpectation == nil && mmListChunks.mock.funcListChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListChunks.mock.afterListChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListChunks implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListChunks *ArtifactPublicServiceServerMock) ListChunks(ctx context.Context, lp1 *mm_artifactv1alpha.ListChunksRequest) (lp2 *mm_artifactv1alpha.ListChunksResponse, err error) {
	mm_atomic.AddUint64(&mmListChunks.beforeListChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmListChunks.afterListChunksCounter, 1)

	mmListChunks.t.Helper()

	if mmListChunks.inspectFuncListChunks != nil {
		mmListChunks.inspectFuncListChunks(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListChunksParams{ctx, lp1}

	// Record call args
	mmListChunks.ListChunksMock.mutex.Lock()
	mmListChunks.ListChunksMock.callArgs = append(mmListChunks.ListChunksMock.callArgs, &mm_params)
	mmListChunks.ListChunksMock.mutex.Unlock()

	for _, e := range mmListChunks.ListChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListChunks.ListChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListChunks.ListChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmListChunks.ListChunksMock.defaultExpectation.params
		mm_want_ptrs := mmListChunks.ListChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListChunksParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListChunks.t.Errorf("ArtifactPublicServiceServerMock.ListChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListChunks.t.Errorf("ArtifactPublicServiceServerMock.ListChunks got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListChunks.t.Errorf("ArtifactPublicServiceServerMock.ListChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListChunks.ListChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmListChunks.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListChunks")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListChunks.funcListChunks != nil {
		return mmListChunks.funcListChunks(ctx, lp1)
	}
	mmListChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListChunks. %v %v", ctx, lp1)
	return
}

// ListChunksAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceServerMock) ListChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.afterListChunksCounter)
}

// ListChunksBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceServerMock) ListChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.beforeListChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListChunks *mArtifactPublicServiceServerMockListChunks) Calls() []*ArtifactPublicServiceServerMockListChunksParams {
	mmListChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListChunksParams, len(mmListChunks.callArgs))
	copy(argCopy, mmListChunks.callArgs)

	mmListChunks.mutex.RUnlock()

	return argCopy
}

// MinimockListChunksDone returns true if the count of the ListChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListChunksDone() bool {
	if m.ListChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListChunksMock.invocationsDone()
}

// MinimockListChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListChunksInspect() {
	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListChunksCounter := mm_atomic.LoadUint64(&m.afterListChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListChunksMock.defaultExpectation != nil && afterListChunksCounter < 1 {
		if m.ListChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s", m.ListChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s with params: %#v", m.ListChunksMock.defaultExpectation.expectationOrigins.origin, *m.ListChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListChunks != nil && afterListChunksCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListChunks at\n%s", m.funcListChunksOrigin)
	}

	if !m.ListChunksMock.invocationsDone() && afterListChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListChunksMock.expectedInvocations), m.ListChunksMock.expectedInvocationsOrigin, afterListChunksCounter)
	}
}

type mArtifactPublicServiceServerMockListFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListFilesExpectation
	expectations       []*ArtifactPublicServiceServerMockListFilesExpectation

	callArgs []*ArtifactPublicServiceServerMockListFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListFilesExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListFiles
type ArtifactPublicServiceServerMockListFilesExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListFilesParams
	paramPtrs          *ArtifactPublicServiceServerMockListFilesParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListFilesExpectationOrigins
	results            *ArtifactPublicServiceServerMockListFilesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListFilesParams contains parameters of the ArtifactPublicServiceServer.ListFiles
type ArtifactPublicServiceServerMockListFilesParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListFilesRequest
}

// ArtifactPublicServiceServerMockListFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListFiles
type ArtifactPublicServiceServerMockListFilesParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListFilesRequest
}

// ArtifactPublicServiceServerMockListFilesResults contains results of the ArtifactPublicServiceServer.ListFiles
type ArtifactPublicServiceServerMockListFilesResults struct {
	lp2 *mm_artifactv1alpha.ListFilesResponse
	err error
}

// ArtifactPublicServiceServerMockListFilesOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListFiles
type ArtifactPublicServiceServerMockListFilesExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) Optional() *mArtifactPublicServiceServerMockListFiles {
	mmListFiles.optional = true
	return mmListFiles
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListFiles
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListFilesRequest) *mArtifactPublicServiceServerMockListFiles {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceServerMockListFilesExpectation{}
	}

	if mmListFiles.defaultExpectation.paramPtrs != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by ExpectParams functions")
	}

	mmListFiles.defaultExpectation.params = &ArtifactPublicServiceServerMockListFilesParams{ctx, lp1}
	mmListFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListFiles.expectations {
		if minimock.Equal(e.params, mmListFiles.defaultExpectation.params) {
			mmListFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListFiles.defaultExpectation.params)
		}
	}

	return mmListFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListFiles
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListFiles {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceServerMockListFilesExpectation{}
	}

	if mmListFiles.defaultExpectation.params != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by Expect")
	}

	if mmListFiles.defaultExpectation.paramPtrs == nil {
		mmListFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListFilesParamPtrs{}
	}
	mmListFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListFiles
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListFiles
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListFilesRequest) *mArtifactPublicServiceServerMockListFiles {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceServerMockListFilesExpectation{}
	}

	if mmListFiles.defaultExpectation.params != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by Expect")
	}

	if mmListFiles.defaultExpectation.paramPtrs == nil {
		mmListFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListFilesParamPtrs{}
	}
	mmListFiles.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListFiles.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListFiles
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListFilesRequest)) *mArtifactPublicServiceServerMockListFiles {
	if mmListFiles.mock.inspectFuncListFiles != nil {
		mmListFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListFiles")
	}

	mmListFiles.mock.inspectFuncListFiles = f

	return mmListFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListFiles
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) Return(lp2 *mm_artifactv1alpha.ListFilesResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceServerMockListFilesExpectation{mock: mmListFiles.mock}
	}
	mmListFiles.defaultExpectation.results = &ArtifactPublicServiceServerMockListFilesResults{lp2, err}
	mmListFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListFiles method
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListFilesRequest) (lp2 *mm_artifactv1alpha.ListFilesResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListFiles.defaultExpectation != nil {
		mmListFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListFiles method")
	}

	if len(mmListFiles.expectations) > 0 {
		mmListFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListFiles method")
	}

	mmListFiles.mock.funcListFiles = f
	mmListFiles.mock.funcListFilesOrigin = minimock.CallerInfo(1)
	return mmListFiles.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListFiles which will trigger the result defined by the following
// Then helper
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListFilesRequest) *ArtifactPublicServiceServerMockListFilesExpectation {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListFilesExpectation{
		mock:               mmListFiles.mock,
		params:             &ArtifactPublicServiceServerMockListFilesParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListFiles.expectations = append(mmListFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListFilesExpectation) Then(lp2 *mm_artifactv1alpha.ListFilesResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListFilesResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListFiles should be invoked
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) Times(n uint64) *mArtifactPublicServiceServerMockListFiles {
	if n == 0 {
		mmListFiles.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListFiles.expectedInvocations, n)
	mmListFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListFiles
}

func (mmListFiles *mArtifactPublicServiceServerMockListFiles) invocationsDone() bool {
	if len(mmListFiles.expectations) == 0 && mmListFiles.defaultExpectation == nil && mmListFiles.mock.funcListFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListFiles.mock.afterListFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListFiles implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListFiles *ArtifactPublicServiceServerMock) ListFiles(ctx context.Context, lp1 *mm_artifactv1alpha.ListFilesRequest) (lp2 *mm_artifactv1alpha.ListFilesResponse, err error) {
	mm_atomic.AddUint64(&mmListFiles.beforeListFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListFiles.afterListFilesCounter, 1)

	mmListFiles.t.Helper()

	if mmListFiles.inspectFuncListFiles != nil {
		mmListFiles.inspectFuncListFiles(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListFilesParams{ctx, lp1}

	// Record call args
	mmListFiles.ListFilesMock.mutex.Lock()
	mmListFiles.ListFilesMock.callArgs = append(mmListFiles.ListFilesMock.callArgs, &mm_params)
	mmListFiles.ListFilesMock.mutex.Unlock()

	for _, e := range mmListFiles.ListFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListFiles.ListFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListFiles.ListFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListFiles.ListFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListFiles.ListFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListFilesParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListFiles.t.Errorf("ArtifactPublicServiceServerMock.ListFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFiles.ListFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListFiles.t.Errorf("ArtifactPublicServiceServerMock.ListFiles got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFiles.ListFilesMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListFiles.t.Errorf("ArtifactPublicServiceServerMock.ListFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListFiles.ListFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListFiles.ListFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListFiles.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListFiles")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListFiles.funcListFiles != nil {
		return mmListFiles.funcListFiles(ctx, lp1)
	}
	mmListFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListFiles. %v %v", ctx, lp1)
	return
}

// ListFilesAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListFiles invocations
func (mmListFiles *ArtifactPublicServiceServerMock) ListFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFiles.afterListFilesCounter)
}

// ListFilesBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListFiles invocations
func (mmListFiles *ArtifactPublicServiceServerMock) ListFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFiles.beforeListFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListFiles *mArtifactPublicServiceServerMockListFiles) Calls() []*ArtifactPublicServiceServerMockListFilesParams {
	mmListFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListFilesParams, len(mmListFiles.callArgs))
	copy(argCopy, mmListFiles.callArgs)

	mmListFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListFilesDone returns true if the count of the ListFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListFilesDone() bool {
	if m.ListFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListFilesMock.invocationsDone()
}

// MinimockListFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListFilesInspect() {
	for _, e := range m.ListFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListFilesCounter := mm_atomic.LoadUint64(&m.afterListFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListFilesMock.defaultExpectation != nil && afterListFilesCounter < 1 {
		if m.ListFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListFiles at\n%s", m.ListFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListFiles at\n%s with params: %#v", m.ListFilesMock.defaultExpectation.expectationOrigins.origin, *m.ListFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListFiles != nil && afterListFilesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListFiles at\n%s", m.funcListFilesOrigin)
	}

	if !m.ListFilesMock.invocationsDone() && afterListFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListFilesMock.expectedInvocations), m.ListFilesMock.expectedInvocationsOrigin, afterListFilesCounter)
	}
}

type mArtifactPublicServiceServerMockListKnowledgeBaseRuns struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation
	expectations       []*ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation

	callArgs []*ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListKnowledgeBaseRuns
type ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams
	paramPtrs          *ArtifactPublicServiceServerMockListKnowledgeBaseRunsParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectationOrigins
	results            *ArtifactPublicServiceServerMockListKnowledgeBaseRunsResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams contains parameters of the ArtifactPublicServiceServer.ListKnowledgeBaseRuns
type ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest
}

// ArtifactPublicServiceServerMockListKnowledgeBaseRunsParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListKnowledgeBaseRuns
type ArtifactPublicServiceServerMockListKnowledgeBaseRunsParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListKnowledgeBaseRunsRequest
}

// ArtifactPublicServiceServerMockListKnowledgeBaseRunsResults contains results of the ArtifactPublicServiceServer.ListKnowledgeBaseRuns
type ArtifactPublicServiceServerMockListKnowledgeBaseRunsResults struct {
	lp2 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse
	err error
}

// ArtifactPublicServiceServerMockListKnowledgeBaseRunsOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListKnowledgeBaseRuns
type ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) Optional() *mArtifactPublicServiceServerMockListKnowledgeBaseRuns {
	mmListKnowledgeBaseRuns.optional = true
	return mmListKnowledgeBaseRuns
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest) *mArtifactPublicServiceServerMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation{}
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseRuns.defaultExpectation.params = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams{ctx, lp1}
	mmListKnowledgeBaseRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBaseRuns.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseRuns.defaultExpectation.params) {
			mmListKnowledgeBaseRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseRuns.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseRuns
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation{}
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.params != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by Expect")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsParamPtrs{}
	}
	mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBaseRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBaseRuns
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest) *mArtifactPublicServiceServerMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation{}
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.params != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by Expect")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsParamPtrs{}
	}
	mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListKnowledgeBaseRuns.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListKnowledgeBaseRuns
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest)) *mArtifactPublicServiceServerMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.inspectFuncListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns")
	}

	mmListKnowledgeBaseRuns.mock.inspectFuncListKnowledgeBaseRuns = f

	return mmListKnowledgeBaseRuns
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) Return(lp2 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation{mock: mmListKnowledgeBaseRuns.mock}
	}
	mmListKnowledgeBaseRuns.defaultExpectation.results = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsResults{lp2, err}
	mmListKnowledgeBaseRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseRuns.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListKnowledgeBaseRuns method
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest) (lp2 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListKnowledgeBaseRuns.defaultExpectation != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListKnowledgeBaseRuns method")
	}

	if len(mmListKnowledgeBaseRuns.expectations) > 0 {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListKnowledgeBaseRuns method")
	}

	mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns = f
	mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRunsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseRuns.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListKnowledgeBaseRuns which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest) *ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation{
		mock:               mmListKnowledgeBaseRuns.mock,
		params:             &ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBaseRuns.expectations = append(mmListKnowledgeBaseRuns.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListKnowledgeBaseRuns return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListKnowledgeBaseRunsExpectation) Then(lp2 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListKnowledgeBaseRunsResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListKnowledgeBaseRuns should be invoked
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) Times(n uint64) *mArtifactPublicServiceServerMockListKnowledgeBaseRuns {
	if n == 0 {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseRuns.expectedInvocations, n)
	mmListKnowledgeBaseRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseRuns
}

func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) invocationsDone() bool {
	if len(mmListKnowledgeBaseRuns.expectations) == 0 && mmListKnowledgeBaseRuns.defaultExpectation == nil && mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.mock.afterListKnowledgeBaseRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseRuns implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListKnowledgeBaseRuns *ArtifactPublicServiceServerMock) ListKnowledgeBaseRuns(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest) (lp2 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseRuns.beforeListKnowledgeBaseRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseRuns.afterListKnowledgeBaseRunsCounter, 1)

	mmListKnowledgeBaseRuns.t.Helper()

	if mmListKnowledgeBaseRuns.inspectFuncListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.inspectFuncListKnowledgeBaseRuns(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams{ctx, lp1}

	// Record call args
	mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.mutex.Lock()
	mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.callArgs = append(mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.callArgs, &mm_params)
	mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseRuns.t.Errorf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListKnowledgeBaseRuns.t.Errorf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseRuns.t.Errorf("ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseRuns.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListKnowledgeBaseRuns.funcListKnowledgeBaseRuns != nil {
		return mmListKnowledgeBaseRuns.funcListKnowledgeBaseRuns(ctx, lp1)
	}
	mmListKnowledgeBaseRuns.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns. %v %v", ctx, lp1)
	return
}

// ListKnowledgeBaseRunsAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns invocations
func (mmListKnowledgeBaseRuns *ArtifactPublicServiceServerMock) ListKnowledgeBaseRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.afterListKnowledgeBaseRunsCounter)
}

// ListKnowledgeBaseRunsBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns invocations
func (mmListKnowledgeBaseRuns *ArtifactPublicServiceServerMock) ListKnowledgeBaseRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.beforeListKnowledgeBaseRunsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceServerMockListKnowledgeBaseRuns) Calls() []*ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams {
	mmListKnowledgeBaseRuns.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListKnowledgeBaseRunsParams, len(mmListKnowledgeBaseRuns.callArgs))
	copy(argCopy, mmListKnowledgeBaseRuns.callArgs)

	mmListKnowledgeBaseRuns.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseRunsDone returns true if the count of the ListKnowledgeBaseRuns invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListKnowledgeBaseRunsDone() bool {
	if m.ListKnowledgeBaseRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBaseRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseRunsMock.invocationsDone()
}

// MinimockListKnowledgeBaseRunsInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListKnowledgeBaseRunsInspect() {
	for _, e := range m.ListKnowledgeBaseRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBaseRunsCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseRunsMock.defaultExpectation != nil && afterListKnowledgeBaseRunsCounter < 1 {
		if m.ListKnowledgeBaseRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns at\n%s", m.ListKnowledgeBaseRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns at\n%s with params: %#v", m.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBaseRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseRuns != nil && afterListKnowledgeBaseRunsCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns at\n%s", m.funcListKnowledgeBaseRunsOrigin)
	}

	if !m.ListKnowledgeBaseRunsMock.invocationsDone() && afterListKnowledgeBaseRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListKnowledgeBaseRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseRunsMock.expectedInvocations), m.ListKnowledgeBaseRunsMock.expectedInvocationsOrigin, afterListKnowledgeBaseRunsCounter)
	}
}

type mArtifactPublicServiceServerMockListKnowledgeBases struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockListKnowledgeBasesExpectation
	expectations       []*ArtifactPublicServiceServerMockListKnowledgeBasesExpectation

	callArgs []*ArtifactPublicServiceServerMockListKnowledgeBasesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockListKnowledgeBasesExpectation specifies expectation struct of the ArtifactPublicServiceServer.ListKnowledgeBases
type ArtifactPublicServiceServerMockListKnowledgeBasesExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockListKnowledgeBasesParams
	paramPtrs          *ArtifactPublicServiceServerMockListKnowledgeBasesParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockListKnowledgeBasesExpectationOrigins
	results            *ArtifactPublicServiceServerMockListKnowledgeBasesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockListKnowledgeBasesParams contains parameters of the ArtifactPublicServiceServer.ListKnowledgeBases
type ArtifactPublicServiceServerMockListKnowledgeBasesParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest
}

// ArtifactPublicServiceServerMockListKnowledgeBasesParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ListKnowledgeBases
type ArtifactPublicServiceServerMockListKnowledgeBasesParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.ListKnowledgeBasesRequest
}

// ArtifactPublicServiceServerMockListKnowledgeBasesResults contains results of the ArtifactPublicServiceServer.ListKnowledgeBases
type ArtifactPublicServiceServerMockListKnowledgeBasesResults struct {
	lp2 *mm_artifactv1alpha.ListKnowledgeBasesResponse
	err error
}

// ArtifactPublicServiceServerMockListKnowledgeBasesOrigins contains origins of expectations of the ArtifactPublicServiceServer.ListKnowledgeBases
type ArtifactPublicServiceServerMockListKnowledgeBasesExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) Optional() *mArtifactPublicServiceServerMockListKnowledgeBases {
	mmListKnowledgeBases.optional = true
	return mmListKnowledgeBases
}

// Expect sets up expected params for ArtifactPublicServiceServer.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest) *mArtifactPublicServiceServerMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBases.defaultExpectation.params = &ArtifactPublicServiceServerMockListKnowledgeBasesParams{ctx, lp1}
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBases.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBases.defaultExpectation.params) {
			mmListKnowledgeBases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBases.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBases
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) ExpectLp1Param2(lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest) *mArtifactPublicServiceServerMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.lp1 = &lp1
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest)) *mArtifactPublicServiceServerMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ListKnowledgeBases")
	}

	mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases = f

	return mmListKnowledgeBases
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) Return(lp2 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error) *ArtifactPublicServiceServerMock {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceServerMockListKnowledgeBasesExpectation{mock: mmListKnowledgeBases.mock}
	}
	mmListKnowledgeBases.defaultExpectation.results = &ArtifactPublicServiceServerMockListKnowledgeBasesResults{lp2, err}
	mmListKnowledgeBases.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ListKnowledgeBases method
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest) (lp2 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmListKnowledgeBases.defaultExpectation != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ListKnowledgeBases method")
	}

	if len(mmListKnowledgeBases.expectations) > 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ListKnowledgeBases method")
	}

	mmListKnowledgeBases.mock.funcListKnowledgeBases = f
	mmListKnowledgeBases.mock.funcListKnowledgeBasesOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ListKnowledgeBases which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) When(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest) *ArtifactPublicServiceServerMockListKnowledgeBasesExpectation {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceServerMock.ListKnowledgeBases mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockListKnowledgeBasesExpectation{
		mock:               mmListKnowledgeBases.mock,
		params:             &ArtifactPublicServiceServerMockListKnowledgeBasesParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockListKnowledgeBasesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBases.expectations = append(mmListKnowledgeBases.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ListKnowledgeBases return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockListKnowledgeBasesExpectation) Then(lp2 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockListKnowledgeBasesResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ListKnowledgeBases should be invoked
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) Times(n uint64) *mArtifactPublicServiceServerMockListKnowledgeBases {
	if n == 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ListKnowledgeBases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBases.expectedInvocations, n)
	mmListKnowledgeBases.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases
}

func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) invocationsDone() bool {
	if len(mmListKnowledgeBases.expectations) == 0 && mmListKnowledgeBases.defaultExpectation == nil && mmListKnowledgeBases.mock.funcListKnowledgeBases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.mock.afterListKnowledgeBasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBases implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmListKnowledgeBases *ArtifactPublicServiceServerMock) ListKnowledgeBases(ctx context.Context, lp1 *mm_artifactv1alpha.ListKnowledgeBasesRequest) (lp2 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter, 1)

	mmListKnowledgeBases.t.Helper()

	if mmListKnowledgeBases.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.inspectFuncListKnowledgeBases(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockListKnowledgeBasesParams{ctx, lp1}

	// Record call args
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Lock()
	mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs = append(mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs, &mm_params)
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBases.ListKnowledgeBasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockListKnowledgeBasesParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBases.t.Errorf("ArtifactPublicServiceServerMock.ListKnowledgeBases got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmListKnowledgeBases.t.Errorf("ArtifactPublicServiceServerMock.ListKnowledgeBases got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBases.t.Errorf("ArtifactPublicServiceServerMock.ListKnowledgeBases got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBases.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ListKnowledgeBases")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListKnowledgeBases.funcListKnowledgeBases != nil {
		return mmListKnowledgeBases.funcListKnowledgeBases(ctx, lp1)
	}
	mmListKnowledgeBases.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ListKnowledgeBases. %v %v", ctx, lp1)
	return
}

// ListKnowledgeBasesAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *ArtifactPublicServiceServerMock) ListKnowledgeBasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter)
}

// ListKnowledgeBasesBeforeCounter returns a count of ArtifactPublicServiceServerMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *ArtifactPublicServiceServerMock) ListKnowledgeBasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ListKnowledgeBases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBases *mArtifactPublicServiceServerMockListKnowledgeBases) Calls() []*ArtifactPublicServiceServerMockListKnowledgeBasesParams {
	mmListKnowledgeBases.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockListKnowledgeBasesParams, len(mmListKnowledgeBases.callArgs))
	copy(argCopy, mmListKnowledgeBases.callArgs)

	mmListKnowledgeBases.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesDone returns true if the count of the ListKnowledgeBases invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockListKnowledgeBasesDone() bool {
	if m.ListKnowledgeBasesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesMock.invocationsDone()
}

// MinimockListKnowledgeBasesInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockListKnowledgeBasesInspect() {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBases at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesMock.defaultExpectation != nil && afterListKnowledgeBasesCounter < 1 {
		if m.ListKnowledgeBasesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBases at\n%s", m.ListKnowledgeBasesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBases at\n%s with params: %#v", m.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBases != nil && afterListKnowledgeBasesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ListKnowledgeBases at\n%s", m.funcListKnowledgeBasesOrigin)
	}

	if !m.ListKnowledgeBasesMock.invocationsDone() && afterListKnowledgeBasesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ListKnowledgeBases at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesMock.expectedInvocations), m.ListKnowledgeBasesMock.expectedInvocationsOrigin, afterListKnowledgeBasesCounter)
	}
}

type mArtifactPublicServiceServerMockLiveness struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockLivenessExpectation
	expectations       []*ArtifactPublicServiceServerMockLivenessExpectation

	callArgs []*ArtifactPublicServiceServerMockLivenessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockLivenessExpectation specifies expectation struct of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockLivenessParams
	paramPtrs          *ArtifactPublicServiceServerMockLivenessParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockLivenessExpectationOrigins
	results            *ArtifactPublicServiceServerMockLivenessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockLivenessParams contains parameters of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessParams struct {
	ctx context.Context
	lp1 *mm_artifactv1alpha.LivenessRequest
}

// ArtifactPublicServiceServerMockLivenessParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessParamPtrs struct {
	ctx *context.Context
	lp1 **mm_artifactv1alpha.LivenessRequest
}

// ArtifactPublicServiceServerMockLivenessResults contains results of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessResults struct {
	lp2 *mm_artifactv1alpha.LivenessResponse
	err error
}

// ArtifactPublicServiceServerMockLivenessOrigins contains origins of expectations of the ArtifactPublicServiceServer.Liveness
type ArtifactPublicServiceServerMockLivenessExpectationOrigins struct {
	origin    string
	originCtx string
	originLp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Optional() *mArtifactPublicServiceServerMockLiveness {
	mmLiveness.optional = true
	return mmLiveness
}

// Expect sets up expected params for ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Expect(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.paramPtrs != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by ExpectParams functions")
	}

	mmLiveness.defaultExpectation.params = &ArtifactPublicServiceServerMockLivenessParams{ctx, lp1}
	mmLiveness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLiveness.expectations {
		if minimock.Equal(e.params, mmLiveness.defaultExpectation.params) {
			mmLiveness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLiveness.defaultExpectation.params)
		}
	}

	return mmLiveness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.ctx = &ctx
	mmLiveness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectLp1Param2 sets up expected param lp1 for ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) ExpectLp1Param2(lp1 *mm_artifactv1alpha.LivenessRequest) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.lp1 = &lp1
	mmLiveness.defaultExpectation.expectationOrigins.originLp1 = minimock.CallerInfo(1)

	return mmLiveness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Inspect(f func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest)) *mArtifactPublicServiceServerMockLiveness {
	if mmLiveness.mock.inspectFuncLiveness != nil {
		mmLiveness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.Liveness")
	}

	mmLiveness.mock.inspectFuncLiveness = f

	return mmLiveness
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.Liveness
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Return(lp2 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceServerMock {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceServerMockLivenessExpectation{mock: mmLiveness.mock}
	}
	mmLiveness.defaultExpectation.results = &ArtifactPublicServiceServerMockLivenessResults{lp2, err}
	mmLiveness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.Liveness method
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Set(f func(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) (lp2 *mm_artifactv1alpha.LivenessResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmLiveness.defaultExpectation != nil {
		mmLiveness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.Liveness method")
	}

	if len(mmLiveness.expectations) > 0 {
		mmLiveness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.Liveness method")
	}

	mmLiveness.mock.funcLiveness = f
	mmLiveness.mock.funcLivenessOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// When sets expectation for the ArtifactPublicServiceServer.Liveness which will trigger the result defined by the following
// Then helper
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) When(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) *ArtifactPublicServiceServerMockLivenessExpectation {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Liveness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockLivenessExpectation{
		mock:               mmLiveness.mock,
		params:             &ArtifactPublicServiceServerMockLivenessParams{ctx, lp1},
		expectationOrigins: ArtifactPublicServiceServerMockLivenessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLiveness.expectations = append(mmLiveness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.Liveness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockLivenessExpectation) Then(lp2 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockLivenessResults{lp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.Liveness should be invoked
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Times(n uint64) *mArtifactPublicServiceServerMockLiveness {
	if n == 0 {
		mmLiveness.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.Liveness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLiveness.expectedInvocations, n)
	mmLiveness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLiveness
}

func (mmLiveness *mArtifactPublicServiceServerMockLiveness) invocationsDone() bool {
	if len(mmLiveness.expectations) == 0 && mmLiveness.defaultExpectation == nil && mmLiveness.mock.funcLiveness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLiveness.mock.afterLivenessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLiveness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Liveness implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmLiveness *ArtifactPublicServiceServerMock) Liveness(ctx context.Context, lp1 *mm_artifactv1alpha.LivenessRequest) (lp2 *mm_artifactv1alpha.LivenessResponse, err error) {
	mm_atomic.AddUint64(&mmLiveness.beforeLivenessCounter, 1)
	defer mm_atomic.AddUint64(&mmLiveness.afterLivenessCounter, 1)

	mmLiveness.t.Helper()

	if mmLiveness.inspectFuncLiveness != nil {
		mmLiveness.inspectFuncLiveness(ctx, lp1)
	}

	mm_params := ArtifactPublicServiceServerMockLivenessParams{ctx, lp1}

	// Record call args
	mmLiveness.LivenessMock.mutex.Lock()
	mmLiveness.LivenessMock.callArgs = append(mmLiveness.LivenessMock.callArgs, &mm_params)
	mmLiveness.LivenessMock.mutex.Unlock()

	for _, e := range mmLiveness.LivenessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmLiveness.LivenessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLiveness.LivenessMock.defaultExpectation.Counter, 1)
		mm_want := mmLiveness.LivenessMock.defaultExpectation.params
		mm_want_ptrs := mmLiveness.LivenessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockLivenessParams{ctx, lp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLiveness.t.Errorf("ArtifactPublicServiceServerMock.Liveness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.lp1 != nil && !minimock.Equal(*mm_want_ptrs.lp1, mm_got.lp1) {
				mmLiveness.t.Errorf("ArtifactPublicServiceServerMock.Liveness got unexpected parameter lp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originLp1, *mm_want_ptrs.lp1, mm_got.lp1, minimock.Diff(*mm_want_ptrs.lp1, mm_got.lp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLiveness.t.Errorf("ArtifactPublicServiceServerMock.Liveness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLiveness.LivenessMock.defaultExpectation.results
		if mm_results == nil {
			mmLiveness.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.Liveness")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmLiveness.funcLiveness != nil {
		return mmLiveness.funcLiveness(ctx, lp1)
	}
	mmLiveness.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.Liveness. %v %v", ctx, lp1)
	return
}

// LivenessAfterCounter returns a count of finished ArtifactPublicServiceServerMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceServerMock) LivenessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.afterLivenessCounter)
}

// LivenessBeforeCounter returns a count of ArtifactPublicServiceServerMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceServerMock) LivenessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.beforeLivenessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.Liveness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLiveness *mArtifactPublicServiceServerMockLiveness) Calls() []*ArtifactPublicServiceServerMockLivenessParams {
	mmLiveness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockLivenessParams, len(mmLiveness.callArgs))
	copy(argCopy, mmLiveness.callArgs)

	mmLiveness.mutex.RUnlock()

	return argCopy
}

// MinimockLivenessDone returns true if the count of the Liveness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockLivenessDone() bool {
	if m.LivenessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LivenessMock.invocationsDone()
}

// MinimockLivenessInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockLivenessInspect() {
	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLivenessCounter := mm_atomic.LoadUint64(&m.afterLivenessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LivenessMock.defaultExpectation != nil && afterLivenessCounter < 1 {
		if m.LivenessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s", m.LivenessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s with params: %#v", m.LivenessMock.defaultExpectation.expectationOrigins.origin, *m.LivenessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLiveness != nil && afterLivenessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Liveness at\n%s", m.funcLivenessOrigin)
	}

	if !m.LivenessMock.invocationsDone() && afterLivenessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.Liveness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LivenessMock.expectedInvocations), m.LivenessMock.expectedInvocationsOrigin, afterLivenessCounter)
	}
}

type mArtifactPublicServiceServerMockReadiness struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockReadinessExpectation
	expectations       []*ArtifactPublicServiceServerMockReadinessExpectation

	callArgs []*ArtifactPublicServiceServerMockReadinessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockReadinessExpectation specifies expectation struct of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockReadinessParams
	paramPtrs          *ArtifactPublicServiceServerMockReadinessParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockReadinessExpectationOrigins
	results            *ArtifactPublicServiceServerMockReadinessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockReadinessParams contains parameters of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessParams struct {
	ctx context.Context
	rp1 *mm_artifactv1alpha.ReadinessRequest
}

// ArtifactPublicServiceServerMockReadinessParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessParamPtrs struct {
	ctx *context.Context
	rp1 **mm_artifactv1alpha.ReadinessRequest
}

// ArtifactPublicServiceServerMockReadinessResults contains results of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessResults struct {
	rp2 *mm_artifactv1alpha.ReadinessResponse
	err error
}

// ArtifactPublicServiceServerMockReadinessOrigins contains origins of expectations of the ArtifactPublicServiceServer.Readiness
type ArtifactPublicServiceServerMockReadinessExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Optional() *mArtifactPublicServiceServerMockReadiness {
	mmReadiness.optional = true
	return mmReadiness
}

// Expect sets up expected params for ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Expect(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.paramPtrs != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by ExpectParams functions")
	}

	mmReadiness.defaultExpectation.params = &ArtifactPublicServiceServerMockReadinessParams{ctx, rp1}
	mmReadiness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadiness.expectations {
		if minimock.Equal(e.params, mmReadiness.defaultExpectation.params) {
			mmReadiness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadiness.defaultExpectation.params)
		}
	}

	return mmReadiness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadiness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectRp1Param2 sets up expected param rp1 for ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) ExpectRp1Param2(rp1 *mm_artifactv1alpha.ReadinessRequest) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.rp1 = &rp1
	mmReadiness.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmReadiness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Inspect(f func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest)) *mArtifactPublicServiceServerMockReadiness {
	if mmReadiness.mock.inspectFuncReadiness != nil {
		mmReadiness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.Readiness")
	}

	mmReadiness.mock.inspectFuncReadiness = f

	return mmReadiness
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.Readiness
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Return(rp2 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceServerMock {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceServerMockReadinessExpectation{mock: mmReadiness.mock}
	}
	mmReadiness.defaultExpectation.results = &ArtifactPublicServiceServerMockReadinessResults{rp2, err}
	mmReadiness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.Readiness method
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Set(f func(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) (rp2 *mm_artifactv1alpha.ReadinessResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmReadiness.defaultExpectation != nil {
		mmReadiness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.Readiness method")
	}

	if len(mmReadiness.expectations) > 0 {
		mmReadiness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.Readiness method")
	}

	mmReadiness.mock.funcReadiness = f
	mmReadiness.mock.funcReadinessOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// When sets expectation for the ArtifactPublicServiceServer.Readiness which will trigger the result defined by the following
// Then helper
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) When(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) *ArtifactPublicServiceServerMockReadinessExpectation {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceServerMock.Readiness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockReadinessExpectation{
		mock:               mmReadiness.mock,
		params:             &ArtifactPublicServiceServerMockReadinessParams{ctx, rp1},
		expectationOrigins: ArtifactPublicServiceServerMockReadinessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadiness.expectations = append(mmReadiness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.Readiness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockReadinessExpectation) Then(rp2 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockReadinessResults{rp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.Readiness should be invoked
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Times(n uint64) *mArtifactPublicServiceServerMockReadiness {
	if n == 0 {
		mmReadiness.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.Readiness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadiness.expectedInvocations, n)
	mmReadiness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadiness
}

func (mmReadiness *mArtifactPublicServiceServerMockReadiness) invocationsDone() bool {
	if len(mmReadiness.expectations) == 0 && mmReadiness.defaultExpectation == nil && mmReadiness.mock.funcReadiness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadiness.mock.afterReadinessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadiness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Readiness implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmReadiness *ArtifactPublicServiceServerMock) Readiness(ctx context.Context, rp1 *mm_artifactv1alpha.ReadinessRequest) (rp2 *mm_artifactv1alpha.ReadinessResponse, err error) {
	mm_atomic.AddUint64(&mmReadiness.beforeReadinessCounter, 1)
	defer mm_atomic.AddUint64(&mmReadiness.afterReadinessCounter, 1)

	mmReadiness.t.Helper()

	if mmReadiness.inspectFuncReadiness != nil {
		mmReadiness.inspectFuncReadiness(ctx, rp1)
	}

	mm_params := ArtifactPublicServiceServerMockReadinessParams{ctx, rp1}

	// Record call args
	mmReadiness.ReadinessMock.mutex.Lock()
	mmReadiness.ReadinessMock.callArgs = append(mmReadiness.ReadinessMock.callArgs, &mm_params)
	mmReadiness.ReadinessMock.mutex.Unlock()

	for _, e := range mmReadiness.ReadinessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmReadiness.ReadinessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadiness.ReadinessMock.defaultExpectation.Counter, 1)
		mm_want := mmReadiness.ReadinessMock.defaultExpectation.params
		mm_want_ptrs := mmReadiness.ReadinessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockReadinessParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadiness.t.Errorf("ArtifactPublicServiceServerMock.Readiness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmReadiness.t.Errorf("ArtifactPublicServiceServerMock.Readiness got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadiness.t.Errorf("ArtifactPublicServiceServerMock.Readiness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadiness.ReadinessMock.defaultExpectation.results
		if mm_results == nil {
			mmReadiness.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.Readiness")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmReadiness.funcReadiness != nil {
		return mmReadiness.funcReadiness(ctx, rp1)
	}
	mmReadiness.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.Readiness. %v %v", ctx, rp1)
	return
}

// ReadinessAfterCounter returns a count of finished ArtifactPublicServiceServerMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceServerMock) ReadinessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.afterReadinessCounter)
}

// ReadinessBeforeCounter returns a count of ArtifactPublicServiceServerMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceServerMock) ReadinessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.beforeReadinessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.Readiness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadiness *mArtifactPublicServiceServerMockReadiness) Calls() []*ArtifactPublicServiceServerMockReadinessParams {
	mmReadiness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockReadinessParams, len(mmReadiness.callArgs))
	copy(argCopy, mmReadiness.callArgs)

	mmReadiness.mutex.RUnlock()

	return argCopy
}

// MinimockReadinessDone returns true if the count of the Readiness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockReadinessDone() bool {
	if m.ReadinessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadinessMock.invocationsDone()
}

// MinimockReadinessInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockReadinessInspect() {
	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadinessCounter := mm_atomic.LoadUint64(&m.afterReadinessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadinessMock.defaultExpectation != nil && afterReadinessCounter < 1 {
		if m.ReadinessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s", m.ReadinessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s with params: %#v", m.ReadinessMock.defaultExpectation.expectationOrigins.origin, *m.ReadinessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadiness != nil && afterReadinessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.Readiness at\n%s", m.funcReadinessOrigin)
	}

	if !m.ReadinessMock.invocationsDone() && afterReadinessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.Readiness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadinessMock.expectedInvocations), m.ReadinessMock.expectedInvocationsOrigin, afterReadinessCounter)
	}
}

type mArtifactPublicServiceServerMockReprocessFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockReprocessFileExpectation
	expectations       []*ArtifactPublicServiceServerMockReprocessFileExpectation

	callArgs []*ArtifactPublicServiceServerMockReprocessFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockReprocessFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.ReprocessFile
type ArtifactPublicServiceServerMockReprocessFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockReprocessFileParams
	paramPtrs          *ArtifactPublicServiceServerMockReprocessFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockReprocessFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockReprocessFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockReprocessFileParams contains parameters of the ArtifactPublicServiceServer.ReprocessFile
type ArtifactPublicServiceServerMockReprocessFileParams struct {
	ctx context.Context
	rp1 *mm_artifactv1alpha.ReprocessFileRequest
}

// ArtifactPublicServiceServerMockReprocessFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.ReprocessFile
type ArtifactPublicServiceServerMockReprocessFileParamPtrs struct {
	ctx *context.Context
	rp1 **mm_artifactv1alpha.ReprocessFileRequest
}

// ArtifactPublicServiceServerMockReprocessFileResults contains results of the ArtifactPublicServiceServer.ReprocessFile
type ArtifactPublicServiceServerMockReprocessFileResults struct {
	rp2 *mm_artifactv1alpha.ReprocessFileResponse
	err error
}

// ArtifactPublicServiceServerMockReprocessFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.ReprocessFile
type ArtifactPublicServiceServerMockReprocessFileExpectationOrigins struct {
	origin    string
	originCtx string
	originRp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) Optional() *mArtifactPublicServiceServerMockReprocessFile {
	mmReprocessFile.optional = true
	return mmReprocessFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) Expect(ctx context.Context, rp1 *mm_artifactv1alpha.ReprocessFileRequest) *mArtifactPublicServiceServerMockReprocessFile {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceServerMockReprocessFileExpectation{}
	}

	if mmReprocessFile.defaultExpectation.paramPtrs != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by ExpectParams functions")
	}

	mmReprocessFile.defaultExpectation.params = &ArtifactPublicServiceServerMockReprocessFileParams{ctx, rp1}
	mmReprocessFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReprocessFile.expectations {
		if minimock.Equal(e.params, mmReprocessFile.defaultExpectation.params) {
			mmReprocessFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReprocessFile.defaultExpectation.params)
		}
	}

	return mmReprocessFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockReprocessFile {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceServerMockReprocessFileExpectation{}
	}

	if mmReprocessFile.defaultExpectation.params != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by Expect")
	}

	if mmReprocessFile.defaultExpectation.paramPtrs == nil {
		mmReprocessFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockReprocessFileParamPtrs{}
	}
	mmReprocessFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmReprocessFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReprocessFile
}

// ExpectRp1Param2 sets up expected param rp1 for ArtifactPublicServiceServer.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) ExpectRp1Param2(rp1 *mm_artifactv1alpha.ReprocessFileRequest) *mArtifactPublicServiceServerMockReprocessFile {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceServerMockReprocessFileExpectation{}
	}

	if mmReprocessFile.defaultExpectation.params != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by Expect")
	}

	if mmReprocessFile.defaultExpectation.paramPtrs == nil {
		mmReprocessFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockReprocessFileParamPtrs{}
	}
	mmReprocessFile.defaultExpectation.paramPtrs.rp1 = &rp1
	mmReprocessFile.defaultExpectation.expectationOrigins.originRp1 = minimock.CallerInfo(1)

	return mmReprocessFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) Inspect(f func(ctx context.Context, rp1 *mm_artifactv1alpha.ReprocessFileRequest)) *mArtifactPublicServiceServerMockReprocessFile {
	if mmReprocessFile.mock.inspectFuncReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.ReprocessFile")
	}

	mmReprocessFile.mock.inspectFuncReprocessFile = f

	return mmReprocessFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) Return(rp2 *mm_artifactv1alpha.ReprocessFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceServerMockReprocessFileExpectation{mock: mmReprocessFile.mock}
	}
	mmReprocessFile.defaultExpectation.results = &ArtifactPublicServiceServerMockReprocessFileResults{rp2, err}
	mmReprocessFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReprocessFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.ReprocessFile method
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) Set(f func(ctx context.Context, rp1 *mm_artifactv1alpha.ReprocessFileRequest) (rp2 *mm_artifactv1alpha.ReprocessFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmReprocessFile.defaultExpectation != nil {
		mmReprocessFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.ReprocessFile method")
	}

	if len(mmReprocessFile.expectations) > 0 {
		mmReprocessFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.ReprocessFile method")
	}

	mmReprocessFile.mock.funcReprocessFile = f
	mmReprocessFile.mock.funcReprocessFileOrigin = minimock.CallerInfo(1)
	return mmReprocessFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.ReprocessFile which will trigger the result defined by the following
// Then helper
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) When(ctx context.Context, rp1 *mm_artifactv1alpha.ReprocessFileRequest) *ArtifactPublicServiceServerMockReprocessFileExpectation {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.ReprocessFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockReprocessFileExpectation{
		mock:               mmReprocessFile.mock,
		params:             &ArtifactPublicServiceServerMockReprocessFileParams{ctx, rp1},
		expectationOrigins: ArtifactPublicServiceServerMockReprocessFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReprocessFile.expectations = append(mmReprocessFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.ReprocessFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockReprocessFileExpectation) Then(rp2 *mm_artifactv1alpha.ReprocessFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockReprocessFileResults{rp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.ReprocessFile should be invoked
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) Times(n uint64) *mArtifactPublicServiceServerMockReprocessFile {
	if n == 0 {
		mmReprocessFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.ReprocessFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReprocessFile.expectedInvocations, n)
	mmReprocessFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReprocessFile
}

func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) invocationsDone() bool {
	if len(mmReprocessFile.expectations) == 0 && mmReprocessFile.defaultExpectation == nil && mmReprocessFile.mock.funcReprocessFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReprocessFile.mock.afterReprocessFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReprocessFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReprocessFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmReprocessFile *ArtifactPublicServiceServerMock) ReprocessFile(ctx context.Context, rp1 *mm_artifactv1alpha.ReprocessFileRequest) (rp2 *mm_artifactv1alpha.ReprocessFileResponse, err error) {
	mm_atomic.AddUint64(&mmReprocessFile.beforeReprocessFileCounter, 1)
	defer mm_atomic.AddUint64(&mmReprocessFile.afterReprocessFileCounter, 1)

	mmReprocessFile.t.Helper()

	if mmReprocessFile.inspectFuncReprocessFile != nil {
		mmReprocessFile.inspectFuncReprocessFile(ctx, rp1)
	}

	mm_params := ArtifactPublicServiceServerMockReprocessFileParams{ctx, rp1}

	// Record call args
	mmReprocessFile.ReprocessFileMock.mutex.Lock()
	mmReprocessFile.ReprocessFileMock.callArgs = append(mmReprocessFile.ReprocessFileMock.callArgs, &mm_params)
	mmReprocessFile.ReprocessFileMock.mutex.Unlock()

	for _, e := range mmReprocessFile.ReprocessFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp2, e.results.err
		}
	}

	if mmReprocessFile.ReprocessFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReprocessFile.ReprocessFileMock.defaultExpectation.Counter, 1)
		mm_want := mmReprocessFile.ReprocessFileMock.defaultExpectation.params
		mm_want_ptrs := mmReprocessFile.ReprocessFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockReprocessFileParams{ctx, rp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReprocessFile.t.Errorf("ArtifactPublicServiceServerMock.ReprocessFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReprocessFile.ReprocessFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.rp1 != nil && !minimock.Equal(*mm_want_ptrs.rp1, mm_got.rp1) {
				mmReprocessFile.t.Errorf("ArtifactPublicServiceServerMock.ReprocessFile got unexpected parameter rp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReprocessFile.ReprocessFileMock.defaultExpectation.expectationOrigins.originRp1, *mm_want_ptrs.rp1, mm_got.rp1, minimock.Diff(*mm_want_ptrs.rp1, mm_got.rp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReprocessFile.t.Errorf("ArtifactPublicServiceServerMock.ReprocessFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReprocessFile.ReprocessFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReprocessFile.ReprocessFileMock.defaultExpectation.results
		if mm_results == nil {
			mmReprocessFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.ReprocessFile")
		}
		return (*mm_results).rp2, (*mm_results).err
	}
	if mmReprocessFile.funcReprocessFile != nil {
		return mmReprocessFile.funcReprocessFile(ctx, rp1)
	}
	mmReprocessFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.ReprocessFile. %v %v", ctx, rp1)
	return
}

// ReprocessFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.ReprocessFile invocations
func (mmReprocessFile *ArtifactPublicServiceServerMock) ReprocessFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReprocessFile.afterReprocessFileCounter)
}

// ReprocessFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.ReprocessFile invocations
func (mmReprocessFile *ArtifactPublicServiceServerMock) ReprocessFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReprocessFile.beforeReprocessFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.ReprocessFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReprocessFile *mArtifactPublicServiceServerMockReprocessFile) Calls() []*ArtifactPublicServiceServerMockReprocessFileParams {
	mmReprocessFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockReprocessFileParams, len(mmReprocessFile.callArgs))
	copy(argCopy, mmReprocessFile.callArgs)

	mmReprocessFile.mutex.RUnlock()

	return argCopy
}

// MinimockReprocessFileDone returns true if the count of the ReprocessFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockReprocessFileDone() bool {
	if m.ReprocessFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReprocessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReprocessFileMock.invocationsDone()
}

// MinimockReprocessFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockReprocessFileInspect() {
	for _, e := range m.ReprocessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ReprocessFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReprocessFileCounter := mm_atomic.LoadUint64(&m.afterReprocessFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReprocessFileMock.defaultExpectation != nil && afterReprocessFileCounter < 1 {
		if m.ReprocessFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ReprocessFile at\n%s", m.ReprocessFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ReprocessFile at\n%s with params: %#v", m.ReprocessFileMock.defaultExpectation.expectationOrigins.origin, *m.ReprocessFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReprocessFile != nil && afterReprocessFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.ReprocessFile at\n%s", m.funcReprocessFileOrigin)
	}

	if !m.ReprocessFileMock.invocationsDone() && afterReprocessFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.ReprocessFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReprocessFileMock.expectedInvocations), m.ReprocessFileMock.expectedInvocationsOrigin, afterReprocessFileCounter)
	}
}

type mArtifactPublicServiceServerMockSearchChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockSearchChunksExpectation
	expectations       []*ArtifactPublicServiceServerMockSearchChunksExpectation

	callArgs []*ArtifactPublicServiceServerMockSearchChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockSearchChunksExpectation specifies expectation struct of the ArtifactPublicServiceServer.SearchChunks
type ArtifactPublicServiceServerMockSearchChunksExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockSearchChunksParams
	paramPtrs          *ArtifactPublicServiceServerMockSearchChunksParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockSearchChunksExpectationOrigins
	results            *ArtifactPublicServiceServerMockSearchChunksResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockSearchChunksParams contains parameters of the ArtifactPublicServiceServer.SearchChunks
type ArtifactPublicServiceServerMockSearchChunksParams struct {
	ctx context.Context
	sp1 *mm_artifactv1alpha.SearchChunksRequest
}

// ArtifactPublicServiceServerMockSearchChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.SearchChunks
type ArtifactPublicServiceServerMockSearchChunksParamPtrs struct {
	ctx *context.Context
	sp1 **mm_artifactv1alpha.SearchChunksRequest
}

// ArtifactPublicServiceServerMockSearchChunksResults contains results of the ArtifactPublicServiceServer.SearchChunks
type ArtifactPublicServiceServerMockSearchChunksResults struct {
	sp2 *mm_artifactv1alpha.SearchChunksResponse
	err error
}

// ArtifactPublicServiceServerMockSearchChunksOrigins contains origins of expectations of the ArtifactPublicServiceServer.SearchChunks
type ArtifactPublicServiceServerMockSearchChunksExpectationOrigins struct {
	origin    string
	originCtx string
	originSp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) Optional() *mArtifactPublicServiceServerMockSearchChunks {
	mmSearchChunks.optional = true
	return mmSearchChunks
}

// Expect sets up expected params for ArtifactPublicServiceServer.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) Expect(ctx context.Context, sp1 *mm_artifactv1alpha.SearchChunksRequest) *mArtifactPublicServiceServerMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceServerMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.paramPtrs != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by ExpectParams functions")
	}

	mmSearchChunks.defaultExpectation.params = &ArtifactPublicServiceServerMockSearchChunksParams{ctx, sp1}
	mmSearchChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchChunks.expectations {
		if minimock.Equal(e.params, mmSearchChunks.defaultExpectation.params) {
			mmSearchChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchChunks.defaultExpectation.params)
		}
	}

	return mmSearchChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceServerMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchChunks
}

// ExpectSp1Param2 sets up expected param sp1 for ArtifactPublicServiceServer.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) ExpectSp1Param2(sp1 *mm_artifactv1alpha.SearchChunksRequest) *mArtifactPublicServiceServerMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceServerMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.sp1 = &sp1
	mmSearchChunks.defaultExpectation.expectationOrigins.originSp1 = minimock.CallerInfo(1)

	return mmSearchChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) Inspect(f func(ctx context.Context, sp1 *mm_artifactv1alpha.SearchChunksRequest)) *mArtifactPublicServiceServerMockSearchChunks {
	if mmSearchChunks.mock.inspectFuncSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.SearchChunks")
	}

	mmSearchChunks.mock.inspectFuncSearchChunks = f

	return mmSearchChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) Return(sp2 *mm_artifactv1alpha.SearchChunksResponse, err error) *ArtifactPublicServiceServerMock {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceServerMockSearchChunksExpectation{mock: mmSearchChunks.mock}
	}
	mmSearchChunks.defaultExpectation.results = &ArtifactPublicServiceServerMockSearchChunksResults{sp2, err}
	mmSearchChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.SearchChunks method
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) Set(f func(ctx context.Context, sp1 *mm_artifactv1alpha.SearchChunksRequest) (sp2 *mm_artifactv1alpha.SearchChunksResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmSearchChunks.defaultExpectation != nil {
		mmSearchChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.SearchChunks method")
	}

	if len(mmSearchChunks.expectations) > 0 {
		mmSearchChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.SearchChunks method")
	}

	mmSearchChunks.mock.funcSearchChunks = f
	mmSearchChunks.mock.funcSearchChunksOrigin = minimock.CallerInfo(1)
	return mmSearchChunks.mock
}

// When sets expectation for the ArtifactPublicServiceServer.SearchChunks which will trigger the result defined by the following
// Then helper
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) When(ctx context.Context, sp1 *mm_artifactv1alpha.SearchChunksRequest) *ArtifactPublicServiceServerMockSearchChunksExpectation {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceServerMock.SearchChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockSearchChunksExpectation{
		mock:               mmSearchChunks.mock,
		params:             &ArtifactPublicServiceServerMockSearchChunksParams{ctx, sp1},
		expectationOrigins: ArtifactPublicServiceServerMockSearchChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchChunks.expectations = append(mmSearchChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.SearchChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockSearchChunksExpectation) Then(sp2 *mm_artifactv1alpha.SearchChunksResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockSearchChunksResults{sp2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.SearchChunks should be invoked
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) Times(n uint64) *mArtifactPublicServiceServerMockSearchChunks {
	if n == 0 {
		mmSearchChunks.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.SearchChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchChunks.expectedInvocations, n)
	mmSearchChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchChunks
}

func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) invocationsDone() bool {
	if len(mmSearchChunks.expectations) == 0 && mmSearchChunks.defaultExpectation == nil && mmSearchChunks.mock.funcSearchChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchChunks.mock.afterSearchChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchChunks implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmSearchChunks *ArtifactPublicServiceServerMock) SearchChunks(ctx context.Context, sp1 *mm_artifactv1alpha.SearchChunksRequest) (sp2 *mm_artifactv1alpha.SearchChunksResponse, err error) {
	mm_atomic.AddUint64(&mmSearchChunks.beforeSearchChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchChunks.afterSearchChunksCounter, 1)

	mmSearchChunks.t.Helper()

	if mmSearchChunks.inspectFuncSearchChunks != nil {
		mmSearchChunks.inspectFuncSearchChunks(ctx, sp1)
	}

	mm_params := ArtifactPublicServiceServerMockSearchChunksParams{ctx, sp1}

	// Record call args
	mmSearchChunks.SearchChunksMock.mutex.Lock()
	mmSearchChunks.SearchChunksMock.callArgs = append(mmSearchChunks.SearchChunksMock.callArgs, &mm_params)
	mmSearchChunks.SearchChunksMock.mutex.Unlock()

	for _, e := range mmSearchChunks.SearchChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp2, e.results.err
		}
	}

	if mmSearchChunks.SearchChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchChunks.SearchChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchChunks.SearchChunksMock.defaultExpectation.params
		mm_want_ptrs := mmSearchChunks.SearchChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockSearchChunksParams{ctx, sp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceServerMock.SearchChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sp1 != nil && !minimock.Equal(*mm_want_ptrs.sp1, mm_got.sp1) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceServerMock.SearchChunks got unexpected parameter sp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originSp1, *mm_want_ptrs.sp1, mm_got.sp1, minimock.Diff(*mm_want_ptrs.sp1, mm_got.sp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchChunks.t.Errorf("ArtifactPublicServiceServerMock.SearchChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchChunks.SearchChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchChunks.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.SearchChunks")
		}
		return (*mm_results).sp2, (*mm_results).err
	}
	if mmSearchChunks.funcSearchChunks != nil {
		return mmSearchChunks.funcSearchChunks(ctx, sp1)
	}
	mmSearchChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.SearchChunks. %v %v", ctx, sp1)
	return
}

// SearchChunksAfterCounter returns a count of finished ArtifactPublicServiceServerMock.SearchChunks invocations
func (mmSearchChunks *ArtifactPublicServiceServerMock) SearchChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchChunks.afterSearchChunksCounter)
}

// SearchChunksBeforeCounter returns a count of ArtifactPublicServiceServerMock.SearchChunks invocations
func (mmSearchChunks *ArtifactPublicServiceServerMock) SearchChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchChunks.beforeSearchChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.SearchChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchChunks *mArtifactPublicServiceServerMockSearchChunks) Calls() []*ArtifactPublicServiceServerMockSearchChunksParams {
	mmSearchChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockSearchChunksParams, len(mmSearchChunks.callArgs))
	copy(argCopy, mmSearchChunks.callArgs)

	mmSearchChunks.mutex.RUnlock()

	return argCopy
}

// MinimockSearchChunksDone returns true if the count of the SearchChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockSearchChunksDone() bool {
	if m.SearchChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchChunksMock.invocationsDone()
}

// MinimockSearchChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockSearchChunksInspect() {
	for _, e := range m.SearchChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SearchChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchChunksCounter := mm_atomic.LoadUint64(&m.afterSearchChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchChunksMock.defaultExpectation != nil && afterSearchChunksCounter < 1 {
		if m.SearchChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SearchChunks at\n%s", m.SearchChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SearchChunks at\n%s with params: %#v", m.SearchChunksMock.defaultExpectation.expectationOrigins.origin, *m.SearchChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchChunks != nil && afterSearchChunksCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.SearchChunks at\n%s", m.funcSearchChunksOrigin)
	}

	if !m.SearchChunksMock.invocationsDone() && afterSearchChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.SearchChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchChunksMock.expectedInvocations), m.SearchChunksMock.expectedInvocationsOrigin, afterSearchChunksCounter)
	}
}

type mArtifactPublicServiceServerMockUpdateChunk struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockUpdateChunkExpectation
	expectations       []*ArtifactPublicServiceServerMockUpdateChunkExpectation

	callArgs []*ArtifactPublicServiceServerMockUpdateChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockUpdateChunkExpectation specifies expectation struct of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockUpdateChunkParams
	paramPtrs          *ArtifactPublicServiceServerMockUpdateChunkParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockUpdateChunkExpectationOrigins
	results            *ArtifactPublicServiceServerMockUpdateChunkResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockUpdateChunkParams contains parameters of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkParams struct {
	ctx context.Context
	up1 *mm_artifactv1alpha.UpdateChunkRequest
}

// ArtifactPublicServiceServerMockUpdateChunkParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkParamPtrs struct {
	ctx *context.Context
	up1 **mm_artifactv1alpha.UpdateChunkRequest
}

// ArtifactPublicServiceServerMockUpdateChunkResults contains results of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkResults struct {
	up2 *mm_artifactv1alpha.UpdateChunkResponse
	err error
}

// ArtifactPublicServiceServerMockUpdateChunkOrigins contains origins of expectations of the ArtifactPublicServiceServer.UpdateChunk
type ArtifactPublicServiceServerMockUpdateChunkExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Optional() *mArtifactPublicServiceServerMockUpdateChunk {
	mmUpdateChunk.optional = true
	return mmUpdateChunk
}

// Expect sets up expected params for ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Expect(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by ExpectParams functions")
	}

	mmUpdateChunk.defaultExpectation.params = &ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1}
	mmUpdateChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateChunk.expectations {
		if minimock.Equal(e.params, mmUpdateChunk.defaultExpectation.params) {
			mmUpdateChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateChunk.defaultExpectation.params)
		}
	}

	return mmUpdateChunk
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// ExpectUp1Param2 sets up expected param up1 for ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) ExpectUp1Param2(up1 *mm_artifactv1alpha.UpdateChunkRequest) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateChunk.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Inspect(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest)) *mArtifactPublicServiceServerMockUpdateChunk {
	if mmUpdateChunk.mock.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.UpdateChunk")
	}

	mmUpdateChunk.mock.inspectFuncUpdateChunk = f

	return mmUpdateChunk
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Return(up2 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceServerMock {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceServerMockUpdateChunkExpectation{mock: mmUpdateChunk.mock}
	}
	mmUpdateChunk.defaultExpectation.results = &ArtifactPublicServiceServerMockUpdateChunkResults{up2, err}
	mmUpdateChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.UpdateChunk method
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Set(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) (up2 *mm_artifactv1alpha.UpdateChunkResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmUpdateChunk.defaultExpectation != nil {
		mmUpdateChunk.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.UpdateChunk method")
	}

	if len(mmUpdateChunk.expectations) > 0 {
		mmUpdateChunk.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.UpdateChunk method")
	}

	mmUpdateChunk.mock.funcUpdateChunk = f
	mmUpdateChunk.mock.funcUpdateChunkOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// When sets expectation for the ArtifactPublicServiceServer.UpdateChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) When(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) *ArtifactPublicServiceServerMockUpdateChunkExpectation {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateChunk mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockUpdateChunkExpectation{
		mock:               mmUpdateChunk.mock,
		params:             &ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1},
		expectationOrigins: ArtifactPublicServiceServerMockUpdateChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateChunk.expectations = append(mmUpdateChunk.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.UpdateChunk return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockUpdateChunkExpectation) Then(up2 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockUpdateChunkResults{up2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.UpdateChunk should be invoked
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Times(n uint64) *mArtifactPublicServiceServerMockUpdateChunk {
	if n == 0 {
		mmUpdateChunk.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.UpdateChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateChunk.expectedInvocations, n)
	mmUpdateChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk
}

func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) invocationsDone() bool {
	if len(mmUpdateChunk.expectations) == 0 && mmUpdateChunk.defaultExpectation == nil && mmUpdateChunk.mock.funcUpdateChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.mock.afterUpdateChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateChunk implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmUpdateChunk *ArtifactPublicServiceServerMock) UpdateChunk(ctx context.Context, up1 *mm_artifactv1alpha.UpdateChunkRequest) (up2 *mm_artifactv1alpha.UpdateChunkResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateChunk.beforeUpdateChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateChunk.afterUpdateChunkCounter, 1)

	mmUpdateChunk.t.Helper()

	if mmUpdateChunk.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.inspectFuncUpdateChunk(ctx, up1)
	}

	mm_params := ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1}

	// Record call args
	mmUpdateChunk.UpdateChunkMock.mutex.Lock()
	mmUpdateChunk.UpdateChunkMock.callArgs = append(mmUpdateChunk.UpdateChunkMock.callArgs, &mm_params)
	mmUpdateChunk.UpdateChunkMock.mutex.Unlock()

	for _, e := range mmUpdateChunk.UpdateChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateChunk.UpdateChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateChunk.UpdateChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateChunk.UpdateChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateChunk.UpdateChunkMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockUpdateChunkParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceServerMock.UpdateChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceServerMock.UpdateChunk got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateChunk.t.Errorf("ArtifactPublicServiceServerMock.UpdateChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateChunk.UpdateChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateChunk.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.UpdateChunk")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateChunk.funcUpdateChunk != nil {
		return mmUpdateChunk.funcUpdateChunk(ctx, up1)
	}
	mmUpdateChunk.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.UpdateChunk. %v %v", ctx, up1)
	return
}

// UpdateChunkAfterCounter returns a count of finished ArtifactPublicServiceServerMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceServerMock) UpdateChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.afterUpdateChunkCounter)
}

// UpdateChunkBeforeCounter returns a count of ArtifactPublicServiceServerMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceServerMock) UpdateChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.beforeUpdateChunkCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.UpdateChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateChunk *mArtifactPublicServiceServerMockUpdateChunk) Calls() []*ArtifactPublicServiceServerMockUpdateChunkParams {
	mmUpdateChunk.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockUpdateChunkParams, len(mmUpdateChunk.callArgs))
	copy(argCopy, mmUpdateChunk.callArgs)

	mmUpdateChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateChunkDone returns true if the count of the UpdateChunk invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockUpdateChunkDone() bool {
	if m.UpdateChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateChunkMock.invocationsDone()
}

// MinimockUpdateChunkInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockUpdateChunkInspect() {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateChunkMock.defaultExpectation != nil && afterUpdateChunkCounter < 1 {
		if m.UpdateChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s", m.UpdateChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s with params: %#v", m.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *m.UpdateChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateChunk != nil && afterUpdateChunkCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateChunk at\n%s", m.funcUpdateChunkOrigin)
	}

	if !m.UpdateChunkMock.invocationsDone() && afterUpdateChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.UpdateChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateChunkMock.expectedInvocations), m.UpdateChunkMock.expectedInvocationsOrigin, afterUpdateChunkCounter)
	}
}

type mArtifactPublicServiceServerMockUpdateFile struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockUpdateFileExpectation
	expectations       []*ArtifactPublicServiceServerMockUpdateFileExpectation

	callArgs []*ArtifactPublicServiceServerMockUpdateFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockUpdateFileExpectation specifies expectation struct of the ArtifactPublicServiceServer.UpdateFile
type ArtifactPublicServiceServerMockUpdateFileExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockUpdateFileParams
	paramPtrs          *ArtifactPublicServiceServerMockUpdateFileParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockUpdateFileExpectationOrigins
	results            *ArtifactPublicServiceServerMockUpdateFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockUpdateFileParams contains parameters of the ArtifactPublicServiceServer.UpdateFile
type ArtifactPublicServiceServerMockUpdateFileParams struct {
	ctx context.Context
	up1 *mm_artifactv1alpha.UpdateFileRequest
}

// ArtifactPublicServiceServerMockUpdateFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.UpdateFile
type ArtifactPublicServiceServerMockUpdateFileParamPtrs struct {
	ctx *context.Context
	up1 **mm_artifactv1alpha.UpdateFileRequest
}

// ArtifactPublicServiceServerMockUpdateFileResults contains results of the ArtifactPublicServiceServer.UpdateFile
type ArtifactPublicServiceServerMockUpdateFileResults struct {
	up2 *mm_artifactv1alpha.UpdateFileResponse
	err error
}

// ArtifactPublicServiceServerMockUpdateFileOrigins contains origins of expectations of the ArtifactPublicServiceServer.UpdateFile
type ArtifactPublicServiceServerMockUpdateFileExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) Optional() *mArtifactPublicServiceServerMockUpdateFile {
	mmUpdateFile.optional = true
	return mmUpdateFile
}

// Expect sets up expected params for ArtifactPublicServiceServer.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) Expect(ctx context.Context, up1 *mm_artifactv1alpha.UpdateFileRequest) *mArtifactPublicServiceServerMockUpdateFile {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceServerMockUpdateFileExpectation{}
	}

	if mmUpdateFile.defaultExpectation.paramPtrs != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by ExpectParams functions")
	}

	mmUpdateFile.defaultExpectation.params = &ArtifactPublicServiceServerMockUpdateFileParams{ctx, up1}
	mmUpdateFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateFile.expectations {
		if minimock.Equal(e.params, mmUpdateFile.defaultExpectation.params) {
			mmUpdateFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateFile.defaultExpectation.params)
		}
	}

	return mmUpdateFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockUpdateFile {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceServerMockUpdateFileExpectation{}
	}

	if mmUpdateFile.defaultExpectation.params != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by Expect")
	}

	if mmUpdateFile.defaultExpectation.paramPtrs == nil {
		mmUpdateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateFileParamPtrs{}
	}
	mmUpdateFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateFile
}

// ExpectUp1Param2 sets up expected param up1 for ArtifactPublicServiceServer.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) ExpectUp1Param2(up1 *mm_artifactv1alpha.UpdateFileRequest) *mArtifactPublicServiceServerMockUpdateFile {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceServerMockUpdateFileExpectation{}
	}

	if mmUpdateFile.defaultExpectation.params != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by Expect")
	}

	if mmUpdateFile.defaultExpectation.paramPtrs == nil {
		mmUpdateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateFileParamPtrs{}
	}
	mmUpdateFile.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateFile.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) Inspect(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateFileRequest)) *mArtifactPublicServiceServerMockUpdateFile {
	if mmUpdateFile.mock.inspectFuncUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.UpdateFile")
	}

	mmUpdateFile.mock.inspectFuncUpdateFile = f

	return mmUpdateFile
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) Return(up2 *mm_artifactv1alpha.UpdateFileResponse, err error) *ArtifactPublicServiceServerMock {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceServerMockUpdateFileExpectation{mock: mmUpdateFile.mock}
	}
	mmUpdateFile.defaultExpectation.results = &ArtifactPublicServiceServerMockUpdateFileResults{up2, err}
	mmUpdateFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.UpdateFile method
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) Set(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateFileRequest) (up2 *mm_artifactv1alpha.UpdateFileResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmUpdateFile.defaultExpectation != nil {
		mmUpdateFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.UpdateFile method")
	}

	if len(mmUpdateFile.expectations) > 0 {
		mmUpdateFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.UpdateFile method")
	}

	mmUpdateFile.mock.funcUpdateFile = f
	mmUpdateFile.mock.funcUpdateFileOrigin = minimock.CallerInfo(1)
	return mmUpdateFile.mock
}

// When sets expectation for the ArtifactPublicServiceServer.UpdateFile which will trigger the result defined by the following
// Then helper
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) When(ctx context.Context, up1 *mm_artifactv1alpha.UpdateFileRequest) *ArtifactPublicServiceServerMockUpdateFileExpectation {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockUpdateFileExpectation{
		mock:               mmUpdateFile.mock,
		params:             &ArtifactPublicServiceServerMockUpdateFileParams{ctx, up1},
		expectationOrigins: ArtifactPublicServiceServerMockUpdateFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateFile.expectations = append(mmUpdateFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.UpdateFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockUpdateFileExpectation) Then(up2 *mm_artifactv1alpha.UpdateFileResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockUpdateFileResults{up2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.UpdateFile should be invoked
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) Times(n uint64) *mArtifactPublicServiceServerMockUpdateFile {
	if n == 0 {
		mmUpdateFile.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.UpdateFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateFile.expectedInvocations, n)
	mmUpdateFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateFile
}

func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) invocationsDone() bool {
	if len(mmUpdateFile.expectations) == 0 && mmUpdateFile.defaultExpectation == nil && mmUpdateFile.mock.funcUpdateFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateFile.mock.afterUpdateFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateFile implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmUpdateFile *ArtifactPublicServiceServerMock) UpdateFile(ctx context.Context, up1 *mm_artifactv1alpha.UpdateFileRequest) (up2 *mm_artifactv1alpha.UpdateFileResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateFile.beforeUpdateFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateFile.afterUpdateFileCounter, 1)

	mmUpdateFile.t.Helper()

	if mmUpdateFile.inspectFuncUpdateFile != nil {
		mmUpdateFile.inspectFuncUpdateFile(ctx, up1)
	}

	mm_params := ArtifactPublicServiceServerMockUpdateFileParams{ctx, up1}

	// Record call args
	mmUpdateFile.UpdateFileMock.mutex.Lock()
	mmUpdateFile.UpdateFileMock.callArgs = append(mmUpdateFile.UpdateFileMock.callArgs, &mm_params)
	mmUpdateFile.UpdateFileMock.mutex.Unlock()

	for _, e := range mmUpdateFile.UpdateFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateFile.UpdateFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateFile.UpdateFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateFile.UpdateFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateFile.UpdateFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockUpdateFileParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateFile.t.Errorf("ArtifactPublicServiceServerMock.UpdateFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateFile.UpdateFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateFile.t.Errorf("ArtifactPublicServiceServerMock.UpdateFile got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateFile.UpdateFileMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateFile.t.Errorf("ArtifactPublicServiceServerMock.UpdateFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateFile.UpdateFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateFile.UpdateFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateFile.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.UpdateFile")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateFile.funcUpdateFile != nil {
		return mmUpdateFile.funcUpdateFile(ctx, up1)
	}
	mmUpdateFile.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.UpdateFile. %v %v", ctx, up1)
	return
}

// UpdateFileAfterCounter returns a count of finished ArtifactPublicServiceServerMock.UpdateFile invocations
func (mmUpdateFile *ArtifactPublicServiceServerMock) UpdateFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateFile.afterUpdateFileCounter)
}

// UpdateFileBeforeCounter returns a count of ArtifactPublicServiceServerMock.UpdateFile invocations
func (mmUpdateFile *ArtifactPublicServiceServerMock) UpdateFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateFile.beforeUpdateFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.UpdateFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateFile *mArtifactPublicServiceServerMockUpdateFile) Calls() []*ArtifactPublicServiceServerMockUpdateFileParams {
	mmUpdateFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockUpdateFileParams, len(mmUpdateFile.callArgs))
	copy(argCopy, mmUpdateFile.callArgs)

	mmUpdateFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateFileDone returns true if the count of the UpdateFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockUpdateFileDone() bool {
	if m.UpdateFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateFileMock.invocationsDone()
}

// MinimockUpdateFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockUpdateFileInspect() {
	for _, e := range m.UpdateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateFileCounter := mm_atomic.LoadUint64(&m.afterUpdateFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateFileMock.defaultExpectation != nil && afterUpdateFileCounter < 1 {
		if m.UpdateFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateFile at\n%s", m.UpdateFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateFile at\n%s with params: %#v", m.UpdateFileMock.defaultExpectation.expectationOrigins.origin, *m.UpdateFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateFile != nil && afterUpdateFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateFile at\n%s", m.funcUpdateFileOrigin)
	}

	if !m.UpdateFileMock.invocationsDone() && afterUpdateFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.UpdateFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateFileMock.expectedInvocations), m.UpdateFileMock.expectedInvocationsOrigin, afterUpdateFileCounter)
	}
}

type mArtifactPublicServiceServerMockUpdateKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceServer.UpdateKnowledgeBase
type ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceServerMockUpdateKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceServerMockUpdateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams contains parameters of the ArtifactPublicServiceServer.UpdateKnowledgeBase
type ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams struct {
	ctx context.Context
	up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.UpdateKnowledgeBase
type ArtifactPublicServiceServerMockUpdateKnowledgeBaseParamPtrs struct {
	ctx *context.Context
	up1 **mm_artifactv1alpha.UpdateKnowledgeBaseRequest
}

// ArtifactPublicServiceServerMockUpdateKnowledgeBaseResults contains results of the ArtifactPublicServiceServer.UpdateKnowledgeBase
type ArtifactPublicServiceServerMockUpdateKnowledgeBaseResults struct {
	up2 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceServerMockUpdateKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceServer.UpdateKnowledgeBase
type ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) Optional() *mArtifactPublicServiceServerMockUpdateKnowledgeBase {
	mmUpdateKnowledgeBase.optional = true
	return mmUpdateKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceServer.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) Expect(ctx context.Context, up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest) *mArtifactPublicServiceServerMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams{ctx, up1}
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectUp1Param2 sets up expected param up1 for ArtifactPublicServiceServer.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) ExpectUp1Param2(up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest) *mArtifactPublicServiceServerMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest)) *mArtifactPublicServiceServerMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) Return(up2 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseResults{up2, err}
	mmUpdateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) Set(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest) (up2 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceServer.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) When(ctx context.Context, up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest) *ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation{
		mock:               mmUpdateKnowledgeBase.mock,
		params:             &ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams{ctx, up1},
		expectationOrigins: ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockUpdateKnowledgeBaseExpectation) Then(up2 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockUpdateKnowledgeBaseResults{up2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) Times(n uint64) *mArtifactPublicServiceServerMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	mmUpdateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmUpdateKnowledgeBase *ArtifactPublicServiceServerMock) UpdateKnowledgeBase(ctx context.Context, up1 *mm_artifactv1alpha.UpdateKnowledgeBaseRequest) (up2 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	mmUpdateKnowledgeBase.t.Helper()

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, up1)
	}

	mm_params := ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams{ctx, up1}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("ArtifactPublicServiceServerMock.UpdateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.UpdateKnowledgeBase")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, up1)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.UpdateKnowledgeBase. %v %v", ctx, up1)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceServerMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *ArtifactPublicServiceServerMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceServerMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *ArtifactPublicServiceServerMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mArtifactPublicServiceServerMockUpdateKnowledgeBase) Calls() []*ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockUpdateKnowledgeBaseDone() bool {
	if m.UpdateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateKnowledgeBase at\n%s", m.UpdateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateKnowledgeBase at\n%s with params: %#v", m.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateKnowledgeBase at\n%s", m.funcUpdateKnowledgeBaseOrigin)
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.UpdateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), m.UpdateKnowledgeBaseMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseCounter)
	}
}

type mArtifactPublicServiceServerMockUpdateObject struct {
	optional           bool
	mock               *ArtifactPublicServiceServerMock
	defaultExpectation *ArtifactPublicServiceServerMockUpdateObjectExpectation
	expectations       []*ArtifactPublicServiceServerMockUpdateObjectExpectation

	callArgs []*ArtifactPublicServiceServerMockUpdateObjectParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceServerMockUpdateObjectExpectation specifies expectation struct of the ArtifactPublicServiceServer.UpdateObject
type ArtifactPublicServiceServerMockUpdateObjectExpectation struct {
	mock               *ArtifactPublicServiceServerMock
	params             *ArtifactPublicServiceServerMockUpdateObjectParams
	paramPtrs          *ArtifactPublicServiceServerMockUpdateObjectParamPtrs
	expectationOrigins ArtifactPublicServiceServerMockUpdateObjectExpectationOrigins
	results            *ArtifactPublicServiceServerMockUpdateObjectResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceServerMockUpdateObjectParams contains parameters of the ArtifactPublicServiceServer.UpdateObject
type ArtifactPublicServiceServerMockUpdateObjectParams struct {
	ctx context.Context
	up1 *mm_artifactv1alpha.UpdateObjectRequest
}

// ArtifactPublicServiceServerMockUpdateObjectParamPtrs contains pointers to parameters of the ArtifactPublicServiceServer.UpdateObject
type ArtifactPublicServiceServerMockUpdateObjectParamPtrs struct {
	ctx *context.Context
	up1 **mm_artifactv1alpha.UpdateObjectRequest
}

// ArtifactPublicServiceServerMockUpdateObjectResults contains results of the ArtifactPublicServiceServer.UpdateObject
type ArtifactPublicServiceServerMockUpdateObjectResults struct {
	up2 *mm_artifactv1alpha.UpdateObjectResponse
	err error
}

// ArtifactPublicServiceServerMockUpdateObjectOrigins contains origins of expectations of the ArtifactPublicServiceServer.UpdateObject
type ArtifactPublicServiceServerMockUpdateObjectExpectationOrigins struct {
	origin    string
	originCtx string
	originUp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) Optional() *mArtifactPublicServiceServerMockUpdateObject {
	mmUpdateObject.optional = true
	return mmUpdateObject
}

// Expect sets up expected params for ArtifactPublicServiceServer.UpdateObject
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) Expect(ctx context.Context, up1 *mm_artifactv1alpha.UpdateObjectRequest) *mArtifactPublicServiceServerMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &ArtifactPublicServiceServerMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.paramPtrs != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by ExpectParams functions")
	}

	mmUpdateObject.defaultExpectation.params = &ArtifactPublicServiceServerMockUpdateObjectParams{ctx, up1}
	mmUpdateObject.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateObject.expectations {
		if minimock.Equal(e.params, mmUpdateObject.defaultExpectation.params) {
			mmUpdateObject.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateObject.defaultExpectation.params)
		}
	}

	return mmUpdateObject
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceServer.UpdateObject
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceServerMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &ArtifactPublicServiceServerMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateObject.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateObject
}

// ExpectUp1Param2 sets up expected param up1 for ArtifactPublicServiceServer.UpdateObject
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) ExpectUp1Param2(up1 *mm_artifactv1alpha.UpdateObjectRequest) *mArtifactPublicServiceServerMockUpdateObject {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &ArtifactPublicServiceServerMockUpdateObjectExpectation{}
	}

	if mmUpdateObject.defaultExpectation.params != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by Expect")
	}

	if mmUpdateObject.defaultExpectation.paramPtrs == nil {
		mmUpdateObject.defaultExpectation.paramPtrs = &ArtifactPublicServiceServerMockUpdateObjectParamPtrs{}
	}
	mmUpdateObject.defaultExpectation.paramPtrs.up1 = &up1
	mmUpdateObject.defaultExpectation.expectationOrigins.originUp1 = minimock.CallerInfo(1)

	return mmUpdateObject
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceServer.UpdateObject
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) Inspect(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateObjectRequest)) *mArtifactPublicServiceServerMockUpdateObject {
	if mmUpdateObject.mock.inspectFuncUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceServerMock.UpdateObject")
	}

	mmUpdateObject.mock.inspectFuncUpdateObject = f

	return mmUpdateObject
}

// Return sets up results that will be returned by ArtifactPublicServiceServer.UpdateObject
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) Return(up2 *mm_artifactv1alpha.UpdateObjectResponse, err error) *ArtifactPublicServiceServerMock {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by Set")
	}

	if mmUpdateObject.defaultExpectation == nil {
		mmUpdateObject.defaultExpectation = &ArtifactPublicServiceServerMockUpdateObjectExpectation{mock: mmUpdateObject.mock}
	}
	mmUpdateObject.defaultExpectation.results = &ArtifactPublicServiceServerMockUpdateObjectResults{up2, err}
	mmUpdateObject.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateObject.mock
}

// Set uses given function f to mock the ArtifactPublicServiceServer.UpdateObject method
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) Set(f func(ctx context.Context, up1 *mm_artifactv1alpha.UpdateObjectRequest) (up2 *mm_artifactv1alpha.UpdateObjectResponse, err error)) *ArtifactPublicServiceServerMock {
	if mmUpdateObject.defaultExpectation != nil {
		mmUpdateObject.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceServer.UpdateObject method")
	}

	if len(mmUpdateObject.expectations) > 0 {
		mmUpdateObject.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceServer.UpdateObject method")
	}

	mmUpdateObject.mock.funcUpdateObject = f
	mmUpdateObject.mock.funcUpdateObjectOrigin = minimock.CallerInfo(1)
	return mmUpdateObject.mock
}

// When sets expectation for the ArtifactPublicServiceServer.UpdateObject which will trigger the result defined by the following
// Then helper
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) When(ctx context.Context, up1 *mm_artifactv1alpha.UpdateObjectRequest) *ArtifactPublicServiceServerMockUpdateObjectExpectation {
	if mmUpdateObject.mock.funcUpdateObject != nil {
		mmUpdateObject.mock.t.Fatalf("ArtifactPublicServiceServerMock.UpdateObject mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceServerMockUpdateObjectExpectation{
		mock:               mmUpdateObject.mock,
		params:             &ArtifactPublicServiceServerMockUpdateObjectParams{ctx, up1},
		expectationOrigins: ArtifactPublicServiceServerMockUpdateObjectExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateObject.expectations = append(mmUpdateObject.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceServer.UpdateObject return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceServerMockUpdateObjectExpectation) Then(up2 *mm_artifactv1alpha.UpdateObjectResponse, err error) *ArtifactPublicServiceServerMock {
	e.results = &ArtifactPublicServiceServerMockUpdateObjectResults{up2, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceServer.UpdateObject should be invoked
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) Times(n uint64) *mArtifactPublicServiceServerMockUpdateObject {
	if n == 0 {
		mmUpdateObject.mock.t.Fatalf("Times of ArtifactPublicServiceServerMock.UpdateObject mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateObject.expectedInvocations, n)
	mmUpdateObject.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateObject
}

func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) invocationsDone() bool {
	if len(mmUpdateObject.expectations) == 0 && mmUpdateObject.defaultExpectation == nil && mmUpdateObject.mock.funcUpdateObject == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateObject.mock.afterUpdateObjectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateObject.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateObject implements mm_artifactv1alpha.ArtifactPublicServiceServer
func (mmUpdateObject *ArtifactPublicServiceServerMock) UpdateObject(ctx context.Context, up1 *mm_artifactv1alpha.UpdateObjectRequest) (up2 *mm_artifactv1alpha.UpdateObjectResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateObject.beforeUpdateObjectCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateObject.afterUpdateObjectCounter, 1)

	mmUpdateObject.t.Helper()

	if mmUpdateObject.inspectFuncUpdateObject != nil {
		mmUpdateObject.inspectFuncUpdateObject(ctx, up1)
	}

	mm_params := ArtifactPublicServiceServerMockUpdateObjectParams{ctx, up1}

	// Record call args
	mmUpdateObject.UpdateObjectMock.mutex.Lock()
	mmUpdateObject.UpdateObjectMock.callArgs = append(mmUpdateObject.UpdateObjectMock.callArgs, &mm_params)
	mmUpdateObject.UpdateObjectMock.mutex.Unlock()

	for _, e := range mmUpdateObject.UpdateObjectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up2, e.results.err
		}
	}

	if mmUpdateObject.UpdateObjectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateObject.UpdateObjectMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateObject.UpdateObjectMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateObject.UpdateObjectMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceServerMockUpdateObjectParams{ctx, up1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateObject.t.Errorf("ArtifactPublicServiceServerMock.UpdateObject got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.up1 != nil && !minimock.Equal(*mm_want_ptrs.up1, mm_got.up1) {
				mmUpdateObject.t.Errorf("ArtifactPublicServiceServerMock.UpdateObject got unexpected parameter up1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.originUp1, *mm_want_ptrs.up1, mm_got.up1, minimock.Diff(*mm_want_ptrs.up1, mm_got.up1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateObject.t.Errorf("ArtifactPublicServiceServerMock.UpdateObject got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateObject.UpdateObjectMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateObject.UpdateObjectMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateObject.t.Fatal("No results are set for the ArtifactPublicServiceServerMock.UpdateObject")
		}
		return (*mm_results).up2, (*mm_results).err
	}
	if mmUpdateObject.funcUpdateObject != nil {
		return mmUpdateObject.funcUpdateObject(ctx, up1)
	}
	mmUpdateObject.t.Fatalf("Unexpected call to ArtifactPublicServiceServerMock.UpdateObject. %v %v", ctx, up1)
	return
}

// UpdateObjectAfterCounter returns a count of finished ArtifactPublicServiceServerMock.UpdateObject invocations
func (mmUpdateObject *ArtifactPublicServiceServerMock) UpdateObjectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.afterUpdateObjectCounter)
}

// UpdateObjectBeforeCounter returns a count of ArtifactPublicServiceServerMock.UpdateObject invocations
func (mmUpdateObject *ArtifactPublicServiceServerMock) UpdateObjectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateObject.beforeUpdateObjectCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceServerMock.UpdateObject.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateObject *mArtifactPublicServiceServerMockUpdateObject) Calls() []*ArtifactPublicServiceServerMockUpdateObjectParams {
	mmUpdateObject.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceServerMockUpdateObjectParams, len(mmUpdateObject.callArgs))
	copy(argCopy, mmUpdateObject.callArgs)

	mmUpdateObject.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateObjectDone returns true if the count of the UpdateObject invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceServerMock) MinimockUpdateObjectDone() bool {
	if m.UpdateObjectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateObjectMock.invocationsDone()
}

// MinimockUpdateObjectInspect logs each unmet expectation
func (m *ArtifactPublicServiceServerMock) MinimockUpdateObjectInspect() {
	for _, e := range m.UpdateObjectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateObject at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateObjectCounter := mm_atomic.LoadUint64(&m.afterUpdateObjectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateObjectMock.defaultExpectation != nil && afterUpdateObjectCounter < 1 {
		if m.UpdateObjectMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateObject at\n%s", m.UpdateObjectMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateObject at\n%s with params: %#v", m.UpdateObjectMock.defaultExpectation.expectationOrigins.origin, *m.UpdateObjectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateObject != nil && afterUpdateObjectCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceServerMock.UpdateObject at\n%s", m.funcUpdateObjectOrigin)
	}

	if !m.UpdateObjectMock.invocationsDone() && afterUpdateObjectCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceServerMock.UpdateObject at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateObjectMock.expectedInvocations), m.UpdateObjectMock.expectedInvocationsOrigin, afterUpdateObjectCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ArtifactPublicServiceServerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateFileInspect()

			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockDeleteFileInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockDeleteObjectInspect()

			m.MinimockGetChunkInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetKnowledgeBaseInspect()

			m.MinimockGetObjectInspect()

			m.MinimockGetObjectDownloadURLInspect()

			m.MinimockGetObjectUploadURLInspect()

			m.MinimockListChunksInspect()

			m.MinimockListFilesInspect()

			m.MinimockListKnowledgeBaseRunsInspect()

			m.MinimockListKnowledgeBasesInspect()

			m.MinimockLivenessInspect()

			m.MinimockReadinessInspect()

			m.MinimockReprocessFileInspect()

			m.MinimockSearchChunksInspect()

			m.MinimockUpdateChunkInspect()

			m.MinimockUpdateFileInspect()

			m.MinimockUpdateKnowledgeBaseInspect()

			m.MinimockUpdateObjectInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ArtifactPublicServiceServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ArtifactPublicServiceServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateFileDone() &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockDeleteFileDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockDeleteObjectDone() &&
		m.MinimockGetChunkDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetKnowledgeBaseDone() &&
		m.MinimockGetObjectDone() &&
		m.MinimockGetObjectDownloadURLDone() &&
		m.MinimockGetObjectUploadURLDone() &&
		m.MinimockListChunksDone() &&
		m.MinimockListFilesDone() &&
		m.MinimockListKnowledgeBaseRunsDone() &&
		m.MinimockListKnowledgeBasesDone() &&
		m.MinimockLivenessDone() &&
		m.MinimockReadinessDone() &&
		m.MinimockReprocessFileDone() &&
		m.MinimockSearchChunksDone() &&
		m.MinimockUpdateChunkDone() &&
		m.MinimockUpdateFileDone() &&
		m.MinimockUpdateKnowledgeBaseDone() &&
		m.MinimockUpdateObjectDone()
}
