// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_artifactv1alpha "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	grpc "google.golang.org/grpc"
)

// ArtifactPublicServiceClientMock implements mm_artifactv1alpha.ArtifactPublicServiceClient
type ArtifactPublicServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateCatalog          func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error)
	funcCreateCatalogOrigin    string
	inspectFuncCreateCatalog   func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption)
	afterCreateCatalogCounter  uint64
	beforeCreateCatalogCounter uint64
	CreateCatalogMock          mArtifactPublicServiceClientMockCreateCatalog

	funcDeleteCatalog          func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error)
	funcDeleteCatalogOrigin    string
	inspectFuncDeleteCatalog   func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption)
	afterDeleteCatalogCounter  uint64
	beforeDeleteCatalogCounter uint64
	DeleteCatalogMock          mArtifactPublicServiceClientMockDeleteCatalog

	funcDeleteCatalogFile          func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error)
	funcDeleteCatalogFileOrigin    string
	inspectFuncDeleteCatalogFile   func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption)
	afterDeleteCatalogFileCounter  uint64
	beforeDeleteCatalogFileCounter uint64
	DeleteCatalogFileMock          mArtifactPublicServiceClientMockDeleteCatalogFile

	funcGetFileCatalog          func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error)
	funcGetFileCatalogOrigin    string
	inspectFuncGetFileCatalog   func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption)
	afterGetFileCatalogCounter  uint64
	beforeGetFileCatalogCounter uint64
	GetFileCatalogMock          mArtifactPublicServiceClientMockGetFileCatalog

	funcGetObjectDownloadURL          func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)
	funcGetObjectDownloadURLOrigin    string
	inspectFuncGetObjectDownloadURL   func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption)
	afterGetObjectDownloadURLCounter  uint64
	beforeGetObjectDownloadURLCounter uint64
	GetObjectDownloadURLMock          mArtifactPublicServiceClientMockGetObjectDownloadURL

	funcGetObjectUploadURL          func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)
	funcGetObjectUploadURLOrigin    string
	inspectFuncGetObjectUploadURL   func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption)
	afterGetObjectUploadURLCounter  uint64
	beforeGetObjectUploadURLCounter uint64
	GetObjectUploadURLMock          mArtifactPublicServiceClientMockGetObjectUploadURL

	funcGetSourceFile          func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error)
	funcGetSourceFileOrigin    string
	inspectFuncGetSourceFile   func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption)
	afterGetSourceFileCounter  uint64
	beforeGetSourceFileCounter uint64
	GetSourceFileMock          mArtifactPublicServiceClientMockGetSourceFile

	funcListCatalogFiles          func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error)
	funcListCatalogFilesOrigin    string
	inspectFuncListCatalogFiles   func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption)
	afterListCatalogFilesCounter  uint64
	beforeListCatalogFilesCounter uint64
	ListCatalogFilesMock          mArtifactPublicServiceClientMockListCatalogFiles

	funcListCatalogRuns          func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogRunsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogRunsResponse, err error)
	funcListCatalogRunsOrigin    string
	inspectFuncListCatalogRuns   func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogRunsRequest, opts ...grpc.CallOption)
	afterListCatalogRunsCounter  uint64
	beforeListCatalogRunsCounter uint64
	ListCatalogRunsMock          mArtifactPublicServiceClientMockListCatalogRuns

	funcListCatalogs          func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error)
	funcListCatalogsOrigin    string
	inspectFuncListCatalogs   func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption)
	afterListCatalogsCounter  uint64
	beforeListCatalogsCounter uint64
	ListCatalogsMock          mArtifactPublicServiceClientMockListCatalogs

	funcListChunks          func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error)
	funcListChunksOrigin    string
	inspectFuncListChunks   func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption)
	afterListChunksCounter  uint64
	beforeListChunksCounter uint64
	ListChunksMock          mArtifactPublicServiceClientMockListChunks

	funcLiveness          func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error)
	funcLivenessOrigin    string
	inspectFuncLiveness   func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption)
	afterLivenessCounter  uint64
	beforeLivenessCounter uint64
	LivenessMock          mArtifactPublicServiceClientMockLiveness

	funcProcessCatalogFiles          func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) (pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error)
	funcProcessCatalogFilesOrigin    string
	inspectFuncProcessCatalogFiles   func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption)
	afterProcessCatalogFilesCounter  uint64
	beforeProcessCatalogFilesCounter uint64
	ProcessCatalogFilesMock          mArtifactPublicServiceClientMockProcessCatalogFiles

	funcQuestionAnswering          func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) (qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error)
	funcQuestionAnsweringOrigin    string
	inspectFuncQuestionAnswering   func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption)
	afterQuestionAnsweringCounter  uint64
	beforeQuestionAnsweringCounter uint64
	QuestionAnsweringMock          mArtifactPublicServiceClientMockQuestionAnswering

	funcReadiness          func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error)
	funcReadinessOrigin    string
	inspectFuncReadiness   func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption)
	afterReadinessCounter  uint64
	beforeReadinessCounter uint64
	ReadinessMock          mArtifactPublicServiceClientMockReadiness

	funcSearchChunks          func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchChunksResponse, err error)
	funcSearchChunksOrigin    string
	inspectFuncSearchChunks   func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption)
	afterSearchChunksCounter  uint64
	beforeSearchChunksCounter uint64
	SearchChunksMock          mArtifactPublicServiceClientMockSearchChunks

	funcSearchSourceFiles          func(ctx context.Context, in *mm_artifactv1alpha.SearchSourceFilesRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchSourceFilesResponse, err error)
	funcSearchSourceFilesOrigin    string
	inspectFuncSearchSourceFiles   func(ctx context.Context, in *mm_artifactv1alpha.SearchSourceFilesRequest, opts ...grpc.CallOption)
	afterSearchSourceFilesCounter  uint64
	beforeSearchSourceFilesCounter uint64
	SearchSourceFilesMock          mArtifactPublicServiceClientMockSearchSourceFiles

	funcSimilarityChunksSearch          func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error)
	funcSimilarityChunksSearchOrigin    string
	inspectFuncSimilarityChunksSearch   func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption)
	afterSimilarityChunksSearchCounter  uint64
	beforeSimilarityChunksSearchCounter uint64
	SimilarityChunksSearchMock          mArtifactPublicServiceClientMockSimilarityChunksSearch

	funcUpdateCatalog          func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error)
	funcUpdateCatalogOrigin    string
	inspectFuncUpdateCatalog   func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption)
	afterUpdateCatalogCounter  uint64
	beforeUpdateCatalogCounter uint64
	UpdateCatalogMock          mArtifactPublicServiceClientMockUpdateCatalog

	funcUpdateChunk          func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error)
	funcUpdateChunkOrigin    string
	inspectFuncUpdateChunk   func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption)
	afterUpdateChunkCounter  uint64
	beforeUpdateChunkCounter uint64
	UpdateChunkMock          mArtifactPublicServiceClientMockUpdateChunk

	funcUploadCatalogFile          func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error)
	funcUploadCatalogFileOrigin    string
	inspectFuncUploadCatalogFile   func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption)
	afterUploadCatalogFileCounter  uint64
	beforeUploadCatalogFileCounter uint64
	UploadCatalogFileMock          mArtifactPublicServiceClientMockUploadCatalogFile
}

// NewArtifactPublicServiceClientMock returns a mock for mm_artifactv1alpha.ArtifactPublicServiceClient
func NewArtifactPublicServiceClientMock(t minimock.Tester) *ArtifactPublicServiceClientMock {
	m := &ArtifactPublicServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCatalogMock = mArtifactPublicServiceClientMockCreateCatalog{mock: m}
	m.CreateCatalogMock.callArgs = []*ArtifactPublicServiceClientMockCreateCatalogParams{}

	m.DeleteCatalogMock = mArtifactPublicServiceClientMockDeleteCatalog{mock: m}
	m.DeleteCatalogMock.callArgs = []*ArtifactPublicServiceClientMockDeleteCatalogParams{}

	m.DeleteCatalogFileMock = mArtifactPublicServiceClientMockDeleteCatalogFile{mock: m}
	m.DeleteCatalogFileMock.callArgs = []*ArtifactPublicServiceClientMockDeleteCatalogFileParams{}

	m.GetFileCatalogMock = mArtifactPublicServiceClientMockGetFileCatalog{mock: m}
	m.GetFileCatalogMock.callArgs = []*ArtifactPublicServiceClientMockGetFileCatalogParams{}

	m.GetObjectDownloadURLMock = mArtifactPublicServiceClientMockGetObjectDownloadURL{mock: m}
	m.GetObjectDownloadURLMock.callArgs = []*ArtifactPublicServiceClientMockGetObjectDownloadURLParams{}

	m.GetObjectUploadURLMock = mArtifactPublicServiceClientMockGetObjectUploadURL{mock: m}
	m.GetObjectUploadURLMock.callArgs = []*ArtifactPublicServiceClientMockGetObjectUploadURLParams{}

	m.GetSourceFileMock = mArtifactPublicServiceClientMockGetSourceFile{mock: m}
	m.GetSourceFileMock.callArgs = []*ArtifactPublicServiceClientMockGetSourceFileParams{}

	m.ListCatalogFilesMock = mArtifactPublicServiceClientMockListCatalogFiles{mock: m}
	m.ListCatalogFilesMock.callArgs = []*ArtifactPublicServiceClientMockListCatalogFilesParams{}

	m.ListCatalogRunsMock = mArtifactPublicServiceClientMockListCatalogRuns{mock: m}
	m.ListCatalogRunsMock.callArgs = []*ArtifactPublicServiceClientMockListCatalogRunsParams{}

	m.ListCatalogsMock = mArtifactPublicServiceClientMockListCatalogs{mock: m}
	m.ListCatalogsMock.callArgs = []*ArtifactPublicServiceClientMockListCatalogsParams{}

	m.ListChunksMock = mArtifactPublicServiceClientMockListChunks{mock: m}
	m.ListChunksMock.callArgs = []*ArtifactPublicServiceClientMockListChunksParams{}

	m.LivenessMock = mArtifactPublicServiceClientMockLiveness{mock: m}
	m.LivenessMock.callArgs = []*ArtifactPublicServiceClientMockLivenessParams{}

	m.ProcessCatalogFilesMock = mArtifactPublicServiceClientMockProcessCatalogFiles{mock: m}
	m.ProcessCatalogFilesMock.callArgs = []*ArtifactPublicServiceClientMockProcessCatalogFilesParams{}

	m.QuestionAnsweringMock = mArtifactPublicServiceClientMockQuestionAnswering{mock: m}
	m.QuestionAnsweringMock.callArgs = []*ArtifactPublicServiceClientMockQuestionAnsweringParams{}

	m.ReadinessMock = mArtifactPublicServiceClientMockReadiness{mock: m}
	m.ReadinessMock.callArgs = []*ArtifactPublicServiceClientMockReadinessParams{}

	m.SearchChunksMock = mArtifactPublicServiceClientMockSearchChunks{mock: m}
	m.SearchChunksMock.callArgs = []*ArtifactPublicServiceClientMockSearchChunksParams{}

	m.SearchSourceFilesMock = mArtifactPublicServiceClientMockSearchSourceFiles{mock: m}
	m.SearchSourceFilesMock.callArgs = []*ArtifactPublicServiceClientMockSearchSourceFilesParams{}

	m.SimilarityChunksSearchMock = mArtifactPublicServiceClientMockSimilarityChunksSearch{mock: m}
	m.SimilarityChunksSearchMock.callArgs = []*ArtifactPublicServiceClientMockSimilarityChunksSearchParams{}

	m.UpdateCatalogMock = mArtifactPublicServiceClientMockUpdateCatalog{mock: m}
	m.UpdateCatalogMock.callArgs = []*ArtifactPublicServiceClientMockUpdateCatalogParams{}

	m.UpdateChunkMock = mArtifactPublicServiceClientMockUpdateChunk{mock: m}
	m.UpdateChunkMock.callArgs = []*ArtifactPublicServiceClientMockUpdateChunkParams{}

	m.UploadCatalogFileMock = mArtifactPublicServiceClientMockUploadCatalogFile{mock: m}
	m.UploadCatalogFileMock.callArgs = []*ArtifactPublicServiceClientMockUploadCatalogFileParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mArtifactPublicServiceClientMockCreateCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockCreateCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockCreateCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockCreateCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockCreateCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockCreateCatalogParams
	paramPtrs          *ArtifactPublicServiceClientMockCreateCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockCreateCatalogExpectationOrigins
	results            *ArtifactPublicServiceClientMockCreateCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockCreateCatalogParams contains parameters of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.CreateCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.CreateCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateCatalogResults contains results of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogResults struct {
	cp1 *mm_artifactv1alpha.CreateCatalogResponse
	err error
}

// ArtifactPublicServiceClientMockCreateCatalogOrigins contains origins of expectations of the ArtifactPublicServiceClient.CreateCatalog
type ArtifactPublicServiceClientMockCreateCatalogExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Optional() *mArtifactPublicServiceClientMockCreateCatalog {
	mmCreateCatalog.optional = true
	return mmCreateCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by ExpectParams functions")
	}

	mmCreateCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts}
	mmCreateCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCatalog.expectations {
		if minimock.Equal(e.params, mmCreateCatalog.defaultExpectation.params) {
			mmCreateCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCatalog.defaultExpectation.params)
		}
	}

	return mmCreateCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) ExpectInParam2(in *mm_artifactv1alpha.CreateCatalogRequest) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.in = &in
	mmCreateCatalog.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmCreateCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{}
	}

	if mmCreateCatalog.defaultExpectation.params != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Expect")
	}

	if mmCreateCatalog.defaultExpectation.paramPtrs == nil {
		mmCreateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateCatalogParamPtrs{}
	}
	mmCreateCatalog.defaultExpectation.paramPtrs.opts = &opts
	mmCreateCatalog.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmCreateCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockCreateCatalog {
	if mmCreateCatalog.mock.inspectFuncCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.CreateCatalog")
	}

	mmCreateCatalog.mock.inspectFuncCreateCatalog = f

	return mmCreateCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.CreateCatalog
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Return(cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	if mmCreateCatalog.defaultExpectation == nil {
		mmCreateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockCreateCatalogExpectation{mock: mmCreateCatalog.mock}
	}
	mmCreateCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockCreateCatalogResults{cp1, err}
	mmCreateCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.CreateCatalog method
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmCreateCatalog.defaultExpectation != nil {
		mmCreateCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.CreateCatalog method")
	}

	if len(mmCreateCatalog.expectations) > 0 {
		mmCreateCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.CreateCatalog method")
	}

	mmCreateCatalog.mock.funcCreateCatalog = f
	mmCreateCatalog.mock.funcCreateCatalogOrigin = minimock.CallerInfo(1)
	return mmCreateCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.CreateCatalog which will trigger the result defined by the following
// Then helper
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) When(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockCreateCatalogExpectation {
	if mmCreateCatalog.mock.funcCreateCatalog != nil {
		mmCreateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockCreateCatalogExpectation{
		mock:               mmCreateCatalog.mock,
		params:             &ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockCreateCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCatalog.expectations = append(mmCreateCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.CreateCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockCreateCatalogExpectation) Then(cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockCreateCatalogResults{cp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.CreateCatalog should be invoked
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Times(n uint64) *mArtifactPublicServiceClientMockCreateCatalog {
	if n == 0 {
		mmCreateCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.CreateCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCatalog.expectedInvocations, n)
	mmCreateCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCatalog
}

func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) invocationsDone() bool {
	if len(mmCreateCatalog.expectations) == 0 && mmCreateCatalog.defaultExpectation == nil && mmCreateCatalog.mock.funcCreateCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCatalog.mock.afterCreateCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCatalog implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmCreateCatalog *ArtifactPublicServiceClientMock) CreateCatalog(ctx context.Context, in *mm_artifactv1alpha.CreateCatalogRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmCreateCatalog.beforeCreateCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCatalog.afterCreateCatalogCounter, 1)

	mmCreateCatalog.t.Helper()

	if mmCreateCatalog.inspectFuncCreateCatalog != nil {
		mmCreateCatalog.inspectFuncCreateCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts}

	// Record call args
	mmCreateCatalog.CreateCatalogMock.mutex.Lock()
	mmCreateCatalog.CreateCatalogMock.callArgs = append(mmCreateCatalog.CreateCatalogMock.callArgs, &mm_params)
	mmCreateCatalog.CreateCatalogMock.mutex.Unlock()

	for _, e := range mmCreateCatalog.CreateCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateCatalog.CreateCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCatalog.CreateCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCatalog.CreateCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCatalog.CreateCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockCreateCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCatalog.CreateCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCatalog.CreateCatalogMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCatalog.CreateCatalogMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCatalog.t.Errorf("ArtifactPublicServiceClientMock.CreateCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCatalog.CreateCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCatalog.CreateCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.CreateCatalog")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateCatalog.funcCreateCatalog != nil {
		return mmCreateCatalog.funcCreateCatalog(ctx, in, opts...)
	}
	mmCreateCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.CreateCatalog. %v %v %v", ctx, in, opts)
	return
}

// CreateCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.CreateCatalog invocations
func (mmCreateCatalog *ArtifactPublicServiceClientMock) CreateCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalog.afterCreateCatalogCounter)
}

// CreateCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.CreateCatalog invocations
func (mmCreateCatalog *ArtifactPublicServiceClientMock) CreateCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalog.beforeCreateCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.CreateCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCatalog *mArtifactPublicServiceClientMockCreateCatalog) Calls() []*ArtifactPublicServiceClientMockCreateCatalogParams {
	mmCreateCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockCreateCatalogParams, len(mmCreateCatalog.callArgs))
	copy(argCopy, mmCreateCatalog.callArgs)

	mmCreateCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCatalogDone returns true if the count of the CreateCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockCreateCatalogDone() bool {
	if m.CreateCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCatalogMock.invocationsDone()
}

// MinimockCreateCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockCreateCatalogInspect() {
	for _, e := range m.CreateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCatalogCounter := mm_atomic.LoadUint64(&m.afterCreateCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCatalogMock.defaultExpectation != nil && afterCreateCatalogCounter < 1 {
		if m.CreateCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateCatalog at\n%s", m.CreateCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateCatalog at\n%s with params: %#v", m.CreateCatalogMock.defaultExpectation.expectationOrigins.origin, *m.CreateCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCatalog != nil && afterCreateCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateCatalog at\n%s", m.funcCreateCatalogOrigin)
	}

	if !m.CreateCatalogMock.invocationsDone() && afterCreateCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.CreateCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCatalogMock.expectedInvocations), m.CreateCatalogMock.expectedInvocationsOrigin, afterCreateCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockDeleteCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockDeleteCatalogParams
	paramPtrs          *ArtifactPublicServiceClientMockDeleteCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockDeleteCatalogExpectationOrigins
	results            *ArtifactPublicServiceClientMockDeleteCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockDeleteCatalogParams contains parameters of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogResults contains results of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogResults struct {
	dp1 *mm_artifactv1alpha.DeleteCatalogResponse
	err error
}

// ArtifactPublicServiceClientMockDeleteCatalogOrigins contains origins of expectations of the ArtifactPublicServiceClient.DeleteCatalog
type ArtifactPublicServiceClientMockDeleteCatalogExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Optional() *mArtifactPublicServiceClientMockDeleteCatalog {
	mmDeleteCatalog.optional = true
	return mmDeleteCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by ExpectParams functions")
	}

	mmDeleteCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts}
	mmDeleteCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCatalog.expectations {
		if minimock.Equal(e.params, mmDeleteCatalog.defaultExpectation.params) {
			mmDeleteCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCatalog.defaultExpectation.params)
		}
	}

	return mmDeleteCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) ExpectInParam2(in *mm_artifactv1alpha.DeleteCatalogRequest) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.in = &in
	mmDeleteCatalog.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmDeleteCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{}
	}

	if mmDeleteCatalog.defaultExpectation.params != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Expect")
	}

	if mmDeleteCatalog.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogParamPtrs{}
	}
	mmDeleteCatalog.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteCatalog.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteCatalog {
	if mmDeleteCatalog.mock.inspectFuncDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteCatalog")
	}

	mmDeleteCatalog.mock.inspectFuncDeleteCatalog = f

	return mmDeleteCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteCatalog
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Return(dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	if mmDeleteCatalog.defaultExpectation == nil {
		mmDeleteCatalog.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogExpectation{mock: mmDeleteCatalog.mock}
	}
	mmDeleteCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteCatalogResults{dp1, err}
	mmDeleteCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteCatalog method
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalog.defaultExpectation != nil {
		mmDeleteCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteCatalog method")
	}

	if len(mmDeleteCatalog.expectations) > 0 {
		mmDeleteCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteCatalog method")
	}

	mmDeleteCatalog.mock.funcDeleteCatalog = f
	mmDeleteCatalog.mock.funcDeleteCatalogOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteCatalog which will trigger the result defined by the following
// Then helper
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) When(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteCatalogExpectation {
	if mmDeleteCatalog.mock.funcDeleteCatalog != nil {
		mmDeleteCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteCatalogExpectation{
		mock:               mmDeleteCatalog.mock,
		params:             &ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockDeleteCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCatalog.expectations = append(mmDeleteCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteCatalogExpectation) Then(dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteCatalogResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteCatalog should be invoked
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Times(n uint64) *mArtifactPublicServiceClientMockDeleteCatalog {
	if n == 0 {
		mmDeleteCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCatalog.expectedInvocations, n)
	mmDeleteCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalog
}

func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) invocationsDone() bool {
	if len(mmDeleteCatalog.expectations) == 0 && mmDeleteCatalog.defaultExpectation == nil && mmDeleteCatalog.mock.funcDeleteCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCatalog.mock.afterDeleteCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCatalog implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteCatalog *ArtifactPublicServiceClientMock) DeleteCatalog(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteCatalog.beforeDeleteCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCatalog.afterDeleteCatalogCounter, 1)

	mmDeleteCatalog.t.Helper()

	if mmDeleteCatalog.inspectFuncDeleteCatalog != nil {
		mmDeleteCatalog.inspectFuncDeleteCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts}

	// Record call args
	mmDeleteCatalog.DeleteCatalogMock.mutex.Lock()
	mmDeleteCatalog.DeleteCatalogMock.callArgs = append(mmDeleteCatalog.DeleteCatalogMock.callArgs, &mm_params)
	mmDeleteCatalog.DeleteCatalogMock.mutex.Unlock()

	for _, e := range mmDeleteCatalog.DeleteCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteCatalog.DeleteCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCatalog.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCatalog.DeleteCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteCatalog")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteCatalog.funcDeleteCatalog != nil {
		return mmDeleteCatalog.funcDeleteCatalog(ctx, in, opts...)
	}
	mmDeleteCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteCatalog. %v %v %v", ctx, in, opts)
	return
}

// DeleteCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteCatalog invocations
func (mmDeleteCatalog *ArtifactPublicServiceClientMock) DeleteCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalog.afterDeleteCatalogCounter)
}

// DeleteCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteCatalog invocations
func (mmDeleteCatalog *ArtifactPublicServiceClientMock) DeleteCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalog.beforeDeleteCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCatalog *mArtifactPublicServiceClientMockDeleteCatalog) Calls() []*ArtifactPublicServiceClientMockDeleteCatalogParams {
	mmDeleteCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteCatalogParams, len(mmDeleteCatalog.callArgs))
	copy(argCopy, mmDeleteCatalog.callArgs)

	mmDeleteCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCatalogDone returns true if the count of the DeleteCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogDone() bool {
	if m.DeleteCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCatalogMock.invocationsDone()
}

// MinimockDeleteCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogInspect() {
	for _, e := range m.DeleteCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCatalogCounter := mm_atomic.LoadUint64(&m.afterDeleteCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCatalogMock.defaultExpectation != nil && afterDeleteCatalogCounter < 1 {
		if m.DeleteCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog at\n%s", m.DeleteCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog at\n%s with params: %#v", m.DeleteCatalogMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCatalog != nil && afterDeleteCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalog at\n%s", m.funcDeleteCatalogOrigin)
	}

	if !m.DeleteCatalogMock.invocationsDone() && afterDeleteCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCatalogMock.expectedInvocations), m.DeleteCatalogMock.expectedInvocationsOrigin, afterDeleteCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteCatalogFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteCatalogFileExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteCatalogFileExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteCatalogFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockDeleteCatalogFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockDeleteCatalogFileParams
	paramPtrs          *ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockDeleteCatalogFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockDeleteCatalogFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockDeleteCatalogFileParams contains parameters of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteCatalogFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteCatalogFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteCatalogFileResults contains results of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileResults struct {
	dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse
	err error
}

// ArtifactPublicServiceClientMockDeleteCatalogFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.DeleteCatalogFile
type ArtifactPublicServiceClientMockDeleteCatalogFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Optional() *mArtifactPublicServiceClientMockDeleteCatalogFile {
	mmDeleteCatalogFile.optional = true
	return mmDeleteCatalogFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by ExpectParams functions")
	}

	mmDeleteCatalogFile.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts}
	mmDeleteCatalogFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCatalogFile.expectations {
		if minimock.Equal(e.params, mmDeleteCatalogFile.defaultExpectation.params) {
			mmDeleteCatalogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCatalogFile.defaultExpectation.params)
		}
	}

	return mmDeleteCatalogFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCatalogFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCatalogFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) ExpectInParam2(in *mm_artifactv1alpha.DeleteCatalogFileRequest) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.in = &in
	mmDeleteCatalogFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmDeleteCatalogFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{}
	}

	if mmDeleteCatalogFile.defaultExpectation.params != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Expect")
	}

	if mmDeleteCatalogFile.defaultExpectation.paramPtrs == nil {
		mmDeleteCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteCatalogFileParamPtrs{}
	}
	mmDeleteCatalogFile.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteCatalogFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteCatalogFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if mmDeleteCatalogFile.mock.inspectFuncDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteCatalogFile")
	}

	mmDeleteCatalogFile.mock.inspectFuncDeleteCatalogFile = f

	return mmDeleteCatalogFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteCatalogFile
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Return(dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	if mmDeleteCatalogFile.defaultExpectation == nil {
		mmDeleteCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{mock: mmDeleteCatalogFile.mock}
	}
	mmDeleteCatalogFile.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteCatalogFileResults{dp1, err}
	mmDeleteCatalogFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalogFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteCatalogFile method
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteCatalogFile.defaultExpectation != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteCatalogFile method")
	}

	if len(mmDeleteCatalogFile.expectations) > 0 {
		mmDeleteCatalogFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteCatalogFile method")
	}

	mmDeleteCatalogFile.mock.funcDeleteCatalogFile = f
	mmDeleteCatalogFile.mock.funcDeleteCatalogFileOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalogFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteCatalogFile which will trigger the result defined by the following
// Then helper
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) When(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteCatalogFileExpectation {
	if mmDeleteCatalogFile.mock.funcDeleteCatalogFile != nil {
		mmDeleteCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteCatalogFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteCatalogFileExpectation{
		mock:               mmDeleteCatalogFile.mock,
		params:             &ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockDeleteCatalogFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCatalogFile.expectations = append(mmDeleteCatalogFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteCatalogFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteCatalogFileExpectation) Then(dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteCatalogFileResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteCatalogFile should be invoked
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Times(n uint64) *mArtifactPublicServiceClientMockDeleteCatalogFile {
	if n == 0 {
		mmDeleteCatalogFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteCatalogFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCatalogFile.expectedInvocations, n)
	mmDeleteCatalogFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCatalogFile
}

func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) invocationsDone() bool {
	if len(mmDeleteCatalogFile.expectations) == 0 && mmDeleteCatalogFile.defaultExpectation == nil && mmDeleteCatalogFile.mock.funcDeleteCatalogFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCatalogFile.mock.afterDeleteCatalogFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCatalogFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCatalogFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteCatalogFile *ArtifactPublicServiceClientMock) DeleteCatalogFile(ctx context.Context, in *mm_artifactv1alpha.DeleteCatalogFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteCatalogFileResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteCatalogFile.beforeDeleteCatalogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCatalogFile.afterDeleteCatalogFileCounter, 1)

	mmDeleteCatalogFile.t.Helper()

	if mmDeleteCatalogFile.inspectFuncDeleteCatalogFile != nil {
		mmDeleteCatalogFile.inspectFuncDeleteCatalogFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts}

	// Record call args
	mmDeleteCatalogFile.DeleteCatalogFileMock.mutex.Lock()
	mmDeleteCatalogFile.DeleteCatalogFileMock.callArgs = append(mmDeleteCatalogFile.DeleteCatalogFileMock.callArgs, &mm_params)
	mmDeleteCatalogFile.DeleteCatalogFileMock.mutex.Unlock()

	for _, e := range mmDeleteCatalogFile.DeleteCatalogFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteCatalogFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteCatalogFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCatalogFile.DeleteCatalogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCatalogFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteCatalogFile")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteCatalogFile.funcDeleteCatalogFile != nil {
		return mmDeleteCatalogFile.funcDeleteCatalogFile(ctx, in, opts...)
	}
	mmDeleteCatalogFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteCatalogFile. %v %v %v", ctx, in, opts)
	return
}

// DeleteCatalogFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteCatalogFile invocations
func (mmDeleteCatalogFile *ArtifactPublicServiceClientMock) DeleteCatalogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalogFile.afterDeleteCatalogFileCounter)
}

// DeleteCatalogFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteCatalogFile invocations
func (mmDeleteCatalogFile *ArtifactPublicServiceClientMock) DeleteCatalogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCatalogFile.beforeDeleteCatalogFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteCatalogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCatalogFile *mArtifactPublicServiceClientMockDeleteCatalogFile) Calls() []*ArtifactPublicServiceClientMockDeleteCatalogFileParams {
	mmDeleteCatalogFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteCatalogFileParams, len(mmDeleteCatalogFile.callArgs))
	copy(argCopy, mmDeleteCatalogFile.callArgs)

	mmDeleteCatalogFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCatalogFileDone returns true if the count of the DeleteCatalogFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogFileDone() bool {
	if m.DeleteCatalogFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCatalogFileMock.invocationsDone()
}

// MinimockDeleteCatalogFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteCatalogFileInspect() {
	for _, e := range m.DeleteCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCatalogFileCounter := mm_atomic.LoadUint64(&m.afterDeleteCatalogFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCatalogFileMock.defaultExpectation != nil && afterDeleteCatalogFileCounter < 1 {
		if m.DeleteCatalogFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile at\n%s", m.DeleteCatalogFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile at\n%s with params: %#v", m.DeleteCatalogFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCatalogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCatalogFile != nil && afterDeleteCatalogFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteCatalogFile at\n%s", m.funcDeleteCatalogFileOrigin)
	}

	if !m.DeleteCatalogFileMock.invocationsDone() && afterDeleteCatalogFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteCatalogFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCatalogFileMock.expectedInvocations), m.DeleteCatalogFileMock.expectedInvocationsOrigin, afterDeleteCatalogFileCounter)
	}
}

type mArtifactPublicServiceClientMockGetFileCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetFileCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockGetFileCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockGetFileCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetFileCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetFileCatalogParams
	paramPtrs          *ArtifactPublicServiceClientMockGetFileCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetFileCatalogExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetFileCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetFileCatalogParams contains parameters of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetFileCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetFileCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetFileCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetFileCatalogResults contains results of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogResults struct {
	gp1 *mm_artifactv1alpha.GetFileCatalogResponse
	err error
}

// ArtifactPublicServiceClientMockGetFileCatalogOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetFileCatalog
type ArtifactPublicServiceClientMockGetFileCatalogExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Optional() *mArtifactPublicServiceClientMockGetFileCatalog {
	mmGetFileCatalog.optional = true
	return mmGetFileCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by ExpectParams functions")
	}

	mmGetFileCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts}
	mmGetFileCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFileCatalog.expectations {
		if minimock.Equal(e.params, mmGetFileCatalog.defaultExpectation.params) {
			mmGetFileCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFileCatalog.defaultExpectation.params)
		}
	}

	return mmGetFileCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFileCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFileCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) ExpectInParam2(in *mm_artifactv1alpha.GetFileCatalogRequest) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.in = &in
	mmGetFileCatalog.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetFileCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{}
	}

	if mmGetFileCatalog.defaultExpectation.params != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Expect")
	}

	if mmGetFileCatalog.defaultExpectation.paramPtrs == nil {
		mmGetFileCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileCatalogParamPtrs{}
	}
	mmGetFileCatalog.defaultExpectation.paramPtrs.opts = &opts
	mmGetFileCatalog.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetFileCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetFileCatalog {
	if mmGetFileCatalog.mock.inspectFuncGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetFileCatalog")
	}

	mmGetFileCatalog.mock.inspectFuncGetFileCatalog = f

	return mmGetFileCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetFileCatalog
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Return(gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	if mmGetFileCatalog.defaultExpectation == nil {
		mmGetFileCatalog.defaultExpectation = &ArtifactPublicServiceClientMockGetFileCatalogExpectation{mock: mmGetFileCatalog.mock}
	}
	mmGetFileCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockGetFileCatalogResults{gp1, err}
	mmGetFileCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFileCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetFileCatalog method
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetFileCatalog.defaultExpectation != nil {
		mmGetFileCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetFileCatalog method")
	}

	if len(mmGetFileCatalog.expectations) > 0 {
		mmGetFileCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetFileCatalog method")
	}

	mmGetFileCatalog.mock.funcGetFileCatalog = f
	mmGetFileCatalog.mock.funcGetFileCatalogOrigin = minimock.CallerInfo(1)
	return mmGetFileCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetFileCatalog which will trigger the result defined by the following
// Then helper
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) When(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetFileCatalogExpectation {
	if mmGetFileCatalog.mock.funcGetFileCatalog != nil {
		mmGetFileCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFileCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetFileCatalogExpectation{
		mock:               mmGetFileCatalog.mock,
		params:             &ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetFileCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFileCatalog.expectations = append(mmGetFileCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetFileCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetFileCatalogExpectation) Then(gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetFileCatalogResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetFileCatalog should be invoked
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Times(n uint64) *mArtifactPublicServiceClientMockGetFileCatalog {
	if n == 0 {
		mmGetFileCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetFileCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFileCatalog.expectedInvocations, n)
	mmGetFileCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFileCatalog
}

func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) invocationsDone() bool {
	if len(mmGetFileCatalog.expectations) == 0 && mmGetFileCatalog.defaultExpectation == nil && mmGetFileCatalog.mock.funcGetFileCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFileCatalog.mock.afterGetFileCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFileCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFileCatalog implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetFileCatalog *ArtifactPublicServiceClientMock) GetFileCatalog(ctx context.Context, in *mm_artifactv1alpha.GetFileCatalogRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmGetFileCatalog.beforeGetFileCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFileCatalog.afterGetFileCatalogCounter, 1)

	mmGetFileCatalog.t.Helper()

	if mmGetFileCatalog.inspectFuncGetFileCatalog != nil {
		mmGetFileCatalog.inspectFuncGetFileCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts}

	// Record call args
	mmGetFileCatalog.GetFileCatalogMock.mutex.Lock()
	mmGetFileCatalog.GetFileCatalogMock.callArgs = append(mmGetFileCatalog.GetFileCatalogMock.callArgs, &mm_params)
	mmGetFileCatalog.GetFileCatalogMock.mutex.Unlock()

	for _, e := range mmGetFileCatalog.GetFileCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetFileCatalog.GetFileCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetFileCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFileCatalog.t.Errorf("ArtifactPublicServiceClientMock.GetFileCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFileCatalog.GetFileCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFileCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetFileCatalog")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetFileCatalog.funcGetFileCatalog != nil {
		return mmGetFileCatalog.funcGetFileCatalog(ctx, in, opts...)
	}
	mmGetFileCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetFileCatalog. %v %v %v", ctx, in, opts)
	return
}

// GetFileCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetFileCatalog invocations
func (mmGetFileCatalog *ArtifactPublicServiceClientMock) GetFileCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCatalog.afterGetFileCatalogCounter)
}

// GetFileCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetFileCatalog invocations
func (mmGetFileCatalog *ArtifactPublicServiceClientMock) GetFileCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFileCatalog.beforeGetFileCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetFileCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFileCatalog *mArtifactPublicServiceClientMockGetFileCatalog) Calls() []*ArtifactPublicServiceClientMockGetFileCatalogParams {
	mmGetFileCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetFileCatalogParams, len(mmGetFileCatalog.callArgs))
	copy(argCopy, mmGetFileCatalog.callArgs)

	mmGetFileCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileCatalogDone returns true if the count of the GetFileCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetFileCatalogDone() bool {
	if m.GetFileCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileCatalogMock.invocationsDone()
}

// MinimockGetFileCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetFileCatalogInspect() {
	for _, e := range m.GetFileCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCatalogCounter := mm_atomic.LoadUint64(&m.afterGetFileCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileCatalogMock.defaultExpectation != nil && afterGetFileCatalogCounter < 1 {
		if m.GetFileCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog at\n%s", m.GetFileCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog at\n%s with params: %#v", m.GetFileCatalogMock.defaultExpectation.expectationOrigins.origin, *m.GetFileCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFileCatalog != nil && afterGetFileCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFileCatalog at\n%s", m.funcGetFileCatalogOrigin)
	}

	if !m.GetFileCatalogMock.invocationsDone() && afterGetFileCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetFileCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileCatalogMock.expectedInvocations), m.GetFileCatalogMock.expectedInvocationsOrigin, afterGetFileCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockGetObjectDownloadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation
	expectations       []*ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation

	callArgs []*ArtifactPublicServiceClientMockGetObjectDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetObjectDownloadURLParams
	paramPtrs          *ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetObjectDownloadURLExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetObjectDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLParams contains parameters of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetObjectDownloadURLRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetObjectDownloadURLRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLResults contains results of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLResults struct {
	gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse
	err error
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Optional() *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	mmGetObjectDownloadURL.optional = true
	return mmGetObjectDownloadURL
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Expect(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectDownloadURL.defaultExpectation.params = &ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts}
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectDownloadURL.defaultExpectation.params) {
			mmGetObjectDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) ExpectInParam2(in *mm_artifactv1alpha.GetObjectDownloadURLRequest) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.in = &in
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.opts = &opts
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetObjectDownloadURL")
	}

	mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL = f

	return mmGetObjectDownloadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Return(gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{mock: mmGetObjectDownloadURL.mock}
	}
	mmGetObjectDownloadURL.defaultExpectation.results = &ArtifactPublicServiceClientMockGetObjectDownloadURLResults{gp1, err}
	mmGetObjectDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetObjectDownloadURL method
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetObjectDownloadURL.defaultExpectation != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetObjectDownloadURL method")
	}

	if len(mmGetObjectDownloadURL.expectations) > 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetObjectDownloadURL method")
	}

	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL = f
	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetObjectDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) When(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{
		mock:               mmGetObjectDownloadURL.mock,
		params:             &ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetObjectDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectDownloadURL.expectations = append(mmGetObjectDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetObjectDownloadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation) Then(gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetObjectDownloadURLResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetObjectDownloadURL should be invoked
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Times(n uint64) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if n == 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetObjectDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectDownloadURL.expectedInvocations, n)
	mmGetObjectDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL
}

func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) invocationsDone() bool {
	if len(mmGetObjectDownloadURL.expectations) == 0 && mmGetObjectDownloadURL.defaultExpectation == nil && mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.mock.afterGetObjectDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectDownloadURL implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetObjectDownloadURL *ArtifactPublicServiceClientMock) GetObjectDownloadURL(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter, 1)

	mmGetObjectDownloadURL.t.Helper()

	if mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts}

	// Record call args
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Lock()
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs = append(mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs, &mm_params)
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectDownloadURL.GetObjectDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectDownloadURL.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetObjectDownloadURL")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetObjectDownloadURL.funcGetObjectDownloadURL != nil {
		return mmGetObjectDownloadURL.funcGetObjectDownloadURL(ctx, in, opts...)
	}
	mmGetObjectDownloadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL. %v %v %v", ctx, in, opts)
	return
}

// GetObjectDownloadURLAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceClientMock) GetObjectDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter)
}

// GetObjectDownloadURLBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceClientMock) GetObjectDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetObjectDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Calls() []*ArtifactPublicServiceClientMockGetObjectDownloadURLParams {
	mmGetObjectDownloadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetObjectDownloadURLParams, len(mmGetObjectDownloadURL.callArgs))
	copy(argCopy, mmGetObjectDownloadURL.callArgs)

	mmGetObjectDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDownloadURLDone returns true if the count of the GetObjectDownloadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectDownloadURLDone() bool {
	if m.GetObjectDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectDownloadURLMock.invocationsDone()
}

// MinimockGetObjectDownloadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectDownloadURLInspect() {
	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectDownloadURLMock.defaultExpectation != nil && afterGetObjectDownloadURLCounter < 1 {
		if m.GetObjectDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s", m.GetObjectDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s with params: %#v", m.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectDownloadURL != nil && afterGetObjectDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s", m.funcGetObjectDownloadURLOrigin)
	}

	if !m.GetObjectDownloadURLMock.invocationsDone() && afterGetObjectDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectDownloadURLMock.expectedInvocations), m.GetObjectDownloadURLMock.expectedInvocationsOrigin, afterGetObjectDownloadURLCounter)
	}
}

type mArtifactPublicServiceClientMockGetObjectUploadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetObjectUploadURLExpectation
	expectations       []*ArtifactPublicServiceClientMockGetObjectUploadURLExpectation

	callArgs []*ArtifactPublicServiceClientMockGetObjectUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetObjectUploadURLExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetObjectUploadURLParams
	paramPtrs          *ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetObjectUploadURLExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetObjectUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetObjectUploadURLParams contains parameters of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetObjectUploadURLRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetObjectUploadURLRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectUploadURLResults contains results of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLResults struct {
	gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse
	err error
}

// ArtifactPublicServiceClientMockGetObjectUploadURLOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Optional() *mArtifactPublicServiceClientMockGetObjectUploadURL {
	mmGetObjectUploadURL.optional = true
	return mmGetObjectUploadURL
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Expect(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectUploadURL.defaultExpectation.params = &ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts}
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectUploadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectUploadURL.defaultExpectation.params) {
			mmGetObjectUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectUploadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) ExpectInParam2(in *mm_artifactv1alpha.GetObjectUploadURLRequest) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.in = &in
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.opts = &opts
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetObjectUploadURL")
	}

	mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL = f

	return mmGetObjectUploadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Return(gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{mock: mmGetObjectUploadURL.mock}
	}
	mmGetObjectUploadURL.defaultExpectation.results = &ArtifactPublicServiceClientMockGetObjectUploadURLResults{gp1, err}
	mmGetObjectUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetObjectUploadURL method
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetObjectUploadURL.defaultExpectation != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetObjectUploadURL method")
	}

	if len(mmGetObjectUploadURL.expectations) > 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetObjectUploadURL method")
	}

	mmGetObjectUploadURL.mock.funcGetObjectUploadURL = f
	mmGetObjectUploadURL.mock.funcGetObjectUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetObjectUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) When(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetObjectUploadURLExpectation {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{
		mock:               mmGetObjectUploadURL.mock,
		params:             &ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetObjectUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectUploadURL.expectations = append(mmGetObjectUploadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetObjectUploadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetObjectUploadURLExpectation) Then(gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetObjectUploadURLResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetObjectUploadURL should be invoked
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Times(n uint64) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if n == 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetObjectUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectUploadURL.expectedInvocations, n)
	mmGetObjectUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL
}

func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) invocationsDone() bool {
	if len(mmGetObjectUploadURL.expectations) == 0 && mmGetObjectUploadURL.defaultExpectation == nil && mmGetObjectUploadURL.mock.funcGetObjectUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.mock.afterGetObjectUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectUploadURL implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetObjectUploadURL *ArtifactPublicServiceClientMock) GetObjectUploadURL(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter, 1)

	mmGetObjectUploadURL.t.Helper()

	if mmGetObjectUploadURL.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.inspectFuncGetObjectUploadURL(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts}

	// Record call args
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Lock()
	mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs = append(mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs, &mm_params)
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectUploadURL.GetObjectUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectUploadURL.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetObjectUploadURL")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetObjectUploadURL.funcGetObjectUploadURL != nil {
		return mmGetObjectUploadURL.funcGetObjectUploadURL(ctx, in, opts...)
	}
	mmGetObjectUploadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetObjectUploadURL. %v %v %v", ctx, in, opts)
	return
}

// GetObjectUploadURLAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceClientMock) GetObjectUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter)
}

// GetObjectUploadURLBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceClientMock) GetObjectUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetObjectUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Calls() []*ArtifactPublicServiceClientMockGetObjectUploadURLParams {
	mmGetObjectUploadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetObjectUploadURLParams, len(mmGetObjectUploadURL.callArgs))
	copy(argCopy, mmGetObjectUploadURL.callArgs)

	mmGetObjectUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectUploadURLDone returns true if the count of the GetObjectUploadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectUploadURLDone() bool {
	if m.GetObjectUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectUploadURLMock.invocationsDone()
}

// MinimockGetObjectUploadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectUploadURLInspect() {
	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectUploadURLMock.defaultExpectation != nil && afterGetObjectUploadURLCounter < 1 {
		if m.GetObjectUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s", m.GetObjectUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s with params: %#v", m.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectUploadURL != nil && afterGetObjectUploadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s", m.funcGetObjectUploadURLOrigin)
	}

	if !m.GetObjectUploadURLMock.invocationsDone() && afterGetObjectUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectUploadURLMock.expectedInvocations), m.GetObjectUploadURLMock.expectedInvocationsOrigin, afterGetObjectUploadURLCounter)
	}
}

type mArtifactPublicServiceClientMockGetSourceFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetSourceFileExpectation
	expectations       []*ArtifactPublicServiceClientMockGetSourceFileExpectation

	callArgs []*ArtifactPublicServiceClientMockGetSourceFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetSourceFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetSourceFileParams
	paramPtrs          *ArtifactPublicServiceClientMockGetSourceFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetSourceFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetSourceFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetSourceFileParams contains parameters of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetSourceFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetSourceFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetSourceFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetSourceFileResults contains results of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileResults struct {
	gp1 *mm_artifactv1alpha.GetSourceFileResponse
	err error
}

// ArtifactPublicServiceClientMockGetSourceFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetSourceFile
type ArtifactPublicServiceClientMockGetSourceFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Optional() *mArtifactPublicServiceClientMockGetSourceFile {
	mmGetSourceFile.optional = true
	return mmGetSourceFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Expect(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by ExpectParams functions")
	}

	mmGetSourceFile.defaultExpectation.params = &ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts}
	mmGetSourceFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSourceFile.expectations {
		if minimock.Equal(e.params, mmGetSourceFile.defaultExpectation.params) {
			mmGetSourceFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSourceFile.defaultExpectation.params)
		}
	}

	return mmGetSourceFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSourceFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSourceFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) ExpectInParam2(in *mm_artifactv1alpha.GetSourceFileRequest) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.in = &in
	mmGetSourceFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetSourceFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{}
	}

	if mmGetSourceFile.defaultExpectation.params != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Expect")
	}

	if mmGetSourceFile.defaultExpectation.paramPtrs == nil {
		mmGetSourceFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetSourceFileParamPtrs{}
	}
	mmGetSourceFile.defaultExpectation.paramPtrs.opts = &opts
	mmGetSourceFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetSourceFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetSourceFile {
	if mmGetSourceFile.mock.inspectFuncGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetSourceFile")
	}

	mmGetSourceFile.mock.inspectFuncGetSourceFile = f

	return mmGetSourceFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetSourceFile
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Return(gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	if mmGetSourceFile.defaultExpectation == nil {
		mmGetSourceFile.defaultExpectation = &ArtifactPublicServiceClientMockGetSourceFileExpectation{mock: mmGetSourceFile.mock}
	}
	mmGetSourceFile.defaultExpectation.results = &ArtifactPublicServiceClientMockGetSourceFileResults{gp1, err}
	mmGetSourceFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSourceFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetSourceFile method
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetSourceFile.defaultExpectation != nil {
		mmGetSourceFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetSourceFile method")
	}

	if len(mmGetSourceFile.expectations) > 0 {
		mmGetSourceFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetSourceFile method")
	}

	mmGetSourceFile.mock.funcGetSourceFile = f
	mmGetSourceFile.mock.funcGetSourceFileOrigin = minimock.CallerInfo(1)
	return mmGetSourceFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetSourceFile which will trigger the result defined by the following
// Then helper
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) When(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetSourceFileExpectation {
	if mmGetSourceFile.mock.funcGetSourceFile != nil {
		mmGetSourceFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetSourceFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetSourceFileExpectation{
		mock:               mmGetSourceFile.mock,
		params:             &ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetSourceFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSourceFile.expectations = append(mmGetSourceFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetSourceFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetSourceFileExpectation) Then(gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetSourceFileResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetSourceFile should be invoked
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Times(n uint64) *mArtifactPublicServiceClientMockGetSourceFile {
	if n == 0 {
		mmGetSourceFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetSourceFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSourceFile.expectedInvocations, n)
	mmGetSourceFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSourceFile
}

func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) invocationsDone() bool {
	if len(mmGetSourceFile.expectations) == 0 && mmGetSourceFile.defaultExpectation == nil && mmGetSourceFile.mock.funcGetSourceFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSourceFile.mock.afterGetSourceFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSourceFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSourceFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetSourceFile *ArtifactPublicServiceClientMock) GetSourceFile(ctx context.Context, in *mm_artifactv1alpha.GetSourceFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetSourceFileResponse, err error) {
	mm_atomic.AddUint64(&mmGetSourceFile.beforeGetSourceFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSourceFile.afterGetSourceFileCounter, 1)

	mmGetSourceFile.t.Helper()

	if mmGetSourceFile.inspectFuncGetSourceFile != nil {
		mmGetSourceFile.inspectFuncGetSourceFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts}

	// Record call args
	mmGetSourceFile.GetSourceFileMock.mutex.Lock()
	mmGetSourceFile.GetSourceFileMock.callArgs = append(mmGetSourceFile.GetSourceFileMock.callArgs, &mm_params)
	mmGetSourceFile.GetSourceFileMock.mutex.Unlock()

	for _, e := range mmGetSourceFile.GetSourceFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetSourceFile.GetSourceFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSourceFile.GetSourceFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSourceFile.GetSourceFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetSourceFile.GetSourceFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetSourceFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceFile.GetSourceFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceFile.GetSourceFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSourceFile.GetSourceFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSourceFile.t.Errorf("ArtifactPublicServiceClientMock.GetSourceFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSourceFile.GetSourceFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSourceFile.GetSourceFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSourceFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetSourceFile")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetSourceFile.funcGetSourceFile != nil {
		return mmGetSourceFile.funcGetSourceFile(ctx, in, opts...)
	}
	mmGetSourceFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetSourceFile. %v %v %v", ctx, in, opts)
	return
}

// GetSourceFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetSourceFile invocations
func (mmGetSourceFile *ArtifactPublicServiceClientMock) GetSourceFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceFile.afterGetSourceFileCounter)
}

// GetSourceFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetSourceFile invocations
func (mmGetSourceFile *ArtifactPublicServiceClientMock) GetSourceFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSourceFile.beforeGetSourceFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetSourceFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSourceFile *mArtifactPublicServiceClientMockGetSourceFile) Calls() []*ArtifactPublicServiceClientMockGetSourceFileParams {
	mmGetSourceFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetSourceFileParams, len(mmGetSourceFile.callArgs))
	copy(argCopy, mmGetSourceFile.callArgs)

	mmGetSourceFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetSourceFileDone returns true if the count of the GetSourceFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetSourceFileDone() bool {
	if m.GetSourceFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSourceFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSourceFileMock.invocationsDone()
}

// MinimockGetSourceFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetSourceFileInspect() {
	for _, e := range m.GetSourceFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetSourceFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSourceFileCounter := mm_atomic.LoadUint64(&m.afterGetSourceFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSourceFileMock.defaultExpectation != nil && afterGetSourceFileCounter < 1 {
		if m.GetSourceFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetSourceFile at\n%s", m.GetSourceFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetSourceFile at\n%s with params: %#v", m.GetSourceFileMock.defaultExpectation.expectationOrigins.origin, *m.GetSourceFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSourceFile != nil && afterGetSourceFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetSourceFile at\n%s", m.funcGetSourceFileOrigin)
	}

	if !m.GetSourceFileMock.invocationsDone() && afterGetSourceFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetSourceFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSourceFileMock.expectedInvocations), m.GetSourceFileMock.expectedInvocationsOrigin, afterGetSourceFileCounter)
	}
}

type mArtifactPublicServiceClientMockListCatalogFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListCatalogFilesExpectation
	expectations       []*ArtifactPublicServiceClientMockListCatalogFilesExpectation

	callArgs []*ArtifactPublicServiceClientMockListCatalogFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListCatalogFilesExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListCatalogFilesParams
	paramPtrs          *ArtifactPublicServiceClientMockListCatalogFilesParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListCatalogFilesExpectationOrigins
	results            *ArtifactPublicServiceClientMockListCatalogFilesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListCatalogFilesParams contains parameters of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListCatalogFilesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListCatalogFilesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogFilesResults contains results of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesResults struct {
	lp1 *mm_artifactv1alpha.ListCatalogFilesResponse
	err error
}

// ArtifactPublicServiceClientMockListCatalogFilesOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListCatalogFiles
type ArtifactPublicServiceClientMockListCatalogFilesExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Optional() *mArtifactPublicServiceClientMockListCatalogFiles {
	mmListCatalogFiles.optional = true
	return mmListCatalogFiles
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Expect(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by ExpectParams functions")
	}

	mmListCatalogFiles.defaultExpectation.params = &ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts}
	mmListCatalogFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCatalogFiles.expectations {
		if minimock.Equal(e.params, mmListCatalogFiles.defaultExpectation.params) {
			mmListCatalogFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogFiles.defaultExpectation.params)
		}
	}

	return mmListCatalogFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCatalogFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCatalogFiles
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) ExpectInParam2(in *mm_artifactv1alpha.ListCatalogFilesRequest) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.in = &in
	mmListCatalogFiles.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListCatalogFiles
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{}
	}

	if mmListCatalogFiles.defaultExpectation.params != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Expect")
	}

	if mmListCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmListCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogFilesParamPtrs{}
	}
	mmListCatalogFiles.defaultExpectation.paramPtrs.opts = &opts
	mmListCatalogFiles.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListCatalogFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListCatalogFiles {
	if mmListCatalogFiles.mock.inspectFuncListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListCatalogFiles")
	}

	mmListCatalogFiles.mock.inspectFuncListCatalogFiles = f

	return mmListCatalogFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListCatalogFiles
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Return(lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	if mmListCatalogFiles.defaultExpectation == nil {
		mmListCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogFilesExpectation{mock: mmListCatalogFiles.mock}
	}
	mmListCatalogFiles.defaultExpectation.results = &ArtifactPublicServiceClientMockListCatalogFilesResults{lp1, err}
	mmListCatalogFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCatalogFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListCatalogFiles method
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListCatalogFiles.defaultExpectation != nil {
		mmListCatalogFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListCatalogFiles method")
	}

	if len(mmListCatalogFiles.expectations) > 0 {
		mmListCatalogFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListCatalogFiles method")
	}

	mmListCatalogFiles.mock.funcListCatalogFiles = f
	mmListCatalogFiles.mock.funcListCatalogFilesOrigin = minimock.CallerInfo(1)
	return mmListCatalogFiles.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListCatalogFiles which will trigger the result defined by the following
// Then helper
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) When(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListCatalogFilesExpectation {
	if mmListCatalogFiles.mock.funcListCatalogFiles != nil {
		mmListCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListCatalogFilesExpectation{
		mock:               mmListCatalogFiles.mock,
		params:             &ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListCatalogFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCatalogFiles.expectations = append(mmListCatalogFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListCatalogFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListCatalogFilesExpectation) Then(lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListCatalogFilesResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListCatalogFiles should be invoked
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Times(n uint64) *mArtifactPublicServiceClientMockListCatalogFiles {
	if n == 0 {
		mmListCatalogFiles.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListCatalogFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogFiles.expectedInvocations, n)
	mmListCatalogFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCatalogFiles
}

func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) invocationsDone() bool {
	if len(mmListCatalogFiles.expectations) == 0 && mmListCatalogFiles.defaultExpectation == nil && mmListCatalogFiles.mock.funcListCatalogFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogFiles.mock.afterListCatalogFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogFiles implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListCatalogFiles *ArtifactPublicServiceClientMock) ListCatalogFiles(ctx context.Context, in *mm_artifactv1alpha.ListCatalogFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogFilesResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogFiles.beforeListCatalogFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogFiles.afterListCatalogFilesCounter, 1)

	mmListCatalogFiles.t.Helper()

	if mmListCatalogFiles.inspectFuncListCatalogFiles != nil {
		mmListCatalogFiles.inspectFuncListCatalogFiles(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts}

	// Record call args
	mmListCatalogFiles.ListCatalogFilesMock.mutex.Lock()
	mmListCatalogFiles.ListCatalogFilesMock.callArgs = append(mmListCatalogFiles.ListCatalogFilesMock.callArgs, &mm_params)
	mmListCatalogFiles.ListCatalogFilesMock.mutex.Unlock()

	for _, e := range mmListCatalogFiles.ListCatalogFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListCatalogFilesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogFiles.ListCatalogFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogFiles.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListCatalogFiles")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListCatalogFiles.funcListCatalogFiles != nil {
		return mmListCatalogFiles.funcListCatalogFiles(ctx, in, opts...)
	}
	mmListCatalogFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListCatalogFiles. %v %v %v", ctx, in, opts)
	return
}

// ListCatalogFilesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListCatalogFiles invocations
func (mmListCatalogFiles *ArtifactPublicServiceClientMock) ListCatalogFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogFiles.afterListCatalogFilesCounter)
}

// ListCatalogFilesBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListCatalogFiles invocations
func (mmListCatalogFiles *ArtifactPublicServiceClientMock) ListCatalogFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogFiles.beforeListCatalogFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListCatalogFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogFiles *mArtifactPublicServiceClientMockListCatalogFiles) Calls() []*ArtifactPublicServiceClientMockListCatalogFilesParams {
	mmListCatalogFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListCatalogFilesParams, len(mmListCatalogFiles.callArgs))
	copy(argCopy, mmListCatalogFiles.callArgs)

	mmListCatalogFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogFilesDone returns true if the count of the ListCatalogFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogFilesDone() bool {
	if m.ListCatalogFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogFilesMock.invocationsDone()
}

// MinimockListCatalogFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogFilesInspect() {
	for _, e := range m.ListCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCatalogFilesCounter := mm_atomic.LoadUint64(&m.afterListCatalogFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogFilesMock.defaultExpectation != nil && afterListCatalogFilesCounter < 1 {
		if m.ListCatalogFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles at\n%s", m.ListCatalogFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles at\n%s with params: %#v", m.ListCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *m.ListCatalogFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogFiles != nil && afterListCatalogFilesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogFiles at\n%s", m.funcListCatalogFilesOrigin)
	}

	if !m.ListCatalogFilesMock.invocationsDone() && afterListCatalogFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListCatalogFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogFilesMock.expectedInvocations), m.ListCatalogFilesMock.expectedInvocationsOrigin, afterListCatalogFilesCounter)
	}
}

type mArtifactPublicServiceClientMockListCatalogRuns struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListCatalogRunsExpectation
	expectations       []*ArtifactPublicServiceClientMockListCatalogRunsExpectation

	callArgs []*ArtifactPublicServiceClientMockListCatalogRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListCatalogRunsExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListCatalogRuns
type ArtifactPublicServiceClientMockListCatalogRunsExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListCatalogRunsParams
	paramPtrs          *ArtifactPublicServiceClientMockListCatalogRunsParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListCatalogRunsExpectationOrigins
	results            *ArtifactPublicServiceClientMockListCatalogRunsResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListCatalogRunsParams contains parameters of the ArtifactPublicServiceClient.ListCatalogRuns
type ArtifactPublicServiceClientMockListCatalogRunsParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListCatalogRunsRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogRunsParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListCatalogRuns
type ArtifactPublicServiceClientMockListCatalogRunsParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListCatalogRunsRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogRunsResults contains results of the ArtifactPublicServiceClient.ListCatalogRuns
type ArtifactPublicServiceClientMockListCatalogRunsResults struct {
	lp1 *mm_artifactv1alpha.ListCatalogRunsResponse
	err error
}

// ArtifactPublicServiceClientMockListCatalogRunsOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListCatalogRuns
type ArtifactPublicServiceClientMockListCatalogRunsExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) Optional() *mArtifactPublicServiceClientMockListCatalogRuns {
	mmListCatalogRuns.optional = true
	return mmListCatalogRuns
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) Expect(ctx context.Context, in *mm_artifactv1alpha.ListCatalogRunsRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogRuns {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogRunsExpectation{}
	}

	if mmListCatalogRuns.defaultExpectation.paramPtrs != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by ExpectParams functions")
	}

	mmListCatalogRuns.defaultExpectation.params = &ArtifactPublicServiceClientMockListCatalogRunsParams{ctx, in, opts}
	mmListCatalogRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCatalogRuns.expectations {
		if minimock.Equal(e.params, mmListCatalogRuns.defaultExpectation.params) {
			mmListCatalogRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogRuns.defaultExpectation.params)
		}
	}

	return mmListCatalogRuns
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListCatalogRuns {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogRunsExpectation{}
	}

	if mmListCatalogRuns.defaultExpectation.params != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Expect")
	}

	if mmListCatalogRuns.defaultExpectation.paramPtrs == nil {
		mmListCatalogRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogRunsParamPtrs{}
	}
	mmListCatalogRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCatalogRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCatalogRuns
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) ExpectInParam2(in *mm_artifactv1alpha.ListCatalogRunsRequest) *mArtifactPublicServiceClientMockListCatalogRuns {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogRunsExpectation{}
	}

	if mmListCatalogRuns.defaultExpectation.params != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Expect")
	}

	if mmListCatalogRuns.defaultExpectation.paramPtrs == nil {
		mmListCatalogRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogRunsParamPtrs{}
	}
	mmListCatalogRuns.defaultExpectation.paramPtrs.in = &in
	mmListCatalogRuns.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListCatalogRuns
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogRuns {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogRunsExpectation{}
	}

	if mmListCatalogRuns.defaultExpectation.params != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Expect")
	}

	if mmListCatalogRuns.defaultExpectation.paramPtrs == nil {
		mmListCatalogRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogRunsParamPtrs{}
	}
	mmListCatalogRuns.defaultExpectation.paramPtrs.opts = &opts
	mmListCatalogRuns.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListCatalogRuns
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogRunsRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListCatalogRuns {
	if mmListCatalogRuns.mock.inspectFuncListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListCatalogRuns")
	}

	mmListCatalogRuns.mock.inspectFuncListCatalogRuns = f

	return mmListCatalogRuns
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListCatalogRuns
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) Return(lp1 *mm_artifactv1alpha.ListCatalogRunsResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Set")
	}

	if mmListCatalogRuns.defaultExpectation == nil {
		mmListCatalogRuns.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogRunsExpectation{mock: mmListCatalogRuns.mock}
	}
	mmListCatalogRuns.defaultExpectation.results = &ArtifactPublicServiceClientMockListCatalogRunsResults{lp1, err}
	mmListCatalogRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCatalogRuns.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListCatalogRuns method
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogRunsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogRunsResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListCatalogRuns.defaultExpectation != nil {
		mmListCatalogRuns.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListCatalogRuns method")
	}

	if len(mmListCatalogRuns.expectations) > 0 {
		mmListCatalogRuns.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListCatalogRuns method")
	}

	mmListCatalogRuns.mock.funcListCatalogRuns = f
	mmListCatalogRuns.mock.funcListCatalogRunsOrigin = minimock.CallerInfo(1)
	return mmListCatalogRuns.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListCatalogRuns which will trigger the result defined by the following
// Then helper
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) When(ctx context.Context, in *mm_artifactv1alpha.ListCatalogRunsRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListCatalogRunsExpectation {
	if mmListCatalogRuns.mock.funcListCatalogRuns != nil {
		mmListCatalogRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogRuns mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListCatalogRunsExpectation{
		mock:               mmListCatalogRuns.mock,
		params:             &ArtifactPublicServiceClientMockListCatalogRunsParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListCatalogRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCatalogRuns.expectations = append(mmListCatalogRuns.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListCatalogRuns return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListCatalogRunsExpectation) Then(lp1 *mm_artifactv1alpha.ListCatalogRunsResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListCatalogRunsResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListCatalogRuns should be invoked
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) Times(n uint64) *mArtifactPublicServiceClientMockListCatalogRuns {
	if n == 0 {
		mmListCatalogRuns.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListCatalogRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogRuns.expectedInvocations, n)
	mmListCatalogRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCatalogRuns
}

func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) invocationsDone() bool {
	if len(mmListCatalogRuns.expectations) == 0 && mmListCatalogRuns.defaultExpectation == nil && mmListCatalogRuns.mock.funcListCatalogRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogRuns.mock.afterListCatalogRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogRuns implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListCatalogRuns *ArtifactPublicServiceClientMock) ListCatalogRuns(ctx context.Context, in *mm_artifactv1alpha.ListCatalogRunsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogRunsResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogRuns.beforeListCatalogRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogRuns.afterListCatalogRunsCounter, 1)

	mmListCatalogRuns.t.Helper()

	if mmListCatalogRuns.inspectFuncListCatalogRuns != nil {
		mmListCatalogRuns.inspectFuncListCatalogRuns(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListCatalogRunsParams{ctx, in, opts}

	// Record call args
	mmListCatalogRuns.ListCatalogRunsMock.mutex.Lock()
	mmListCatalogRuns.ListCatalogRunsMock.callArgs = append(mmListCatalogRuns.ListCatalogRunsMock.callArgs, &mm_params)
	mmListCatalogRuns.ListCatalogRunsMock.mutex.Unlock()

	for _, e := range mmListCatalogRuns.ListCatalogRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListCatalogRunsParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogRuns.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListCatalogRuns.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogRuns got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListCatalogRuns.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogRuns got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogRuns.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogRuns.ListCatalogRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogRuns.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListCatalogRuns")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListCatalogRuns.funcListCatalogRuns != nil {
		return mmListCatalogRuns.funcListCatalogRuns(ctx, in, opts...)
	}
	mmListCatalogRuns.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListCatalogRuns. %v %v %v", ctx, in, opts)
	return
}

// ListCatalogRunsAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListCatalogRuns invocations
func (mmListCatalogRuns *ArtifactPublicServiceClientMock) ListCatalogRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogRuns.afterListCatalogRunsCounter)
}

// ListCatalogRunsBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListCatalogRuns invocations
func (mmListCatalogRuns *ArtifactPublicServiceClientMock) ListCatalogRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogRuns.beforeListCatalogRunsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListCatalogRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogRuns *mArtifactPublicServiceClientMockListCatalogRuns) Calls() []*ArtifactPublicServiceClientMockListCatalogRunsParams {
	mmListCatalogRuns.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListCatalogRunsParams, len(mmListCatalogRuns.callArgs))
	copy(argCopy, mmListCatalogRuns.callArgs)

	mmListCatalogRuns.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogRunsDone returns true if the count of the ListCatalogRuns invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogRunsDone() bool {
	if m.ListCatalogRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogRunsMock.invocationsDone()
}

// MinimockListCatalogRunsInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogRunsInspect() {
	for _, e := range m.ListCatalogRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCatalogRunsCounter := mm_atomic.LoadUint64(&m.afterListCatalogRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogRunsMock.defaultExpectation != nil && afterListCatalogRunsCounter < 1 {
		if m.ListCatalogRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogRuns at\n%s", m.ListCatalogRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogRuns at\n%s with params: %#v", m.ListCatalogRunsMock.defaultExpectation.expectationOrigins.origin, *m.ListCatalogRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogRuns != nil && afterListCatalogRunsCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogRuns at\n%s", m.funcListCatalogRunsOrigin)
	}

	if !m.ListCatalogRunsMock.invocationsDone() && afterListCatalogRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListCatalogRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogRunsMock.expectedInvocations), m.ListCatalogRunsMock.expectedInvocationsOrigin, afterListCatalogRunsCounter)
	}
}

type mArtifactPublicServiceClientMockListCatalogs struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListCatalogsExpectation
	expectations       []*ArtifactPublicServiceClientMockListCatalogsExpectation

	callArgs []*ArtifactPublicServiceClientMockListCatalogsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListCatalogsExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListCatalogsParams
	paramPtrs          *ArtifactPublicServiceClientMockListCatalogsParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListCatalogsExpectationOrigins
	results            *ArtifactPublicServiceClientMockListCatalogsResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListCatalogsParams contains parameters of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListCatalogsRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogsParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListCatalogsRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListCatalogsResults contains results of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsResults struct {
	lp1 *mm_artifactv1alpha.ListCatalogsResponse
	err error
}

// ArtifactPublicServiceClientMockListCatalogsOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListCatalogs
type ArtifactPublicServiceClientMockListCatalogsExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Optional() *mArtifactPublicServiceClientMockListCatalogs {
	mmListCatalogs.optional = true
	return mmListCatalogs
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Expect(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.paramPtrs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by ExpectParams functions")
	}

	mmListCatalogs.defaultExpectation.params = &ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts}
	mmListCatalogs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCatalogs.expectations {
		if minimock.Equal(e.params, mmListCatalogs.defaultExpectation.params) {
			mmListCatalogs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCatalogs.defaultExpectation.params)
		}
	}

	return mmListCatalogs
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCatalogs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCatalogs
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) ExpectInParam2(in *mm_artifactv1alpha.ListCatalogsRequest) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.in = &in
	mmListCatalogs.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListCatalogs
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{}
	}

	if mmListCatalogs.defaultExpectation.params != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Expect")
	}

	if mmListCatalogs.defaultExpectation.paramPtrs == nil {
		mmListCatalogs.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListCatalogsParamPtrs{}
	}
	mmListCatalogs.defaultExpectation.paramPtrs.opts = &opts
	mmListCatalogs.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListCatalogs
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListCatalogs {
	if mmListCatalogs.mock.inspectFuncListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListCatalogs")
	}

	mmListCatalogs.mock.inspectFuncListCatalogs = f

	return mmListCatalogs
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListCatalogs
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Return(lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	if mmListCatalogs.defaultExpectation == nil {
		mmListCatalogs.defaultExpectation = &ArtifactPublicServiceClientMockListCatalogsExpectation{mock: mmListCatalogs.mock}
	}
	mmListCatalogs.defaultExpectation.results = &ArtifactPublicServiceClientMockListCatalogsResults{lp1, err}
	mmListCatalogs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCatalogs.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListCatalogs method
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListCatalogs.defaultExpectation != nil {
		mmListCatalogs.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListCatalogs method")
	}

	if len(mmListCatalogs.expectations) > 0 {
		mmListCatalogs.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListCatalogs method")
	}

	mmListCatalogs.mock.funcListCatalogs = f
	mmListCatalogs.mock.funcListCatalogsOrigin = minimock.CallerInfo(1)
	return mmListCatalogs.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListCatalogs which will trigger the result defined by the following
// Then helper
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) When(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListCatalogsExpectation {
	if mmListCatalogs.mock.funcListCatalogs != nil {
		mmListCatalogs.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListCatalogs mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListCatalogsExpectation{
		mock:               mmListCatalogs.mock,
		params:             &ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListCatalogsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCatalogs.expectations = append(mmListCatalogs.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListCatalogs return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListCatalogsExpectation) Then(lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListCatalogsResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListCatalogs should be invoked
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Times(n uint64) *mArtifactPublicServiceClientMockListCatalogs {
	if n == 0 {
		mmListCatalogs.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListCatalogs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCatalogs.expectedInvocations, n)
	mmListCatalogs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCatalogs
}

func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) invocationsDone() bool {
	if len(mmListCatalogs.expectations) == 0 && mmListCatalogs.defaultExpectation == nil && mmListCatalogs.mock.funcListCatalogs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCatalogs.mock.afterListCatalogsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCatalogs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCatalogs implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListCatalogs *ArtifactPublicServiceClientMock) ListCatalogs(ctx context.Context, in *mm_artifactv1alpha.ListCatalogsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListCatalogsResponse, err error) {
	mm_atomic.AddUint64(&mmListCatalogs.beforeListCatalogsCounter, 1)
	defer mm_atomic.AddUint64(&mmListCatalogs.afterListCatalogsCounter, 1)

	mmListCatalogs.t.Helper()

	if mmListCatalogs.inspectFuncListCatalogs != nil {
		mmListCatalogs.inspectFuncListCatalogs(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts}

	// Record call args
	mmListCatalogs.ListCatalogsMock.mutex.Lock()
	mmListCatalogs.ListCatalogsMock.callArgs = append(mmListCatalogs.ListCatalogsMock.callArgs, &mm_params)
	mmListCatalogs.ListCatalogsMock.mutex.Unlock()

	for _, e := range mmListCatalogs.ListCatalogsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListCatalogs.ListCatalogsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCatalogs.ListCatalogsMock.defaultExpectation.Counter, 1)
		mm_want := mmListCatalogs.ListCatalogsMock.defaultExpectation.params
		mm_want_ptrs := mmListCatalogs.ListCatalogsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListCatalogsParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogs.ListCatalogsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogs.ListCatalogsMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCatalogs.ListCatalogsMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCatalogs.t.Errorf("ArtifactPublicServiceClientMock.ListCatalogs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCatalogs.ListCatalogsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCatalogs.ListCatalogsMock.defaultExpectation.results
		if mm_results == nil {
			mmListCatalogs.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListCatalogs")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListCatalogs.funcListCatalogs != nil {
		return mmListCatalogs.funcListCatalogs(ctx, in, opts...)
	}
	mmListCatalogs.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListCatalogs. %v %v %v", ctx, in, opts)
	return
}

// ListCatalogsAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListCatalogs invocations
func (mmListCatalogs *ArtifactPublicServiceClientMock) ListCatalogsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogs.afterListCatalogsCounter)
}

// ListCatalogsBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListCatalogs invocations
func (mmListCatalogs *ArtifactPublicServiceClientMock) ListCatalogsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCatalogs.beforeListCatalogsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListCatalogs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCatalogs *mArtifactPublicServiceClientMockListCatalogs) Calls() []*ArtifactPublicServiceClientMockListCatalogsParams {
	mmListCatalogs.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListCatalogsParams, len(mmListCatalogs.callArgs))
	copy(argCopy, mmListCatalogs.callArgs)

	mmListCatalogs.mutex.RUnlock()

	return argCopy
}

// MinimockListCatalogsDone returns true if the count of the ListCatalogs invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogsDone() bool {
	if m.ListCatalogsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCatalogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCatalogsMock.invocationsDone()
}

// MinimockListCatalogsInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListCatalogsInspect() {
	for _, e := range m.ListCatalogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCatalogsCounter := mm_atomic.LoadUint64(&m.afterListCatalogsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCatalogsMock.defaultExpectation != nil && afterListCatalogsCounter < 1 {
		if m.ListCatalogsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogs at\n%s", m.ListCatalogsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogs at\n%s with params: %#v", m.ListCatalogsMock.defaultExpectation.expectationOrigins.origin, *m.ListCatalogsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCatalogs != nil && afterListCatalogsCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListCatalogs at\n%s", m.funcListCatalogsOrigin)
	}

	if !m.ListCatalogsMock.invocationsDone() && afterListCatalogsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListCatalogs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCatalogsMock.expectedInvocations), m.ListCatalogsMock.expectedInvocationsOrigin, afterListCatalogsCounter)
	}
}

type mArtifactPublicServiceClientMockListChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListChunksExpectation
	expectations       []*ArtifactPublicServiceClientMockListChunksExpectation

	callArgs []*ArtifactPublicServiceClientMockListChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListChunksExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListChunksParams
	paramPtrs          *ArtifactPublicServiceClientMockListChunksParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListChunksExpectationOrigins
	results            *ArtifactPublicServiceClientMockListChunksResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListChunksParams contains parameters of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListChunksRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListChunksRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListChunksResults contains results of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksResults struct {
	lp1 *mm_artifactv1alpha.ListChunksResponse
	err error
}

// ArtifactPublicServiceClientMockListChunksOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Optional() *mArtifactPublicServiceClientMockListChunks {
	mmListChunks.optional = true
	return mmListChunks
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Expect(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.paramPtrs != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by ExpectParams functions")
	}

	mmListChunks.defaultExpectation.params = &ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}
	mmListChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListChunks.expectations {
		if minimock.Equal(e.params, mmListChunks.defaultExpectation.params) {
			mmListChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListChunks.defaultExpectation.params)
		}
	}

	return mmListChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmListChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListChunks
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectInParam2(in *mm_artifactv1alpha.ListChunksRequest) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.in = &in
	mmListChunks.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListChunks
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.opts = &opts
	mmListChunks.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.inspectFuncListChunks != nil {
		mmListChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListChunks")
	}

	mmListChunks.mock.inspectFuncListChunks = f

	return mmListChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Return(lp1 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{mock: mmListChunks.mock}
	}
	mmListChunks.defaultExpectation.results = &ArtifactPublicServiceClientMockListChunksResults{lp1, err}
	mmListChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListChunks method
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListChunks.defaultExpectation != nil {
		mmListChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListChunks method")
	}

	if len(mmListChunks.expectations) > 0 {
		mmListChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListChunks method")
	}

	mmListChunks.mock.funcListChunks = f
	mmListChunks.mock.funcListChunksOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListChunks which will trigger the result defined by the following
// Then helper
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) When(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListChunksExpectation {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListChunksExpectation{
		mock:               mmListChunks.mock,
		params:             &ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListChunks.expectations = append(mmListChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListChunksExpectation) Then(lp1 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListChunksResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListChunks should be invoked
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Times(n uint64) *mArtifactPublicServiceClientMockListChunks {
	if n == 0 {
		mmListChunks.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListChunks.expectedInvocations, n)
	mmListChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListChunks
}

func (mmListChunks *mArtifactPublicServiceClientMockListChunks) invocationsDone() bool {
	if len(mmListChunks.expectations) == 0 && mmListChunks.defaultExpectation == nil && mmListChunks.mock.funcListChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListChunks.mock.afterListChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListChunks implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunks(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error) {
	mm_atomic.AddUint64(&mmListChunks.beforeListChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmListChunks.afterListChunksCounter, 1)

	mmListChunks.t.Helper()

	if mmListChunks.inspectFuncListChunks != nil {
		mmListChunks.inspectFuncListChunks(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}

	// Record call args
	mmListChunks.ListChunksMock.mutex.Lock()
	mmListChunks.ListChunksMock.callArgs = append(mmListChunks.ListChunksMock.callArgs, &mm_params)
	mmListChunks.ListChunksMock.mutex.Unlock()

	for _, e := range mmListChunks.ListChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListChunks.ListChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListChunks.ListChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmListChunks.ListChunksMock.defaultExpectation.params
		mm_want_ptrs := mmListChunks.ListChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListChunks.ListChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmListChunks.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListChunks")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListChunks.funcListChunks != nil {
		return mmListChunks.funcListChunks(ctx, in, opts...)
	}
	mmListChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListChunks. %v %v %v", ctx, in, opts)
	return
}

// ListChunksAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.afterListChunksCounter)
}

// ListChunksBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.beforeListChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Calls() []*ArtifactPublicServiceClientMockListChunksParams {
	mmListChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListChunksParams, len(mmListChunks.callArgs))
	copy(argCopy, mmListChunks.callArgs)

	mmListChunks.mutex.RUnlock()

	return argCopy
}

// MinimockListChunksDone returns true if the count of the ListChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListChunksDone() bool {
	if m.ListChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListChunksMock.invocationsDone()
}

// MinimockListChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListChunksInspect() {
	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListChunksCounter := mm_atomic.LoadUint64(&m.afterListChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListChunksMock.defaultExpectation != nil && afterListChunksCounter < 1 {
		if m.ListChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s", m.ListChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s with params: %#v", m.ListChunksMock.defaultExpectation.expectationOrigins.origin, *m.ListChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListChunks != nil && afterListChunksCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s", m.funcListChunksOrigin)
	}

	if !m.ListChunksMock.invocationsDone() && afterListChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListChunksMock.expectedInvocations), m.ListChunksMock.expectedInvocationsOrigin, afterListChunksCounter)
	}
}

type mArtifactPublicServiceClientMockLiveness struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockLivenessExpectation
	expectations       []*ArtifactPublicServiceClientMockLivenessExpectation

	callArgs []*ArtifactPublicServiceClientMockLivenessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockLivenessExpectation specifies expectation struct of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockLivenessParams
	paramPtrs          *ArtifactPublicServiceClientMockLivenessParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockLivenessExpectationOrigins
	results            *ArtifactPublicServiceClientMockLivenessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockLivenessParams contains parameters of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.LivenessRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockLivenessParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.LivenessRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockLivenessResults contains results of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessResults struct {
	lp1 *mm_artifactv1alpha.LivenessResponse
	err error
}

// ArtifactPublicServiceClientMockLivenessOrigins contains origins of expectations of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Optional() *mArtifactPublicServiceClientMockLiveness {
	mmLiveness.optional = true
	return mmLiveness
}

// Expect sets up expected params for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Expect(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.paramPtrs != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by ExpectParams functions")
	}

	mmLiveness.defaultExpectation.params = &ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}
	mmLiveness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLiveness.expectations {
		if minimock.Equal(e.params, mmLiveness.defaultExpectation.params) {
			mmLiveness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLiveness.defaultExpectation.params)
		}
	}

	return mmLiveness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.ctx = &ctx
	mmLiveness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectInParam2(in *mm_artifactv1alpha.LivenessRequest) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.in = &in
	mmLiveness.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.opts = &opts
	mmLiveness.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmLiveness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.inspectFuncLiveness != nil {
		mmLiveness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.Liveness")
	}

	mmLiveness.mock.inspectFuncLiveness = f

	return mmLiveness
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Return(lp1 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceClientMock {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{mock: mmLiveness.mock}
	}
	mmLiveness.defaultExpectation.results = &ArtifactPublicServiceClientMockLivenessResults{lp1, err}
	mmLiveness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.Liveness method
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Set(f func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmLiveness.defaultExpectation != nil {
		mmLiveness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.Liveness method")
	}

	if len(mmLiveness.expectations) > 0 {
		mmLiveness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.Liveness method")
	}

	mmLiveness.mock.funcLiveness = f
	mmLiveness.mock.funcLivenessOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// When sets expectation for the ArtifactPublicServiceClient.Liveness which will trigger the result defined by the following
// Then helper
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) When(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockLivenessExpectation {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockLivenessExpectation{
		mock:               mmLiveness.mock,
		params:             &ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockLivenessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLiveness.expectations = append(mmLiveness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.Liveness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockLivenessExpectation) Then(lp1 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockLivenessResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.Liveness should be invoked
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Times(n uint64) *mArtifactPublicServiceClientMockLiveness {
	if n == 0 {
		mmLiveness.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.Liveness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLiveness.expectedInvocations, n)
	mmLiveness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLiveness
}

func (mmLiveness *mArtifactPublicServiceClientMockLiveness) invocationsDone() bool {
	if len(mmLiveness.expectations) == 0 && mmLiveness.defaultExpectation == nil && mmLiveness.mock.funcLiveness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLiveness.mock.afterLivenessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLiveness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Liveness implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmLiveness *ArtifactPublicServiceClientMock) Liveness(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error) {
	mm_atomic.AddUint64(&mmLiveness.beforeLivenessCounter, 1)
	defer mm_atomic.AddUint64(&mmLiveness.afterLivenessCounter, 1)

	mmLiveness.t.Helper()

	if mmLiveness.inspectFuncLiveness != nil {
		mmLiveness.inspectFuncLiveness(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}

	// Record call args
	mmLiveness.LivenessMock.mutex.Lock()
	mmLiveness.LivenessMock.callArgs = append(mmLiveness.LivenessMock.callArgs, &mm_params)
	mmLiveness.LivenessMock.mutex.Unlock()

	for _, e := range mmLiveness.LivenessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmLiveness.LivenessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLiveness.LivenessMock.defaultExpectation.Counter, 1)
		mm_want := mmLiveness.LivenessMock.defaultExpectation.params
		mm_want_ptrs := mmLiveness.LivenessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLiveness.LivenessMock.defaultExpectation.results
		if mm_results == nil {
			mmLiveness.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.Liveness")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmLiveness.funcLiveness != nil {
		return mmLiveness.funcLiveness(ctx, in, opts...)
	}
	mmLiveness.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.Liveness. %v %v %v", ctx, in, opts)
	return
}

// LivenessAfterCounter returns a count of finished ArtifactPublicServiceClientMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceClientMock) LivenessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.afterLivenessCounter)
}

// LivenessBeforeCounter returns a count of ArtifactPublicServiceClientMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceClientMock) LivenessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.beforeLivenessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.Liveness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Calls() []*ArtifactPublicServiceClientMockLivenessParams {
	mmLiveness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockLivenessParams, len(mmLiveness.callArgs))
	copy(argCopy, mmLiveness.callArgs)

	mmLiveness.mutex.RUnlock()

	return argCopy
}

// MinimockLivenessDone returns true if the count of the Liveness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockLivenessDone() bool {
	if m.LivenessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LivenessMock.invocationsDone()
}

// MinimockLivenessInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockLivenessInspect() {
	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLivenessCounter := mm_atomic.LoadUint64(&m.afterLivenessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LivenessMock.defaultExpectation != nil && afterLivenessCounter < 1 {
		if m.LivenessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s", m.LivenessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s with params: %#v", m.LivenessMock.defaultExpectation.expectationOrigins.origin, *m.LivenessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLiveness != nil && afterLivenessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s", m.funcLivenessOrigin)
	}

	if !m.LivenessMock.invocationsDone() && afterLivenessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.Liveness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LivenessMock.expectedInvocations), m.LivenessMock.expectedInvocationsOrigin, afterLivenessCounter)
	}
}

type mArtifactPublicServiceClientMockProcessCatalogFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockProcessCatalogFilesExpectation
	expectations       []*ArtifactPublicServiceClientMockProcessCatalogFilesExpectation

	callArgs []*ArtifactPublicServiceClientMockProcessCatalogFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockProcessCatalogFilesExpectation specifies expectation struct of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockProcessCatalogFilesParams
	paramPtrs          *ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockProcessCatalogFilesExpectationOrigins
	results            *ArtifactPublicServiceClientMockProcessCatalogFilesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockProcessCatalogFilesParams contains parameters of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ProcessCatalogFilesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ProcessCatalogFilesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockProcessCatalogFilesResults contains results of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesResults struct {
	pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse
	err error
}

// ArtifactPublicServiceClientMockProcessCatalogFilesOrigins contains origins of expectations of the ArtifactPublicServiceClient.ProcessCatalogFiles
type ArtifactPublicServiceClientMockProcessCatalogFilesExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Optional() *mArtifactPublicServiceClientMockProcessCatalogFiles {
	mmProcessCatalogFiles.optional = true
	return mmProcessCatalogFiles
}

// Expect sets up expected params for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Expect(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by ExpectParams functions")
	}

	mmProcessCatalogFiles.defaultExpectation.params = &ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts}
	mmProcessCatalogFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProcessCatalogFiles.expectations {
		if minimock.Equal(e.params, mmProcessCatalogFiles.defaultExpectation.params) {
			mmProcessCatalogFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProcessCatalogFiles.defaultExpectation.params)
		}
	}

	return mmProcessCatalogFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmProcessCatalogFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProcessCatalogFiles
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) ExpectInParam2(in *mm_artifactv1alpha.ProcessCatalogFilesRequest) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.in = &in
	mmProcessCatalogFiles.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmProcessCatalogFiles
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{}
	}

	if mmProcessCatalogFiles.defaultExpectation.params != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Expect")
	}

	if mmProcessCatalogFiles.defaultExpectation.paramPtrs == nil {
		mmProcessCatalogFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockProcessCatalogFilesParamPtrs{}
	}
	mmProcessCatalogFiles.defaultExpectation.paramPtrs.opts = &opts
	mmProcessCatalogFiles.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmProcessCatalogFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if mmProcessCatalogFiles.mock.inspectFuncProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ProcessCatalogFiles")
	}

	mmProcessCatalogFiles.mock.inspectFuncProcessCatalogFiles = f

	return mmProcessCatalogFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ProcessCatalogFiles
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Return(pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	if mmProcessCatalogFiles.defaultExpectation == nil {
		mmProcessCatalogFiles.defaultExpectation = &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{mock: mmProcessCatalogFiles.mock}
	}
	mmProcessCatalogFiles.defaultExpectation.results = &ArtifactPublicServiceClientMockProcessCatalogFilesResults{pp1, err}
	mmProcessCatalogFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProcessCatalogFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ProcessCatalogFiles method
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) (pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmProcessCatalogFiles.defaultExpectation != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ProcessCatalogFiles method")
	}

	if len(mmProcessCatalogFiles.expectations) > 0 {
		mmProcessCatalogFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ProcessCatalogFiles method")
	}

	mmProcessCatalogFiles.mock.funcProcessCatalogFiles = f
	mmProcessCatalogFiles.mock.funcProcessCatalogFilesOrigin = minimock.CallerInfo(1)
	return mmProcessCatalogFiles.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ProcessCatalogFiles which will trigger the result defined by the following
// Then helper
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) When(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockProcessCatalogFilesExpectation {
	if mmProcessCatalogFiles.mock.funcProcessCatalogFiles != nil {
		mmProcessCatalogFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ProcessCatalogFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockProcessCatalogFilesExpectation{
		mock:               mmProcessCatalogFiles.mock,
		params:             &ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockProcessCatalogFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProcessCatalogFiles.expectations = append(mmProcessCatalogFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ProcessCatalogFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockProcessCatalogFilesExpectation) Then(pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockProcessCatalogFilesResults{pp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ProcessCatalogFiles should be invoked
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Times(n uint64) *mArtifactPublicServiceClientMockProcessCatalogFiles {
	if n == 0 {
		mmProcessCatalogFiles.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ProcessCatalogFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProcessCatalogFiles.expectedInvocations, n)
	mmProcessCatalogFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProcessCatalogFiles
}

func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) invocationsDone() bool {
	if len(mmProcessCatalogFiles.expectations) == 0 && mmProcessCatalogFiles.defaultExpectation == nil && mmProcessCatalogFiles.mock.funcProcessCatalogFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProcessCatalogFiles.mock.afterProcessCatalogFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProcessCatalogFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ProcessCatalogFiles implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmProcessCatalogFiles *ArtifactPublicServiceClientMock) ProcessCatalogFiles(ctx context.Context, in *mm_artifactv1alpha.ProcessCatalogFilesRequest, opts ...grpc.CallOption) (pp1 *mm_artifactv1alpha.ProcessCatalogFilesResponse, err error) {
	mm_atomic.AddUint64(&mmProcessCatalogFiles.beforeProcessCatalogFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmProcessCatalogFiles.afterProcessCatalogFilesCounter, 1)

	mmProcessCatalogFiles.t.Helper()

	if mmProcessCatalogFiles.inspectFuncProcessCatalogFiles != nil {
		mmProcessCatalogFiles.inspectFuncProcessCatalogFiles(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts}

	// Record call args
	mmProcessCatalogFiles.ProcessCatalogFilesMock.mutex.Lock()
	mmProcessCatalogFiles.ProcessCatalogFilesMock.callArgs = append(mmProcessCatalogFiles.ProcessCatalogFilesMock.callArgs, &mm_params)
	mmProcessCatalogFiles.ProcessCatalogFilesMock.mutex.Unlock()

	for _, e := range mmProcessCatalogFiles.ProcessCatalogFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.params
		mm_want_ptrs := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockProcessCatalogFilesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProcessCatalogFiles.t.Errorf("ArtifactPublicServiceClientMock.ProcessCatalogFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProcessCatalogFiles.ProcessCatalogFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmProcessCatalogFiles.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ProcessCatalogFiles")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmProcessCatalogFiles.funcProcessCatalogFiles != nil {
		return mmProcessCatalogFiles.funcProcessCatalogFiles(ctx, in, opts...)
	}
	mmProcessCatalogFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles. %v %v %v", ctx, in, opts)
	return
}

// ProcessCatalogFilesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ProcessCatalogFiles invocations
func (mmProcessCatalogFiles *ArtifactPublicServiceClientMock) ProcessCatalogFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessCatalogFiles.afterProcessCatalogFilesCounter)
}

// ProcessCatalogFilesBeforeCounter returns a count of ArtifactPublicServiceClientMock.ProcessCatalogFiles invocations
func (mmProcessCatalogFiles *ArtifactPublicServiceClientMock) ProcessCatalogFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProcessCatalogFiles.beforeProcessCatalogFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ProcessCatalogFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProcessCatalogFiles *mArtifactPublicServiceClientMockProcessCatalogFiles) Calls() []*ArtifactPublicServiceClientMockProcessCatalogFilesParams {
	mmProcessCatalogFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockProcessCatalogFilesParams, len(mmProcessCatalogFiles.callArgs))
	copy(argCopy, mmProcessCatalogFiles.callArgs)

	mmProcessCatalogFiles.mutex.RUnlock()

	return argCopy
}

// MinimockProcessCatalogFilesDone returns true if the count of the ProcessCatalogFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockProcessCatalogFilesDone() bool {
	if m.ProcessCatalogFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProcessCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProcessCatalogFilesMock.invocationsDone()
}

// MinimockProcessCatalogFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockProcessCatalogFilesInspect() {
	for _, e := range m.ProcessCatalogFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProcessCatalogFilesCounter := mm_atomic.LoadUint64(&m.afterProcessCatalogFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProcessCatalogFilesMock.defaultExpectation != nil && afterProcessCatalogFilesCounter < 1 {
		if m.ProcessCatalogFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles at\n%s", m.ProcessCatalogFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles at\n%s with params: %#v", m.ProcessCatalogFilesMock.defaultExpectation.expectationOrigins.origin, *m.ProcessCatalogFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProcessCatalogFiles != nil && afterProcessCatalogFilesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ProcessCatalogFiles at\n%s", m.funcProcessCatalogFilesOrigin)
	}

	if !m.ProcessCatalogFilesMock.invocationsDone() && afterProcessCatalogFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ProcessCatalogFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProcessCatalogFilesMock.expectedInvocations), m.ProcessCatalogFilesMock.expectedInvocationsOrigin, afterProcessCatalogFilesCounter)
	}
}

type mArtifactPublicServiceClientMockQuestionAnswering struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockQuestionAnsweringExpectation
	expectations       []*ArtifactPublicServiceClientMockQuestionAnsweringExpectation

	callArgs []*ArtifactPublicServiceClientMockQuestionAnsweringParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockQuestionAnsweringExpectation specifies expectation struct of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockQuestionAnsweringParams
	paramPtrs          *ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockQuestionAnsweringExpectationOrigins
	results            *ArtifactPublicServiceClientMockQuestionAnsweringResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockQuestionAnsweringParams contains parameters of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.QuestionAnsweringRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.QuestionAnsweringRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockQuestionAnsweringResults contains results of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringResults struct {
	qp1 *mm_artifactv1alpha.QuestionAnsweringResponse
	err error
}

// ArtifactPublicServiceClientMockQuestionAnsweringOrigins contains origins of expectations of the ArtifactPublicServiceClient.QuestionAnswering
type ArtifactPublicServiceClientMockQuestionAnsweringExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Optional() *mArtifactPublicServiceClientMockQuestionAnswering {
	mmQuestionAnswering.optional = true
	return mmQuestionAnswering
}

// Expect sets up expected params for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Expect(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by ExpectParams functions")
	}

	mmQuestionAnswering.defaultExpectation.params = &ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts}
	mmQuestionAnswering.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQuestionAnswering.expectations {
		if minimock.Equal(e.params, mmQuestionAnswering.defaultExpectation.params) {
			mmQuestionAnswering.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuestionAnswering.defaultExpectation.params)
		}
	}

	return mmQuestionAnswering
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.ctx = &ctx
	mmQuestionAnswering.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQuestionAnswering
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) ExpectInParam2(in *mm_artifactv1alpha.QuestionAnsweringRequest) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.in = &in
	mmQuestionAnswering.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmQuestionAnswering
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{}
	}

	if mmQuestionAnswering.defaultExpectation.params != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Expect")
	}

	if mmQuestionAnswering.defaultExpectation.paramPtrs == nil {
		mmQuestionAnswering.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockQuestionAnsweringParamPtrs{}
	}
	mmQuestionAnswering.defaultExpectation.paramPtrs.opts = &opts
	mmQuestionAnswering.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmQuestionAnswering
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockQuestionAnswering {
	if mmQuestionAnswering.mock.inspectFuncQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.QuestionAnswering")
	}

	mmQuestionAnswering.mock.inspectFuncQuestionAnswering = f

	return mmQuestionAnswering
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.QuestionAnswering
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Return(qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) *ArtifactPublicServiceClientMock {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	if mmQuestionAnswering.defaultExpectation == nil {
		mmQuestionAnswering.defaultExpectation = &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{mock: mmQuestionAnswering.mock}
	}
	mmQuestionAnswering.defaultExpectation.results = &ArtifactPublicServiceClientMockQuestionAnsweringResults{qp1, err}
	mmQuestionAnswering.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQuestionAnswering.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.QuestionAnswering method
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Set(f func(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) (qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmQuestionAnswering.defaultExpectation != nil {
		mmQuestionAnswering.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.QuestionAnswering method")
	}

	if len(mmQuestionAnswering.expectations) > 0 {
		mmQuestionAnswering.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.QuestionAnswering method")
	}

	mmQuestionAnswering.mock.funcQuestionAnswering = f
	mmQuestionAnswering.mock.funcQuestionAnsweringOrigin = minimock.CallerInfo(1)
	return mmQuestionAnswering.mock
}

// When sets expectation for the ArtifactPublicServiceClient.QuestionAnswering which will trigger the result defined by the following
// Then helper
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) When(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockQuestionAnsweringExpectation {
	if mmQuestionAnswering.mock.funcQuestionAnswering != nil {
		mmQuestionAnswering.mock.t.Fatalf("ArtifactPublicServiceClientMock.QuestionAnswering mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockQuestionAnsweringExpectation{
		mock:               mmQuestionAnswering.mock,
		params:             &ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockQuestionAnsweringExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQuestionAnswering.expectations = append(mmQuestionAnswering.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.QuestionAnswering return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockQuestionAnsweringExpectation) Then(qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockQuestionAnsweringResults{qp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.QuestionAnswering should be invoked
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Times(n uint64) *mArtifactPublicServiceClientMockQuestionAnswering {
	if n == 0 {
		mmQuestionAnswering.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.QuestionAnswering mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuestionAnswering.expectedInvocations, n)
	mmQuestionAnswering.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQuestionAnswering
}

func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) invocationsDone() bool {
	if len(mmQuestionAnswering.expectations) == 0 && mmQuestionAnswering.defaultExpectation == nil && mmQuestionAnswering.mock.funcQuestionAnswering == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuestionAnswering.mock.afterQuestionAnsweringCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuestionAnswering.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QuestionAnswering implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmQuestionAnswering *ArtifactPublicServiceClientMock) QuestionAnswering(ctx context.Context, in *mm_artifactv1alpha.QuestionAnsweringRequest, opts ...grpc.CallOption) (qp1 *mm_artifactv1alpha.QuestionAnsweringResponse, err error) {
	mm_atomic.AddUint64(&mmQuestionAnswering.beforeQuestionAnsweringCounter, 1)
	defer mm_atomic.AddUint64(&mmQuestionAnswering.afterQuestionAnsweringCounter, 1)

	mmQuestionAnswering.t.Helper()

	if mmQuestionAnswering.inspectFuncQuestionAnswering != nil {
		mmQuestionAnswering.inspectFuncQuestionAnswering(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts}

	// Record call args
	mmQuestionAnswering.QuestionAnsweringMock.mutex.Lock()
	mmQuestionAnswering.QuestionAnsweringMock.callArgs = append(mmQuestionAnswering.QuestionAnsweringMock.callArgs, &mm_params)
	mmQuestionAnswering.QuestionAnsweringMock.mutex.Unlock()

	for _, e := range mmQuestionAnswering.QuestionAnsweringMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.qp1, e.results.err
		}
	}

	if mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.Counter, 1)
		mm_want := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.params
		mm_want_ptrs := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockQuestionAnsweringParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuestionAnswering.t.Errorf("ArtifactPublicServiceClientMock.QuestionAnswering got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuestionAnswering.QuestionAnsweringMock.defaultExpectation.results
		if mm_results == nil {
			mmQuestionAnswering.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.QuestionAnswering")
		}
		return (*mm_results).qp1, (*mm_results).err
	}
	if mmQuestionAnswering.funcQuestionAnswering != nil {
		return mmQuestionAnswering.funcQuestionAnswering(ctx, in, opts...)
	}
	mmQuestionAnswering.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.QuestionAnswering. %v %v %v", ctx, in, opts)
	return
}

// QuestionAnsweringAfterCounter returns a count of finished ArtifactPublicServiceClientMock.QuestionAnswering invocations
func (mmQuestionAnswering *ArtifactPublicServiceClientMock) QuestionAnsweringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnswering.afterQuestionAnsweringCounter)
}

// QuestionAnsweringBeforeCounter returns a count of ArtifactPublicServiceClientMock.QuestionAnswering invocations
func (mmQuestionAnswering *ArtifactPublicServiceClientMock) QuestionAnsweringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuestionAnswering.beforeQuestionAnsweringCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.QuestionAnswering.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuestionAnswering *mArtifactPublicServiceClientMockQuestionAnswering) Calls() []*ArtifactPublicServiceClientMockQuestionAnsweringParams {
	mmQuestionAnswering.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockQuestionAnsweringParams, len(mmQuestionAnswering.callArgs))
	copy(argCopy, mmQuestionAnswering.callArgs)

	mmQuestionAnswering.mutex.RUnlock()

	return argCopy
}

// MinimockQuestionAnsweringDone returns true if the count of the QuestionAnswering invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockQuestionAnsweringDone() bool {
	if m.QuestionAnsweringMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QuestionAnsweringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QuestionAnsweringMock.invocationsDone()
}

// MinimockQuestionAnsweringInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockQuestionAnsweringInspect() {
	for _, e := range m.QuestionAnsweringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQuestionAnsweringCounter := mm_atomic.LoadUint64(&m.afterQuestionAnsweringCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QuestionAnsweringMock.defaultExpectation != nil && afterQuestionAnsweringCounter < 1 {
		if m.QuestionAnsweringMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering at\n%s", m.QuestionAnsweringMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering at\n%s with params: %#v", m.QuestionAnsweringMock.defaultExpectation.expectationOrigins.origin, *m.QuestionAnsweringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuestionAnswering != nil && afterQuestionAnsweringCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.QuestionAnswering at\n%s", m.funcQuestionAnsweringOrigin)
	}

	if !m.QuestionAnsweringMock.invocationsDone() && afterQuestionAnsweringCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.QuestionAnswering at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QuestionAnsweringMock.expectedInvocations), m.QuestionAnsweringMock.expectedInvocationsOrigin, afterQuestionAnsweringCounter)
	}
}

type mArtifactPublicServiceClientMockReadiness struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockReadinessExpectation
	expectations       []*ArtifactPublicServiceClientMockReadinessExpectation

	callArgs []*ArtifactPublicServiceClientMockReadinessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockReadinessExpectation specifies expectation struct of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockReadinessParams
	paramPtrs          *ArtifactPublicServiceClientMockReadinessParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockReadinessExpectationOrigins
	results            *ArtifactPublicServiceClientMockReadinessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockReadinessParams contains parameters of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ReadinessRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockReadinessParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ReadinessRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockReadinessResults contains results of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessResults struct {
	rp1 *mm_artifactv1alpha.ReadinessResponse
	err error
}

// ArtifactPublicServiceClientMockReadinessOrigins contains origins of expectations of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Optional() *mArtifactPublicServiceClientMockReadiness {
	mmReadiness.optional = true
	return mmReadiness
}

// Expect sets up expected params for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Expect(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.paramPtrs != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by ExpectParams functions")
	}

	mmReadiness.defaultExpectation.params = &ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}
	mmReadiness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadiness.expectations {
		if minimock.Equal(e.params, mmReadiness.defaultExpectation.params) {
			mmReadiness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadiness.defaultExpectation.params)
		}
	}

	return mmReadiness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadiness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectInParam2(in *mm_artifactv1alpha.ReadinessRequest) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.in = &in
	mmReadiness.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.opts = &opts
	mmReadiness.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmReadiness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.inspectFuncReadiness != nil {
		mmReadiness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.Readiness")
	}

	mmReadiness.mock.inspectFuncReadiness = f

	return mmReadiness
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Return(rp1 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceClientMock {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{mock: mmReadiness.mock}
	}
	mmReadiness.defaultExpectation.results = &ArtifactPublicServiceClientMockReadinessResults{rp1, err}
	mmReadiness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.Readiness method
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmReadiness.defaultExpectation != nil {
		mmReadiness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.Readiness method")
	}

	if len(mmReadiness.expectations) > 0 {
		mmReadiness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.Readiness method")
	}

	mmReadiness.mock.funcReadiness = f
	mmReadiness.mock.funcReadinessOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// When sets expectation for the ArtifactPublicServiceClient.Readiness which will trigger the result defined by the following
// Then helper
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) When(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockReadinessExpectation {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockReadinessExpectation{
		mock:               mmReadiness.mock,
		params:             &ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockReadinessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadiness.expectations = append(mmReadiness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.Readiness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockReadinessExpectation) Then(rp1 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockReadinessResults{rp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.Readiness should be invoked
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Times(n uint64) *mArtifactPublicServiceClientMockReadiness {
	if n == 0 {
		mmReadiness.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.Readiness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadiness.expectedInvocations, n)
	mmReadiness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadiness
}

func (mmReadiness *mArtifactPublicServiceClientMockReadiness) invocationsDone() bool {
	if len(mmReadiness.expectations) == 0 && mmReadiness.defaultExpectation == nil && mmReadiness.mock.funcReadiness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadiness.mock.afterReadinessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadiness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Readiness implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmReadiness *ArtifactPublicServiceClientMock) Readiness(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error) {
	mm_atomic.AddUint64(&mmReadiness.beforeReadinessCounter, 1)
	defer mm_atomic.AddUint64(&mmReadiness.afterReadinessCounter, 1)

	mmReadiness.t.Helper()

	if mmReadiness.inspectFuncReadiness != nil {
		mmReadiness.inspectFuncReadiness(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}

	// Record call args
	mmReadiness.ReadinessMock.mutex.Lock()
	mmReadiness.ReadinessMock.callArgs = append(mmReadiness.ReadinessMock.callArgs, &mm_params)
	mmReadiness.ReadinessMock.mutex.Unlock()

	for _, e := range mmReadiness.ReadinessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmReadiness.ReadinessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadiness.ReadinessMock.defaultExpectation.Counter, 1)
		mm_want := mmReadiness.ReadinessMock.defaultExpectation.params
		mm_want_ptrs := mmReadiness.ReadinessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadiness.ReadinessMock.defaultExpectation.results
		if mm_results == nil {
			mmReadiness.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.Readiness")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmReadiness.funcReadiness != nil {
		return mmReadiness.funcReadiness(ctx, in, opts...)
	}
	mmReadiness.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.Readiness. %v %v %v", ctx, in, opts)
	return
}

// ReadinessAfterCounter returns a count of finished ArtifactPublicServiceClientMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceClientMock) ReadinessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.afterReadinessCounter)
}

// ReadinessBeforeCounter returns a count of ArtifactPublicServiceClientMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceClientMock) ReadinessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.beforeReadinessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.Readiness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Calls() []*ArtifactPublicServiceClientMockReadinessParams {
	mmReadiness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockReadinessParams, len(mmReadiness.callArgs))
	copy(argCopy, mmReadiness.callArgs)

	mmReadiness.mutex.RUnlock()

	return argCopy
}

// MinimockReadinessDone returns true if the count of the Readiness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockReadinessDone() bool {
	if m.ReadinessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadinessMock.invocationsDone()
}

// MinimockReadinessInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockReadinessInspect() {
	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadinessCounter := mm_atomic.LoadUint64(&m.afterReadinessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadinessMock.defaultExpectation != nil && afterReadinessCounter < 1 {
		if m.ReadinessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s", m.ReadinessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s with params: %#v", m.ReadinessMock.defaultExpectation.expectationOrigins.origin, *m.ReadinessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadiness != nil && afterReadinessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s", m.funcReadinessOrigin)
	}

	if !m.ReadinessMock.invocationsDone() && afterReadinessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.Readiness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadinessMock.expectedInvocations), m.ReadinessMock.expectedInvocationsOrigin, afterReadinessCounter)
	}
}

type mArtifactPublicServiceClientMockSearchChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockSearchChunksExpectation
	expectations       []*ArtifactPublicServiceClientMockSearchChunksExpectation

	callArgs []*ArtifactPublicServiceClientMockSearchChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockSearchChunksExpectation specifies expectation struct of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockSearchChunksParams
	paramPtrs          *ArtifactPublicServiceClientMockSearchChunksParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockSearchChunksExpectationOrigins
	results            *ArtifactPublicServiceClientMockSearchChunksResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockSearchChunksParams contains parameters of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.SearchChunksRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockSearchChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.SearchChunksRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockSearchChunksResults contains results of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksResults struct {
	sp1 *mm_artifactv1alpha.SearchChunksResponse
	err error
}

// ArtifactPublicServiceClientMockSearchChunksOrigins contains origins of expectations of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Optional() *mArtifactPublicServiceClientMockSearchChunks {
	mmSearchChunks.optional = true
	return mmSearchChunks
}

// Expect sets up expected params for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Expect(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.paramPtrs != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by ExpectParams functions")
	}

	mmSearchChunks.defaultExpectation.params = &ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts}
	mmSearchChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchChunks.expectations {
		if minimock.Equal(e.params, mmSearchChunks.defaultExpectation.params) {
			mmSearchChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchChunks.defaultExpectation.params)
		}
	}

	return mmSearchChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchChunks
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) ExpectInParam2(in *mm_artifactv1alpha.SearchChunksRequest) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.in = &in
	mmSearchChunks.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmSearchChunks
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.opts = &opts
	mmSearchChunks.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmSearchChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.inspectFuncSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.SearchChunks")
	}

	mmSearchChunks.mock.inspectFuncSearchChunks = f

	return mmSearchChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Return(sp1 *mm_artifactv1alpha.SearchChunksResponse, err error) *ArtifactPublicServiceClientMock {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{mock: mmSearchChunks.mock}
	}
	mmSearchChunks.defaultExpectation.results = &ArtifactPublicServiceClientMockSearchChunksResults{sp1, err}
	mmSearchChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.SearchChunks method
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Set(f func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchChunksResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmSearchChunks.defaultExpectation != nil {
		mmSearchChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.SearchChunks method")
	}

	if len(mmSearchChunks.expectations) > 0 {
		mmSearchChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.SearchChunks method")
	}

	mmSearchChunks.mock.funcSearchChunks = f
	mmSearchChunks.mock.funcSearchChunksOrigin = minimock.CallerInfo(1)
	return mmSearchChunks.mock
}

// When sets expectation for the ArtifactPublicServiceClient.SearchChunks which will trigger the result defined by the following
// Then helper
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) When(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockSearchChunksExpectation {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockSearchChunksExpectation{
		mock:               mmSearchChunks.mock,
		params:             &ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockSearchChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchChunks.expectations = append(mmSearchChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.SearchChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockSearchChunksExpectation) Then(sp1 *mm_artifactv1alpha.SearchChunksResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockSearchChunksResults{sp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.SearchChunks should be invoked
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Times(n uint64) *mArtifactPublicServiceClientMockSearchChunks {
	if n == 0 {
		mmSearchChunks.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.SearchChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchChunks.expectedInvocations, n)
	mmSearchChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchChunks
}

func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) invocationsDone() bool {
	if len(mmSearchChunks.expectations) == 0 && mmSearchChunks.defaultExpectation == nil && mmSearchChunks.mock.funcSearchChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchChunks.mock.afterSearchChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchChunks implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmSearchChunks *ArtifactPublicServiceClientMock) SearchChunks(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchChunksResponse, err error) {
	mm_atomic.AddUint64(&mmSearchChunks.beforeSearchChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchChunks.afterSearchChunksCounter, 1)

	mmSearchChunks.t.Helper()

	if mmSearchChunks.inspectFuncSearchChunks != nil {
		mmSearchChunks.inspectFuncSearchChunks(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts}

	// Record call args
	mmSearchChunks.SearchChunksMock.mutex.Lock()
	mmSearchChunks.SearchChunksMock.callArgs = append(mmSearchChunks.SearchChunksMock.callArgs, &mm_params)
	mmSearchChunks.SearchChunksMock.mutex.Unlock()

	for _, e := range mmSearchChunks.SearchChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmSearchChunks.SearchChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchChunks.SearchChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchChunks.SearchChunksMock.defaultExpectation.params
		mm_want_ptrs := mmSearchChunks.SearchChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchChunks.SearchChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchChunks.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.SearchChunks")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmSearchChunks.funcSearchChunks != nil {
		return mmSearchChunks.funcSearchChunks(ctx, in, opts...)
	}
	mmSearchChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.SearchChunks. %v %v %v", ctx, in, opts)
	return
}

// SearchChunksAfterCounter returns a count of finished ArtifactPublicServiceClientMock.SearchChunks invocations
func (mmSearchChunks *ArtifactPublicServiceClientMock) SearchChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchChunks.afterSearchChunksCounter)
}

// SearchChunksBeforeCounter returns a count of ArtifactPublicServiceClientMock.SearchChunks invocations
func (mmSearchChunks *ArtifactPublicServiceClientMock) SearchChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchChunks.beforeSearchChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.SearchChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Calls() []*ArtifactPublicServiceClientMockSearchChunksParams {
	mmSearchChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockSearchChunksParams, len(mmSearchChunks.callArgs))
	copy(argCopy, mmSearchChunks.callArgs)

	mmSearchChunks.mutex.RUnlock()

	return argCopy
}

// MinimockSearchChunksDone returns true if the count of the SearchChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockSearchChunksDone() bool {
	if m.SearchChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchChunksMock.invocationsDone()
}

// MinimockSearchChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockSearchChunksInspect() {
	for _, e := range m.SearchChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchChunksCounter := mm_atomic.LoadUint64(&m.afterSearchChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchChunksMock.defaultExpectation != nil && afterSearchChunksCounter < 1 {
		if m.SearchChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s", m.SearchChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s with params: %#v", m.SearchChunksMock.defaultExpectation.expectationOrigins.origin, *m.SearchChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchChunks != nil && afterSearchChunksCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s", m.funcSearchChunksOrigin)
	}

	if !m.SearchChunksMock.invocationsDone() && afterSearchChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.SearchChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchChunksMock.expectedInvocations), m.SearchChunksMock.expectedInvocationsOrigin, afterSearchChunksCounter)
	}
}

type mArtifactPublicServiceClientMockSearchSourceFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockSearchSourceFilesExpectation
	expectations       []*ArtifactPublicServiceClientMockSearchSourceFilesExpectation

	callArgs []*ArtifactPublicServiceClientMockSearchSourceFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockSearchSourceFilesExpectation specifies expectation struct of the ArtifactPublicServiceClient.SearchSourceFiles
type ArtifactPublicServiceClientMockSearchSourceFilesExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockSearchSourceFilesParams
	paramPtrs          *ArtifactPublicServiceClientMockSearchSourceFilesParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockSearchSourceFilesExpectationOrigins
	results            *ArtifactPublicServiceClientMockSearchSourceFilesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockSearchSourceFilesParams contains parameters of the ArtifactPublicServiceClient.SearchSourceFiles
type ArtifactPublicServiceClientMockSearchSourceFilesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.SearchSourceFilesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockSearchSourceFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.SearchSourceFiles
type ArtifactPublicServiceClientMockSearchSourceFilesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.SearchSourceFilesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockSearchSourceFilesResults contains results of the ArtifactPublicServiceClient.SearchSourceFiles
type ArtifactPublicServiceClientMockSearchSourceFilesResults struct {
	sp1 *mm_artifactv1alpha.SearchSourceFilesResponse
	err error
}

// ArtifactPublicServiceClientMockSearchSourceFilesOrigins contains origins of expectations of the ArtifactPublicServiceClient.SearchSourceFiles
type ArtifactPublicServiceClientMockSearchSourceFilesExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) Optional() *mArtifactPublicServiceClientMockSearchSourceFiles {
	mmSearchSourceFiles.optional = true
	return mmSearchSourceFiles
}

// Expect sets up expected params for ArtifactPublicServiceClient.SearchSourceFiles
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) Expect(ctx context.Context, in *mm_artifactv1alpha.SearchSourceFilesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSearchSourceFiles {
	if mmSearchSourceFiles.mock.funcSearchSourceFiles != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Set")
	}

	if mmSearchSourceFiles.defaultExpectation == nil {
		mmSearchSourceFiles.defaultExpectation = &ArtifactPublicServiceClientMockSearchSourceFilesExpectation{}
	}

	if mmSearchSourceFiles.defaultExpectation.paramPtrs != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by ExpectParams functions")
	}

	mmSearchSourceFiles.defaultExpectation.params = &ArtifactPublicServiceClientMockSearchSourceFilesParams{ctx, in, opts}
	mmSearchSourceFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchSourceFiles.expectations {
		if minimock.Equal(e.params, mmSearchSourceFiles.defaultExpectation.params) {
			mmSearchSourceFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchSourceFiles.defaultExpectation.params)
		}
	}

	return mmSearchSourceFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.SearchSourceFiles
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockSearchSourceFiles {
	if mmSearchSourceFiles.mock.funcSearchSourceFiles != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Set")
	}

	if mmSearchSourceFiles.defaultExpectation == nil {
		mmSearchSourceFiles.defaultExpectation = &ArtifactPublicServiceClientMockSearchSourceFilesExpectation{}
	}

	if mmSearchSourceFiles.defaultExpectation.params != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Expect")
	}

	if mmSearchSourceFiles.defaultExpectation.paramPtrs == nil {
		mmSearchSourceFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchSourceFilesParamPtrs{}
	}
	mmSearchSourceFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchSourceFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchSourceFiles
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.SearchSourceFiles
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) ExpectInParam2(in *mm_artifactv1alpha.SearchSourceFilesRequest) *mArtifactPublicServiceClientMockSearchSourceFiles {
	if mmSearchSourceFiles.mock.funcSearchSourceFiles != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Set")
	}

	if mmSearchSourceFiles.defaultExpectation == nil {
		mmSearchSourceFiles.defaultExpectation = &ArtifactPublicServiceClientMockSearchSourceFilesExpectation{}
	}

	if mmSearchSourceFiles.defaultExpectation.params != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Expect")
	}

	if mmSearchSourceFiles.defaultExpectation.paramPtrs == nil {
		mmSearchSourceFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchSourceFilesParamPtrs{}
	}
	mmSearchSourceFiles.defaultExpectation.paramPtrs.in = &in
	mmSearchSourceFiles.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmSearchSourceFiles
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.SearchSourceFiles
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSearchSourceFiles {
	if mmSearchSourceFiles.mock.funcSearchSourceFiles != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Set")
	}

	if mmSearchSourceFiles.defaultExpectation == nil {
		mmSearchSourceFiles.defaultExpectation = &ArtifactPublicServiceClientMockSearchSourceFilesExpectation{}
	}

	if mmSearchSourceFiles.defaultExpectation.params != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Expect")
	}

	if mmSearchSourceFiles.defaultExpectation.paramPtrs == nil {
		mmSearchSourceFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchSourceFilesParamPtrs{}
	}
	mmSearchSourceFiles.defaultExpectation.paramPtrs.opts = &opts
	mmSearchSourceFiles.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmSearchSourceFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.SearchSourceFiles
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.SearchSourceFilesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockSearchSourceFiles {
	if mmSearchSourceFiles.mock.inspectFuncSearchSourceFiles != nil {
		mmSearchSourceFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.SearchSourceFiles")
	}

	mmSearchSourceFiles.mock.inspectFuncSearchSourceFiles = f

	return mmSearchSourceFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.SearchSourceFiles
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) Return(sp1 *mm_artifactv1alpha.SearchSourceFilesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmSearchSourceFiles.mock.funcSearchSourceFiles != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Set")
	}

	if mmSearchSourceFiles.defaultExpectation == nil {
		mmSearchSourceFiles.defaultExpectation = &ArtifactPublicServiceClientMockSearchSourceFilesExpectation{mock: mmSearchSourceFiles.mock}
	}
	mmSearchSourceFiles.defaultExpectation.results = &ArtifactPublicServiceClientMockSearchSourceFilesResults{sp1, err}
	mmSearchSourceFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchSourceFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.SearchSourceFiles method
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) Set(f func(ctx context.Context, in *mm_artifactv1alpha.SearchSourceFilesRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchSourceFilesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmSearchSourceFiles.defaultExpectation != nil {
		mmSearchSourceFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.SearchSourceFiles method")
	}

	if len(mmSearchSourceFiles.expectations) > 0 {
		mmSearchSourceFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.SearchSourceFiles method")
	}

	mmSearchSourceFiles.mock.funcSearchSourceFiles = f
	mmSearchSourceFiles.mock.funcSearchSourceFilesOrigin = minimock.CallerInfo(1)
	return mmSearchSourceFiles.mock
}

// When sets expectation for the ArtifactPublicServiceClient.SearchSourceFiles which will trigger the result defined by the following
// Then helper
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) When(ctx context.Context, in *mm_artifactv1alpha.SearchSourceFilesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockSearchSourceFilesExpectation {
	if mmSearchSourceFiles.mock.funcSearchSourceFiles != nil {
		mmSearchSourceFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchSourceFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockSearchSourceFilesExpectation{
		mock:               mmSearchSourceFiles.mock,
		params:             &ArtifactPublicServiceClientMockSearchSourceFilesParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockSearchSourceFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchSourceFiles.expectations = append(mmSearchSourceFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.SearchSourceFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockSearchSourceFilesExpectation) Then(sp1 *mm_artifactv1alpha.SearchSourceFilesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockSearchSourceFilesResults{sp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.SearchSourceFiles should be invoked
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) Times(n uint64) *mArtifactPublicServiceClientMockSearchSourceFiles {
	if n == 0 {
		mmSearchSourceFiles.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.SearchSourceFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchSourceFiles.expectedInvocations, n)
	mmSearchSourceFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchSourceFiles
}

func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) invocationsDone() bool {
	if len(mmSearchSourceFiles.expectations) == 0 && mmSearchSourceFiles.defaultExpectation == nil && mmSearchSourceFiles.mock.funcSearchSourceFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchSourceFiles.mock.afterSearchSourceFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchSourceFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchSourceFiles implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmSearchSourceFiles *ArtifactPublicServiceClientMock) SearchSourceFiles(ctx context.Context, in *mm_artifactv1alpha.SearchSourceFilesRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchSourceFilesResponse, err error) {
	mm_atomic.AddUint64(&mmSearchSourceFiles.beforeSearchSourceFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchSourceFiles.afterSearchSourceFilesCounter, 1)

	mmSearchSourceFiles.t.Helper()

	if mmSearchSourceFiles.inspectFuncSearchSourceFiles != nil {
		mmSearchSourceFiles.inspectFuncSearchSourceFiles(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockSearchSourceFilesParams{ctx, in, opts}

	// Record call args
	mmSearchSourceFiles.SearchSourceFilesMock.mutex.Lock()
	mmSearchSourceFiles.SearchSourceFilesMock.callArgs = append(mmSearchSourceFiles.SearchSourceFilesMock.callArgs, &mm_params)
	mmSearchSourceFiles.SearchSourceFilesMock.mutex.Unlock()

	for _, e := range mmSearchSourceFiles.SearchSourceFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.params
		mm_want_ptrs := mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockSearchSourceFilesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchSourceFiles.t.Errorf("ArtifactPublicServiceClientMock.SearchSourceFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmSearchSourceFiles.t.Errorf("ArtifactPublicServiceClientMock.SearchSourceFiles got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmSearchSourceFiles.t.Errorf("ArtifactPublicServiceClientMock.SearchSourceFiles got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchSourceFiles.t.Errorf("ArtifactPublicServiceClientMock.SearchSourceFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchSourceFiles.SearchSourceFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchSourceFiles.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.SearchSourceFiles")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmSearchSourceFiles.funcSearchSourceFiles != nil {
		return mmSearchSourceFiles.funcSearchSourceFiles(ctx, in, opts...)
	}
	mmSearchSourceFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.SearchSourceFiles. %v %v %v", ctx, in, opts)
	return
}

// SearchSourceFilesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.SearchSourceFiles invocations
func (mmSearchSourceFiles *ArtifactPublicServiceClientMock) SearchSourceFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchSourceFiles.afterSearchSourceFilesCounter)
}

// SearchSourceFilesBeforeCounter returns a count of ArtifactPublicServiceClientMock.SearchSourceFiles invocations
func (mmSearchSourceFiles *ArtifactPublicServiceClientMock) SearchSourceFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchSourceFiles.beforeSearchSourceFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.SearchSourceFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchSourceFiles *mArtifactPublicServiceClientMockSearchSourceFiles) Calls() []*ArtifactPublicServiceClientMockSearchSourceFilesParams {
	mmSearchSourceFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockSearchSourceFilesParams, len(mmSearchSourceFiles.callArgs))
	copy(argCopy, mmSearchSourceFiles.callArgs)

	mmSearchSourceFiles.mutex.RUnlock()

	return argCopy
}

// MinimockSearchSourceFilesDone returns true if the count of the SearchSourceFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockSearchSourceFilesDone() bool {
	if m.SearchSourceFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchSourceFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchSourceFilesMock.invocationsDone()
}

// MinimockSearchSourceFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockSearchSourceFilesInspect() {
	for _, e := range m.SearchSourceFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchSourceFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchSourceFilesCounter := mm_atomic.LoadUint64(&m.afterSearchSourceFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchSourceFilesMock.defaultExpectation != nil && afterSearchSourceFilesCounter < 1 {
		if m.SearchSourceFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchSourceFiles at\n%s", m.SearchSourceFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchSourceFiles at\n%s with params: %#v", m.SearchSourceFilesMock.defaultExpectation.expectationOrigins.origin, *m.SearchSourceFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchSourceFiles != nil && afterSearchSourceFilesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchSourceFiles at\n%s", m.funcSearchSourceFilesOrigin)
	}

	if !m.SearchSourceFilesMock.invocationsDone() && afterSearchSourceFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.SearchSourceFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchSourceFilesMock.expectedInvocations), m.SearchSourceFilesMock.expectedInvocationsOrigin, afterSearchSourceFilesCounter)
	}
}

type mArtifactPublicServiceClientMockSimilarityChunksSearch struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation
	expectations       []*ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation

	callArgs []*ArtifactPublicServiceClientMockSimilarityChunksSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation specifies expectation struct of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockSimilarityChunksSearchParams
	paramPtrs          *ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockSimilarityChunksSearchExpectationOrigins
	results            *ArtifactPublicServiceClientMockSimilarityChunksSearchResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchParams contains parameters of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.SimilarityChunksSearchRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.SimilarityChunksSearchRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchResults contains results of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchResults struct {
	sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse
	err error
}

// ArtifactPublicServiceClientMockSimilarityChunksSearchOrigins contains origins of expectations of the ArtifactPublicServiceClient.SimilarityChunksSearch
type ArtifactPublicServiceClientMockSimilarityChunksSearchExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Optional() *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	mmSimilarityChunksSearch.optional = true
	return mmSimilarityChunksSearch
}

// Expect sets up expected params for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Expect(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by ExpectParams functions")
	}

	mmSimilarityChunksSearch.defaultExpectation.params = &ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts}
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSimilarityChunksSearch.expectations {
		if minimock.Equal(e.params, mmSimilarityChunksSearch.defaultExpectation.params) {
			mmSimilarityChunksSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSimilarityChunksSearch.defaultExpectation.params)
		}
	}

	return mmSimilarityChunksSearch
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) ExpectInParam2(in *mm_artifactv1alpha.SimilarityChunksSearchRequest) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.in = &in
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{}
	}

	if mmSimilarityChunksSearch.defaultExpectation.params != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Expect")
	}

	if mmSimilarityChunksSearch.defaultExpectation.paramPtrs == nil {
		mmSimilarityChunksSearch.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSimilarityChunksSearchParamPtrs{}
	}
	mmSimilarityChunksSearch.defaultExpectation.paramPtrs.opts = &opts
	mmSimilarityChunksSearch.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmSimilarityChunksSearch
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.SimilarityChunksSearch")
	}

	mmSimilarityChunksSearch.mock.inspectFuncSimilarityChunksSearch = f

	return mmSimilarityChunksSearch
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.SimilarityChunksSearch
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Return(sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) *ArtifactPublicServiceClientMock {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	if mmSimilarityChunksSearch.defaultExpectation == nil {
		mmSimilarityChunksSearch.defaultExpectation = &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{mock: mmSimilarityChunksSearch.mock}
	}
	mmSimilarityChunksSearch.defaultExpectation.results = &ArtifactPublicServiceClientMockSimilarityChunksSearchResults{sp1, err}
	mmSimilarityChunksSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.SimilarityChunksSearch method
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Set(f func(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmSimilarityChunksSearch.defaultExpectation != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.SimilarityChunksSearch method")
	}

	if len(mmSimilarityChunksSearch.expectations) > 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.SimilarityChunksSearch method")
	}

	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch = f
	mmSimilarityChunksSearch.mock.funcSimilarityChunksSearchOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch.mock
}

// When sets expectation for the ArtifactPublicServiceClient.SimilarityChunksSearch which will trigger the result defined by the following
// Then helper
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) When(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation {
	if mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.mock.t.Fatalf("ArtifactPublicServiceClientMock.SimilarityChunksSearch mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation{
		mock:               mmSimilarityChunksSearch.mock,
		params:             &ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockSimilarityChunksSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSimilarityChunksSearch.expectations = append(mmSimilarityChunksSearch.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.SimilarityChunksSearch return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockSimilarityChunksSearchExpectation) Then(sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockSimilarityChunksSearchResults{sp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.SimilarityChunksSearch should be invoked
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Times(n uint64) *mArtifactPublicServiceClientMockSimilarityChunksSearch {
	if n == 0 {
		mmSimilarityChunksSearch.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.SimilarityChunksSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSimilarityChunksSearch.expectedInvocations, n)
	mmSimilarityChunksSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSimilarityChunksSearch
}

func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) invocationsDone() bool {
	if len(mmSimilarityChunksSearch.expectations) == 0 && mmSimilarityChunksSearch.defaultExpectation == nil && mmSimilarityChunksSearch.mock.funcSimilarityChunksSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.mock.afterSimilarityChunksSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSimilarityChunksSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SimilarityChunksSearch implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmSimilarityChunksSearch *ArtifactPublicServiceClientMock) SimilarityChunksSearch(ctx context.Context, in *mm_artifactv1alpha.SimilarityChunksSearchRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SimilarityChunksSearchResponse, err error) {
	mm_atomic.AddUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter, 1)

	mmSimilarityChunksSearch.t.Helper()

	if mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch != nil {
		mmSimilarityChunksSearch.inspectFuncSimilarityChunksSearch(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts}

	// Record call args
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Lock()
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs = append(mmSimilarityChunksSearch.SimilarityChunksSearchMock.callArgs, &mm_params)
	mmSimilarityChunksSearch.SimilarityChunksSearchMock.mutex.Unlock()

	for _, e := range mmSimilarityChunksSearch.SimilarityChunksSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.params
		mm_want_ptrs := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockSimilarityChunksSearchParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSimilarityChunksSearch.t.Errorf("ArtifactPublicServiceClientMock.SimilarityChunksSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSimilarityChunksSearch.SimilarityChunksSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSimilarityChunksSearch.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.SimilarityChunksSearch")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmSimilarityChunksSearch.funcSimilarityChunksSearch != nil {
		return mmSimilarityChunksSearch.funcSimilarityChunksSearch(ctx, in, opts...)
	}
	mmSimilarityChunksSearch.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch. %v %v %v", ctx, in, opts)
	return
}

// SimilarityChunksSearchAfterCounter returns a count of finished ArtifactPublicServiceClientMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ArtifactPublicServiceClientMock) SimilarityChunksSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.afterSimilarityChunksSearchCounter)
}

// SimilarityChunksSearchBeforeCounter returns a count of ArtifactPublicServiceClientMock.SimilarityChunksSearch invocations
func (mmSimilarityChunksSearch *ArtifactPublicServiceClientMock) SimilarityChunksSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSimilarityChunksSearch.beforeSimilarityChunksSearchCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.SimilarityChunksSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSimilarityChunksSearch *mArtifactPublicServiceClientMockSimilarityChunksSearch) Calls() []*ArtifactPublicServiceClientMockSimilarityChunksSearchParams {
	mmSimilarityChunksSearch.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockSimilarityChunksSearchParams, len(mmSimilarityChunksSearch.callArgs))
	copy(argCopy, mmSimilarityChunksSearch.callArgs)

	mmSimilarityChunksSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSimilarityChunksSearchDone returns true if the count of the SimilarityChunksSearch invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockSimilarityChunksSearchDone() bool {
	if m.SimilarityChunksSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SimilarityChunksSearchMock.invocationsDone()
}

// MinimockSimilarityChunksSearchInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockSimilarityChunksSearchInspect() {
	for _, e := range m.SimilarityChunksSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSimilarityChunksSearchCounter := mm_atomic.LoadUint64(&m.afterSimilarityChunksSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SimilarityChunksSearchMock.defaultExpectation != nil && afterSimilarityChunksSearchCounter < 1 {
		if m.SimilarityChunksSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch at\n%s", m.SimilarityChunksSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch at\n%s with params: %#v", m.SimilarityChunksSearchMock.defaultExpectation.expectationOrigins.origin, *m.SimilarityChunksSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSimilarityChunksSearch != nil && afterSimilarityChunksSearchCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SimilarityChunksSearch at\n%s", m.funcSimilarityChunksSearchOrigin)
	}

	if !m.SimilarityChunksSearchMock.invocationsDone() && afterSimilarityChunksSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.SimilarityChunksSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SimilarityChunksSearchMock.expectedInvocations), m.SimilarityChunksSearchMock.expectedInvocationsOrigin, afterSimilarityChunksSearchCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateCatalog struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateCatalogExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateCatalogExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateCatalogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockUpdateCatalogExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockUpdateCatalogParams
	paramPtrs          *ArtifactPublicServiceClientMockUpdateCatalogParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockUpdateCatalogExpectationOrigins
	results            *ArtifactPublicServiceClientMockUpdateCatalogResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockUpdateCatalogParams contains parameters of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateCatalogRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateCatalogParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateCatalogRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateCatalogResults contains results of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogResults struct {
	up1 *mm_artifactv1alpha.UpdateCatalogResponse
	err error
}

// ArtifactPublicServiceClientMockUpdateCatalogOrigins contains origins of expectations of the ArtifactPublicServiceClient.UpdateCatalog
type ArtifactPublicServiceClientMockUpdateCatalogExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Optional() *mArtifactPublicServiceClientMockUpdateCatalog {
	mmUpdateCatalog.optional = true
	return mmUpdateCatalog
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by ExpectParams functions")
	}

	mmUpdateCatalog.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts}
	mmUpdateCatalog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateCatalog.expectations {
		if minimock.Equal(e.params, mmUpdateCatalog.defaultExpectation.params) {
			mmUpdateCatalog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCatalog.defaultExpectation.params)
		}
	}

	return mmUpdateCatalog
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateCatalog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateCatalog
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) ExpectInParam2(in *mm_artifactv1alpha.UpdateCatalogRequest) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.in = &in
	mmUpdateCatalog.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmUpdateCatalog
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{}
	}

	if mmUpdateCatalog.defaultExpectation.params != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Expect")
	}

	if mmUpdateCatalog.defaultExpectation.paramPtrs == nil {
		mmUpdateCatalog.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateCatalogParamPtrs{}
	}
	mmUpdateCatalog.defaultExpectation.paramPtrs.opts = &opts
	mmUpdateCatalog.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmUpdateCatalog
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateCatalog {
	if mmUpdateCatalog.mock.inspectFuncUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateCatalog")
	}

	mmUpdateCatalog.mock.inspectFuncUpdateCatalog = f

	return mmUpdateCatalog
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateCatalog
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Return(up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	if mmUpdateCatalog.defaultExpectation == nil {
		mmUpdateCatalog.defaultExpectation = &ArtifactPublicServiceClientMockUpdateCatalogExpectation{mock: mmUpdateCatalog.mock}
	}
	mmUpdateCatalog.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateCatalogResults{up1, err}
	mmUpdateCatalog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateCatalog.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateCatalog method
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateCatalog.defaultExpectation != nil {
		mmUpdateCatalog.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateCatalog method")
	}

	if len(mmUpdateCatalog.expectations) > 0 {
		mmUpdateCatalog.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateCatalog method")
	}

	mmUpdateCatalog.mock.funcUpdateCatalog = f
	mmUpdateCatalog.mock.funcUpdateCatalogOrigin = minimock.CallerInfo(1)
	return mmUpdateCatalog.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateCatalog which will trigger the result defined by the following
// Then helper
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) When(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateCatalogExpectation {
	if mmUpdateCatalog.mock.funcUpdateCatalog != nil {
		mmUpdateCatalog.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateCatalog mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateCatalogExpectation{
		mock:               mmUpdateCatalog.mock,
		params:             &ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockUpdateCatalogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateCatalog.expectations = append(mmUpdateCatalog.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateCatalog return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateCatalogExpectation) Then(up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateCatalogResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateCatalog should be invoked
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Times(n uint64) *mArtifactPublicServiceClientMockUpdateCatalog {
	if n == 0 {
		mmUpdateCatalog.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateCatalog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCatalog.expectedInvocations, n)
	mmUpdateCatalog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateCatalog
}

func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) invocationsDone() bool {
	if len(mmUpdateCatalog.expectations) == 0 && mmUpdateCatalog.defaultExpectation == nil && mmUpdateCatalog.mock.funcUpdateCatalog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCatalog.mock.afterUpdateCatalogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCatalog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCatalog implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateCatalog *ArtifactPublicServiceClientMock) UpdateCatalog(ctx context.Context, in *mm_artifactv1alpha.UpdateCatalogRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateCatalogResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateCatalog.beforeUpdateCatalogCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCatalog.afterUpdateCatalogCounter, 1)

	mmUpdateCatalog.t.Helper()

	if mmUpdateCatalog.inspectFuncUpdateCatalog != nil {
		mmUpdateCatalog.inspectFuncUpdateCatalog(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts}

	// Record call args
	mmUpdateCatalog.UpdateCatalogMock.mutex.Lock()
	mmUpdateCatalog.UpdateCatalogMock.callArgs = append(mmUpdateCatalog.UpdateCatalogMock.callArgs, &mm_params)
	mmUpdateCatalog.UpdateCatalogMock.mutex.Unlock()

	for _, e := range mmUpdateCatalog.UpdateCatalogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateCatalog.UpdateCatalogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateCatalogParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCatalog.t.Errorf("ArtifactPublicServiceClientMock.UpdateCatalog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCatalog.UpdateCatalogMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCatalog.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateCatalog")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateCatalog.funcUpdateCatalog != nil {
		return mmUpdateCatalog.funcUpdateCatalog(ctx, in, opts...)
	}
	mmUpdateCatalog.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateCatalog. %v %v %v", ctx, in, opts)
	return
}

// UpdateCatalogAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateCatalog invocations
func (mmUpdateCatalog *ArtifactPublicServiceClientMock) UpdateCatalogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCatalog.afterUpdateCatalogCounter)
}

// UpdateCatalogBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateCatalog invocations
func (mmUpdateCatalog *ArtifactPublicServiceClientMock) UpdateCatalogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCatalog.beforeUpdateCatalogCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateCatalog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCatalog *mArtifactPublicServiceClientMockUpdateCatalog) Calls() []*ArtifactPublicServiceClientMockUpdateCatalogParams {
	mmUpdateCatalog.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateCatalogParams, len(mmUpdateCatalog.callArgs))
	copy(argCopy, mmUpdateCatalog.callArgs)

	mmUpdateCatalog.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCatalogDone returns true if the count of the UpdateCatalog invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateCatalogDone() bool {
	if m.UpdateCatalogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCatalogMock.invocationsDone()
}

// MinimockUpdateCatalogInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateCatalogInspect() {
	for _, e := range m.UpdateCatalogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCatalogCounter := mm_atomic.LoadUint64(&m.afterUpdateCatalogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCatalogMock.defaultExpectation != nil && afterUpdateCatalogCounter < 1 {
		if m.UpdateCatalogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog at\n%s", m.UpdateCatalogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog at\n%s with params: %#v", m.UpdateCatalogMock.defaultExpectation.expectationOrigins.origin, *m.UpdateCatalogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCatalog != nil && afterUpdateCatalogCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateCatalog at\n%s", m.funcUpdateCatalogOrigin)
	}

	if !m.UpdateCatalogMock.invocationsDone() && afterUpdateCatalogCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateCatalog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCatalogMock.expectedInvocations), m.UpdateCatalogMock.expectedInvocationsOrigin, afterUpdateCatalogCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateChunk struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateChunkExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateChunkExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockUpdateChunkExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockUpdateChunkParams
	paramPtrs          *ArtifactPublicServiceClientMockUpdateChunkParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockUpdateChunkExpectationOrigins
	results            *ArtifactPublicServiceClientMockUpdateChunkResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockUpdateChunkParams contains parameters of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateChunkRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateChunkParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateChunkRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateChunkResults contains results of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkResults struct {
	up1 *mm_artifactv1alpha.UpdateChunkResponse
	err error
}

// ArtifactPublicServiceClientMockUpdateChunkOrigins contains origins of expectations of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Optional() *mArtifactPublicServiceClientMockUpdateChunk {
	mmUpdateChunk.optional = true
	return mmUpdateChunk
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by ExpectParams functions")
	}

	mmUpdateChunk.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}
	mmUpdateChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateChunk.expectations {
		if minimock.Equal(e.params, mmUpdateChunk.defaultExpectation.params) {
			mmUpdateChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateChunk.defaultExpectation.params)
		}
	}

	return mmUpdateChunk
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectInParam2(in *mm_artifactv1alpha.UpdateChunkRequest) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.in = &in
	mmUpdateChunk.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.opts = &opts
	mmUpdateChunk.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateChunk")
	}

	mmUpdateChunk.mock.inspectFuncUpdateChunk = f

	return mmUpdateChunk
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Return(up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{mock: mmUpdateChunk.mock}
	}
	mmUpdateChunk.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateChunkResults{up1, err}
	mmUpdateChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateChunk method
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateChunk.defaultExpectation != nil {
		mmUpdateChunk.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateChunk method")
	}

	if len(mmUpdateChunk.expectations) > 0 {
		mmUpdateChunk.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateChunk method")
	}

	mmUpdateChunk.mock.funcUpdateChunk = f
	mmUpdateChunk.mock.funcUpdateChunkOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) When(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateChunkExpectation {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateChunkExpectation{
		mock:               mmUpdateChunk.mock,
		params:             &ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockUpdateChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateChunk.expectations = append(mmUpdateChunk.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateChunk return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateChunkExpectation) Then(up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateChunkResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateChunk should be invoked
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Times(n uint64) *mArtifactPublicServiceClientMockUpdateChunk {
	if n == 0 {
		mmUpdateChunk.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateChunk.expectedInvocations, n)
	mmUpdateChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk
}

func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) invocationsDone() bool {
	if len(mmUpdateChunk.expectations) == 0 && mmUpdateChunk.defaultExpectation == nil && mmUpdateChunk.mock.funcUpdateChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.mock.afterUpdateChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateChunk implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunk(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateChunk.beforeUpdateChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateChunk.afterUpdateChunkCounter, 1)

	mmUpdateChunk.t.Helper()

	if mmUpdateChunk.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.inspectFuncUpdateChunk(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}

	// Record call args
	mmUpdateChunk.UpdateChunkMock.mutex.Lock()
	mmUpdateChunk.UpdateChunkMock.callArgs = append(mmUpdateChunk.UpdateChunkMock.callArgs, &mm_params)
	mmUpdateChunk.UpdateChunkMock.mutex.Unlock()

	for _, e := range mmUpdateChunk.UpdateChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateChunk.UpdateChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateChunk.UpdateChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateChunk.UpdateChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateChunk.UpdateChunkMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateChunk.UpdateChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateChunk.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateChunk")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateChunk.funcUpdateChunk != nil {
		return mmUpdateChunk.funcUpdateChunk(ctx, in, opts...)
	}
	mmUpdateChunk.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateChunk. %v %v %v", ctx, in, opts)
	return
}

// UpdateChunkAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.afterUpdateChunkCounter)
}

// UpdateChunkBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.beforeUpdateChunkCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Calls() []*ArtifactPublicServiceClientMockUpdateChunkParams {
	mmUpdateChunk.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateChunkParams, len(mmUpdateChunk.callArgs))
	copy(argCopy, mmUpdateChunk.callArgs)

	mmUpdateChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateChunkDone returns true if the count of the UpdateChunk invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateChunkDone() bool {
	if m.UpdateChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateChunkMock.invocationsDone()
}

// MinimockUpdateChunkInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateChunkInspect() {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateChunkMock.defaultExpectation != nil && afterUpdateChunkCounter < 1 {
		if m.UpdateChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s", m.UpdateChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s with params: %#v", m.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *m.UpdateChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateChunk != nil && afterUpdateChunkCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s", m.funcUpdateChunkOrigin)
	}

	if !m.UpdateChunkMock.invocationsDone() && afterUpdateChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateChunkMock.expectedInvocations), m.UpdateChunkMock.expectedInvocationsOrigin, afterUpdateChunkCounter)
	}
}

type mArtifactPublicServiceClientMockUploadCatalogFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUploadCatalogFileExpectation
	expectations       []*ArtifactPublicServiceClientMockUploadCatalogFileExpectation

	callArgs []*ArtifactPublicServiceClientMockUploadCatalogFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockUploadCatalogFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockUploadCatalogFileParams
	paramPtrs          *ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockUploadCatalogFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockUploadCatalogFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockUploadCatalogFileParams contains parameters of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UploadCatalogFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UploadCatalogFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUploadCatalogFileResults contains results of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileResults struct {
	up1 *mm_artifactv1alpha.UploadCatalogFileResponse
	err error
}

// ArtifactPublicServiceClientMockUploadCatalogFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.UploadCatalogFile
type ArtifactPublicServiceClientMockUploadCatalogFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Optional() *mArtifactPublicServiceClientMockUploadCatalogFile {
	mmUploadCatalogFile.optional = true
	return mmUploadCatalogFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Expect(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by ExpectParams functions")
	}

	mmUploadCatalogFile.defaultExpectation.params = &ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts}
	mmUploadCatalogFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadCatalogFile.expectations {
		if minimock.Equal(e.params, mmUploadCatalogFile.defaultExpectation.params) {
			mmUploadCatalogFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadCatalogFile.defaultExpectation.params)
		}
	}

	return mmUploadCatalogFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadCatalogFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadCatalogFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) ExpectInParam2(in *mm_artifactv1alpha.UploadCatalogFileRequest) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.in = &in
	mmUploadCatalogFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmUploadCatalogFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{}
	}

	if mmUploadCatalogFile.defaultExpectation.params != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Expect")
	}

	if mmUploadCatalogFile.defaultExpectation.paramPtrs == nil {
		mmUploadCatalogFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUploadCatalogFileParamPtrs{}
	}
	mmUploadCatalogFile.defaultExpectation.paramPtrs.opts = &opts
	mmUploadCatalogFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmUploadCatalogFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if mmUploadCatalogFile.mock.inspectFuncUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UploadCatalogFile")
	}

	mmUploadCatalogFile.mock.inspectFuncUploadCatalogFile = f

	return mmUploadCatalogFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UploadCatalogFile
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Return(up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	if mmUploadCatalogFile.defaultExpectation == nil {
		mmUploadCatalogFile.defaultExpectation = &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{mock: mmUploadCatalogFile.mock}
	}
	mmUploadCatalogFile.defaultExpectation.results = &ArtifactPublicServiceClientMockUploadCatalogFileResults{up1, err}
	mmUploadCatalogFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadCatalogFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UploadCatalogFile method
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUploadCatalogFile.defaultExpectation != nil {
		mmUploadCatalogFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UploadCatalogFile method")
	}

	if len(mmUploadCatalogFile.expectations) > 0 {
		mmUploadCatalogFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UploadCatalogFile method")
	}

	mmUploadCatalogFile.mock.funcUploadCatalogFile = f
	mmUploadCatalogFile.mock.funcUploadCatalogFileOrigin = minimock.CallerInfo(1)
	return mmUploadCatalogFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UploadCatalogFile which will trigger the result defined by the following
// Then helper
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) When(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUploadCatalogFileExpectation {
	if mmUploadCatalogFile.mock.funcUploadCatalogFile != nil {
		mmUploadCatalogFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UploadCatalogFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUploadCatalogFileExpectation{
		mock:               mmUploadCatalogFile.mock,
		params:             &ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockUploadCatalogFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadCatalogFile.expectations = append(mmUploadCatalogFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UploadCatalogFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUploadCatalogFileExpectation) Then(up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUploadCatalogFileResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UploadCatalogFile should be invoked
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Times(n uint64) *mArtifactPublicServiceClientMockUploadCatalogFile {
	if n == 0 {
		mmUploadCatalogFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UploadCatalogFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadCatalogFile.expectedInvocations, n)
	mmUploadCatalogFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadCatalogFile
}

func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) invocationsDone() bool {
	if len(mmUploadCatalogFile.expectations) == 0 && mmUploadCatalogFile.defaultExpectation == nil && mmUploadCatalogFile.mock.funcUploadCatalogFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadCatalogFile.mock.afterUploadCatalogFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadCatalogFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadCatalogFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmUploadCatalogFile *ArtifactPublicServiceClientMock) UploadCatalogFile(ctx context.Context, in *mm_artifactv1alpha.UploadCatalogFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UploadCatalogFileResponse, err error) {
	mm_atomic.AddUint64(&mmUploadCatalogFile.beforeUploadCatalogFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadCatalogFile.afterUploadCatalogFileCounter, 1)

	mmUploadCatalogFile.t.Helper()

	if mmUploadCatalogFile.inspectFuncUploadCatalogFile != nil {
		mmUploadCatalogFile.inspectFuncUploadCatalogFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts}

	// Record call args
	mmUploadCatalogFile.UploadCatalogFileMock.mutex.Lock()
	mmUploadCatalogFile.UploadCatalogFileMock.callArgs = append(mmUploadCatalogFile.UploadCatalogFileMock.callArgs, &mm_params)
	mmUploadCatalogFile.UploadCatalogFileMock.mutex.Unlock()

	for _, e := range mmUploadCatalogFile.UploadCatalogFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUploadCatalogFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadCatalogFile.t.Errorf("ArtifactPublicServiceClientMock.UploadCatalogFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadCatalogFile.UploadCatalogFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadCatalogFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UploadCatalogFile")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUploadCatalogFile.funcUploadCatalogFile != nil {
		return mmUploadCatalogFile.funcUploadCatalogFile(ctx, in, opts...)
	}
	mmUploadCatalogFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UploadCatalogFile. %v %v %v", ctx, in, opts)
	return
}

// UploadCatalogFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UploadCatalogFile invocations
func (mmUploadCatalogFile *ArtifactPublicServiceClientMock) UploadCatalogFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadCatalogFile.afterUploadCatalogFileCounter)
}

// UploadCatalogFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.UploadCatalogFile invocations
func (mmUploadCatalogFile *ArtifactPublicServiceClientMock) UploadCatalogFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadCatalogFile.beforeUploadCatalogFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UploadCatalogFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadCatalogFile *mArtifactPublicServiceClientMockUploadCatalogFile) Calls() []*ArtifactPublicServiceClientMockUploadCatalogFileParams {
	mmUploadCatalogFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUploadCatalogFileParams, len(mmUploadCatalogFile.callArgs))
	copy(argCopy, mmUploadCatalogFile.callArgs)

	mmUploadCatalogFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadCatalogFileDone returns true if the count of the UploadCatalogFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUploadCatalogFileDone() bool {
	if m.UploadCatalogFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadCatalogFileMock.invocationsDone()
}

// MinimockUploadCatalogFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUploadCatalogFileInspect() {
	for _, e := range m.UploadCatalogFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadCatalogFileCounter := mm_atomic.LoadUint64(&m.afterUploadCatalogFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadCatalogFileMock.defaultExpectation != nil && afterUploadCatalogFileCounter < 1 {
		if m.UploadCatalogFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile at\n%s", m.UploadCatalogFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile at\n%s with params: %#v", m.UploadCatalogFileMock.defaultExpectation.expectationOrigins.origin, *m.UploadCatalogFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadCatalogFile != nil && afterUploadCatalogFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UploadCatalogFile at\n%s", m.funcUploadCatalogFileOrigin)
	}

	if !m.UploadCatalogFileMock.invocationsDone() && afterUploadCatalogFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UploadCatalogFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadCatalogFileMock.expectedInvocations), m.UploadCatalogFileMock.expectedInvocationsOrigin, afterUploadCatalogFileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ArtifactPublicServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateCatalogInspect()

			m.MinimockDeleteCatalogInspect()

			m.MinimockDeleteCatalogFileInspect()

			m.MinimockGetFileCatalogInspect()

			m.MinimockGetObjectDownloadURLInspect()

			m.MinimockGetObjectUploadURLInspect()

			m.MinimockGetSourceFileInspect()

			m.MinimockListCatalogFilesInspect()

			m.MinimockListCatalogRunsInspect()

			m.MinimockListCatalogsInspect()

			m.MinimockListChunksInspect()

			m.MinimockLivenessInspect()

			m.MinimockProcessCatalogFilesInspect()

			m.MinimockQuestionAnsweringInspect()

			m.MinimockReadinessInspect()

			m.MinimockSearchChunksInspect()

			m.MinimockSearchSourceFilesInspect()

			m.MinimockSimilarityChunksSearchInspect()

			m.MinimockUpdateCatalogInspect()

			m.MinimockUpdateChunkInspect()

			m.MinimockUploadCatalogFileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ArtifactPublicServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ArtifactPublicServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCatalogDone() &&
		m.MinimockDeleteCatalogDone() &&
		m.MinimockDeleteCatalogFileDone() &&
		m.MinimockGetFileCatalogDone() &&
		m.MinimockGetObjectDownloadURLDone() &&
		m.MinimockGetObjectUploadURLDone() &&
		m.MinimockGetSourceFileDone() &&
		m.MinimockListCatalogFilesDone() &&
		m.MinimockListCatalogRunsDone() &&
		m.MinimockListCatalogsDone() &&
		m.MinimockListChunksDone() &&
		m.MinimockLivenessDone() &&
		m.MinimockProcessCatalogFilesDone() &&
		m.MinimockQuestionAnsweringDone() &&
		m.MinimockReadinessDone() &&
		m.MinimockSearchChunksDone() &&
		m.MinimockSearchSourceFilesDone() &&
		m.MinimockSimilarityChunksSearchDone() &&
		m.MinimockUpdateCatalogDone() &&
		m.MinimockUpdateChunkDone() &&
		m.MinimockUploadCatalogFileDone()
}
