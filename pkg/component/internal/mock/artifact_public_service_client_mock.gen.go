// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_artifactv1alpha "github.com/instill-ai/protogen-go/artifact/artifact/v1alpha"
	grpc "google.golang.org/grpc"
)

// ArtifactPublicServiceClientMock implements mm_artifactv1alpha.ArtifactPublicServiceClient
type ArtifactPublicServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateFile          func(ctx context.Context, in *mm_artifactv1alpha.CreateFileRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateFileResponse, err error)
	funcCreateFileOrigin    string
	inspectFuncCreateFile   func(ctx context.Context, in *mm_artifactv1alpha.CreateFileRequest, opts ...grpc.CallOption)
	afterCreateFileCounter  uint64
	beforeCreateFileCounter uint64
	CreateFileMock          mArtifactPublicServiceClientMockCreateFile

	funcCreateKnowledgeBase          func(ctx context.Context, in *mm_artifactv1alpha.CreateKnowledgeBaseRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error)
	funcCreateKnowledgeBaseOrigin    string
	inspectFuncCreateKnowledgeBase   func(ctx context.Context, in *mm_artifactv1alpha.CreateKnowledgeBaseRequest, opts ...grpc.CallOption)
	afterCreateKnowledgeBaseCounter  uint64
	beforeCreateKnowledgeBaseCounter uint64
	CreateKnowledgeBaseMock          mArtifactPublicServiceClientMockCreateKnowledgeBase

	funcDeleteFile          func(ctx context.Context, in *mm_artifactv1alpha.DeleteFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteFileResponse, err error)
	funcDeleteFileOrigin    string
	inspectFuncDeleteFile   func(ctx context.Context, in *mm_artifactv1alpha.DeleteFileRequest, opts ...grpc.CallOption)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mArtifactPublicServiceClientMockDeleteFile

	funcDeleteKnowledgeBase          func(ctx context.Context, in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error)
	funcDeleteKnowledgeBaseOrigin    string
	inspectFuncDeleteKnowledgeBase   func(ctx context.Context, in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest, opts ...grpc.CallOption)
	afterDeleteKnowledgeBaseCounter  uint64
	beforeDeleteKnowledgeBaseCounter uint64
	DeleteKnowledgeBaseMock          mArtifactPublicServiceClientMockDeleteKnowledgeBase

	funcGetChunk          func(ctx context.Context, in *mm_artifactv1alpha.GetChunkRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetChunkResponse, err error)
	funcGetChunkOrigin    string
	inspectFuncGetChunk   func(ctx context.Context, in *mm_artifactv1alpha.GetChunkRequest, opts ...grpc.CallOption)
	afterGetChunkCounter  uint64
	beforeGetChunkCounter uint64
	GetChunkMock          mArtifactPublicServiceClientMockGetChunk

	funcGetFile          func(ctx context.Context, in *mm_artifactv1alpha.GetFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileResponse, err error)
	funcGetFileOrigin    string
	inspectFuncGetFile   func(ctx context.Context, in *mm_artifactv1alpha.GetFileRequest, opts ...grpc.CallOption)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mArtifactPublicServiceClientMockGetFile

	funcGetKnowledgeBase          func(ctx context.Context, in *mm_artifactv1alpha.GetKnowledgeBaseRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error)
	funcGetKnowledgeBaseOrigin    string
	inspectFuncGetKnowledgeBase   func(ctx context.Context, in *mm_artifactv1alpha.GetKnowledgeBaseRequest, opts ...grpc.CallOption)
	afterGetKnowledgeBaseCounter  uint64
	beforeGetKnowledgeBaseCounter uint64
	GetKnowledgeBaseMock          mArtifactPublicServiceClientMockGetKnowledgeBase

	funcGetObjectDownloadURL          func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)
	funcGetObjectDownloadURLOrigin    string
	inspectFuncGetObjectDownloadURL   func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption)
	afterGetObjectDownloadURLCounter  uint64
	beforeGetObjectDownloadURLCounter uint64
	GetObjectDownloadURLMock          mArtifactPublicServiceClientMockGetObjectDownloadURL

	funcGetObjectUploadURL          func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)
	funcGetObjectUploadURLOrigin    string
	inspectFuncGetObjectUploadURL   func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption)
	afterGetObjectUploadURLCounter  uint64
	beforeGetObjectUploadURLCounter uint64
	GetObjectUploadURLMock          mArtifactPublicServiceClientMockGetObjectUploadURL

	funcListChunks          func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error)
	funcListChunksOrigin    string
	inspectFuncListChunks   func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption)
	afterListChunksCounter  uint64
	beforeListChunksCounter uint64
	ListChunksMock          mArtifactPublicServiceClientMockListChunks

	funcListFiles          func(ctx context.Context, in *mm_artifactv1alpha.ListFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListFilesResponse, err error)
	funcListFilesOrigin    string
	inspectFuncListFiles   func(ctx context.Context, in *mm_artifactv1alpha.ListFilesRequest, opts ...grpc.CallOption)
	afterListFilesCounter  uint64
	beforeListFilesCounter uint64
	ListFilesMock          mArtifactPublicServiceClientMockListFiles

	funcListKnowledgeBaseRuns          func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error)
	funcListKnowledgeBaseRunsOrigin    string
	inspectFuncListKnowledgeBaseRuns   func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest, opts ...grpc.CallOption)
	afterListKnowledgeBaseRunsCounter  uint64
	beforeListKnowledgeBaseRunsCounter uint64
	ListKnowledgeBaseRunsMock          mArtifactPublicServiceClientMockListKnowledgeBaseRuns

	funcListKnowledgeBases          func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBasesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error)
	funcListKnowledgeBasesOrigin    string
	inspectFuncListKnowledgeBases   func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBasesRequest, opts ...grpc.CallOption)
	afterListKnowledgeBasesCounter  uint64
	beforeListKnowledgeBasesCounter uint64
	ListKnowledgeBasesMock          mArtifactPublicServiceClientMockListKnowledgeBases

	funcLiveness          func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error)
	funcLivenessOrigin    string
	inspectFuncLiveness   func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption)
	afterLivenessCounter  uint64
	beforeLivenessCounter uint64
	LivenessMock          mArtifactPublicServiceClientMockLiveness

	funcReadiness          func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error)
	funcReadinessOrigin    string
	inspectFuncReadiness   func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption)
	afterReadinessCounter  uint64
	beforeReadinessCounter uint64
	ReadinessMock          mArtifactPublicServiceClientMockReadiness

	funcReprocessFile          func(ctx context.Context, in *mm_artifactv1alpha.ReprocessFileRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReprocessFileResponse, err error)
	funcReprocessFileOrigin    string
	inspectFuncReprocessFile   func(ctx context.Context, in *mm_artifactv1alpha.ReprocessFileRequest, opts ...grpc.CallOption)
	afterReprocessFileCounter  uint64
	beforeReprocessFileCounter uint64
	ReprocessFileMock          mArtifactPublicServiceClientMockReprocessFile

	funcSearchChunks          func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchChunksResponse, err error)
	funcSearchChunksOrigin    string
	inspectFuncSearchChunks   func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption)
	afterSearchChunksCounter  uint64
	beforeSearchChunksCounter uint64
	SearchChunksMock          mArtifactPublicServiceClientMockSearchChunks

	funcUpdateChunk          func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error)
	funcUpdateChunkOrigin    string
	inspectFuncUpdateChunk   func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption)
	afterUpdateChunkCounter  uint64
	beforeUpdateChunkCounter uint64
	UpdateChunkMock          mArtifactPublicServiceClientMockUpdateChunk

	funcUpdateFile          func(ctx context.Context, in *mm_artifactv1alpha.UpdateFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateFileResponse, err error)
	funcUpdateFileOrigin    string
	inspectFuncUpdateFile   func(ctx context.Context, in *mm_artifactv1alpha.UpdateFileRequest, opts ...grpc.CallOption)
	afterUpdateFileCounter  uint64
	beforeUpdateFileCounter uint64
	UpdateFileMock          mArtifactPublicServiceClientMockUpdateFile

	funcUpdateKnowledgeBase          func(ctx context.Context, in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error)
	funcUpdateKnowledgeBaseOrigin    string
	inspectFuncUpdateKnowledgeBase   func(ctx context.Context, in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest, opts ...grpc.CallOption)
	afterUpdateKnowledgeBaseCounter  uint64
	beforeUpdateKnowledgeBaseCounter uint64
	UpdateKnowledgeBaseMock          mArtifactPublicServiceClientMockUpdateKnowledgeBase
}

// NewArtifactPublicServiceClientMock returns a mock for mm_artifactv1alpha.ArtifactPublicServiceClient
func NewArtifactPublicServiceClientMock(t minimock.Tester) *ArtifactPublicServiceClientMock {
	m := &ArtifactPublicServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateFileMock = mArtifactPublicServiceClientMockCreateFile{mock: m}
	m.CreateFileMock.callArgs = []*ArtifactPublicServiceClientMockCreateFileParams{}

	m.CreateKnowledgeBaseMock = mArtifactPublicServiceClientMockCreateKnowledgeBase{mock: m}
	m.CreateKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceClientMockCreateKnowledgeBaseParams{}

	m.DeleteFileMock = mArtifactPublicServiceClientMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*ArtifactPublicServiceClientMockDeleteFileParams{}

	m.DeleteKnowledgeBaseMock = mArtifactPublicServiceClientMockDeleteKnowledgeBase{mock: m}
	m.DeleteKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams{}

	m.GetChunkMock = mArtifactPublicServiceClientMockGetChunk{mock: m}
	m.GetChunkMock.callArgs = []*ArtifactPublicServiceClientMockGetChunkParams{}

	m.GetFileMock = mArtifactPublicServiceClientMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*ArtifactPublicServiceClientMockGetFileParams{}

	m.GetKnowledgeBaseMock = mArtifactPublicServiceClientMockGetKnowledgeBase{mock: m}
	m.GetKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceClientMockGetKnowledgeBaseParams{}

	m.GetObjectDownloadURLMock = mArtifactPublicServiceClientMockGetObjectDownloadURL{mock: m}
	m.GetObjectDownloadURLMock.callArgs = []*ArtifactPublicServiceClientMockGetObjectDownloadURLParams{}

	m.GetObjectUploadURLMock = mArtifactPublicServiceClientMockGetObjectUploadURL{mock: m}
	m.GetObjectUploadURLMock.callArgs = []*ArtifactPublicServiceClientMockGetObjectUploadURLParams{}

	m.ListChunksMock = mArtifactPublicServiceClientMockListChunks{mock: m}
	m.ListChunksMock.callArgs = []*ArtifactPublicServiceClientMockListChunksParams{}

	m.ListFilesMock = mArtifactPublicServiceClientMockListFiles{mock: m}
	m.ListFilesMock.callArgs = []*ArtifactPublicServiceClientMockListFilesParams{}

	m.ListKnowledgeBaseRunsMock = mArtifactPublicServiceClientMockListKnowledgeBaseRuns{mock: m}
	m.ListKnowledgeBaseRunsMock.callArgs = []*ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams{}

	m.ListKnowledgeBasesMock = mArtifactPublicServiceClientMockListKnowledgeBases{mock: m}
	m.ListKnowledgeBasesMock.callArgs = []*ArtifactPublicServiceClientMockListKnowledgeBasesParams{}

	m.LivenessMock = mArtifactPublicServiceClientMockLiveness{mock: m}
	m.LivenessMock.callArgs = []*ArtifactPublicServiceClientMockLivenessParams{}

	m.ReadinessMock = mArtifactPublicServiceClientMockReadiness{mock: m}
	m.ReadinessMock.callArgs = []*ArtifactPublicServiceClientMockReadinessParams{}

	m.ReprocessFileMock = mArtifactPublicServiceClientMockReprocessFile{mock: m}
	m.ReprocessFileMock.callArgs = []*ArtifactPublicServiceClientMockReprocessFileParams{}

	m.SearchChunksMock = mArtifactPublicServiceClientMockSearchChunks{mock: m}
	m.SearchChunksMock.callArgs = []*ArtifactPublicServiceClientMockSearchChunksParams{}

	m.UpdateChunkMock = mArtifactPublicServiceClientMockUpdateChunk{mock: m}
	m.UpdateChunkMock.callArgs = []*ArtifactPublicServiceClientMockUpdateChunkParams{}

	m.UpdateFileMock = mArtifactPublicServiceClientMockUpdateFile{mock: m}
	m.UpdateFileMock.callArgs = []*ArtifactPublicServiceClientMockUpdateFileParams{}

	m.UpdateKnowledgeBaseMock = mArtifactPublicServiceClientMockUpdateKnowledgeBase{mock: m}
	m.UpdateKnowledgeBaseMock.callArgs = []*ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mArtifactPublicServiceClientMockCreateFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockCreateFileExpectation
	expectations       []*ArtifactPublicServiceClientMockCreateFileExpectation

	callArgs []*ArtifactPublicServiceClientMockCreateFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockCreateFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.CreateFile
type ArtifactPublicServiceClientMockCreateFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockCreateFileParams
	paramPtrs          *ArtifactPublicServiceClientMockCreateFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockCreateFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockCreateFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockCreateFileParams contains parameters of the ArtifactPublicServiceClient.CreateFile
type ArtifactPublicServiceClientMockCreateFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.CreateFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.CreateFile
type ArtifactPublicServiceClientMockCreateFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.CreateFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateFileResults contains results of the ArtifactPublicServiceClient.CreateFile
type ArtifactPublicServiceClientMockCreateFileResults struct {
	cp1 *mm_artifactv1alpha.CreateFileResponse
	err error
}

// ArtifactPublicServiceClientMockCreateFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.CreateFile
type ArtifactPublicServiceClientMockCreateFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) Optional() *mArtifactPublicServiceClientMockCreateFile {
	mmCreateFile.optional = true
	return mmCreateFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.CreateFile
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) Expect(ctx context.Context, in *mm_artifactv1alpha.CreateFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateFile {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceClientMockCreateFileExpectation{}
	}

	if mmCreateFile.defaultExpectation.paramPtrs != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by ExpectParams functions")
	}

	mmCreateFile.defaultExpectation.params = &ArtifactPublicServiceClientMockCreateFileParams{ctx, in, opts}
	mmCreateFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateFile.expectations {
		if minimock.Equal(e.params, mmCreateFile.defaultExpectation.params) {
			mmCreateFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateFile.defaultExpectation.params)
		}
	}

	return mmCreateFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.CreateFile
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockCreateFile {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceClientMockCreateFileExpectation{}
	}

	if mmCreateFile.defaultExpectation.params != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Expect")
	}

	if mmCreateFile.defaultExpectation.paramPtrs == nil {
		mmCreateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateFileParamPtrs{}
	}
	mmCreateFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.CreateFile
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) ExpectInParam2(in *mm_artifactv1alpha.CreateFileRequest) *mArtifactPublicServiceClientMockCreateFile {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceClientMockCreateFileExpectation{}
	}

	if mmCreateFile.defaultExpectation.params != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Expect")
	}

	if mmCreateFile.defaultExpectation.paramPtrs == nil {
		mmCreateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateFileParamPtrs{}
	}
	mmCreateFile.defaultExpectation.paramPtrs.in = &in
	mmCreateFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmCreateFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.CreateFile
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateFile {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceClientMockCreateFileExpectation{}
	}

	if mmCreateFile.defaultExpectation.params != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Expect")
	}

	if mmCreateFile.defaultExpectation.paramPtrs == nil {
		mmCreateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateFileParamPtrs{}
	}
	mmCreateFile.defaultExpectation.paramPtrs.opts = &opts
	mmCreateFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmCreateFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.CreateFile
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.CreateFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockCreateFile {
	if mmCreateFile.mock.inspectFuncCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.CreateFile")
	}

	mmCreateFile.mock.inspectFuncCreateFile = f

	return mmCreateFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.CreateFile
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) Return(cp1 *mm_artifactv1alpha.CreateFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Set")
	}

	if mmCreateFile.defaultExpectation == nil {
		mmCreateFile.defaultExpectation = &ArtifactPublicServiceClientMockCreateFileExpectation{mock: mmCreateFile.mock}
	}
	mmCreateFile.defaultExpectation.results = &ArtifactPublicServiceClientMockCreateFileResults{cp1, err}
	mmCreateFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.CreateFile method
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.CreateFileRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmCreateFile.defaultExpectation != nil {
		mmCreateFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.CreateFile method")
	}

	if len(mmCreateFile.expectations) > 0 {
		mmCreateFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.CreateFile method")
	}

	mmCreateFile.mock.funcCreateFile = f
	mmCreateFile.mock.funcCreateFileOrigin = minimock.CallerInfo(1)
	return mmCreateFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.CreateFile which will trigger the result defined by the following
// Then helper
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) When(ctx context.Context, in *mm_artifactv1alpha.CreateFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockCreateFileExpectation {
	if mmCreateFile.mock.funcCreateFile != nil {
		mmCreateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockCreateFileExpectation{
		mock:               mmCreateFile.mock,
		params:             &ArtifactPublicServiceClientMockCreateFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockCreateFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateFile.expectations = append(mmCreateFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.CreateFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockCreateFileExpectation) Then(cp1 *mm_artifactv1alpha.CreateFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockCreateFileResults{cp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.CreateFile should be invoked
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) Times(n uint64) *mArtifactPublicServiceClientMockCreateFile {
	if n == 0 {
		mmCreateFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.CreateFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateFile.expectedInvocations, n)
	mmCreateFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateFile
}

func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) invocationsDone() bool {
	if len(mmCreateFile.expectations) == 0 && mmCreateFile.defaultExpectation == nil && mmCreateFile.mock.funcCreateFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateFile.mock.afterCreateFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmCreateFile *ArtifactPublicServiceClientMock) CreateFile(ctx context.Context, in *mm_artifactv1alpha.CreateFileRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateFileResponse, err error) {
	mm_atomic.AddUint64(&mmCreateFile.beforeCreateFileCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateFile.afterCreateFileCounter, 1)

	mmCreateFile.t.Helper()

	if mmCreateFile.inspectFuncCreateFile != nil {
		mmCreateFile.inspectFuncCreateFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockCreateFileParams{ctx, in, opts}

	// Record call args
	mmCreateFile.CreateFileMock.mutex.Lock()
	mmCreateFile.CreateFileMock.callArgs = append(mmCreateFile.CreateFileMock.callArgs, &mm_params)
	mmCreateFile.CreateFileMock.mutex.Unlock()

	for _, e := range mmCreateFile.CreateFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateFile.CreateFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateFile.CreateFileMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateFile.CreateFileMock.defaultExpectation.params
		mm_want_ptrs := mmCreateFile.CreateFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockCreateFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateFile.t.Errorf("ArtifactPublicServiceClientMock.CreateFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateFile.CreateFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateFile.t.Errorf("ArtifactPublicServiceClientMock.CreateFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateFile.CreateFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateFile.t.Errorf("ArtifactPublicServiceClientMock.CreateFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateFile.CreateFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateFile.t.Errorf("ArtifactPublicServiceClientMock.CreateFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateFile.CreateFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateFile.CreateFileMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.CreateFile")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateFile.funcCreateFile != nil {
		return mmCreateFile.funcCreateFile(ctx, in, opts...)
	}
	mmCreateFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.CreateFile. %v %v %v", ctx, in, opts)
	return
}

// CreateFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.CreateFile invocations
func (mmCreateFile *ArtifactPublicServiceClientMock) CreateFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateFile.afterCreateFileCounter)
}

// CreateFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.CreateFile invocations
func (mmCreateFile *ArtifactPublicServiceClientMock) CreateFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateFile.beforeCreateFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.CreateFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateFile *mArtifactPublicServiceClientMockCreateFile) Calls() []*ArtifactPublicServiceClientMockCreateFileParams {
	mmCreateFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockCreateFileParams, len(mmCreateFile.callArgs))
	copy(argCopy, mmCreateFile.callArgs)

	mmCreateFile.mutex.RUnlock()

	return argCopy
}

// MinimockCreateFileDone returns true if the count of the CreateFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockCreateFileDone() bool {
	if m.CreateFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateFileMock.invocationsDone()
}

// MinimockCreateFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockCreateFileInspect() {
	for _, e := range m.CreateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateFileCounter := mm_atomic.LoadUint64(&m.afterCreateFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateFileMock.defaultExpectation != nil && afterCreateFileCounter < 1 {
		if m.CreateFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateFile at\n%s", m.CreateFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateFile at\n%s with params: %#v", m.CreateFileMock.defaultExpectation.expectationOrigins.origin, *m.CreateFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateFile != nil && afterCreateFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateFile at\n%s", m.funcCreateFileOrigin)
	}

	if !m.CreateFileMock.invocationsDone() && afterCreateFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.CreateFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateFileMock.expectedInvocations), m.CreateFileMock.expectedInvocationsOrigin, afterCreateFileCounter)
	}
}

type mArtifactPublicServiceClientMockCreateKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceClientMockCreateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceClient.CreateKnowledgeBase
type ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockCreateKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceClientMockCreateKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceClientMockCreateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockCreateKnowledgeBaseParams contains parameters of the ArtifactPublicServiceClient.CreateKnowledgeBase
type ArtifactPublicServiceClientMockCreateKnowledgeBaseParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.CreateKnowledgeBaseRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.CreateKnowledgeBase
type ArtifactPublicServiceClientMockCreateKnowledgeBaseParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.CreateKnowledgeBaseRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockCreateKnowledgeBaseResults contains results of the ArtifactPublicServiceClient.CreateKnowledgeBase
type ArtifactPublicServiceClientMockCreateKnowledgeBaseResults struct {
	cp1 *mm_artifactv1alpha.CreateKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceClientMockCreateKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceClient.CreateKnowledgeBase
type ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) Optional() *mArtifactPublicServiceClientMockCreateKnowledgeBase {
	mmCreateKnowledgeBase.optional = true
	return mmCreateKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceClient.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) Expect(ctx context.Context, in *mm_artifactv1alpha.CreateKnowledgeBaseRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmCreateKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceClientMockCreateKnowledgeBaseParams{ctx, in, opts}
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmCreateKnowledgeBase.defaultExpectation.params) {
			mmCreateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmCreateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) ExpectInParam2(in *mm_artifactv1alpha.CreateKnowledgeBaseRequest) *mArtifactPublicServiceClientMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.in = &in
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation{}
	}

	if mmCreateKnowledgeBase.defaultExpectation.params != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Expect")
	}

	if mmCreateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmCreateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockCreateKnowledgeBaseParamPtrs{}
	}
	mmCreateKnowledgeBase.defaultExpectation.paramPtrs.opts = &opts
	mmCreateKnowledgeBase.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmCreateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.CreateKnowledgeBaseRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockCreateKnowledgeBase {
	if mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.CreateKnowledgeBase")
	}

	mmCreateKnowledgeBase.mock.inspectFuncCreateKnowledgeBase = f

	return mmCreateKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.CreateKnowledgeBase
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) Return(cp1 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Set")
	}

	if mmCreateKnowledgeBase.defaultExpectation == nil {
		mmCreateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation{mock: mmCreateKnowledgeBase.mock}
	}
	mmCreateKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceClientMockCreateKnowledgeBaseResults{cp1, err}
	mmCreateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.CreateKnowledgeBase method
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) Set(f func(ctx context.Context, in *mm_artifactv1alpha.CreateKnowledgeBaseRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmCreateKnowledgeBase.defaultExpectation != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.CreateKnowledgeBase method")
	}

	if len(mmCreateKnowledgeBase.expectations) > 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.CreateKnowledgeBase method")
	}

	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase = f
	mmCreateKnowledgeBase.mock.funcCreateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceClient.CreateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) When(ctx context.Context, in *mm_artifactv1alpha.CreateKnowledgeBaseRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation {
	if mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.CreateKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation{
		mock:               mmCreateKnowledgeBase.mock,
		params:             &ArtifactPublicServiceClientMockCreateKnowledgeBaseParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateKnowledgeBase.expectations = append(mmCreateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.CreateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockCreateKnowledgeBaseExpectation) Then(cp1 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockCreateKnowledgeBaseResults{cp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.CreateKnowledgeBase should be invoked
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) Times(n uint64) *mArtifactPublicServiceClientMockCreateKnowledgeBase {
	if n == 0 {
		mmCreateKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.CreateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateKnowledgeBase.expectedInvocations, n)
	mmCreateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateKnowledgeBase
}

func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) invocationsDone() bool {
	if len(mmCreateKnowledgeBase.expectations) == 0 && mmCreateKnowledgeBase.defaultExpectation == nil && mmCreateKnowledgeBase.mock.funcCreateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.mock.afterCreateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmCreateKnowledgeBase *ArtifactPublicServiceClientMock) CreateKnowledgeBase(ctx context.Context, in *mm_artifactv1alpha.CreateKnowledgeBaseRequest, opts ...grpc.CallOption) (cp1 *mm_artifactv1alpha.CreateKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter, 1)

	mmCreateKnowledgeBase.t.Helper()

	if mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase != nil {
		mmCreateKnowledgeBase.inspectFuncCreateKnowledgeBase(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockCreateKnowledgeBaseParams{ctx, in, opts}

	// Record call args
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Lock()
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs = append(mmCreateKnowledgeBase.CreateKnowledgeBaseMock.callArgs, &mm_params)
	mmCreateKnowledgeBase.CreateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmCreateKnowledgeBase.CreateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockCreateKnowledgeBaseParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.CreateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmCreateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.CreateKnowledgeBase got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmCreateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.CreateKnowledgeBase got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.CreateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateKnowledgeBase.CreateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.CreateKnowledgeBase")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreateKnowledgeBase.funcCreateKnowledgeBase != nil {
		return mmCreateKnowledgeBase.funcCreateKnowledgeBase(ctx, in, opts...)
	}
	mmCreateKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.CreateKnowledgeBase. %v %v %v", ctx, in, opts)
	return
}

// CreateKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceClientMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *ArtifactPublicServiceClientMock) CreateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.afterCreateKnowledgeBaseCounter)
}

// CreateKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceClientMock.CreateKnowledgeBase invocations
func (mmCreateKnowledgeBase *ArtifactPublicServiceClientMock) CreateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateKnowledgeBase.beforeCreateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.CreateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateKnowledgeBase *mArtifactPublicServiceClientMockCreateKnowledgeBase) Calls() []*ArtifactPublicServiceClientMockCreateKnowledgeBaseParams {
	mmCreateKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockCreateKnowledgeBaseParams, len(mmCreateKnowledgeBase.callArgs))
	copy(argCopy, mmCreateKnowledgeBase.callArgs)

	mmCreateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockCreateKnowledgeBaseDone returns true if the count of the CreateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockCreateKnowledgeBaseDone() bool {
	if m.CreateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateKnowledgeBaseMock.invocationsDone()
}

// MinimockCreateKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockCreateKnowledgeBaseInspect() {
	for _, e := range m.CreateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterCreateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateKnowledgeBaseMock.defaultExpectation != nil && afterCreateKnowledgeBaseCounter < 1 {
		if m.CreateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateKnowledgeBase at\n%s", m.CreateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateKnowledgeBase at\n%s with params: %#v", m.CreateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.CreateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateKnowledgeBase != nil && afterCreateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.CreateKnowledgeBase at\n%s", m.funcCreateKnowledgeBaseOrigin)
	}

	if !m.CreateKnowledgeBaseMock.invocationsDone() && afterCreateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.CreateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateKnowledgeBaseMock.expectedInvocations), m.CreateKnowledgeBaseMock.expectedInvocationsOrigin, afterCreateKnowledgeBaseCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteFileExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteFileExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockDeleteFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteFile
type ArtifactPublicServiceClientMockDeleteFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockDeleteFileParams
	paramPtrs          *ArtifactPublicServiceClientMockDeleteFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockDeleteFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockDeleteFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockDeleteFileParams contains parameters of the ArtifactPublicServiceClient.DeleteFile
type ArtifactPublicServiceClientMockDeleteFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteFile
type ArtifactPublicServiceClientMockDeleteFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteFileResults contains results of the ArtifactPublicServiceClient.DeleteFile
type ArtifactPublicServiceClientMockDeleteFileResults struct {
	dp1 *mm_artifactv1alpha.DeleteFileResponse
	err error
}

// ArtifactPublicServiceClientMockDeleteFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.DeleteFile
type ArtifactPublicServiceClientMockDeleteFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) Optional() *mArtifactPublicServiceClientMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteFileParams{ctx, in, opts}
	mmDeleteFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) ExpectInParam2(in *mm_artifactv1alpha.DeleteFileRequest) *mArtifactPublicServiceClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.in = &in
	mmDeleteFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteFile
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) Return(dp1 *mm_artifactv1alpha.DeleteFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &ArtifactPublicServiceClientMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteFileResults{dp1, err}
	mmDeleteFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteFile method
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	mmDeleteFile.mock.funcDeleteFileOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) When(ctx context.Context, in *mm_artifactv1alpha.DeleteFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteFileExpectation{
		mock:               mmDeleteFile.mock,
		params:             &ArtifactPublicServiceClientMockDeleteFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockDeleteFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteFileExpectation) Then(dp1 *mm_artifactv1alpha.DeleteFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteFileResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteFile should be invoked
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) Times(n uint64) *mArtifactPublicServiceClientMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	mmDeleteFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFile
}

func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteFile *ArtifactPublicServiceClientMock) DeleteFile(ctx context.Context, in *mm_artifactv1alpha.DeleteFileRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteFileResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	mmDeleteFile.t.Helper()

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteFileParams{ctx, in, opts}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("ArtifactPublicServiceClientMock.DeleteFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteFile")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, in, opts...)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteFile. %v %v %v", ctx, in, opts)
	return
}

// DeleteFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteFile invocations
func (mmDeleteFile *ArtifactPublicServiceClientMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteFile invocations
func (mmDeleteFile *ArtifactPublicServiceClientMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mArtifactPublicServiceClientMockDeleteFile) Calls() []*ArtifactPublicServiceClientMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteFile at\n%s", m.DeleteFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteFile at\n%s with params: %#v", m.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteFile at\n%s", m.funcDeleteFileOrigin)
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), m.DeleteFileMock.expectedInvocationsOrigin, afterDeleteFileCounter)
	}
}

type mArtifactPublicServiceClientMockDeleteKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceClient.DeleteKnowledgeBase
type ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceClientMockDeleteKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceClientMockDeleteKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams contains parameters of the ArtifactPublicServiceClient.DeleteKnowledgeBase
type ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.DeleteKnowledgeBaseRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.DeleteKnowledgeBase
type ArtifactPublicServiceClientMockDeleteKnowledgeBaseParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.DeleteKnowledgeBaseRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockDeleteKnowledgeBaseResults contains results of the ArtifactPublicServiceClient.DeleteKnowledgeBase
type ArtifactPublicServiceClientMockDeleteKnowledgeBaseResults struct {
	dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceClientMockDeleteKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceClient.DeleteKnowledgeBase
type ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) Optional() *mArtifactPublicServiceClientMockDeleteKnowledgeBase {
	mmDeleteKnowledgeBase.optional = true
	return mmDeleteKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceClient.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) Expect(ctx context.Context, in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmDeleteKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams{ctx, in, opts}
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmDeleteKnowledgeBase.defaultExpectation.params) {
			mmDeleteKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmDeleteKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) ExpectInParam2(in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest) *mArtifactPublicServiceClientMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.in = &in
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation{}
	}

	if mmDeleteKnowledgeBase.defaultExpectation.params != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Expect")
	}

	if mmDeleteKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmDeleteKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseParamPtrs{}
	}
	mmDeleteKnowledgeBase.defaultExpectation.paramPtrs.opts = &opts
	mmDeleteKnowledgeBase.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmDeleteKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockDeleteKnowledgeBase {
	if mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.DeleteKnowledgeBase")
	}

	mmDeleteKnowledgeBase.mock.inspectFuncDeleteKnowledgeBase = f

	return mmDeleteKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.DeleteKnowledgeBase
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) Return(dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Set")
	}

	if mmDeleteKnowledgeBase.defaultExpectation == nil {
		mmDeleteKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation{mock: mmDeleteKnowledgeBase.mock}
	}
	mmDeleteKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseResults{dp1, err}
	mmDeleteKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.DeleteKnowledgeBase method
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) Set(f func(ctx context.Context, in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmDeleteKnowledgeBase.defaultExpectation != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.DeleteKnowledgeBase method")
	}

	if len(mmDeleteKnowledgeBase.expectations) > 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.DeleteKnowledgeBase method")
	}

	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase = f
	mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceClient.DeleteKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) When(ctx context.Context, in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation {
	if mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation{
		mock:               mmDeleteKnowledgeBase.mock,
		params:             &ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteKnowledgeBase.expectations = append(mmDeleteKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.DeleteKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockDeleteKnowledgeBaseExpectation) Then(dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockDeleteKnowledgeBaseResults{dp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.DeleteKnowledgeBase should be invoked
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) Times(n uint64) *mArtifactPublicServiceClientMockDeleteKnowledgeBase {
	if n == 0 {
		mmDeleteKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.DeleteKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteKnowledgeBase.expectedInvocations, n)
	mmDeleteKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteKnowledgeBase
}

func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) invocationsDone() bool {
	if len(mmDeleteKnowledgeBase.expectations) == 0 && mmDeleteKnowledgeBase.defaultExpectation == nil && mmDeleteKnowledgeBase.mock.funcDeleteKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.mock.afterDeleteKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmDeleteKnowledgeBase *ArtifactPublicServiceClientMock) DeleteKnowledgeBase(ctx context.Context, in *mm_artifactv1alpha.DeleteKnowledgeBaseRequest, opts ...grpc.CallOption) (dp1 *mm_artifactv1alpha.DeleteKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter, 1)

	mmDeleteKnowledgeBase.t.Helper()

	if mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase != nil {
		mmDeleteKnowledgeBase.inspectFuncDeleteKnowledgeBase(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams{ctx, in, opts}

	// Record call args
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Lock()
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs = append(mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.callArgs, &mm_params)
	mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmDeleteKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmDeleteKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.DeleteKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteKnowledgeBase.DeleteKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.DeleteKnowledgeBase")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDeleteKnowledgeBase.funcDeleteKnowledgeBase != nil {
		return mmDeleteKnowledgeBase.funcDeleteKnowledgeBase(ctx, in, opts...)
	}
	mmDeleteKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.DeleteKnowledgeBase. %v %v %v", ctx, in, opts)
	return
}

// DeleteKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceClientMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *ArtifactPublicServiceClientMock) DeleteKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.afterDeleteKnowledgeBaseCounter)
}

// DeleteKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceClientMock.DeleteKnowledgeBase invocations
func (mmDeleteKnowledgeBase *ArtifactPublicServiceClientMock) DeleteKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteKnowledgeBase.beforeDeleteKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.DeleteKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteKnowledgeBase *mArtifactPublicServiceClientMockDeleteKnowledgeBase) Calls() []*ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams {
	mmDeleteKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockDeleteKnowledgeBaseParams, len(mmDeleteKnowledgeBase.callArgs))
	copy(argCopy, mmDeleteKnowledgeBase.callArgs)

	mmDeleteKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteKnowledgeBaseDone returns true if the count of the DeleteKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockDeleteKnowledgeBaseDone() bool {
	if m.DeleteKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteKnowledgeBaseMock.invocationsDone()
}

// MinimockDeleteKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockDeleteKnowledgeBaseInspect() {
	for _, e := range m.DeleteKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterDeleteKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteKnowledgeBaseMock.defaultExpectation != nil && afterDeleteKnowledgeBaseCounter < 1 {
		if m.DeleteKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteKnowledgeBase at\n%s", m.DeleteKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteKnowledgeBase at\n%s with params: %#v", m.DeleteKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.DeleteKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteKnowledgeBase != nil && afterDeleteKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.DeleteKnowledgeBase at\n%s", m.funcDeleteKnowledgeBaseOrigin)
	}

	if !m.DeleteKnowledgeBaseMock.invocationsDone() && afterDeleteKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.DeleteKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteKnowledgeBaseMock.expectedInvocations), m.DeleteKnowledgeBaseMock.expectedInvocationsOrigin, afterDeleteKnowledgeBaseCounter)
	}
}

type mArtifactPublicServiceClientMockGetChunk struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetChunkExpectation
	expectations       []*ArtifactPublicServiceClientMockGetChunkExpectation

	callArgs []*ArtifactPublicServiceClientMockGetChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetChunkExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetChunk
type ArtifactPublicServiceClientMockGetChunkExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetChunkParams
	paramPtrs          *ArtifactPublicServiceClientMockGetChunkParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetChunkExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetChunkResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetChunkParams contains parameters of the ArtifactPublicServiceClient.GetChunk
type ArtifactPublicServiceClientMockGetChunkParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetChunkRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetChunkParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetChunk
type ArtifactPublicServiceClientMockGetChunkParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetChunkRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetChunkResults contains results of the ArtifactPublicServiceClient.GetChunk
type ArtifactPublicServiceClientMockGetChunkResults struct {
	gp1 *mm_artifactv1alpha.GetChunkResponse
	err error
}

// ArtifactPublicServiceClientMockGetChunkOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetChunk
type ArtifactPublicServiceClientMockGetChunkExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) Optional() *mArtifactPublicServiceClientMockGetChunk {
	mmGetChunk.optional = true
	return mmGetChunk
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetChunk
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) Expect(ctx context.Context, in *mm_artifactv1alpha.GetChunkRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetChunk {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceClientMockGetChunkExpectation{}
	}

	if mmGetChunk.defaultExpectation.paramPtrs != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by ExpectParams functions")
	}

	mmGetChunk.defaultExpectation.params = &ArtifactPublicServiceClientMockGetChunkParams{ctx, in, opts}
	mmGetChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChunk.expectations {
		if minimock.Equal(e.params, mmGetChunk.defaultExpectation.params) {
			mmGetChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChunk.defaultExpectation.params)
		}
	}

	return mmGetChunk
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetChunk
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetChunk {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceClientMockGetChunkExpectation{}
	}

	if mmGetChunk.defaultExpectation.params != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Expect")
	}

	if mmGetChunk.defaultExpectation.paramPtrs == nil {
		mmGetChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetChunkParamPtrs{}
	}
	mmGetChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChunk
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetChunk
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) ExpectInParam2(in *mm_artifactv1alpha.GetChunkRequest) *mArtifactPublicServiceClientMockGetChunk {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceClientMockGetChunkExpectation{}
	}

	if mmGetChunk.defaultExpectation.params != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Expect")
	}

	if mmGetChunk.defaultExpectation.paramPtrs == nil {
		mmGetChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetChunkParamPtrs{}
	}
	mmGetChunk.defaultExpectation.paramPtrs.in = &in
	mmGetChunk.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetChunk
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetChunk
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetChunk {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceClientMockGetChunkExpectation{}
	}

	if mmGetChunk.defaultExpectation.params != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Expect")
	}

	if mmGetChunk.defaultExpectation.paramPtrs == nil {
		mmGetChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetChunkParamPtrs{}
	}
	mmGetChunk.defaultExpectation.paramPtrs.opts = &opts
	mmGetChunk.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetChunk
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetChunk
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetChunkRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetChunk {
	if mmGetChunk.mock.inspectFuncGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetChunk")
	}

	mmGetChunk.mock.inspectFuncGetChunk = f

	return mmGetChunk
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetChunk
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) Return(gp1 *mm_artifactv1alpha.GetChunkResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Set")
	}

	if mmGetChunk.defaultExpectation == nil {
		mmGetChunk.defaultExpectation = &ArtifactPublicServiceClientMockGetChunkExpectation{mock: mmGetChunk.mock}
	}
	mmGetChunk.defaultExpectation.results = &ArtifactPublicServiceClientMockGetChunkResults{gp1, err}
	mmGetChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChunk.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetChunk method
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetChunkRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetChunkResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetChunk.defaultExpectation != nil {
		mmGetChunk.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetChunk method")
	}

	if len(mmGetChunk.expectations) > 0 {
		mmGetChunk.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetChunk method")
	}

	mmGetChunk.mock.funcGetChunk = f
	mmGetChunk.mock.funcGetChunkOrigin = minimock.CallerInfo(1)
	return mmGetChunk.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetChunk which will trigger the result defined by the following
// Then helper
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) When(ctx context.Context, in *mm_artifactv1alpha.GetChunkRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetChunkExpectation {
	if mmGetChunk.mock.funcGetChunk != nil {
		mmGetChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetChunk mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetChunkExpectation{
		mock:               mmGetChunk.mock,
		params:             &ArtifactPublicServiceClientMockGetChunkParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChunk.expectations = append(mmGetChunk.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetChunk return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetChunkExpectation) Then(gp1 *mm_artifactv1alpha.GetChunkResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetChunkResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetChunk should be invoked
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) Times(n uint64) *mArtifactPublicServiceClientMockGetChunk {
	if n == 0 {
		mmGetChunk.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChunk.expectedInvocations, n)
	mmGetChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChunk
}

func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) invocationsDone() bool {
	if len(mmGetChunk.expectations) == 0 && mmGetChunk.defaultExpectation == nil && mmGetChunk.mock.funcGetChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChunk.mock.afterGetChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChunk implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetChunk *ArtifactPublicServiceClientMock) GetChunk(ctx context.Context, in *mm_artifactv1alpha.GetChunkRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetChunkResponse, err error) {
	mm_atomic.AddUint64(&mmGetChunk.beforeGetChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChunk.afterGetChunkCounter, 1)

	mmGetChunk.t.Helper()

	if mmGetChunk.inspectFuncGetChunk != nil {
		mmGetChunk.inspectFuncGetChunk(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetChunkParams{ctx, in, opts}

	// Record call args
	mmGetChunk.GetChunkMock.mutex.Lock()
	mmGetChunk.GetChunkMock.callArgs = append(mmGetChunk.GetChunkMock.callArgs, &mm_params)
	mmGetChunk.GetChunkMock.mutex.Unlock()

	for _, e := range mmGetChunk.GetChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetChunk.GetChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChunk.GetChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChunk.GetChunkMock.defaultExpectation.params
		mm_want_ptrs := mmGetChunk.GetChunkMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetChunkParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChunk.t.Errorf("ArtifactPublicServiceClientMock.GetChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunk.GetChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetChunk.t.Errorf("ArtifactPublicServiceClientMock.GetChunk got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunk.GetChunkMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetChunk.t.Errorf("ArtifactPublicServiceClientMock.GetChunk got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChunk.GetChunkMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChunk.t.Errorf("ArtifactPublicServiceClientMock.GetChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChunk.GetChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChunk.GetChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChunk.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetChunk")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetChunk.funcGetChunk != nil {
		return mmGetChunk.funcGetChunk(ctx, in, opts...)
	}
	mmGetChunk.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetChunk. %v %v %v", ctx, in, opts)
	return
}

// GetChunkAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetChunk invocations
func (mmGetChunk *ArtifactPublicServiceClientMock) GetChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunk.afterGetChunkCounter)
}

// GetChunkBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetChunk invocations
func (mmGetChunk *ArtifactPublicServiceClientMock) GetChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChunk.beforeGetChunkCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChunk *mArtifactPublicServiceClientMockGetChunk) Calls() []*ArtifactPublicServiceClientMockGetChunkParams {
	mmGetChunk.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetChunkParams, len(mmGetChunk.callArgs))
	copy(argCopy, mmGetChunk.callArgs)

	mmGetChunk.mutex.RUnlock()

	return argCopy
}

// MinimockGetChunkDone returns true if the count of the GetChunk invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetChunkDone() bool {
	if m.GetChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChunkMock.invocationsDone()
}

// MinimockGetChunkInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetChunkInspect() {
	for _, e := range m.GetChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChunkCounter := mm_atomic.LoadUint64(&m.afterGetChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChunkMock.defaultExpectation != nil && afterGetChunkCounter < 1 {
		if m.GetChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetChunk at\n%s", m.GetChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetChunk at\n%s with params: %#v", m.GetChunkMock.defaultExpectation.expectationOrigins.origin, *m.GetChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChunk != nil && afterGetChunkCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetChunk at\n%s", m.funcGetChunkOrigin)
	}

	if !m.GetChunkMock.invocationsDone() && afterGetChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChunkMock.expectedInvocations), m.GetChunkMock.expectedInvocationsOrigin, afterGetChunkCounter)
	}
}

type mArtifactPublicServiceClientMockGetFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetFileExpectation
	expectations       []*ArtifactPublicServiceClientMockGetFileExpectation

	callArgs []*ArtifactPublicServiceClientMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetFile
type ArtifactPublicServiceClientMockGetFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetFileParams
	paramPtrs          *ArtifactPublicServiceClientMockGetFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetFileParams contains parameters of the ArtifactPublicServiceClient.GetFile
type ArtifactPublicServiceClientMockGetFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetFile
type ArtifactPublicServiceClientMockGetFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetFileResults contains results of the ArtifactPublicServiceClient.GetFile
type ArtifactPublicServiceClientMockGetFileResults struct {
	gp1 *mm_artifactv1alpha.GetFileResponse
	err error
}

// ArtifactPublicServiceClientMockGetFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetFile
type ArtifactPublicServiceClientMockGetFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) Optional() *mArtifactPublicServiceClientMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetFile
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) Expect(ctx context.Context, in *mm_artifactv1alpha.GetFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &ArtifactPublicServiceClientMockGetFileParams{ctx, in, opts}
	mmGetFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetFile
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetFile
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) ExpectInParam2(in *mm_artifactv1alpha.GetFileRequest) *mArtifactPublicServiceClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.in = &in
	mmGetFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetFile
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceClientMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.opts = &opts
	mmGetFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetFile
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetFile
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) Return(gp1 *mm_artifactv1alpha.GetFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &ArtifactPublicServiceClientMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &ArtifactPublicServiceClientMockGetFileResults{gp1, err}
	mmGetFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetFile method
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	mmGetFile.mock.funcGetFileOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) When(ctx context.Context, in *mm_artifactv1alpha.GetFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetFileExpectation{
		mock:               mmGetFile.mock,
		params:             &ArtifactPublicServiceClientMockGetFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetFileExpectation) Then(gp1 *mm_artifactv1alpha.GetFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetFileResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetFile should be invoked
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) Times(n uint64) *mArtifactPublicServiceClientMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	mmGetFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFile
}

func (mmGetFile *mArtifactPublicServiceClientMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetFile *ArtifactPublicServiceClientMock) GetFile(ctx context.Context, in *mm_artifactv1alpha.GetFileRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetFileResponse, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	mmGetFile.t.Helper()

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetFileParams{ctx, in, opts}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("ArtifactPublicServiceClientMock.GetFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetFile.t.Errorf("ArtifactPublicServiceClientMock.GetFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetFile.t.Errorf("ArtifactPublicServiceClientMock.GetFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("ArtifactPublicServiceClientMock.GetFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetFile")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, in, opts...)
	}
	mmGetFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetFile. %v %v %v", ctx, in, opts)
	return
}

// GetFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetFile invocations
func (mmGetFile *ArtifactPublicServiceClientMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetFile invocations
func (mmGetFile *ArtifactPublicServiceClientMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mArtifactPublicServiceClientMockGetFile) Calls() []*ArtifactPublicServiceClientMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFile at\n%s", m.GetFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFile at\n%s with params: %#v", m.GetFileMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetFile at\n%s", m.funcGetFileOrigin)
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), m.GetFileMock.expectedInvocationsOrigin, afterGetFileCounter)
	}
}

type mArtifactPublicServiceClientMockGetKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceClientMockGetKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetKnowledgeBase
type ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceClientMockGetKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetKnowledgeBaseParams contains parameters of the ArtifactPublicServiceClient.GetKnowledgeBase
type ArtifactPublicServiceClientMockGetKnowledgeBaseParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetKnowledgeBaseRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetKnowledgeBase
type ArtifactPublicServiceClientMockGetKnowledgeBaseParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetKnowledgeBaseRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetKnowledgeBaseResults contains results of the ArtifactPublicServiceClient.GetKnowledgeBase
type ArtifactPublicServiceClientMockGetKnowledgeBaseResults struct {
	gp1 *mm_artifactv1alpha.GetKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceClientMockGetKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetKnowledgeBase
type ArtifactPublicServiceClientMockGetKnowledgeBaseExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) Optional() *mArtifactPublicServiceClientMockGetKnowledgeBase {
	mmGetKnowledgeBase.optional = true
	return mmGetKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) Expect(ctx context.Context, in *mm_artifactv1alpha.GetKnowledgeBaseRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmGetKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceClientMockGetKnowledgeBaseParams{ctx, in, opts}
	mmGetKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmGetKnowledgeBase.defaultExpectation.params) {
			mmGetKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmGetKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.params != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Expect")
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetKnowledgeBaseParamPtrs{}
	}
	mmGetKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKnowledgeBase
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) ExpectInParam2(in *mm_artifactv1alpha.GetKnowledgeBaseRequest) *mArtifactPublicServiceClientMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.params != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Expect")
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetKnowledgeBaseParamPtrs{}
	}
	mmGetKnowledgeBase.defaultExpectation.paramPtrs.in = &in
	mmGetKnowledgeBase.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetKnowledgeBase
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation{}
	}

	if mmGetKnowledgeBase.defaultExpectation.params != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Expect")
	}

	if mmGetKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmGetKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetKnowledgeBaseParamPtrs{}
	}
	mmGetKnowledgeBase.defaultExpectation.paramPtrs.opts = &opts
	mmGetKnowledgeBase.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetKnowledgeBaseRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetKnowledgeBase {
	if mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetKnowledgeBase")
	}

	mmGetKnowledgeBase.mock.inspectFuncGetKnowledgeBase = f

	return mmGetKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetKnowledgeBase
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) Return(gp1 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Set")
	}

	if mmGetKnowledgeBase.defaultExpectation == nil {
		mmGetKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation{mock: mmGetKnowledgeBase.mock}
	}
	mmGetKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceClientMockGetKnowledgeBaseResults{gp1, err}
	mmGetKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetKnowledgeBase method
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetKnowledgeBaseRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetKnowledgeBase.defaultExpectation != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetKnowledgeBase method")
	}

	if len(mmGetKnowledgeBase.expectations) > 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetKnowledgeBase method")
	}

	mmGetKnowledgeBase.mock.funcGetKnowledgeBase = f
	mmGetKnowledgeBase.mock.funcGetKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) When(ctx context.Context, in *mm_artifactv1alpha.GetKnowledgeBaseRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation {
	if mmGetKnowledgeBase.mock.funcGetKnowledgeBase != nil {
		mmGetKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation{
		mock:               mmGetKnowledgeBase.mock,
		params:             &ArtifactPublicServiceClientMockGetKnowledgeBaseParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKnowledgeBase.expectations = append(mmGetKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetKnowledgeBaseExpectation) Then(gp1 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetKnowledgeBaseResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetKnowledgeBase should be invoked
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) Times(n uint64) *mArtifactPublicServiceClientMockGetKnowledgeBase {
	if n == 0 {
		mmGetKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKnowledgeBase.expectedInvocations, n)
	mmGetKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKnowledgeBase
}

func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) invocationsDone() bool {
	if len(mmGetKnowledgeBase.expectations) == 0 && mmGetKnowledgeBase.defaultExpectation == nil && mmGetKnowledgeBase.mock.funcGetKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.mock.afterGetKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetKnowledgeBase *ArtifactPublicServiceClientMock) GetKnowledgeBase(ctx context.Context, in *mm_artifactv1alpha.GetKnowledgeBaseRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter, 1)

	mmGetKnowledgeBase.t.Helper()

	if mmGetKnowledgeBase.inspectFuncGetKnowledgeBase != nil {
		mmGetKnowledgeBase.inspectFuncGetKnowledgeBase(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetKnowledgeBaseParams{ctx, in, opts}

	// Record call args
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Lock()
	mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs = append(mmGetKnowledgeBase.GetKnowledgeBaseMock.callArgs, &mm_params)
	mmGetKnowledgeBase.GetKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmGetKnowledgeBase.GetKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetKnowledgeBaseParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.GetKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.GetKnowledgeBase got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.GetKnowledgeBase got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.GetKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKnowledgeBase.GetKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetKnowledgeBase")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetKnowledgeBase.funcGetKnowledgeBase != nil {
		return mmGetKnowledgeBase.funcGetKnowledgeBase(ctx, in, opts...)
	}
	mmGetKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetKnowledgeBase. %v %v %v", ctx, in, opts)
	return
}

// GetKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *ArtifactPublicServiceClientMock) GetKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.afterGetKnowledgeBaseCounter)
}

// GetKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetKnowledgeBase invocations
func (mmGetKnowledgeBase *ArtifactPublicServiceClientMock) GetKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKnowledgeBase.beforeGetKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKnowledgeBase *mArtifactPublicServiceClientMockGetKnowledgeBase) Calls() []*ArtifactPublicServiceClientMockGetKnowledgeBaseParams {
	mmGetKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetKnowledgeBaseParams, len(mmGetKnowledgeBase.callArgs))
	copy(argCopy, mmGetKnowledgeBase.callArgs)

	mmGetKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockGetKnowledgeBaseDone returns true if the count of the GetKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetKnowledgeBaseDone() bool {
	if m.GetKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKnowledgeBaseMock.invocationsDone()
}

// MinimockGetKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetKnowledgeBaseInspect() {
	for _, e := range m.GetKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterGetKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKnowledgeBaseMock.defaultExpectation != nil && afterGetKnowledgeBaseCounter < 1 {
		if m.GetKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetKnowledgeBase at\n%s", m.GetKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetKnowledgeBase at\n%s with params: %#v", m.GetKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.GetKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKnowledgeBase != nil && afterGetKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetKnowledgeBase at\n%s", m.funcGetKnowledgeBaseOrigin)
	}

	if !m.GetKnowledgeBaseMock.invocationsDone() && afterGetKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKnowledgeBaseMock.expectedInvocations), m.GetKnowledgeBaseMock.expectedInvocationsOrigin, afterGetKnowledgeBaseCounter)
	}
}

type mArtifactPublicServiceClientMockGetObjectDownloadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation
	expectations       []*ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation

	callArgs []*ArtifactPublicServiceClientMockGetObjectDownloadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetObjectDownloadURLParams
	paramPtrs          *ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetObjectDownloadURLExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetObjectDownloadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLParams contains parameters of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetObjectDownloadURLRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetObjectDownloadURLRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLResults contains results of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLResults struct {
	gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse
	err error
}

// ArtifactPublicServiceClientMockGetObjectDownloadURLOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetObjectDownloadURL
type ArtifactPublicServiceClientMockGetObjectDownloadURLExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Optional() *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	mmGetObjectDownloadURL.optional = true
	return mmGetObjectDownloadURL
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Expect(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectDownloadURL.defaultExpectation.params = &ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts}
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectDownloadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectDownloadURL.defaultExpectation.params) {
			mmGetObjectDownloadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectDownloadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectDownloadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) ExpectInParam2(in *mm_artifactv1alpha.GetObjectDownloadURLRequest) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.in = &in
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{}
	}

	if mmGetObjectDownloadURL.defaultExpectation.params != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Expect")
	}

	if mmGetObjectDownloadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectDownloadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectDownloadURLParamPtrs{}
	}
	mmGetObjectDownloadURL.defaultExpectation.paramPtrs.opts = &opts
	mmGetObjectDownloadURL.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetObjectDownloadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetObjectDownloadURL")
	}

	mmGetObjectDownloadURL.mock.inspectFuncGetObjectDownloadURL = f

	return mmGetObjectDownloadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetObjectDownloadURL
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Return(gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	if mmGetObjectDownloadURL.defaultExpectation == nil {
		mmGetObjectDownloadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{mock: mmGetObjectDownloadURL.mock}
	}
	mmGetObjectDownloadURL.defaultExpectation.results = &ArtifactPublicServiceClientMockGetObjectDownloadURLResults{gp1, err}
	mmGetObjectDownloadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetObjectDownloadURL method
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetObjectDownloadURL.defaultExpectation != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetObjectDownloadURL method")
	}

	if len(mmGetObjectDownloadURL.expectations) > 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetObjectDownloadURL method")
	}

	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL = f
	mmGetObjectDownloadURL.mock.funcGetObjectDownloadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetObjectDownloadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) When(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation {
	if mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectDownloadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation{
		mock:               mmGetObjectDownloadURL.mock,
		params:             &ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetObjectDownloadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectDownloadURL.expectations = append(mmGetObjectDownloadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetObjectDownloadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetObjectDownloadURLExpectation) Then(gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetObjectDownloadURLResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetObjectDownloadURL should be invoked
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Times(n uint64) *mArtifactPublicServiceClientMockGetObjectDownloadURL {
	if n == 0 {
		mmGetObjectDownloadURL.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetObjectDownloadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectDownloadURL.expectedInvocations, n)
	mmGetObjectDownloadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectDownloadURL
}

func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) invocationsDone() bool {
	if len(mmGetObjectDownloadURL.expectations) == 0 && mmGetObjectDownloadURL.defaultExpectation == nil && mmGetObjectDownloadURL.mock.funcGetObjectDownloadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.mock.afterGetObjectDownloadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectDownloadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectDownloadURL implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetObjectDownloadURL *ArtifactPublicServiceClientMock) GetObjectDownloadURL(ctx context.Context, in *mm_artifactv1alpha.GetObjectDownloadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectDownloadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter, 1)

	mmGetObjectDownloadURL.t.Helper()

	if mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL != nil {
		mmGetObjectDownloadURL.inspectFuncGetObjectDownloadURL(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts}

	// Record call args
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Lock()
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs = append(mmGetObjectDownloadURL.GetObjectDownloadURLMock.callArgs, &mm_params)
	mmGetObjectDownloadURL.GetObjectDownloadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectDownloadURL.GetObjectDownloadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetObjectDownloadURLParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectDownloadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectDownloadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectDownloadURL.GetObjectDownloadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectDownloadURL.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetObjectDownloadURL")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetObjectDownloadURL.funcGetObjectDownloadURL != nil {
		return mmGetObjectDownloadURL.funcGetObjectDownloadURL(ctx, in, opts...)
	}
	mmGetObjectDownloadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL. %v %v %v", ctx, in, opts)
	return
}

// GetObjectDownloadURLAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceClientMock) GetObjectDownloadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.afterGetObjectDownloadURLCounter)
}

// GetObjectDownloadURLBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetObjectDownloadURL invocations
func (mmGetObjectDownloadURL *ArtifactPublicServiceClientMock) GetObjectDownloadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectDownloadURL.beforeGetObjectDownloadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetObjectDownloadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectDownloadURL *mArtifactPublicServiceClientMockGetObjectDownloadURL) Calls() []*ArtifactPublicServiceClientMockGetObjectDownloadURLParams {
	mmGetObjectDownloadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetObjectDownloadURLParams, len(mmGetObjectDownloadURL.callArgs))
	copy(argCopy, mmGetObjectDownloadURL.callArgs)

	mmGetObjectDownloadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectDownloadURLDone returns true if the count of the GetObjectDownloadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectDownloadURLDone() bool {
	if m.GetObjectDownloadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectDownloadURLMock.invocationsDone()
}

// MinimockGetObjectDownloadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectDownloadURLInspect() {
	for _, e := range m.GetObjectDownloadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectDownloadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectDownloadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectDownloadURLMock.defaultExpectation != nil && afterGetObjectDownloadURLCounter < 1 {
		if m.GetObjectDownloadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s", m.GetObjectDownloadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s with params: %#v", m.GetObjectDownloadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectDownloadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectDownloadURL != nil && afterGetObjectDownloadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s", m.funcGetObjectDownloadURLOrigin)
	}

	if !m.GetObjectDownloadURLMock.invocationsDone() && afterGetObjectDownloadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetObjectDownloadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectDownloadURLMock.expectedInvocations), m.GetObjectDownloadURLMock.expectedInvocationsOrigin, afterGetObjectDownloadURLCounter)
	}
}

type mArtifactPublicServiceClientMockGetObjectUploadURL struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockGetObjectUploadURLExpectation
	expectations       []*ArtifactPublicServiceClientMockGetObjectUploadURLExpectation

	callArgs []*ArtifactPublicServiceClientMockGetObjectUploadURLParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockGetObjectUploadURLExpectation specifies expectation struct of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockGetObjectUploadURLParams
	paramPtrs          *ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockGetObjectUploadURLExpectationOrigins
	results            *ArtifactPublicServiceClientMockGetObjectUploadURLResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockGetObjectUploadURLParams contains parameters of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.GetObjectUploadURLRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.GetObjectUploadURLRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockGetObjectUploadURLResults contains results of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLResults struct {
	gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse
	err error
}

// ArtifactPublicServiceClientMockGetObjectUploadURLOrigins contains origins of expectations of the ArtifactPublicServiceClient.GetObjectUploadURL
type ArtifactPublicServiceClientMockGetObjectUploadURLExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Optional() *mArtifactPublicServiceClientMockGetObjectUploadURL {
	mmGetObjectUploadURL.optional = true
	return mmGetObjectUploadURL
}

// Expect sets up expected params for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Expect(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by ExpectParams functions")
	}

	mmGetObjectUploadURL.defaultExpectation.params = &ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts}
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetObjectUploadURL.expectations {
		if minimock.Equal(e.params, mmGetObjectUploadURL.defaultExpectation.params) {
			mmGetObjectUploadURL.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetObjectUploadURL.defaultExpectation.params)
		}
	}

	return mmGetObjectUploadURL
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) ExpectInParam2(in *mm_artifactv1alpha.GetObjectUploadURLRequest) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.in = &in
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{}
	}

	if mmGetObjectUploadURL.defaultExpectation.params != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Expect")
	}

	if mmGetObjectUploadURL.defaultExpectation.paramPtrs == nil {
		mmGetObjectUploadURL.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockGetObjectUploadURLParamPtrs{}
	}
	mmGetObjectUploadURL.defaultExpectation.paramPtrs.opts = &opts
	mmGetObjectUploadURL.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmGetObjectUploadURL
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.GetObjectUploadURL")
	}

	mmGetObjectUploadURL.mock.inspectFuncGetObjectUploadURL = f

	return mmGetObjectUploadURL
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.GetObjectUploadURL
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Return(gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceClientMock {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	if mmGetObjectUploadURL.defaultExpectation == nil {
		mmGetObjectUploadURL.defaultExpectation = &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{mock: mmGetObjectUploadURL.mock}
	}
	mmGetObjectUploadURL.defaultExpectation.results = &ArtifactPublicServiceClientMockGetObjectUploadURLResults{gp1, err}
	mmGetObjectUploadURL.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.GetObjectUploadURL method
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Set(f func(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmGetObjectUploadURL.defaultExpectation != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.GetObjectUploadURL method")
	}

	if len(mmGetObjectUploadURL.expectations) > 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.GetObjectUploadURL method")
	}

	mmGetObjectUploadURL.mock.funcGetObjectUploadURL = f
	mmGetObjectUploadURL.mock.funcGetObjectUploadURLOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL.mock
}

// When sets expectation for the ArtifactPublicServiceClient.GetObjectUploadURL which will trigger the result defined by the following
// Then helper
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) When(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockGetObjectUploadURLExpectation {
	if mmGetObjectUploadURL.mock.funcGetObjectUploadURL != nil {
		mmGetObjectUploadURL.mock.t.Fatalf("ArtifactPublicServiceClientMock.GetObjectUploadURL mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockGetObjectUploadURLExpectation{
		mock:               mmGetObjectUploadURL.mock,
		params:             &ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockGetObjectUploadURLExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetObjectUploadURL.expectations = append(mmGetObjectUploadURL.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.GetObjectUploadURL return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockGetObjectUploadURLExpectation) Then(gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockGetObjectUploadURLResults{gp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.GetObjectUploadURL should be invoked
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Times(n uint64) *mArtifactPublicServiceClientMockGetObjectUploadURL {
	if n == 0 {
		mmGetObjectUploadURL.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.GetObjectUploadURL mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectUploadURL.expectedInvocations, n)
	mmGetObjectUploadURL.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectUploadURL
}

func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) invocationsDone() bool {
	if len(mmGetObjectUploadURL.expectations) == 0 && mmGetObjectUploadURL.defaultExpectation == nil && mmGetObjectUploadURL.mock.funcGetObjectUploadURL == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.mock.afterGetObjectUploadURLCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectUploadURL.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectUploadURL implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmGetObjectUploadURL *ArtifactPublicServiceClientMock) GetObjectUploadURL(ctx context.Context, in *mm_artifactv1alpha.GetObjectUploadURLRequest, opts ...grpc.CallOption) (gp1 *mm_artifactv1alpha.GetObjectUploadURLResponse, err error) {
	mm_atomic.AddUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter, 1)

	mmGetObjectUploadURL.t.Helper()

	if mmGetObjectUploadURL.inspectFuncGetObjectUploadURL != nil {
		mmGetObjectUploadURL.inspectFuncGetObjectUploadURL(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts}

	// Record call args
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Lock()
	mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs = append(mmGetObjectUploadURL.GetObjectUploadURLMock.callArgs, &mm_params)
	mmGetObjectUploadURL.GetObjectUploadURLMock.mutex.Unlock()

	for _, e := range mmGetObjectUploadURL.GetObjectUploadURLMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.Counter, 1)
		mm_want := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.params
		mm_want_ptrs := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockGetObjectUploadURLParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetObjectUploadURL.t.Errorf("ArtifactPublicServiceClientMock.GetObjectUploadURL got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetObjectUploadURL.GetObjectUploadURLMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectUploadURL.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.GetObjectUploadURL")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetObjectUploadURL.funcGetObjectUploadURL != nil {
		return mmGetObjectUploadURL.funcGetObjectUploadURL(ctx, in, opts...)
	}
	mmGetObjectUploadURL.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.GetObjectUploadURL. %v %v %v", ctx, in, opts)
	return
}

// GetObjectUploadURLAfterCounter returns a count of finished ArtifactPublicServiceClientMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceClientMock) GetObjectUploadURLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.afterGetObjectUploadURLCounter)
}

// GetObjectUploadURLBeforeCounter returns a count of ArtifactPublicServiceClientMock.GetObjectUploadURL invocations
func (mmGetObjectUploadURL *ArtifactPublicServiceClientMock) GetObjectUploadURLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectUploadURL.beforeGetObjectUploadURLCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.GetObjectUploadURL.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetObjectUploadURL *mArtifactPublicServiceClientMockGetObjectUploadURL) Calls() []*ArtifactPublicServiceClientMockGetObjectUploadURLParams {
	mmGetObjectUploadURL.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockGetObjectUploadURLParams, len(mmGetObjectUploadURL.callArgs))
	copy(argCopy, mmGetObjectUploadURL.callArgs)

	mmGetObjectUploadURL.mutex.RUnlock()

	return argCopy
}

// MinimockGetObjectUploadURLDone returns true if the count of the GetObjectUploadURL invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectUploadURLDone() bool {
	if m.GetObjectUploadURLMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectUploadURLMock.invocationsDone()
}

// MinimockGetObjectUploadURLInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockGetObjectUploadURLInspect() {
	for _, e := range m.GetObjectUploadURLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetObjectUploadURLCounter := mm_atomic.LoadUint64(&m.afterGetObjectUploadURLCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectUploadURLMock.defaultExpectation != nil && afterGetObjectUploadURLCounter < 1 {
		if m.GetObjectUploadURLMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s", m.GetObjectUploadURLMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s with params: %#v", m.GetObjectUploadURLMock.defaultExpectation.expectationOrigins.origin, *m.GetObjectUploadURLMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectUploadURL != nil && afterGetObjectUploadURLCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s", m.funcGetObjectUploadURLOrigin)
	}

	if !m.GetObjectUploadURLMock.invocationsDone() && afterGetObjectUploadURLCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.GetObjectUploadURL at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectUploadURLMock.expectedInvocations), m.GetObjectUploadURLMock.expectedInvocationsOrigin, afterGetObjectUploadURLCounter)
	}
}

type mArtifactPublicServiceClientMockListChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListChunksExpectation
	expectations       []*ArtifactPublicServiceClientMockListChunksExpectation

	callArgs []*ArtifactPublicServiceClientMockListChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListChunksExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListChunksParams
	paramPtrs          *ArtifactPublicServiceClientMockListChunksParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListChunksExpectationOrigins
	results            *ArtifactPublicServiceClientMockListChunksResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListChunksParams contains parameters of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListChunksRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListChunksRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListChunksResults contains results of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksResults struct {
	lp1 *mm_artifactv1alpha.ListChunksResponse
	err error
}

// ArtifactPublicServiceClientMockListChunksOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListChunks
type ArtifactPublicServiceClientMockListChunksExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Optional() *mArtifactPublicServiceClientMockListChunks {
	mmListChunks.optional = true
	return mmListChunks
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Expect(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.paramPtrs != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by ExpectParams functions")
	}

	mmListChunks.defaultExpectation.params = &ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}
	mmListChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListChunks.expectations {
		if minimock.Equal(e.params, mmListChunks.defaultExpectation.params) {
			mmListChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListChunks.defaultExpectation.params)
		}
	}

	return mmListChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmListChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListChunks
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectInParam2(in *mm_artifactv1alpha.ListChunksRequest) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.in = &in
	mmListChunks.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListChunks
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{}
	}

	if mmListChunks.defaultExpectation.params != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Expect")
	}

	if mmListChunks.defaultExpectation.paramPtrs == nil {
		mmListChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListChunksParamPtrs{}
	}
	mmListChunks.defaultExpectation.paramPtrs.opts = &opts
	mmListChunks.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListChunks {
	if mmListChunks.mock.inspectFuncListChunks != nil {
		mmListChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListChunks")
	}

	mmListChunks.mock.inspectFuncListChunks = f

	return mmListChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListChunks
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Return(lp1 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	if mmListChunks.defaultExpectation == nil {
		mmListChunks.defaultExpectation = &ArtifactPublicServiceClientMockListChunksExpectation{mock: mmListChunks.mock}
	}
	mmListChunks.defaultExpectation.results = &ArtifactPublicServiceClientMockListChunksResults{lp1, err}
	mmListChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListChunks method
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListChunks.defaultExpectation != nil {
		mmListChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListChunks method")
	}

	if len(mmListChunks.expectations) > 0 {
		mmListChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListChunks method")
	}

	mmListChunks.mock.funcListChunks = f
	mmListChunks.mock.funcListChunksOrigin = minimock.CallerInfo(1)
	return mmListChunks.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListChunks which will trigger the result defined by the following
// Then helper
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) When(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListChunksExpectation {
	if mmListChunks.mock.funcListChunks != nil {
		mmListChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListChunksExpectation{
		mock:               mmListChunks.mock,
		params:             &ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListChunks.expectations = append(mmListChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListChunksExpectation) Then(lp1 *mm_artifactv1alpha.ListChunksResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListChunksResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListChunks should be invoked
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Times(n uint64) *mArtifactPublicServiceClientMockListChunks {
	if n == 0 {
		mmListChunks.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListChunks.expectedInvocations, n)
	mmListChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListChunks
}

func (mmListChunks *mArtifactPublicServiceClientMockListChunks) invocationsDone() bool {
	if len(mmListChunks.expectations) == 0 && mmListChunks.defaultExpectation == nil && mmListChunks.mock.funcListChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListChunks.mock.afterListChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListChunks implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunks(ctx context.Context, in *mm_artifactv1alpha.ListChunksRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListChunksResponse, err error) {
	mm_atomic.AddUint64(&mmListChunks.beforeListChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmListChunks.afterListChunksCounter, 1)

	mmListChunks.t.Helper()

	if mmListChunks.inspectFuncListChunks != nil {
		mmListChunks.inspectFuncListChunks(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}

	// Record call args
	mmListChunks.ListChunksMock.mutex.Lock()
	mmListChunks.ListChunksMock.callArgs = append(mmListChunks.ListChunksMock.callArgs, &mm_params)
	mmListChunks.ListChunksMock.mutex.Unlock()

	for _, e := range mmListChunks.ListChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListChunks.ListChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListChunks.ListChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmListChunks.ListChunksMock.defaultExpectation.params
		mm_want_ptrs := mmListChunks.ListChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListChunksParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListChunks.t.Errorf("ArtifactPublicServiceClientMock.ListChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListChunks.ListChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListChunks.ListChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmListChunks.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListChunks")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListChunks.funcListChunks != nil {
		return mmListChunks.funcListChunks(ctx, in, opts...)
	}
	mmListChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListChunks. %v %v %v", ctx, in, opts)
	return
}

// ListChunksAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.afterListChunksCounter)
}

// ListChunksBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListChunks invocations
func (mmListChunks *ArtifactPublicServiceClientMock) ListChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListChunks.beforeListChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListChunks *mArtifactPublicServiceClientMockListChunks) Calls() []*ArtifactPublicServiceClientMockListChunksParams {
	mmListChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListChunksParams, len(mmListChunks.callArgs))
	copy(argCopy, mmListChunks.callArgs)

	mmListChunks.mutex.RUnlock()

	return argCopy
}

// MinimockListChunksDone returns true if the count of the ListChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListChunksDone() bool {
	if m.ListChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListChunksMock.invocationsDone()
}

// MinimockListChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListChunksInspect() {
	for _, e := range m.ListChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListChunksCounter := mm_atomic.LoadUint64(&m.afterListChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListChunksMock.defaultExpectation != nil && afterListChunksCounter < 1 {
		if m.ListChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s", m.ListChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s with params: %#v", m.ListChunksMock.defaultExpectation.expectationOrigins.origin, *m.ListChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListChunks != nil && afterListChunksCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListChunks at\n%s", m.funcListChunksOrigin)
	}

	if !m.ListChunksMock.invocationsDone() && afterListChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListChunksMock.expectedInvocations), m.ListChunksMock.expectedInvocationsOrigin, afterListChunksCounter)
	}
}

type mArtifactPublicServiceClientMockListFiles struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListFilesExpectation
	expectations       []*ArtifactPublicServiceClientMockListFilesExpectation

	callArgs []*ArtifactPublicServiceClientMockListFilesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListFilesExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListFiles
type ArtifactPublicServiceClientMockListFilesExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListFilesParams
	paramPtrs          *ArtifactPublicServiceClientMockListFilesParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListFilesExpectationOrigins
	results            *ArtifactPublicServiceClientMockListFilesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListFilesParams contains parameters of the ArtifactPublicServiceClient.ListFiles
type ArtifactPublicServiceClientMockListFilesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListFilesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListFilesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListFiles
type ArtifactPublicServiceClientMockListFilesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListFilesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListFilesResults contains results of the ArtifactPublicServiceClient.ListFiles
type ArtifactPublicServiceClientMockListFilesResults struct {
	lp1 *mm_artifactv1alpha.ListFilesResponse
	err error
}

// ArtifactPublicServiceClientMockListFilesOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListFiles
type ArtifactPublicServiceClientMockListFilesExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) Optional() *mArtifactPublicServiceClientMockListFiles {
	mmListFiles.optional = true
	return mmListFiles
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListFiles
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) Expect(ctx context.Context, in *mm_artifactv1alpha.ListFilesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListFiles {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceClientMockListFilesExpectation{}
	}

	if mmListFiles.defaultExpectation.paramPtrs != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by ExpectParams functions")
	}

	mmListFiles.defaultExpectation.params = &ArtifactPublicServiceClientMockListFilesParams{ctx, in, opts}
	mmListFiles.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListFiles.expectations {
		if minimock.Equal(e.params, mmListFiles.defaultExpectation.params) {
			mmListFiles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListFiles.defaultExpectation.params)
		}
	}

	return mmListFiles
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListFiles
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListFiles {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceClientMockListFilesExpectation{}
	}

	if mmListFiles.defaultExpectation.params != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Expect")
	}

	if mmListFiles.defaultExpectation.paramPtrs == nil {
		mmListFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListFilesParamPtrs{}
	}
	mmListFiles.defaultExpectation.paramPtrs.ctx = &ctx
	mmListFiles.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListFiles
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListFiles
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) ExpectInParam2(in *mm_artifactv1alpha.ListFilesRequest) *mArtifactPublicServiceClientMockListFiles {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceClientMockListFilesExpectation{}
	}

	if mmListFiles.defaultExpectation.params != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Expect")
	}

	if mmListFiles.defaultExpectation.paramPtrs == nil {
		mmListFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListFilesParamPtrs{}
	}
	mmListFiles.defaultExpectation.paramPtrs.in = &in
	mmListFiles.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListFiles
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListFiles
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListFiles {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceClientMockListFilesExpectation{}
	}

	if mmListFiles.defaultExpectation.params != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Expect")
	}

	if mmListFiles.defaultExpectation.paramPtrs == nil {
		mmListFiles.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListFilesParamPtrs{}
	}
	mmListFiles.defaultExpectation.paramPtrs.opts = &opts
	mmListFiles.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListFiles
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListFiles
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListFilesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListFiles {
	if mmListFiles.mock.inspectFuncListFiles != nil {
		mmListFiles.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListFiles")
	}

	mmListFiles.mock.inspectFuncListFiles = f

	return mmListFiles
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListFiles
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) Return(lp1 *mm_artifactv1alpha.ListFilesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Set")
	}

	if mmListFiles.defaultExpectation == nil {
		mmListFiles.defaultExpectation = &ArtifactPublicServiceClientMockListFilesExpectation{mock: mmListFiles.mock}
	}
	mmListFiles.defaultExpectation.results = &ArtifactPublicServiceClientMockListFilesResults{lp1, err}
	mmListFiles.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListFiles.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListFiles method
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListFilesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListFiles.defaultExpectation != nil {
		mmListFiles.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListFiles method")
	}

	if len(mmListFiles.expectations) > 0 {
		mmListFiles.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListFiles method")
	}

	mmListFiles.mock.funcListFiles = f
	mmListFiles.mock.funcListFilesOrigin = minimock.CallerInfo(1)
	return mmListFiles.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListFiles which will trigger the result defined by the following
// Then helper
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) When(ctx context.Context, in *mm_artifactv1alpha.ListFilesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListFilesExpectation {
	if mmListFiles.mock.funcListFiles != nil {
		mmListFiles.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListFiles mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListFilesExpectation{
		mock:               mmListFiles.mock,
		params:             &ArtifactPublicServiceClientMockListFilesParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListFilesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListFiles.expectations = append(mmListFiles.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListFiles return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListFilesExpectation) Then(lp1 *mm_artifactv1alpha.ListFilesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListFilesResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListFiles should be invoked
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) Times(n uint64) *mArtifactPublicServiceClientMockListFiles {
	if n == 0 {
		mmListFiles.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListFiles mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListFiles.expectedInvocations, n)
	mmListFiles.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListFiles
}

func (mmListFiles *mArtifactPublicServiceClientMockListFiles) invocationsDone() bool {
	if len(mmListFiles.expectations) == 0 && mmListFiles.defaultExpectation == nil && mmListFiles.mock.funcListFiles == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListFiles.mock.afterListFilesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListFiles.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListFiles implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListFiles *ArtifactPublicServiceClientMock) ListFiles(ctx context.Context, in *mm_artifactv1alpha.ListFilesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListFilesResponse, err error) {
	mm_atomic.AddUint64(&mmListFiles.beforeListFilesCounter, 1)
	defer mm_atomic.AddUint64(&mmListFiles.afterListFilesCounter, 1)

	mmListFiles.t.Helper()

	if mmListFiles.inspectFuncListFiles != nil {
		mmListFiles.inspectFuncListFiles(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListFilesParams{ctx, in, opts}

	// Record call args
	mmListFiles.ListFilesMock.mutex.Lock()
	mmListFiles.ListFilesMock.callArgs = append(mmListFiles.ListFilesMock.callArgs, &mm_params)
	mmListFiles.ListFilesMock.mutex.Unlock()

	for _, e := range mmListFiles.ListFilesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListFiles.ListFilesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListFiles.ListFilesMock.defaultExpectation.Counter, 1)
		mm_want := mmListFiles.ListFilesMock.defaultExpectation.params
		mm_want_ptrs := mmListFiles.ListFilesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListFilesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListFiles.t.Errorf("ArtifactPublicServiceClientMock.ListFiles got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFiles.ListFilesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListFiles.t.Errorf("ArtifactPublicServiceClientMock.ListFiles got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFiles.ListFilesMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListFiles.t.Errorf("ArtifactPublicServiceClientMock.ListFiles got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListFiles.ListFilesMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListFiles.t.Errorf("ArtifactPublicServiceClientMock.ListFiles got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListFiles.ListFilesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListFiles.ListFilesMock.defaultExpectation.results
		if mm_results == nil {
			mmListFiles.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListFiles")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListFiles.funcListFiles != nil {
		return mmListFiles.funcListFiles(ctx, in, opts...)
	}
	mmListFiles.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListFiles. %v %v %v", ctx, in, opts)
	return
}

// ListFilesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListFiles invocations
func (mmListFiles *ArtifactPublicServiceClientMock) ListFilesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFiles.afterListFilesCounter)
}

// ListFilesBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListFiles invocations
func (mmListFiles *ArtifactPublicServiceClientMock) ListFilesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListFiles.beforeListFilesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListFiles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListFiles *mArtifactPublicServiceClientMockListFiles) Calls() []*ArtifactPublicServiceClientMockListFilesParams {
	mmListFiles.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListFilesParams, len(mmListFiles.callArgs))
	copy(argCopy, mmListFiles.callArgs)

	mmListFiles.mutex.RUnlock()

	return argCopy
}

// MinimockListFilesDone returns true if the count of the ListFiles invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListFilesDone() bool {
	if m.ListFilesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListFilesMock.invocationsDone()
}

// MinimockListFilesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListFilesInspect() {
	for _, e := range m.ListFilesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListFiles at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListFilesCounter := mm_atomic.LoadUint64(&m.afterListFilesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListFilesMock.defaultExpectation != nil && afterListFilesCounter < 1 {
		if m.ListFilesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListFiles at\n%s", m.ListFilesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListFiles at\n%s with params: %#v", m.ListFilesMock.defaultExpectation.expectationOrigins.origin, *m.ListFilesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListFiles != nil && afterListFilesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListFiles at\n%s", m.funcListFilesOrigin)
	}

	if !m.ListFilesMock.invocationsDone() && afterListFilesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListFiles at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListFilesMock.expectedInvocations), m.ListFilesMock.expectedInvocationsOrigin, afterListFilesCounter)
	}
}

type mArtifactPublicServiceClientMockListKnowledgeBaseRuns struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation
	expectations       []*ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation

	callArgs []*ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListKnowledgeBaseRuns
type ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams
	paramPtrs          *ArtifactPublicServiceClientMockListKnowledgeBaseRunsParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectationOrigins
	results            *ArtifactPublicServiceClientMockListKnowledgeBaseRunsResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams contains parameters of the ArtifactPublicServiceClient.ListKnowledgeBaseRuns
type ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListKnowledgeBaseRunsParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListKnowledgeBaseRuns
type ArtifactPublicServiceClientMockListKnowledgeBaseRunsParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListKnowledgeBaseRunsRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListKnowledgeBaseRunsResults contains results of the ArtifactPublicServiceClient.ListKnowledgeBaseRuns
type ArtifactPublicServiceClientMockListKnowledgeBaseRunsResults struct {
	lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse
	err error
}

// ArtifactPublicServiceClientMockListKnowledgeBaseRunsOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListKnowledgeBaseRuns
type ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) Optional() *mArtifactPublicServiceClientMockListKnowledgeBaseRuns {
	mmListKnowledgeBaseRuns.optional = true
	return mmListKnowledgeBaseRuns
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) Expect(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation{}
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBaseRuns.defaultExpectation.params = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams{ctx, in, opts}
	mmListKnowledgeBaseRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBaseRuns.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBaseRuns.defaultExpectation.params) {
			mmListKnowledgeBaseRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBaseRuns.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBaseRuns
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation{}
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.params != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Expect")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsParamPtrs{}
	}
	mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBaseRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBaseRuns
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) ExpectInParam2(in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest) *mArtifactPublicServiceClientMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation{}
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.params != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Expect")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsParamPtrs{}
	}
	mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs.in = &in
	mmListKnowledgeBaseRuns.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListKnowledgeBaseRuns
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation{}
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.params != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Expect")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsParamPtrs{}
	}
	mmListKnowledgeBaseRuns.defaultExpectation.paramPtrs.opts = &opts
	mmListKnowledgeBaseRuns.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListKnowledgeBaseRuns
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListKnowledgeBaseRuns {
	if mmListKnowledgeBaseRuns.mock.inspectFuncListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns")
	}

	mmListKnowledgeBaseRuns.mock.inspectFuncListKnowledgeBaseRuns = f

	return mmListKnowledgeBaseRuns
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListKnowledgeBaseRuns
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) Return(lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	if mmListKnowledgeBaseRuns.defaultExpectation == nil {
		mmListKnowledgeBaseRuns.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation{mock: mmListKnowledgeBaseRuns.mock}
	}
	mmListKnowledgeBaseRuns.defaultExpectation.results = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsResults{lp1, err}
	mmListKnowledgeBaseRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseRuns.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListKnowledgeBaseRuns method
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListKnowledgeBaseRuns.defaultExpectation != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListKnowledgeBaseRuns method")
	}

	if len(mmListKnowledgeBaseRuns.expectations) > 0 {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListKnowledgeBaseRuns method")
	}

	mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns = f
	mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRunsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseRuns.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListKnowledgeBaseRuns which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) When(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation {
	if mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation{
		mock:               mmListKnowledgeBaseRuns.mock,
		params:             &ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBaseRuns.expectations = append(mmListKnowledgeBaseRuns.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListKnowledgeBaseRuns return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListKnowledgeBaseRunsExpectation) Then(lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListKnowledgeBaseRunsResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListKnowledgeBaseRuns should be invoked
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) Times(n uint64) *mArtifactPublicServiceClientMockListKnowledgeBaseRuns {
	if n == 0 {
		mmListKnowledgeBaseRuns.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBaseRuns.expectedInvocations, n)
	mmListKnowledgeBaseRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBaseRuns
}

func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) invocationsDone() bool {
	if len(mmListKnowledgeBaseRuns.expectations) == 0 && mmListKnowledgeBaseRuns.defaultExpectation == nil && mmListKnowledgeBaseRuns.mock.funcListKnowledgeBaseRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.mock.afterListKnowledgeBaseRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBaseRuns implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListKnowledgeBaseRuns *ArtifactPublicServiceClientMock) ListKnowledgeBaseRuns(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBaseRunsRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListKnowledgeBaseRunsResponse, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBaseRuns.beforeListKnowledgeBaseRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBaseRuns.afterListKnowledgeBaseRunsCounter, 1)

	mmListKnowledgeBaseRuns.t.Helper()

	if mmListKnowledgeBaseRuns.inspectFuncListKnowledgeBaseRuns != nil {
		mmListKnowledgeBaseRuns.inspectFuncListKnowledgeBaseRuns(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams{ctx, in, opts}

	// Record call args
	mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.mutex.Lock()
	mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.callArgs = append(mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.callArgs, &mm_params)
	mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBaseRuns.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListKnowledgeBaseRuns.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListKnowledgeBaseRuns.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBaseRuns.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBaseRuns.ListKnowledgeBaseRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBaseRuns.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListKnowledgeBaseRuns.funcListKnowledgeBaseRuns != nil {
		return mmListKnowledgeBaseRuns.funcListKnowledgeBaseRuns(ctx, in, opts...)
	}
	mmListKnowledgeBaseRuns.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns. %v %v %v", ctx, in, opts)
	return
}

// ListKnowledgeBaseRunsAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns invocations
func (mmListKnowledgeBaseRuns *ArtifactPublicServiceClientMock) ListKnowledgeBaseRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.afterListKnowledgeBaseRunsCounter)
}

// ListKnowledgeBaseRunsBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns invocations
func (mmListKnowledgeBaseRuns *ArtifactPublicServiceClientMock) ListKnowledgeBaseRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBaseRuns.beforeListKnowledgeBaseRunsCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBaseRuns *mArtifactPublicServiceClientMockListKnowledgeBaseRuns) Calls() []*ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams {
	mmListKnowledgeBaseRuns.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListKnowledgeBaseRunsParams, len(mmListKnowledgeBaseRuns.callArgs))
	copy(argCopy, mmListKnowledgeBaseRuns.callArgs)

	mmListKnowledgeBaseRuns.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBaseRunsDone returns true if the count of the ListKnowledgeBaseRuns invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListKnowledgeBaseRunsDone() bool {
	if m.ListKnowledgeBaseRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBaseRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBaseRunsMock.invocationsDone()
}

// MinimockListKnowledgeBaseRunsInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListKnowledgeBaseRunsInspect() {
	for _, e := range m.ListKnowledgeBaseRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBaseRunsCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBaseRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBaseRunsMock.defaultExpectation != nil && afterListKnowledgeBaseRunsCounter < 1 {
		if m.ListKnowledgeBaseRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns at\n%s", m.ListKnowledgeBaseRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns at\n%s with params: %#v", m.ListKnowledgeBaseRunsMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBaseRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBaseRuns != nil && afterListKnowledgeBaseRunsCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns at\n%s", m.funcListKnowledgeBaseRunsOrigin)
	}

	if !m.ListKnowledgeBaseRunsMock.invocationsDone() && afterListKnowledgeBaseRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListKnowledgeBaseRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBaseRunsMock.expectedInvocations), m.ListKnowledgeBaseRunsMock.expectedInvocationsOrigin, afterListKnowledgeBaseRunsCounter)
	}
}

type mArtifactPublicServiceClientMockListKnowledgeBases struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockListKnowledgeBasesExpectation
	expectations       []*ArtifactPublicServiceClientMockListKnowledgeBasesExpectation

	callArgs []*ArtifactPublicServiceClientMockListKnowledgeBasesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockListKnowledgeBasesExpectation specifies expectation struct of the ArtifactPublicServiceClient.ListKnowledgeBases
type ArtifactPublicServiceClientMockListKnowledgeBasesExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockListKnowledgeBasesParams
	paramPtrs          *ArtifactPublicServiceClientMockListKnowledgeBasesParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockListKnowledgeBasesExpectationOrigins
	results            *ArtifactPublicServiceClientMockListKnowledgeBasesResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockListKnowledgeBasesParams contains parameters of the ArtifactPublicServiceClient.ListKnowledgeBases
type ArtifactPublicServiceClientMockListKnowledgeBasesParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ListKnowledgeBasesRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockListKnowledgeBasesParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ListKnowledgeBases
type ArtifactPublicServiceClientMockListKnowledgeBasesParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ListKnowledgeBasesRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockListKnowledgeBasesResults contains results of the ArtifactPublicServiceClient.ListKnowledgeBases
type ArtifactPublicServiceClientMockListKnowledgeBasesResults struct {
	lp1 *mm_artifactv1alpha.ListKnowledgeBasesResponse
	err error
}

// ArtifactPublicServiceClientMockListKnowledgeBasesOrigins contains origins of expectations of the ArtifactPublicServiceClient.ListKnowledgeBases
type ArtifactPublicServiceClientMockListKnowledgeBasesExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) Optional() *mArtifactPublicServiceClientMockListKnowledgeBases {
	mmListKnowledgeBases.optional = true
	return mmListKnowledgeBases
}

// Expect sets up expected params for ArtifactPublicServiceClient.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) Expect(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBasesRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by ExpectParams functions")
	}

	mmListKnowledgeBases.defaultExpectation.params = &ArtifactPublicServiceClientMockListKnowledgeBasesParams{ctx, in, opts}
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListKnowledgeBases.expectations {
		if minimock.Equal(e.params, mmListKnowledgeBases.defaultExpectation.params) {
			mmListKnowledgeBases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListKnowledgeBases.defaultExpectation.params)
		}
	}

	return mmListKnowledgeBases
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.ctx = &ctx
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) ExpectInParam2(in *mm_artifactv1alpha.ListKnowledgeBasesRequest) *mArtifactPublicServiceClientMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.in = &in
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBasesExpectation{}
	}

	if mmListKnowledgeBases.defaultExpectation.params != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Expect")
	}

	if mmListKnowledgeBases.defaultExpectation.paramPtrs == nil {
		mmListKnowledgeBases.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockListKnowledgeBasesParamPtrs{}
	}
	mmListKnowledgeBases.defaultExpectation.paramPtrs.opts = &opts
	mmListKnowledgeBases.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmListKnowledgeBases
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBasesRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockListKnowledgeBases {
	if mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ListKnowledgeBases")
	}

	mmListKnowledgeBases.mock.inspectFuncListKnowledgeBases = f

	return mmListKnowledgeBases
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ListKnowledgeBases
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) Return(lp1 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error) *ArtifactPublicServiceClientMock {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Set")
	}

	if mmListKnowledgeBases.defaultExpectation == nil {
		mmListKnowledgeBases.defaultExpectation = &ArtifactPublicServiceClientMockListKnowledgeBasesExpectation{mock: mmListKnowledgeBases.mock}
	}
	mmListKnowledgeBases.defaultExpectation.results = &ArtifactPublicServiceClientMockListKnowledgeBasesResults{lp1, err}
	mmListKnowledgeBases.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ListKnowledgeBases method
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBasesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmListKnowledgeBases.defaultExpectation != nil {
		mmListKnowledgeBases.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ListKnowledgeBases method")
	}

	if len(mmListKnowledgeBases.expectations) > 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ListKnowledgeBases method")
	}

	mmListKnowledgeBases.mock.funcListKnowledgeBases = f
	mmListKnowledgeBases.mock.funcListKnowledgeBasesOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ListKnowledgeBases which will trigger the result defined by the following
// Then helper
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) When(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBasesRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockListKnowledgeBasesExpectation {
	if mmListKnowledgeBases.mock.funcListKnowledgeBases != nil {
		mmListKnowledgeBases.mock.t.Fatalf("ArtifactPublicServiceClientMock.ListKnowledgeBases mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockListKnowledgeBasesExpectation{
		mock:               mmListKnowledgeBases.mock,
		params:             &ArtifactPublicServiceClientMockListKnowledgeBasesParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockListKnowledgeBasesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListKnowledgeBases.expectations = append(mmListKnowledgeBases.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ListKnowledgeBases return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockListKnowledgeBasesExpectation) Then(lp1 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockListKnowledgeBasesResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ListKnowledgeBases should be invoked
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) Times(n uint64) *mArtifactPublicServiceClientMockListKnowledgeBases {
	if n == 0 {
		mmListKnowledgeBases.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ListKnowledgeBases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListKnowledgeBases.expectedInvocations, n)
	mmListKnowledgeBases.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListKnowledgeBases
}

func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) invocationsDone() bool {
	if len(mmListKnowledgeBases.expectations) == 0 && mmListKnowledgeBases.defaultExpectation == nil && mmListKnowledgeBases.mock.funcListKnowledgeBases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.mock.afterListKnowledgeBasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListKnowledgeBases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListKnowledgeBases implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmListKnowledgeBases *ArtifactPublicServiceClientMock) ListKnowledgeBases(ctx context.Context, in *mm_artifactv1alpha.ListKnowledgeBasesRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.ListKnowledgeBasesResponse, err error) {
	mm_atomic.AddUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter, 1)

	mmListKnowledgeBases.t.Helper()

	if mmListKnowledgeBases.inspectFuncListKnowledgeBases != nil {
		mmListKnowledgeBases.inspectFuncListKnowledgeBases(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockListKnowledgeBasesParams{ctx, in, opts}

	// Record call args
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Lock()
	mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs = append(mmListKnowledgeBases.ListKnowledgeBasesMock.callArgs, &mm_params)
	mmListKnowledgeBases.ListKnowledgeBasesMock.mutex.Unlock()

	for _, e := range mmListKnowledgeBases.ListKnowledgeBasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.params
		mm_want_ptrs := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockListKnowledgeBasesParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListKnowledgeBases.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBases got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmListKnowledgeBases.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBases got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmListKnowledgeBases.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBases got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListKnowledgeBases.t.Errorf("ArtifactPublicServiceClientMock.ListKnowledgeBases got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListKnowledgeBases.ListKnowledgeBasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListKnowledgeBases.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ListKnowledgeBases")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListKnowledgeBases.funcListKnowledgeBases != nil {
		return mmListKnowledgeBases.funcListKnowledgeBases(ctx, in, opts...)
	}
	mmListKnowledgeBases.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ListKnowledgeBases. %v %v %v", ctx, in, opts)
	return
}

// ListKnowledgeBasesAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *ArtifactPublicServiceClientMock) ListKnowledgeBasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.afterListKnowledgeBasesCounter)
}

// ListKnowledgeBasesBeforeCounter returns a count of ArtifactPublicServiceClientMock.ListKnowledgeBases invocations
func (mmListKnowledgeBases *ArtifactPublicServiceClientMock) ListKnowledgeBasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListKnowledgeBases.beforeListKnowledgeBasesCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ListKnowledgeBases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListKnowledgeBases *mArtifactPublicServiceClientMockListKnowledgeBases) Calls() []*ArtifactPublicServiceClientMockListKnowledgeBasesParams {
	mmListKnowledgeBases.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockListKnowledgeBasesParams, len(mmListKnowledgeBases.callArgs))
	copy(argCopy, mmListKnowledgeBases.callArgs)

	mmListKnowledgeBases.mutex.RUnlock()

	return argCopy
}

// MinimockListKnowledgeBasesDone returns true if the count of the ListKnowledgeBases invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockListKnowledgeBasesDone() bool {
	if m.ListKnowledgeBasesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListKnowledgeBasesMock.invocationsDone()
}

// MinimockListKnowledgeBasesInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockListKnowledgeBasesInspect() {
	for _, e := range m.ListKnowledgeBasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBases at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListKnowledgeBasesCounter := mm_atomic.LoadUint64(&m.afterListKnowledgeBasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListKnowledgeBasesMock.defaultExpectation != nil && afterListKnowledgeBasesCounter < 1 {
		if m.ListKnowledgeBasesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBases at\n%s", m.ListKnowledgeBasesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBases at\n%s with params: %#v", m.ListKnowledgeBasesMock.defaultExpectation.expectationOrigins.origin, *m.ListKnowledgeBasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListKnowledgeBases != nil && afterListKnowledgeBasesCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ListKnowledgeBases at\n%s", m.funcListKnowledgeBasesOrigin)
	}

	if !m.ListKnowledgeBasesMock.invocationsDone() && afterListKnowledgeBasesCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ListKnowledgeBases at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListKnowledgeBasesMock.expectedInvocations), m.ListKnowledgeBasesMock.expectedInvocationsOrigin, afterListKnowledgeBasesCounter)
	}
}

type mArtifactPublicServiceClientMockLiveness struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockLivenessExpectation
	expectations       []*ArtifactPublicServiceClientMockLivenessExpectation

	callArgs []*ArtifactPublicServiceClientMockLivenessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockLivenessExpectation specifies expectation struct of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockLivenessParams
	paramPtrs          *ArtifactPublicServiceClientMockLivenessParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockLivenessExpectationOrigins
	results            *ArtifactPublicServiceClientMockLivenessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockLivenessParams contains parameters of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.LivenessRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockLivenessParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.LivenessRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockLivenessResults contains results of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessResults struct {
	lp1 *mm_artifactv1alpha.LivenessResponse
	err error
}

// ArtifactPublicServiceClientMockLivenessOrigins contains origins of expectations of the ArtifactPublicServiceClient.Liveness
type ArtifactPublicServiceClientMockLivenessExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Optional() *mArtifactPublicServiceClientMockLiveness {
	mmLiveness.optional = true
	return mmLiveness
}

// Expect sets up expected params for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Expect(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.paramPtrs != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by ExpectParams functions")
	}

	mmLiveness.defaultExpectation.params = &ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}
	mmLiveness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLiveness.expectations {
		if minimock.Equal(e.params, mmLiveness.defaultExpectation.params) {
			mmLiveness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLiveness.defaultExpectation.params)
		}
	}

	return mmLiveness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.ctx = &ctx
	mmLiveness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectInParam2(in *mm_artifactv1alpha.LivenessRequest) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.in = &in
	mmLiveness.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmLiveness
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{}
	}

	if mmLiveness.defaultExpectation.params != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Expect")
	}

	if mmLiveness.defaultExpectation.paramPtrs == nil {
		mmLiveness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockLivenessParamPtrs{}
	}
	mmLiveness.defaultExpectation.paramPtrs.opts = &opts
	mmLiveness.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmLiveness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockLiveness {
	if mmLiveness.mock.inspectFuncLiveness != nil {
		mmLiveness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.Liveness")
	}

	mmLiveness.mock.inspectFuncLiveness = f

	return mmLiveness
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.Liveness
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Return(lp1 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceClientMock {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	if mmLiveness.defaultExpectation == nil {
		mmLiveness.defaultExpectation = &ArtifactPublicServiceClientMockLivenessExpectation{mock: mmLiveness.mock}
	}
	mmLiveness.defaultExpectation.results = &ArtifactPublicServiceClientMockLivenessResults{lp1, err}
	mmLiveness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.Liveness method
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Set(f func(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmLiveness.defaultExpectation != nil {
		mmLiveness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.Liveness method")
	}

	if len(mmLiveness.expectations) > 0 {
		mmLiveness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.Liveness method")
	}

	mmLiveness.mock.funcLiveness = f
	mmLiveness.mock.funcLivenessOrigin = minimock.CallerInfo(1)
	return mmLiveness.mock
}

// When sets expectation for the ArtifactPublicServiceClient.Liveness which will trigger the result defined by the following
// Then helper
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) When(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockLivenessExpectation {
	if mmLiveness.mock.funcLiveness != nil {
		mmLiveness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Liveness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockLivenessExpectation{
		mock:               mmLiveness.mock,
		params:             &ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockLivenessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLiveness.expectations = append(mmLiveness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.Liveness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockLivenessExpectation) Then(lp1 *mm_artifactv1alpha.LivenessResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockLivenessResults{lp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.Liveness should be invoked
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Times(n uint64) *mArtifactPublicServiceClientMockLiveness {
	if n == 0 {
		mmLiveness.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.Liveness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLiveness.expectedInvocations, n)
	mmLiveness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLiveness
}

func (mmLiveness *mArtifactPublicServiceClientMockLiveness) invocationsDone() bool {
	if len(mmLiveness.expectations) == 0 && mmLiveness.defaultExpectation == nil && mmLiveness.mock.funcLiveness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLiveness.mock.afterLivenessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLiveness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Liveness implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmLiveness *ArtifactPublicServiceClientMock) Liveness(ctx context.Context, in *mm_artifactv1alpha.LivenessRequest, opts ...grpc.CallOption) (lp1 *mm_artifactv1alpha.LivenessResponse, err error) {
	mm_atomic.AddUint64(&mmLiveness.beforeLivenessCounter, 1)
	defer mm_atomic.AddUint64(&mmLiveness.afterLivenessCounter, 1)

	mmLiveness.t.Helper()

	if mmLiveness.inspectFuncLiveness != nil {
		mmLiveness.inspectFuncLiveness(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}

	// Record call args
	mmLiveness.LivenessMock.mutex.Lock()
	mmLiveness.LivenessMock.callArgs = append(mmLiveness.LivenessMock.callArgs, &mm_params)
	mmLiveness.LivenessMock.mutex.Unlock()

	for _, e := range mmLiveness.LivenessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmLiveness.LivenessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLiveness.LivenessMock.defaultExpectation.Counter, 1)
		mm_want := mmLiveness.LivenessMock.defaultExpectation.params
		mm_want_ptrs := mmLiveness.LivenessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockLivenessParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLiveness.t.Errorf("ArtifactPublicServiceClientMock.Liveness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLiveness.LivenessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLiveness.LivenessMock.defaultExpectation.results
		if mm_results == nil {
			mmLiveness.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.Liveness")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmLiveness.funcLiveness != nil {
		return mmLiveness.funcLiveness(ctx, in, opts...)
	}
	mmLiveness.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.Liveness. %v %v %v", ctx, in, opts)
	return
}

// LivenessAfterCounter returns a count of finished ArtifactPublicServiceClientMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceClientMock) LivenessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.afterLivenessCounter)
}

// LivenessBeforeCounter returns a count of ArtifactPublicServiceClientMock.Liveness invocations
func (mmLiveness *ArtifactPublicServiceClientMock) LivenessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLiveness.beforeLivenessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.Liveness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLiveness *mArtifactPublicServiceClientMockLiveness) Calls() []*ArtifactPublicServiceClientMockLivenessParams {
	mmLiveness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockLivenessParams, len(mmLiveness.callArgs))
	copy(argCopy, mmLiveness.callArgs)

	mmLiveness.mutex.RUnlock()

	return argCopy
}

// MinimockLivenessDone returns true if the count of the Liveness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockLivenessDone() bool {
	if m.LivenessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LivenessMock.invocationsDone()
}

// MinimockLivenessInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockLivenessInspect() {
	for _, e := range m.LivenessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLivenessCounter := mm_atomic.LoadUint64(&m.afterLivenessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LivenessMock.defaultExpectation != nil && afterLivenessCounter < 1 {
		if m.LivenessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s", m.LivenessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s with params: %#v", m.LivenessMock.defaultExpectation.expectationOrigins.origin, *m.LivenessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLiveness != nil && afterLivenessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Liveness at\n%s", m.funcLivenessOrigin)
	}

	if !m.LivenessMock.invocationsDone() && afterLivenessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.Liveness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LivenessMock.expectedInvocations), m.LivenessMock.expectedInvocationsOrigin, afterLivenessCounter)
	}
}

type mArtifactPublicServiceClientMockReadiness struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockReadinessExpectation
	expectations       []*ArtifactPublicServiceClientMockReadinessExpectation

	callArgs []*ArtifactPublicServiceClientMockReadinessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockReadinessExpectation specifies expectation struct of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockReadinessParams
	paramPtrs          *ArtifactPublicServiceClientMockReadinessParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockReadinessExpectationOrigins
	results            *ArtifactPublicServiceClientMockReadinessResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockReadinessParams contains parameters of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ReadinessRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockReadinessParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ReadinessRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockReadinessResults contains results of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessResults struct {
	rp1 *mm_artifactv1alpha.ReadinessResponse
	err error
}

// ArtifactPublicServiceClientMockReadinessOrigins contains origins of expectations of the ArtifactPublicServiceClient.Readiness
type ArtifactPublicServiceClientMockReadinessExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Optional() *mArtifactPublicServiceClientMockReadiness {
	mmReadiness.optional = true
	return mmReadiness
}

// Expect sets up expected params for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Expect(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.paramPtrs != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by ExpectParams functions")
	}

	mmReadiness.defaultExpectation.params = &ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}
	mmReadiness.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReadiness.expectations {
		if minimock.Equal(e.params, mmReadiness.defaultExpectation.params) {
			mmReadiness.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadiness.defaultExpectation.params)
		}
	}

	return mmReadiness
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.ctx = &ctx
	mmReadiness.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectInParam2(in *mm_artifactv1alpha.ReadinessRequest) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.in = &in
	mmReadiness.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmReadiness
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{}
	}

	if mmReadiness.defaultExpectation.params != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Expect")
	}

	if mmReadiness.defaultExpectation.paramPtrs == nil {
		mmReadiness.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReadinessParamPtrs{}
	}
	mmReadiness.defaultExpectation.paramPtrs.opts = &opts
	mmReadiness.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmReadiness
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockReadiness {
	if mmReadiness.mock.inspectFuncReadiness != nil {
		mmReadiness.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.Readiness")
	}

	mmReadiness.mock.inspectFuncReadiness = f

	return mmReadiness
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.Readiness
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Return(rp1 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceClientMock {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	if mmReadiness.defaultExpectation == nil {
		mmReadiness.defaultExpectation = &ArtifactPublicServiceClientMockReadinessExpectation{mock: mmReadiness.mock}
	}
	mmReadiness.defaultExpectation.results = &ArtifactPublicServiceClientMockReadinessResults{rp1, err}
	mmReadiness.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.Readiness method
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmReadiness.defaultExpectation != nil {
		mmReadiness.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.Readiness method")
	}

	if len(mmReadiness.expectations) > 0 {
		mmReadiness.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.Readiness method")
	}

	mmReadiness.mock.funcReadiness = f
	mmReadiness.mock.funcReadinessOrigin = minimock.CallerInfo(1)
	return mmReadiness.mock
}

// When sets expectation for the ArtifactPublicServiceClient.Readiness which will trigger the result defined by the following
// Then helper
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) When(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockReadinessExpectation {
	if mmReadiness.mock.funcReadiness != nil {
		mmReadiness.mock.t.Fatalf("ArtifactPublicServiceClientMock.Readiness mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockReadinessExpectation{
		mock:               mmReadiness.mock,
		params:             &ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockReadinessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReadiness.expectations = append(mmReadiness.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.Readiness return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockReadinessExpectation) Then(rp1 *mm_artifactv1alpha.ReadinessResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockReadinessResults{rp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.Readiness should be invoked
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Times(n uint64) *mArtifactPublicServiceClientMockReadiness {
	if n == 0 {
		mmReadiness.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.Readiness mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReadiness.expectedInvocations, n)
	mmReadiness.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReadiness
}

func (mmReadiness *mArtifactPublicServiceClientMockReadiness) invocationsDone() bool {
	if len(mmReadiness.expectations) == 0 && mmReadiness.defaultExpectation == nil && mmReadiness.mock.funcReadiness == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReadiness.mock.afterReadinessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReadiness.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Readiness implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmReadiness *ArtifactPublicServiceClientMock) Readiness(ctx context.Context, in *mm_artifactv1alpha.ReadinessRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReadinessResponse, err error) {
	mm_atomic.AddUint64(&mmReadiness.beforeReadinessCounter, 1)
	defer mm_atomic.AddUint64(&mmReadiness.afterReadinessCounter, 1)

	mmReadiness.t.Helper()

	if mmReadiness.inspectFuncReadiness != nil {
		mmReadiness.inspectFuncReadiness(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}

	// Record call args
	mmReadiness.ReadinessMock.mutex.Lock()
	mmReadiness.ReadinessMock.callArgs = append(mmReadiness.ReadinessMock.callArgs, &mm_params)
	mmReadiness.ReadinessMock.mutex.Unlock()

	for _, e := range mmReadiness.ReadinessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmReadiness.ReadinessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadiness.ReadinessMock.defaultExpectation.Counter, 1)
		mm_want := mmReadiness.ReadinessMock.defaultExpectation.params
		mm_want_ptrs := mmReadiness.ReadinessMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockReadinessParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadiness.t.Errorf("ArtifactPublicServiceClientMock.Readiness got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReadiness.ReadinessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadiness.ReadinessMock.defaultExpectation.results
		if mm_results == nil {
			mmReadiness.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.Readiness")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmReadiness.funcReadiness != nil {
		return mmReadiness.funcReadiness(ctx, in, opts...)
	}
	mmReadiness.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.Readiness. %v %v %v", ctx, in, opts)
	return
}

// ReadinessAfterCounter returns a count of finished ArtifactPublicServiceClientMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceClientMock) ReadinessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.afterReadinessCounter)
}

// ReadinessBeforeCounter returns a count of ArtifactPublicServiceClientMock.Readiness invocations
func (mmReadiness *ArtifactPublicServiceClientMock) ReadinessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadiness.beforeReadinessCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.Readiness.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadiness *mArtifactPublicServiceClientMockReadiness) Calls() []*ArtifactPublicServiceClientMockReadinessParams {
	mmReadiness.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockReadinessParams, len(mmReadiness.callArgs))
	copy(argCopy, mmReadiness.callArgs)

	mmReadiness.mutex.RUnlock()

	return argCopy
}

// MinimockReadinessDone returns true if the count of the Readiness invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockReadinessDone() bool {
	if m.ReadinessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadinessMock.invocationsDone()
}

// MinimockReadinessInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockReadinessInspect() {
	for _, e := range m.ReadinessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadinessCounter := mm_atomic.LoadUint64(&m.afterReadinessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadinessMock.defaultExpectation != nil && afterReadinessCounter < 1 {
		if m.ReadinessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s", m.ReadinessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s with params: %#v", m.ReadinessMock.defaultExpectation.expectationOrigins.origin, *m.ReadinessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadiness != nil && afterReadinessCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.Readiness at\n%s", m.funcReadinessOrigin)
	}

	if !m.ReadinessMock.invocationsDone() && afterReadinessCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.Readiness at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadinessMock.expectedInvocations), m.ReadinessMock.expectedInvocationsOrigin, afterReadinessCounter)
	}
}

type mArtifactPublicServiceClientMockReprocessFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockReprocessFileExpectation
	expectations       []*ArtifactPublicServiceClientMockReprocessFileExpectation

	callArgs []*ArtifactPublicServiceClientMockReprocessFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockReprocessFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.ReprocessFile
type ArtifactPublicServiceClientMockReprocessFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockReprocessFileParams
	paramPtrs          *ArtifactPublicServiceClientMockReprocessFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockReprocessFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockReprocessFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockReprocessFileParams contains parameters of the ArtifactPublicServiceClient.ReprocessFile
type ArtifactPublicServiceClientMockReprocessFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.ReprocessFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockReprocessFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.ReprocessFile
type ArtifactPublicServiceClientMockReprocessFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.ReprocessFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockReprocessFileResults contains results of the ArtifactPublicServiceClient.ReprocessFile
type ArtifactPublicServiceClientMockReprocessFileResults struct {
	rp1 *mm_artifactv1alpha.ReprocessFileResponse
	err error
}

// ArtifactPublicServiceClientMockReprocessFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.ReprocessFile
type ArtifactPublicServiceClientMockReprocessFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) Optional() *mArtifactPublicServiceClientMockReprocessFile {
	mmReprocessFile.optional = true
	return mmReprocessFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) Expect(ctx context.Context, in *mm_artifactv1alpha.ReprocessFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReprocessFile {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceClientMockReprocessFileExpectation{}
	}

	if mmReprocessFile.defaultExpectation.paramPtrs != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by ExpectParams functions")
	}

	mmReprocessFile.defaultExpectation.params = &ArtifactPublicServiceClientMockReprocessFileParams{ctx, in, opts}
	mmReprocessFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReprocessFile.expectations {
		if minimock.Equal(e.params, mmReprocessFile.defaultExpectation.params) {
			mmReprocessFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReprocessFile.defaultExpectation.params)
		}
	}

	return mmReprocessFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockReprocessFile {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceClientMockReprocessFileExpectation{}
	}

	if mmReprocessFile.defaultExpectation.params != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Expect")
	}

	if mmReprocessFile.defaultExpectation.paramPtrs == nil {
		mmReprocessFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReprocessFileParamPtrs{}
	}
	mmReprocessFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmReprocessFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReprocessFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) ExpectInParam2(in *mm_artifactv1alpha.ReprocessFileRequest) *mArtifactPublicServiceClientMockReprocessFile {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceClientMockReprocessFileExpectation{}
	}

	if mmReprocessFile.defaultExpectation.params != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Expect")
	}

	if mmReprocessFile.defaultExpectation.paramPtrs == nil {
		mmReprocessFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReprocessFileParamPtrs{}
	}
	mmReprocessFile.defaultExpectation.paramPtrs.in = &in
	mmReprocessFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmReprocessFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockReprocessFile {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceClientMockReprocessFileExpectation{}
	}

	if mmReprocessFile.defaultExpectation.params != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Expect")
	}

	if mmReprocessFile.defaultExpectation.paramPtrs == nil {
		mmReprocessFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockReprocessFileParamPtrs{}
	}
	mmReprocessFile.defaultExpectation.paramPtrs.opts = &opts
	mmReprocessFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmReprocessFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.ReprocessFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockReprocessFile {
	if mmReprocessFile.mock.inspectFuncReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.ReprocessFile")
	}

	mmReprocessFile.mock.inspectFuncReprocessFile = f

	return mmReprocessFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.ReprocessFile
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) Return(rp1 *mm_artifactv1alpha.ReprocessFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Set")
	}

	if mmReprocessFile.defaultExpectation == nil {
		mmReprocessFile.defaultExpectation = &ArtifactPublicServiceClientMockReprocessFileExpectation{mock: mmReprocessFile.mock}
	}
	mmReprocessFile.defaultExpectation.results = &ArtifactPublicServiceClientMockReprocessFileResults{rp1, err}
	mmReprocessFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReprocessFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.ReprocessFile method
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.ReprocessFileRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReprocessFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmReprocessFile.defaultExpectation != nil {
		mmReprocessFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.ReprocessFile method")
	}

	if len(mmReprocessFile.expectations) > 0 {
		mmReprocessFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.ReprocessFile method")
	}

	mmReprocessFile.mock.funcReprocessFile = f
	mmReprocessFile.mock.funcReprocessFileOrigin = minimock.CallerInfo(1)
	return mmReprocessFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.ReprocessFile which will trigger the result defined by the following
// Then helper
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) When(ctx context.Context, in *mm_artifactv1alpha.ReprocessFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockReprocessFileExpectation {
	if mmReprocessFile.mock.funcReprocessFile != nil {
		mmReprocessFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.ReprocessFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockReprocessFileExpectation{
		mock:               mmReprocessFile.mock,
		params:             &ArtifactPublicServiceClientMockReprocessFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockReprocessFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReprocessFile.expectations = append(mmReprocessFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.ReprocessFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockReprocessFileExpectation) Then(rp1 *mm_artifactv1alpha.ReprocessFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockReprocessFileResults{rp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.ReprocessFile should be invoked
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) Times(n uint64) *mArtifactPublicServiceClientMockReprocessFile {
	if n == 0 {
		mmReprocessFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.ReprocessFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReprocessFile.expectedInvocations, n)
	mmReprocessFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReprocessFile
}

func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) invocationsDone() bool {
	if len(mmReprocessFile.expectations) == 0 && mmReprocessFile.defaultExpectation == nil && mmReprocessFile.mock.funcReprocessFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReprocessFile.mock.afterReprocessFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReprocessFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReprocessFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmReprocessFile *ArtifactPublicServiceClientMock) ReprocessFile(ctx context.Context, in *mm_artifactv1alpha.ReprocessFileRequest, opts ...grpc.CallOption) (rp1 *mm_artifactv1alpha.ReprocessFileResponse, err error) {
	mm_atomic.AddUint64(&mmReprocessFile.beforeReprocessFileCounter, 1)
	defer mm_atomic.AddUint64(&mmReprocessFile.afterReprocessFileCounter, 1)

	mmReprocessFile.t.Helper()

	if mmReprocessFile.inspectFuncReprocessFile != nil {
		mmReprocessFile.inspectFuncReprocessFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockReprocessFileParams{ctx, in, opts}

	// Record call args
	mmReprocessFile.ReprocessFileMock.mutex.Lock()
	mmReprocessFile.ReprocessFileMock.callArgs = append(mmReprocessFile.ReprocessFileMock.callArgs, &mm_params)
	mmReprocessFile.ReprocessFileMock.mutex.Unlock()

	for _, e := range mmReprocessFile.ReprocessFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmReprocessFile.ReprocessFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReprocessFile.ReprocessFileMock.defaultExpectation.Counter, 1)
		mm_want := mmReprocessFile.ReprocessFileMock.defaultExpectation.params
		mm_want_ptrs := mmReprocessFile.ReprocessFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockReprocessFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReprocessFile.t.Errorf("ArtifactPublicServiceClientMock.ReprocessFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReprocessFile.ReprocessFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmReprocessFile.t.Errorf("ArtifactPublicServiceClientMock.ReprocessFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReprocessFile.ReprocessFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmReprocessFile.t.Errorf("ArtifactPublicServiceClientMock.ReprocessFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReprocessFile.ReprocessFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReprocessFile.t.Errorf("ArtifactPublicServiceClientMock.ReprocessFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReprocessFile.ReprocessFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReprocessFile.ReprocessFileMock.defaultExpectation.results
		if mm_results == nil {
			mmReprocessFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.ReprocessFile")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmReprocessFile.funcReprocessFile != nil {
		return mmReprocessFile.funcReprocessFile(ctx, in, opts...)
	}
	mmReprocessFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.ReprocessFile. %v %v %v", ctx, in, opts)
	return
}

// ReprocessFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.ReprocessFile invocations
func (mmReprocessFile *ArtifactPublicServiceClientMock) ReprocessFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReprocessFile.afterReprocessFileCounter)
}

// ReprocessFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.ReprocessFile invocations
func (mmReprocessFile *ArtifactPublicServiceClientMock) ReprocessFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReprocessFile.beforeReprocessFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.ReprocessFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReprocessFile *mArtifactPublicServiceClientMockReprocessFile) Calls() []*ArtifactPublicServiceClientMockReprocessFileParams {
	mmReprocessFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockReprocessFileParams, len(mmReprocessFile.callArgs))
	copy(argCopy, mmReprocessFile.callArgs)

	mmReprocessFile.mutex.RUnlock()

	return argCopy
}

// MinimockReprocessFileDone returns true if the count of the ReprocessFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockReprocessFileDone() bool {
	if m.ReprocessFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReprocessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReprocessFileMock.invocationsDone()
}

// MinimockReprocessFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockReprocessFileInspect() {
	for _, e := range m.ReprocessFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ReprocessFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReprocessFileCounter := mm_atomic.LoadUint64(&m.afterReprocessFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReprocessFileMock.defaultExpectation != nil && afterReprocessFileCounter < 1 {
		if m.ReprocessFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ReprocessFile at\n%s", m.ReprocessFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ReprocessFile at\n%s with params: %#v", m.ReprocessFileMock.defaultExpectation.expectationOrigins.origin, *m.ReprocessFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReprocessFile != nil && afterReprocessFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.ReprocessFile at\n%s", m.funcReprocessFileOrigin)
	}

	if !m.ReprocessFileMock.invocationsDone() && afterReprocessFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.ReprocessFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReprocessFileMock.expectedInvocations), m.ReprocessFileMock.expectedInvocationsOrigin, afterReprocessFileCounter)
	}
}

type mArtifactPublicServiceClientMockSearchChunks struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockSearchChunksExpectation
	expectations       []*ArtifactPublicServiceClientMockSearchChunksExpectation

	callArgs []*ArtifactPublicServiceClientMockSearchChunksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockSearchChunksExpectation specifies expectation struct of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockSearchChunksParams
	paramPtrs          *ArtifactPublicServiceClientMockSearchChunksParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockSearchChunksExpectationOrigins
	results            *ArtifactPublicServiceClientMockSearchChunksResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockSearchChunksParams contains parameters of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.SearchChunksRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockSearchChunksParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.SearchChunksRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockSearchChunksResults contains results of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksResults struct {
	sp1 *mm_artifactv1alpha.SearchChunksResponse
	err error
}

// ArtifactPublicServiceClientMockSearchChunksOrigins contains origins of expectations of the ArtifactPublicServiceClient.SearchChunks
type ArtifactPublicServiceClientMockSearchChunksExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Optional() *mArtifactPublicServiceClientMockSearchChunks {
	mmSearchChunks.optional = true
	return mmSearchChunks
}

// Expect sets up expected params for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Expect(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.paramPtrs != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by ExpectParams functions")
	}

	mmSearchChunks.defaultExpectation.params = &ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts}
	mmSearchChunks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchChunks.expectations {
		if minimock.Equal(e.params, mmSearchChunks.defaultExpectation.params) {
			mmSearchChunks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchChunks.defaultExpectation.params)
		}
	}

	return mmSearchChunks
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchChunks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchChunks
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) ExpectInParam2(in *mm_artifactv1alpha.SearchChunksRequest) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.in = &in
	mmSearchChunks.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmSearchChunks
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{}
	}

	if mmSearchChunks.defaultExpectation.params != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Expect")
	}

	if mmSearchChunks.defaultExpectation.paramPtrs == nil {
		mmSearchChunks.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockSearchChunksParamPtrs{}
	}
	mmSearchChunks.defaultExpectation.paramPtrs.opts = &opts
	mmSearchChunks.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmSearchChunks
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockSearchChunks {
	if mmSearchChunks.mock.inspectFuncSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.SearchChunks")
	}

	mmSearchChunks.mock.inspectFuncSearchChunks = f

	return mmSearchChunks
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.SearchChunks
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Return(sp1 *mm_artifactv1alpha.SearchChunksResponse, err error) *ArtifactPublicServiceClientMock {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	if mmSearchChunks.defaultExpectation == nil {
		mmSearchChunks.defaultExpectation = &ArtifactPublicServiceClientMockSearchChunksExpectation{mock: mmSearchChunks.mock}
	}
	mmSearchChunks.defaultExpectation.results = &ArtifactPublicServiceClientMockSearchChunksResults{sp1, err}
	mmSearchChunks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchChunks.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.SearchChunks method
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Set(f func(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchChunksResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmSearchChunks.defaultExpectation != nil {
		mmSearchChunks.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.SearchChunks method")
	}

	if len(mmSearchChunks.expectations) > 0 {
		mmSearchChunks.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.SearchChunks method")
	}

	mmSearchChunks.mock.funcSearchChunks = f
	mmSearchChunks.mock.funcSearchChunksOrigin = minimock.CallerInfo(1)
	return mmSearchChunks.mock
}

// When sets expectation for the ArtifactPublicServiceClient.SearchChunks which will trigger the result defined by the following
// Then helper
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) When(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockSearchChunksExpectation {
	if mmSearchChunks.mock.funcSearchChunks != nil {
		mmSearchChunks.mock.t.Fatalf("ArtifactPublicServiceClientMock.SearchChunks mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockSearchChunksExpectation{
		mock:               mmSearchChunks.mock,
		params:             &ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockSearchChunksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchChunks.expectations = append(mmSearchChunks.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.SearchChunks return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockSearchChunksExpectation) Then(sp1 *mm_artifactv1alpha.SearchChunksResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockSearchChunksResults{sp1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.SearchChunks should be invoked
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Times(n uint64) *mArtifactPublicServiceClientMockSearchChunks {
	if n == 0 {
		mmSearchChunks.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.SearchChunks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchChunks.expectedInvocations, n)
	mmSearchChunks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchChunks
}

func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) invocationsDone() bool {
	if len(mmSearchChunks.expectations) == 0 && mmSearchChunks.defaultExpectation == nil && mmSearchChunks.mock.funcSearchChunks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchChunks.mock.afterSearchChunksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchChunks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchChunks implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmSearchChunks *ArtifactPublicServiceClientMock) SearchChunks(ctx context.Context, in *mm_artifactv1alpha.SearchChunksRequest, opts ...grpc.CallOption) (sp1 *mm_artifactv1alpha.SearchChunksResponse, err error) {
	mm_atomic.AddUint64(&mmSearchChunks.beforeSearchChunksCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchChunks.afterSearchChunksCounter, 1)

	mmSearchChunks.t.Helper()

	if mmSearchChunks.inspectFuncSearchChunks != nil {
		mmSearchChunks.inspectFuncSearchChunks(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts}

	// Record call args
	mmSearchChunks.SearchChunksMock.mutex.Lock()
	mmSearchChunks.SearchChunksMock.callArgs = append(mmSearchChunks.SearchChunksMock.callArgs, &mm_params)
	mmSearchChunks.SearchChunksMock.mutex.Unlock()

	for _, e := range mmSearchChunks.SearchChunksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmSearchChunks.SearchChunksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchChunks.SearchChunksMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchChunks.SearchChunksMock.defaultExpectation.params
		mm_want_ptrs := mmSearchChunks.SearchChunksMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockSearchChunksParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchChunks.t.Errorf("ArtifactPublicServiceClientMock.SearchChunks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchChunks.SearchChunksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchChunks.SearchChunksMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchChunks.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.SearchChunks")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmSearchChunks.funcSearchChunks != nil {
		return mmSearchChunks.funcSearchChunks(ctx, in, opts...)
	}
	mmSearchChunks.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.SearchChunks. %v %v %v", ctx, in, opts)
	return
}

// SearchChunksAfterCounter returns a count of finished ArtifactPublicServiceClientMock.SearchChunks invocations
func (mmSearchChunks *ArtifactPublicServiceClientMock) SearchChunksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchChunks.afterSearchChunksCounter)
}

// SearchChunksBeforeCounter returns a count of ArtifactPublicServiceClientMock.SearchChunks invocations
func (mmSearchChunks *ArtifactPublicServiceClientMock) SearchChunksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchChunks.beforeSearchChunksCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.SearchChunks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchChunks *mArtifactPublicServiceClientMockSearchChunks) Calls() []*ArtifactPublicServiceClientMockSearchChunksParams {
	mmSearchChunks.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockSearchChunksParams, len(mmSearchChunks.callArgs))
	copy(argCopy, mmSearchChunks.callArgs)

	mmSearchChunks.mutex.RUnlock()

	return argCopy
}

// MinimockSearchChunksDone returns true if the count of the SearchChunks invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockSearchChunksDone() bool {
	if m.SearchChunksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchChunksMock.invocationsDone()
}

// MinimockSearchChunksInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockSearchChunksInspect() {
	for _, e := range m.SearchChunksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchChunksCounter := mm_atomic.LoadUint64(&m.afterSearchChunksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchChunksMock.defaultExpectation != nil && afterSearchChunksCounter < 1 {
		if m.SearchChunksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s", m.SearchChunksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s with params: %#v", m.SearchChunksMock.defaultExpectation.expectationOrigins.origin, *m.SearchChunksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchChunks != nil && afterSearchChunksCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.SearchChunks at\n%s", m.funcSearchChunksOrigin)
	}

	if !m.SearchChunksMock.invocationsDone() && afterSearchChunksCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.SearchChunks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchChunksMock.expectedInvocations), m.SearchChunksMock.expectedInvocationsOrigin, afterSearchChunksCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateChunk struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateChunkExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateChunkExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateChunkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockUpdateChunkExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockUpdateChunkParams
	paramPtrs          *ArtifactPublicServiceClientMockUpdateChunkParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockUpdateChunkExpectationOrigins
	results            *ArtifactPublicServiceClientMockUpdateChunkResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockUpdateChunkParams contains parameters of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateChunkRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateChunkParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateChunkRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateChunkResults contains results of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkResults struct {
	up1 *mm_artifactv1alpha.UpdateChunkResponse
	err error
}

// ArtifactPublicServiceClientMockUpdateChunkOrigins contains origins of expectations of the ArtifactPublicServiceClient.UpdateChunk
type ArtifactPublicServiceClientMockUpdateChunkExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Optional() *mArtifactPublicServiceClientMockUpdateChunk {
	mmUpdateChunk.optional = true
	return mmUpdateChunk
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by ExpectParams functions")
	}

	mmUpdateChunk.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}
	mmUpdateChunk.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateChunk.expectations {
		if minimock.Equal(e.params, mmUpdateChunk.defaultExpectation.params) {
			mmUpdateChunk.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateChunk.defaultExpectation.params)
		}
	}

	return mmUpdateChunk
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateChunk.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectInParam2(in *mm_artifactv1alpha.UpdateChunkRequest) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.in = &in
	mmUpdateChunk.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{}
	}

	if mmUpdateChunk.defaultExpectation.params != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Expect")
	}

	if mmUpdateChunk.defaultExpectation.paramPtrs == nil {
		mmUpdateChunk.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateChunkParamPtrs{}
	}
	mmUpdateChunk.defaultExpectation.paramPtrs.opts = &opts
	mmUpdateChunk.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmUpdateChunk
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateChunk {
	if mmUpdateChunk.mock.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateChunk")
	}

	mmUpdateChunk.mock.inspectFuncUpdateChunk = f

	return mmUpdateChunk
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateChunk
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Return(up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	if mmUpdateChunk.defaultExpectation == nil {
		mmUpdateChunk.defaultExpectation = &ArtifactPublicServiceClientMockUpdateChunkExpectation{mock: mmUpdateChunk.mock}
	}
	mmUpdateChunk.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateChunkResults{up1, err}
	mmUpdateChunk.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateChunk method
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateChunk.defaultExpectation != nil {
		mmUpdateChunk.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateChunk method")
	}

	if len(mmUpdateChunk.expectations) > 0 {
		mmUpdateChunk.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateChunk method")
	}

	mmUpdateChunk.mock.funcUpdateChunk = f
	mmUpdateChunk.mock.funcUpdateChunkOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateChunk which will trigger the result defined by the following
// Then helper
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) When(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateChunkExpectation {
	if mmUpdateChunk.mock.funcUpdateChunk != nil {
		mmUpdateChunk.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateChunk mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateChunkExpectation{
		mock:               mmUpdateChunk.mock,
		params:             &ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockUpdateChunkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateChunk.expectations = append(mmUpdateChunk.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateChunk return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateChunkExpectation) Then(up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateChunkResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateChunk should be invoked
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Times(n uint64) *mArtifactPublicServiceClientMockUpdateChunk {
	if n == 0 {
		mmUpdateChunk.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateChunk mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateChunk.expectedInvocations, n)
	mmUpdateChunk.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateChunk
}

func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) invocationsDone() bool {
	if len(mmUpdateChunk.expectations) == 0 && mmUpdateChunk.defaultExpectation == nil && mmUpdateChunk.mock.funcUpdateChunk == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.mock.afterUpdateChunkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateChunk.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateChunk implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunk(ctx context.Context, in *mm_artifactv1alpha.UpdateChunkRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateChunkResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateChunk.beforeUpdateChunkCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateChunk.afterUpdateChunkCounter, 1)

	mmUpdateChunk.t.Helper()

	if mmUpdateChunk.inspectFuncUpdateChunk != nil {
		mmUpdateChunk.inspectFuncUpdateChunk(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}

	// Record call args
	mmUpdateChunk.UpdateChunkMock.mutex.Lock()
	mmUpdateChunk.UpdateChunkMock.callArgs = append(mmUpdateChunk.UpdateChunkMock.callArgs, &mm_params)
	mmUpdateChunk.UpdateChunkMock.mutex.Unlock()

	for _, e := range mmUpdateChunk.UpdateChunkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateChunk.UpdateChunkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateChunk.UpdateChunkMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateChunk.UpdateChunkMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateChunk.UpdateChunkMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateChunkParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateChunk.t.Errorf("ArtifactPublicServiceClientMock.UpdateChunk got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateChunk.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateChunk.UpdateChunkMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateChunk.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateChunk")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateChunk.funcUpdateChunk != nil {
		return mmUpdateChunk.funcUpdateChunk(ctx, in, opts...)
	}
	mmUpdateChunk.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateChunk. %v %v %v", ctx, in, opts)
	return
}

// UpdateChunkAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.afterUpdateChunkCounter)
}

// UpdateChunkBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateChunk invocations
func (mmUpdateChunk *ArtifactPublicServiceClientMock) UpdateChunkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateChunk.beforeUpdateChunkCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateChunk.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateChunk *mArtifactPublicServiceClientMockUpdateChunk) Calls() []*ArtifactPublicServiceClientMockUpdateChunkParams {
	mmUpdateChunk.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateChunkParams, len(mmUpdateChunk.callArgs))
	copy(argCopy, mmUpdateChunk.callArgs)

	mmUpdateChunk.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateChunkDone returns true if the count of the UpdateChunk invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateChunkDone() bool {
	if m.UpdateChunkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateChunkMock.invocationsDone()
}

// MinimockUpdateChunkInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateChunkInspect() {
	for _, e := range m.UpdateChunkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateChunkCounter := mm_atomic.LoadUint64(&m.afterUpdateChunkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateChunkMock.defaultExpectation != nil && afterUpdateChunkCounter < 1 {
		if m.UpdateChunkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s", m.UpdateChunkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s with params: %#v", m.UpdateChunkMock.defaultExpectation.expectationOrigins.origin, *m.UpdateChunkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateChunk != nil && afterUpdateChunkCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateChunk at\n%s", m.funcUpdateChunkOrigin)
	}

	if !m.UpdateChunkMock.invocationsDone() && afterUpdateChunkCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateChunk at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateChunkMock.expectedInvocations), m.UpdateChunkMock.expectedInvocationsOrigin, afterUpdateChunkCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateFile struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateFileExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateFileExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockUpdateFileExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateFile
type ArtifactPublicServiceClientMockUpdateFileExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockUpdateFileParams
	paramPtrs          *ArtifactPublicServiceClientMockUpdateFileParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockUpdateFileExpectationOrigins
	results            *ArtifactPublicServiceClientMockUpdateFileResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockUpdateFileParams contains parameters of the ArtifactPublicServiceClient.UpdateFile
type ArtifactPublicServiceClientMockUpdateFileParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateFileRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateFileParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateFile
type ArtifactPublicServiceClientMockUpdateFileParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateFileRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateFileResults contains results of the ArtifactPublicServiceClient.UpdateFile
type ArtifactPublicServiceClientMockUpdateFileResults struct {
	up1 *mm_artifactv1alpha.UpdateFileResponse
	err error
}

// ArtifactPublicServiceClientMockUpdateFileOrigins contains origins of expectations of the ArtifactPublicServiceClient.UpdateFile
type ArtifactPublicServiceClientMockUpdateFileExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) Optional() *mArtifactPublicServiceClientMockUpdateFile {
	mmUpdateFile.optional = true
	return mmUpdateFile
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateFileRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateFile {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceClientMockUpdateFileExpectation{}
	}

	if mmUpdateFile.defaultExpectation.paramPtrs != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by ExpectParams functions")
	}

	mmUpdateFile.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateFileParams{ctx, in, opts}
	mmUpdateFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateFile.expectations {
		if minimock.Equal(e.params, mmUpdateFile.defaultExpectation.params) {
			mmUpdateFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateFile.defaultExpectation.params)
		}
	}

	return mmUpdateFile
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateFile {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceClientMockUpdateFileExpectation{}
	}

	if mmUpdateFile.defaultExpectation.params != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Expect")
	}

	if mmUpdateFile.defaultExpectation.paramPtrs == nil {
		mmUpdateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateFileParamPtrs{}
	}
	mmUpdateFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateFile
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) ExpectInParam2(in *mm_artifactv1alpha.UpdateFileRequest) *mArtifactPublicServiceClientMockUpdateFile {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceClientMockUpdateFileExpectation{}
	}

	if mmUpdateFile.defaultExpectation.params != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Expect")
	}

	if mmUpdateFile.defaultExpectation.paramPtrs == nil {
		mmUpdateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateFileParamPtrs{}
	}
	mmUpdateFile.defaultExpectation.paramPtrs.in = &in
	mmUpdateFile.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmUpdateFile
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateFile {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceClientMockUpdateFileExpectation{}
	}

	if mmUpdateFile.defaultExpectation.params != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Expect")
	}

	if mmUpdateFile.defaultExpectation.paramPtrs == nil {
		mmUpdateFile.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateFileParamPtrs{}
	}
	mmUpdateFile.defaultExpectation.paramPtrs.opts = &opts
	mmUpdateFile.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmUpdateFile
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateFileRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateFile {
	if mmUpdateFile.mock.inspectFuncUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateFile")
	}

	mmUpdateFile.mock.inspectFuncUpdateFile = f

	return mmUpdateFile
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateFile
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) Return(up1 *mm_artifactv1alpha.UpdateFileResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Set")
	}

	if mmUpdateFile.defaultExpectation == nil {
		mmUpdateFile.defaultExpectation = &ArtifactPublicServiceClientMockUpdateFileExpectation{mock: mmUpdateFile.mock}
	}
	mmUpdateFile.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateFileResults{up1, err}
	mmUpdateFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateFile.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateFile method
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateFileResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateFile.defaultExpectation != nil {
		mmUpdateFile.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateFile method")
	}

	if len(mmUpdateFile.expectations) > 0 {
		mmUpdateFile.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateFile method")
	}

	mmUpdateFile.mock.funcUpdateFile = f
	mmUpdateFile.mock.funcUpdateFileOrigin = minimock.CallerInfo(1)
	return mmUpdateFile.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateFile which will trigger the result defined by the following
// Then helper
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) When(ctx context.Context, in *mm_artifactv1alpha.UpdateFileRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateFileExpectation {
	if mmUpdateFile.mock.funcUpdateFile != nil {
		mmUpdateFile.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateFile mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateFileExpectation{
		mock:               mmUpdateFile.mock,
		params:             &ArtifactPublicServiceClientMockUpdateFileParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockUpdateFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateFile.expectations = append(mmUpdateFile.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateFile return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateFileExpectation) Then(up1 *mm_artifactv1alpha.UpdateFileResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateFileResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateFile should be invoked
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) Times(n uint64) *mArtifactPublicServiceClientMockUpdateFile {
	if n == 0 {
		mmUpdateFile.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateFile.expectedInvocations, n)
	mmUpdateFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateFile
}

func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) invocationsDone() bool {
	if len(mmUpdateFile.expectations) == 0 && mmUpdateFile.defaultExpectation == nil && mmUpdateFile.mock.funcUpdateFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateFile.mock.afterUpdateFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateFile implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateFile *ArtifactPublicServiceClientMock) UpdateFile(ctx context.Context, in *mm_artifactv1alpha.UpdateFileRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateFileResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateFile.beforeUpdateFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateFile.afterUpdateFileCounter, 1)

	mmUpdateFile.t.Helper()

	if mmUpdateFile.inspectFuncUpdateFile != nil {
		mmUpdateFile.inspectFuncUpdateFile(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateFileParams{ctx, in, opts}

	// Record call args
	mmUpdateFile.UpdateFileMock.mutex.Lock()
	mmUpdateFile.UpdateFileMock.callArgs = append(mmUpdateFile.UpdateFileMock.callArgs, &mm_params)
	mmUpdateFile.UpdateFileMock.mutex.Unlock()

	for _, e := range mmUpdateFile.UpdateFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateFile.UpdateFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateFile.UpdateFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateFile.UpdateFileMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateFile.UpdateFileMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateFileParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateFile.t.Errorf("ArtifactPublicServiceClientMock.UpdateFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateFile.UpdateFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateFile.t.Errorf("ArtifactPublicServiceClientMock.UpdateFile got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateFile.UpdateFileMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateFile.t.Errorf("ArtifactPublicServiceClientMock.UpdateFile got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateFile.UpdateFileMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateFile.t.Errorf("ArtifactPublicServiceClientMock.UpdateFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateFile.UpdateFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateFile.UpdateFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateFile.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateFile")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateFile.funcUpdateFile != nil {
		return mmUpdateFile.funcUpdateFile(ctx, in, opts...)
	}
	mmUpdateFile.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateFile. %v %v %v", ctx, in, opts)
	return
}

// UpdateFileAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateFile invocations
func (mmUpdateFile *ArtifactPublicServiceClientMock) UpdateFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateFile.afterUpdateFileCounter)
}

// UpdateFileBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateFile invocations
func (mmUpdateFile *ArtifactPublicServiceClientMock) UpdateFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateFile.beforeUpdateFileCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateFile *mArtifactPublicServiceClientMockUpdateFile) Calls() []*ArtifactPublicServiceClientMockUpdateFileParams {
	mmUpdateFile.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateFileParams, len(mmUpdateFile.callArgs))
	copy(argCopy, mmUpdateFile.callArgs)

	mmUpdateFile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateFileDone returns true if the count of the UpdateFile invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateFileDone() bool {
	if m.UpdateFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateFileMock.invocationsDone()
}

// MinimockUpdateFileInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateFileInspect() {
	for _, e := range m.UpdateFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateFileCounter := mm_atomic.LoadUint64(&m.afterUpdateFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateFileMock.defaultExpectation != nil && afterUpdateFileCounter < 1 {
		if m.UpdateFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateFile at\n%s", m.UpdateFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateFile at\n%s with params: %#v", m.UpdateFileMock.defaultExpectation.expectationOrigins.origin, *m.UpdateFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateFile != nil && afterUpdateFileCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateFile at\n%s", m.funcUpdateFileOrigin)
	}

	if !m.UpdateFileMock.invocationsDone() && afterUpdateFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateFileMock.expectedInvocations), m.UpdateFileMock.expectedInvocationsOrigin, afterUpdateFileCounter)
	}
}

type mArtifactPublicServiceClientMockUpdateKnowledgeBase struct {
	optional           bool
	mock               *ArtifactPublicServiceClientMock
	defaultExpectation *ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation
	expectations       []*ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation

	callArgs []*ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation specifies expectation struct of the ArtifactPublicServiceClient.UpdateKnowledgeBase
type ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation struct {
	mock               *ArtifactPublicServiceClientMock
	params             *ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams
	paramPtrs          *ArtifactPublicServiceClientMockUpdateKnowledgeBaseParamPtrs
	expectationOrigins ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectationOrigins
	results            *ArtifactPublicServiceClientMockUpdateKnowledgeBaseResults
	returnOrigin       string
	Counter            uint64
}

// ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams contains parameters of the ArtifactPublicServiceClient.UpdateKnowledgeBase
type ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams struct {
	ctx  context.Context
	in   *mm_artifactv1alpha.UpdateKnowledgeBaseRequest
	opts []grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateKnowledgeBaseParamPtrs contains pointers to parameters of the ArtifactPublicServiceClient.UpdateKnowledgeBase
type ArtifactPublicServiceClientMockUpdateKnowledgeBaseParamPtrs struct {
	ctx  *context.Context
	in   **mm_artifactv1alpha.UpdateKnowledgeBaseRequest
	opts *[]grpc.CallOption
}

// ArtifactPublicServiceClientMockUpdateKnowledgeBaseResults contains results of the ArtifactPublicServiceClient.UpdateKnowledgeBase
type ArtifactPublicServiceClientMockUpdateKnowledgeBaseResults struct {
	up1 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse
	err error
}

// ArtifactPublicServiceClientMockUpdateKnowledgeBaseOrigins contains origins of expectations of the ArtifactPublicServiceClient.UpdateKnowledgeBase
type ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectationOrigins struct {
	origin     string
	originCtx  string
	originIn   string
	originOpts string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) Optional() *mArtifactPublicServiceClientMockUpdateKnowledgeBase {
	mmUpdateKnowledgeBase.optional = true
	return mmUpdateKnowledgeBase
}

// Expect sets up expected params for ArtifactPublicServiceClient.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) Expect(ctx context.Context, in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest, opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by ExpectParams functions")
	}

	mmUpdateKnowledgeBase.defaultExpectation.params = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams{ctx, in, opts}
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateKnowledgeBase.expectations {
		if minimock.Equal(e.params, mmUpdateKnowledgeBase.defaultExpectation.params) {
			mmUpdateKnowledgeBase.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateKnowledgeBase.defaultExpectation.params)
		}
	}

	return mmUpdateKnowledgeBase
}

// ExpectCtxParam1 sets up expected param ctx for ArtifactPublicServiceClient.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) ExpectCtxParam1(ctx context.Context) *mArtifactPublicServiceClientMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectInParam2 sets up expected param in for ArtifactPublicServiceClient.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) ExpectInParam2(in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest) *mArtifactPublicServiceClientMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.in = &in
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originIn = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// ExpectOptsParam3 sets up expected param opts for ArtifactPublicServiceClient.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) ExpectOptsParam3(opts ...grpc.CallOption) *mArtifactPublicServiceClientMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation{}
	}

	if mmUpdateKnowledgeBase.defaultExpectation.params != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Expect")
	}

	if mmUpdateKnowledgeBase.defaultExpectation.paramPtrs == nil {
		mmUpdateKnowledgeBase.defaultExpectation.paramPtrs = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseParamPtrs{}
	}
	mmUpdateKnowledgeBase.defaultExpectation.paramPtrs.opts = &opts
	mmUpdateKnowledgeBase.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmUpdateKnowledgeBase
}

// Inspect accepts an inspector function that has same arguments as the ArtifactPublicServiceClient.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) Inspect(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest, opts ...grpc.CallOption)) *mArtifactPublicServiceClientMockUpdateKnowledgeBase {
	if mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Inspect function is already set for ArtifactPublicServiceClientMock.UpdateKnowledgeBase")
	}

	mmUpdateKnowledgeBase.mock.inspectFuncUpdateKnowledgeBase = f

	return mmUpdateKnowledgeBase
}

// Return sets up results that will be returned by ArtifactPublicServiceClient.UpdateKnowledgeBase
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) Return(up1 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Set")
	}

	if mmUpdateKnowledgeBase.defaultExpectation == nil {
		mmUpdateKnowledgeBase.defaultExpectation = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation{mock: mmUpdateKnowledgeBase.mock}
	}
	mmUpdateKnowledgeBase.defaultExpectation.results = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseResults{up1, err}
	mmUpdateKnowledgeBase.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// Set uses given function f to mock the ArtifactPublicServiceClient.UpdateKnowledgeBase method
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) Set(f func(ctx context.Context, in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error)) *ArtifactPublicServiceClientMock {
	if mmUpdateKnowledgeBase.defaultExpectation != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Default expectation is already set for the ArtifactPublicServiceClient.UpdateKnowledgeBase method")
	}

	if len(mmUpdateKnowledgeBase.expectations) > 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Some expectations are already set for the ArtifactPublicServiceClient.UpdateKnowledgeBase method")
	}

	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase = f
	mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBaseOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase.mock
}

// When sets expectation for the ArtifactPublicServiceClient.UpdateKnowledgeBase which will trigger the result defined by the following
// Then helper
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) When(ctx context.Context, in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest, opts ...grpc.CallOption) *ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation {
	if mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.mock.t.Fatalf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock is already set by Set")
	}

	expectation := &ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation{
		mock:               mmUpdateKnowledgeBase.mock,
		params:             &ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams{ctx, in, opts},
		expectationOrigins: ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateKnowledgeBase.expectations = append(mmUpdateKnowledgeBase.expectations, expectation)
	return expectation
}

// Then sets up ArtifactPublicServiceClient.UpdateKnowledgeBase return parameters for the expectation previously defined by the When method
func (e *ArtifactPublicServiceClientMockUpdateKnowledgeBaseExpectation) Then(up1 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error) *ArtifactPublicServiceClientMock {
	e.results = &ArtifactPublicServiceClientMockUpdateKnowledgeBaseResults{up1, err}
	return e.mock
}

// Times sets number of times ArtifactPublicServiceClient.UpdateKnowledgeBase should be invoked
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) Times(n uint64) *mArtifactPublicServiceClientMockUpdateKnowledgeBase {
	if n == 0 {
		mmUpdateKnowledgeBase.mock.t.Fatalf("Times of ArtifactPublicServiceClientMock.UpdateKnowledgeBase mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateKnowledgeBase.expectedInvocations, n)
	mmUpdateKnowledgeBase.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateKnowledgeBase
}

func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) invocationsDone() bool {
	if len(mmUpdateKnowledgeBase.expectations) == 0 && mmUpdateKnowledgeBase.defaultExpectation == nil && mmUpdateKnowledgeBase.mock.funcUpdateKnowledgeBase == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.mock.afterUpdateKnowledgeBaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateKnowledgeBase implements mm_artifactv1alpha.ArtifactPublicServiceClient
func (mmUpdateKnowledgeBase *ArtifactPublicServiceClientMock) UpdateKnowledgeBase(ctx context.Context, in *mm_artifactv1alpha.UpdateKnowledgeBaseRequest, opts ...grpc.CallOption) (up1 *mm_artifactv1alpha.UpdateKnowledgeBaseResponse, err error) {
	mm_atomic.AddUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter, 1)

	mmUpdateKnowledgeBase.t.Helper()

	if mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase != nil {
		mmUpdateKnowledgeBase.inspectFuncUpdateKnowledgeBase(ctx, in, opts...)
	}

	mm_params := ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams{ctx, in, opts}

	// Record call args
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Lock()
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs = append(mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.callArgs, &mm_params)
	mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.mutex.Unlock()

	for _, e := range mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.paramPtrs

		mm_got := ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams{ctx, in, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmUpdateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase got unexpected parameter in, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originIn, *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmUpdateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateKnowledgeBase.t.Errorf("ArtifactPublicServiceClientMock.UpdateKnowledgeBase got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateKnowledgeBase.UpdateKnowledgeBaseMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateKnowledgeBase.t.Fatal("No results are set for the ArtifactPublicServiceClientMock.UpdateKnowledgeBase")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmUpdateKnowledgeBase.funcUpdateKnowledgeBase != nil {
		return mmUpdateKnowledgeBase.funcUpdateKnowledgeBase(ctx, in, opts...)
	}
	mmUpdateKnowledgeBase.t.Fatalf("Unexpected call to ArtifactPublicServiceClientMock.UpdateKnowledgeBase. %v %v %v", ctx, in, opts)
	return
}

// UpdateKnowledgeBaseAfterCounter returns a count of finished ArtifactPublicServiceClientMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *ArtifactPublicServiceClientMock) UpdateKnowledgeBaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.afterUpdateKnowledgeBaseCounter)
}

// UpdateKnowledgeBaseBeforeCounter returns a count of ArtifactPublicServiceClientMock.UpdateKnowledgeBase invocations
func (mmUpdateKnowledgeBase *ArtifactPublicServiceClientMock) UpdateKnowledgeBaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateKnowledgeBase.beforeUpdateKnowledgeBaseCounter)
}

// Calls returns a list of arguments used in each call to ArtifactPublicServiceClientMock.UpdateKnowledgeBase.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateKnowledgeBase *mArtifactPublicServiceClientMockUpdateKnowledgeBase) Calls() []*ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams {
	mmUpdateKnowledgeBase.mutex.RLock()

	argCopy := make([]*ArtifactPublicServiceClientMockUpdateKnowledgeBaseParams, len(mmUpdateKnowledgeBase.callArgs))
	copy(argCopy, mmUpdateKnowledgeBase.callArgs)

	mmUpdateKnowledgeBase.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateKnowledgeBaseDone returns true if the count of the UpdateKnowledgeBase invocations corresponds
// the number of defined expectations
func (m *ArtifactPublicServiceClientMock) MinimockUpdateKnowledgeBaseDone() bool {
	if m.UpdateKnowledgeBaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateKnowledgeBaseMock.invocationsDone()
}

// MinimockUpdateKnowledgeBaseInspect logs each unmet expectation
func (m *ArtifactPublicServiceClientMock) MinimockUpdateKnowledgeBaseInspect() {
	for _, e := range m.UpdateKnowledgeBaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateKnowledgeBase at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateKnowledgeBaseCounter := mm_atomic.LoadUint64(&m.afterUpdateKnowledgeBaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateKnowledgeBaseMock.defaultExpectation != nil && afterUpdateKnowledgeBaseCounter < 1 {
		if m.UpdateKnowledgeBaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateKnowledgeBase at\n%s", m.UpdateKnowledgeBaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateKnowledgeBase at\n%s with params: %#v", m.UpdateKnowledgeBaseMock.defaultExpectation.expectationOrigins.origin, *m.UpdateKnowledgeBaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateKnowledgeBase != nil && afterUpdateKnowledgeBaseCounter < 1 {
		m.t.Errorf("Expected call to ArtifactPublicServiceClientMock.UpdateKnowledgeBase at\n%s", m.funcUpdateKnowledgeBaseOrigin)
	}

	if !m.UpdateKnowledgeBaseMock.invocationsDone() && afterUpdateKnowledgeBaseCounter > 0 {
		m.t.Errorf("Expected %d calls to ArtifactPublicServiceClientMock.UpdateKnowledgeBase at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateKnowledgeBaseMock.expectedInvocations), m.UpdateKnowledgeBaseMock.expectedInvocationsOrigin, afterUpdateKnowledgeBaseCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ArtifactPublicServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateFileInspect()

			m.MinimockCreateKnowledgeBaseInspect()

			m.MinimockDeleteFileInspect()

			m.MinimockDeleteKnowledgeBaseInspect()

			m.MinimockGetChunkInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetKnowledgeBaseInspect()

			m.MinimockGetObjectDownloadURLInspect()

			m.MinimockGetObjectUploadURLInspect()

			m.MinimockListChunksInspect()

			m.MinimockListFilesInspect()

			m.MinimockListKnowledgeBaseRunsInspect()

			m.MinimockListKnowledgeBasesInspect()

			m.MinimockLivenessInspect()

			m.MinimockReadinessInspect()

			m.MinimockReprocessFileInspect()

			m.MinimockSearchChunksInspect()

			m.MinimockUpdateChunkInspect()

			m.MinimockUpdateFileInspect()

			m.MinimockUpdateKnowledgeBaseInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ArtifactPublicServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ArtifactPublicServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateFileDone() &&
		m.MinimockCreateKnowledgeBaseDone() &&
		m.MinimockDeleteFileDone() &&
		m.MinimockDeleteKnowledgeBaseDone() &&
		m.MinimockGetChunkDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetKnowledgeBaseDone() &&
		m.MinimockGetObjectDownloadURLDone() &&
		m.MinimockGetObjectUploadURLDone() &&
		m.MinimockListChunksDone() &&
		m.MinimockListFilesDone() &&
		m.MinimockListKnowledgeBaseRunsDone() &&
		m.MinimockListKnowledgeBasesDone() &&
		m.MinimockLivenessDone() &&
		m.MinimockReadinessDone() &&
		m.MinimockReprocessFileDone() &&
		m.MinimockSearchChunksDone() &&
		m.MinimockUpdateChunkDone() &&
		m.MinimockUpdateFileDone() &&
		m.MinimockUpdateKnowledgeBaseDone()
}
