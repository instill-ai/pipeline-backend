package handler

import (
	"context"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/iancoleman/strcase"
	"go.einride.tech/aip/filtering"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

	fieldmask_utils "github.com/mennanov/fieldmask-utils"

	"github.com/instill-ai/x/checkfield"

	errorsx "github.com/instill-ai/x/errors"
	pipelinepb "github.com/instill-ai/protogen-go/pipeline/v1beta"
)

// parseNamespaceFromParent extracts namespace ID from parent string.
// Format: namespaces/{namespace}
func parseNamespaceFromParent(parent string) (string, error) {
	parts := strings.Split(parent, "/")
	if len(parts) < 2 || parts[0] != "namespaces" {
		return "", fmt.Errorf("invalid parent format: %s", parent)
	}
	return parts[1], nil
}

// parseSecretFromName extracts namespace ID and secret ID from name string.
// Format: namespaces/{namespace}/secrets/{secret}
func parseSecretFromName(name string) (namespaceID, secretID string, err error) {
	parts := strings.Split(name, "/")
	if len(parts) < 4 || parts[0] != "namespaces" || parts[2] != "secrets" {
		return "", "", fmt.Errorf("invalid secret name format: %s", name)
	}
	return parts[1], parts[3], nil
}

// CreateNamespaceSecret creates a namespace secret.
func (h *PublicHandler) CreateNamespaceSecret(ctx context.Context, req *pipelinepb.CreateNamespaceSecretRequest) (resp *pipelinepb.CreateNamespaceSecretResponse, err error) {

	// Return error if REQUIRED fields are not provided in the requested payload secret resource
	if err := checkfield.CheckRequiredFields(req.GetSecret(), append(createSecretRequiredFields, immutableSecretFields...)); err != nil {
		return nil, errorsx.ErrCheckRequiredFields
	}

	// Set all OUTPUT_ONLY fields to zero value on the requested payload secret resource
	if err := checkfield.CheckCreateOutputOnlyFields(req.GetSecret(), outputOnlySecretFields); err != nil {
		return nil, errorsx.ErrCheckOutputOnlyFields
	}

	// Note: Per AIP standard, id is OUTPUT_ONLY and auto-generated by the server.
	// The server generates the id (e.g., "sec-8f3A2k9E7c1") in the BeforeCreate hook.

	// Parse namespace ID from parent: namespaces/{namespace}
	namespaceID, err := parseNamespaceFromParent(req.GetParent())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetNamespaceByID(ctx, namespaceID)
	if err != nil {
		return nil, err
	}

	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}

	secretToCreate := req.GetSecret()
	secret, err := h.service.CreateNamespaceSecret(ctx, ns, secretToCreate)

	if err != nil {
		return nil, err
	}

	// Manually set the custom header to have a StatusCreated http response for REST endpoint
	if err := grpc.SetHeader(ctx, metadata.Pairs("x-http-code", strconv.Itoa(http.StatusCreated))); err != nil {
		return nil, err
	}

	return &pipelinepb.CreateNamespaceSecretResponse{Secret: secret}, nil
}

// ListNamespaceSecrets lists namespace secrets.
func (h *PublicHandler) ListNamespaceSecrets(ctx context.Context, req *pipelinepb.ListNamespaceSecretsRequest) (resp *pipelinepb.ListNamespaceSecretsResponse, err error) {

	// Parse namespace ID from parent: namespaces/{namespace}
	namespaceID, err := parseNamespaceFromParent(req.GetParent())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetNamespaceByID(ctx, namespaceID)
	if err != nil {
		return nil, err
	}

	if err := authenticateUser(ctx, true); err != nil {
		return nil, err
	}

	pbSecrets, totalSize, nextPageToken, err := h.service.ListNamespaceSecrets(ctx, ns, req.GetPageSize(), req.GetPageToken(), filtering.Filter{})
	if err != nil {
		return nil, err
	}

	return &pipelinepb.ListNamespaceSecretsResponse{
		Secrets:       pbSecrets,
		NextPageToken: nextPageToken,
		TotalSize:     totalSize,
	}, nil
}

// GetNamespaceSecret gets a namespace secret.
func (h *PublicHandler) GetNamespaceSecret(ctx context.Context, req *pipelinepb.GetNamespaceSecretRequest) (*pipelinepb.GetNamespaceSecretResponse, error) {

	// Parse namespace ID and secret ID from name: namespaces/{namespace}/secrets/{secret}
	namespaceID, secretID, err := parseSecretFromName(req.GetName())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetNamespaceByID(ctx, namespaceID)
	if err != nil {
		return nil, err
	}
	if err := authenticateUser(ctx, true); err != nil {
		return nil, err
	}

	pbSecret, err := h.service.GetNamespaceSecretByID(ctx, ns, secretID)

	if err != nil {
		return nil, err
	}

	return &pipelinepb.GetNamespaceSecretResponse{Secret: pbSecret}, nil
}

// UpdateNamespaceSecret updates a namespace secret.
func (h *PublicHandler) UpdateNamespaceSecret(ctx context.Context, req *pipelinepb.UpdateNamespaceSecretRequest) (*pipelinepb.UpdateNamespaceSecretResponse, error) {

	// Parse namespace ID and secret ID from secret.name: namespaces/{namespace}/secrets/{secret}
	namespaceID, secretID, err := parseSecretFromName(req.GetSecret().GetName())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetNamespaceByID(ctx, namespaceID)
	if err != nil {
		return nil, err
	}
	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}

	pbSecretReq := req.GetSecret()
	if pbSecretReq.Id == "" {
		pbSecretReq.Id = secretID
	}
	pbUpdateMask := req.GetUpdateMask()

	// metadata field is type google.protobuf.Struct, which needs to be updated as a whole
	for idx, path := range pbUpdateMask.Paths {
		if strings.Contains(path, "metadata") {
			pbUpdateMask.Paths[idx] = "metadata"
		}
		if strings.Contains(path, "recipe") {
			pbUpdateMask.Paths[idx] = "recipe"
		}
	}
	// Validate the field mask
	if !pbUpdateMask.IsValid(pbSecretReq) {
		return nil, errorsx.ErrUpdateMask
	}

	getResp, err := h.GetNamespaceSecret(ctx, &pipelinepb.GetNamespaceSecretRequest{Name: req.GetSecret().GetName()})
	if err != nil {
		return nil, err
	}

	pbUpdateMask, err = checkfield.CheckUpdateOutputOnlyFields(pbUpdateMask, outputOnlySecretFields)
	if err != nil {
		return nil, errorsx.ErrCheckOutputOnlyFields
	}

	mask, err := fieldmask_utils.MaskFromProtoFieldMask(pbUpdateMask, strcase.ToCamel)
	if err != nil {
		return nil, errorsx.ErrFieldMask
	}

	if mask.IsEmpty() {
		return &pipelinepb.UpdateNamespaceSecretResponse{Secret: getResp.GetSecret()}, nil
	}

	pbSecretToUpdate := getResp.GetSecret()

	// Return error if IMMUTABLE fields are intentionally changed
	if err := checkfield.CheckUpdateImmutableFields(pbSecretReq, pbSecretToUpdate, immutableSecretFields); err != nil {
		return nil, errorsx.ErrCheckUpdateImmutableFields
	}

	// Only the fields mentioned in the field mask will be copied to `pbSecretToUpdate`, other fields are left intact
	err = fieldmask_utils.StructToStruct(mask, pbSecretReq, pbSecretToUpdate)
	if err != nil {
		return nil, err
	}

	pbSecret, err := h.service.UpdateNamespaceSecretByID(ctx, ns, secretID, pbSecretToUpdate)
	if err != nil {
		return nil, err
	}

	return &pipelinepb.UpdateNamespaceSecretResponse{Secret: pbSecret}, nil
}

// DeleteNamespaceSecret deletes a namespace secret.
func (h *PublicHandler) DeleteNamespaceSecret(ctx context.Context, req *pipelinepb.DeleteNamespaceSecretRequest) (*pipelinepb.DeleteNamespaceSecretResponse, error) {

	// Parse namespace ID and secret ID from name: namespaces/{namespace}/secrets/{secret}
	namespaceID, secretID, err := parseSecretFromName(req.GetName())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetNamespaceByID(ctx, namespaceID)
	if err != nil {
		return nil, err
	}
	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}
	_, err = h.GetNamespaceSecret(ctx, &pipelinepb.GetNamespaceSecretRequest{Name: req.GetName()})
	if err != nil {
		return nil, err
	}

	if err := h.service.DeleteNamespaceSecretByID(ctx, ns, secretID); err != nil {
		return nil, err
	}

	// We need to manually set the custom header to have a StatusCreated http response for REST endpoint
	if err := grpc.SetHeader(ctx, metadata.Pairs("x-http-code", strconv.Itoa(http.StatusNoContent))); err != nil {
		return nil, err
	}

	return &pipelinepb.DeleteNamespaceSecretResponse{}, nil
}
