// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/pipeline-backend/pkg/datamodel"
	"github.com/instill-ai/x/openfga"
	openfgax "github.com/instill-ai/x/openfga"
	openfgaclient "github.com/openfga/go-sdk/client"
)

// ACLClientMock implements mm_acl.ACLClient
type ACLClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckPermission          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) (b1 bool, err error)
	funcCheckPermissionOrigin    string
	inspectFuncCheckPermission   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string)
	afterCheckPermissionCounter  uint64
	beforeCheckPermissionCounter uint64
	CheckPermissionMock          mACLClientMockCheckPermission

	funcCheckPermissionByUser          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) (b1 bool, err error)
	funcCheckPermissionByUserOrigin    string
	inspectFuncCheckPermissionByUser   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string)
	afterCheckPermissionByUserCounter  uint64
	beforeCheckPermissionByUserCounter uint64
	CheckPermissionByUserMock          mACLClientMockCheckPermissionByUser

	funcCheckPublicExecutable          func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) (b1 bool, err error)
	funcCheckPublicExecutableOrigin    string
	inspectFuncCheckPublicExecutable   func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID)
	afterCheckPublicExecutableCounter  uint64
	beforeCheckPublicExecutableCounter uint64
	CheckPublicExecutableMock          mACLClientMockCheckPublicExecutable

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mACLClientMockClose

	funcDeletePipelinePermission          func(ctx context.Context, pipelineUID uuid.UUID, user string) (err error)
	funcDeletePipelinePermissionOrigin    string
	inspectFuncDeletePipelinePermission   func(ctx context.Context, pipelineUID uuid.UUID, user string)
	afterDeletePipelinePermissionCounter  uint64
	beforeDeletePipelinePermissionCounter uint64
	DeletePipelinePermissionMock          mACLClientMockDeletePipelinePermission

	funcGetAuthorizationModelID          func() (s1 string)
	funcGetAuthorizationModelIDOrigin    string
	inspectFuncGetAuthorizationModelID   func()
	afterGetAuthorizationModelIDCounter  uint64
	beforeGetAuthorizationModelIDCounter uint64
	GetAuthorizationModelIDMock          mACLClientMockGetAuthorizationModelID

	funcGetStoreID          func() (s1 string)
	funcGetStoreIDOrigin    string
	inspectFuncGetStoreID   func()
	afterGetStoreIDCounter  uint64
	beforeGetStoreIDCounter uint64
	GetStoreIDMock          mACLClientMockGetStoreID

	funcListPermissions          func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) (ua1 []uuid.UUID, err error)
	funcListPermissionsOrigin    string
	inspectFuncListPermissions   func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool)
	afterListPermissionsCounter  uint64
	beforeListPermissionsCounter uint64
	ListPermissionsMock          mACLClientMockListPermissions

	funcPurge          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) (err error)
	funcPurgeOrigin    string
	inspectFuncPurge   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID)
	afterPurgeCounter  uint64
	beforePurgeCounter uint64
	PurgeMock          mACLClientMockPurge

	funcSDKClient          func() (op1 *openfgaclient.OpenFgaClient)
	funcSDKClientOrigin    string
	inspectFuncSDKClient   func()
	afterSDKClientCounter  uint64
	beforeSDKClientCounter uint64
	SDKClientMock          mACLClientMockSDKClient

	funcSetAuthorizationModelID          func(modelID string) (err error)
	funcSetAuthorizationModelIDOrigin    string
	inspectFuncSetAuthorizationModelID   func(modelID string)
	afterSetAuthorizationModelIDCounter  uint64
	beforeSetAuthorizationModelIDCounter uint64
	SetAuthorizationModelIDMock          mACLClientMockSetAuthorizationModelID

	funcSetOwner          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) (err error)
	funcSetOwnerOrigin    string
	inspectFuncSetOwner   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID)
	afterSetOwnerCounter  uint64
	beforeSetOwnerCounter uint64
	SetOwnerMock          mACLClientMockSetOwner

	funcSetPipelinePermission          func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error)
	funcSetPipelinePermissionOrigin    string
	inspectFuncSetPipelinePermission   func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool)
	afterSetPipelinePermissionCounter  uint64
	beforeSetPipelinePermissionCounter uint64
	SetPipelinePermissionMock          mACLClientMockSetPipelinePermission

	funcSetPipelinePermissionMap          func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)
	funcSetPipelinePermissionMapOrigin    string
	inspectFuncSetPipelinePermissionMap   func(ctx context.Context, pipeline *datamodel.Pipeline)
	afterSetPipelinePermissionMapCounter  uint64
	beforeSetPipelinePermissionMapCounter uint64
	SetPipelinePermissionMapMock          mACLClientMockSetPipelinePermissionMap

	funcSetStoreID          func(storeID string) (err error)
	funcSetStoreIDOrigin    string
	inspectFuncSetStoreID   func(storeID string)
	afterSetStoreIDCounter  uint64
	beforeSetStoreIDCounter uint64
	SetStoreIDMock          mACLClientMockSetStoreID
}

// NewACLClientMock returns a mock for mm_acl.ACLClient
func NewACLClientMock(t minimock.Tester) *ACLClientMock {
	m := &ACLClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckPermissionMock = mACLClientMockCheckPermission{mock: m}
	m.CheckPermissionMock.callArgs = []*ACLClientMockCheckPermissionParams{}

	m.CheckPermissionByUserMock = mACLClientMockCheckPermissionByUser{mock: m}
	m.CheckPermissionByUserMock.callArgs = []*ACLClientMockCheckPermissionByUserParams{}

	m.CheckPublicExecutableMock = mACLClientMockCheckPublicExecutable{mock: m}
	m.CheckPublicExecutableMock.callArgs = []*ACLClientMockCheckPublicExecutableParams{}

	m.CloseMock = mACLClientMockClose{mock: m}

	m.DeletePipelinePermissionMock = mACLClientMockDeletePipelinePermission{mock: m}
	m.DeletePipelinePermissionMock.callArgs = []*ACLClientMockDeletePipelinePermissionParams{}

	m.GetAuthorizationModelIDMock = mACLClientMockGetAuthorizationModelID{mock: m}

	m.GetStoreIDMock = mACLClientMockGetStoreID{mock: m}

	m.ListPermissionsMock = mACLClientMockListPermissions{mock: m}
	m.ListPermissionsMock.callArgs = []*ACLClientMockListPermissionsParams{}

	m.PurgeMock = mACLClientMockPurge{mock: m}
	m.PurgeMock.callArgs = []*ACLClientMockPurgeParams{}

	m.SDKClientMock = mACLClientMockSDKClient{mock: m}

	m.SetAuthorizationModelIDMock = mACLClientMockSetAuthorizationModelID{mock: m}
	m.SetAuthorizationModelIDMock.callArgs = []*ACLClientMockSetAuthorizationModelIDParams{}

	m.SetOwnerMock = mACLClientMockSetOwner{mock: m}
	m.SetOwnerMock.callArgs = []*ACLClientMockSetOwnerParams{}

	m.SetPipelinePermissionMock = mACLClientMockSetPipelinePermission{mock: m}
	m.SetPipelinePermissionMock.callArgs = []*ACLClientMockSetPipelinePermissionParams{}

	m.SetPipelinePermissionMapMock = mACLClientMockSetPipelinePermissionMap{mock: m}
	m.SetPipelinePermissionMapMock.callArgs = []*ACLClientMockSetPipelinePermissionMapParams{}

	m.SetStoreIDMock = mACLClientMockSetStoreID{mock: m}
	m.SetStoreIDMock.callArgs = []*ACLClientMockSetStoreIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mACLClientMockCheckPermission struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockCheckPermissionExpectation
	expectations       []*ACLClientMockCheckPermissionExpectation

	callArgs []*ACLClientMockCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockCheckPermissionExpectation specifies expectation struct of the ACLClient.CheckPermission
type ACLClientMockCheckPermissionExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockCheckPermissionParams
	paramPtrs          *ACLClientMockCheckPermissionParamPtrs
	expectationOrigins ACLClientMockCheckPermissionExpectationOrigins
	results            *ACLClientMockCheckPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockCheckPermissionParams contains parameters of the ACLClient.CheckPermission
type ACLClientMockCheckPermissionParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
	role       string
}

// ACLClientMockCheckPermissionParamPtrs contains pointers to parameters of the ACLClient.CheckPermission
type ACLClientMockCheckPermissionParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
	role       *string
}

// ACLClientMockCheckPermissionResults contains results of the ACLClient.CheckPermission
type ACLClientMockCheckPermissionResults struct {
	b1  bool
	err error
}

// ACLClientMockCheckPermissionOrigins contains origins of expectations of the ACLClient.CheckPermission
type ACLClientMockCheckPermissionExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originRole       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPermission *mACLClientMockCheckPermission) Optional() *mACLClientMockCheckPermission {
	mmCheckPermission.optional = true
	return mmCheckPermission
}

// Expect sets up expected params for ACLClient.CheckPermission
func (mmCheckPermission *mACLClientMockCheckPermission) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) *mACLClientMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.paramPtrs != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by ExpectParams functions")
	}

	mmCheckPermission.defaultExpectation.params = &ACLClientMockCheckPermissionParams{ctx, objectType, objectUID, role}
	mmCheckPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPermission.expectations {
		if minimock.Equal(e.params, mmCheckPermission.defaultExpectation.params) {
			mmCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPermission.defaultExpectation.params)
		}
	}

	return mmCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.CheckPermission
func (mmCheckPermission *mACLClientMockCheckPermission) ExpectCtxParam1(ctx context.Context) *mACLClientMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClient.CheckPermission
func (mmCheckPermission *mACLClientMockCheckPermission) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClient.CheckPermission
func (mmCheckPermission *mACLClientMockCheckPermission) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClient.CheckPermission
func (mmCheckPermission *mACLClientMockCheckPermission) ExpectRoleParam4(role string) *mACLClientMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.role = &role
	mmCheckPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.CheckPermission
func (mmCheckPermission *mACLClientMockCheckPermission) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string)) *mACLClientMockCheckPermission {
	if mmCheckPermission.mock.inspectFuncCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("Inspect function is already set for ACLClientMock.CheckPermission")
	}

	mmCheckPermission.mock.inspectFuncCheckPermission = f

	return mmCheckPermission
}

// Return sets up results that will be returned by ACLClient.CheckPermission
func (mmCheckPermission *mACLClientMockCheckPermission) Return(b1 bool, err error) *ACLClientMock {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientMockCheckPermissionExpectation{mock: mmCheckPermission.mock}
	}
	mmCheckPermission.defaultExpectation.results = &ACLClientMockCheckPermissionResults{b1, err}
	mmCheckPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// Set uses given function f to mock the ACLClient.CheckPermission method
func (mmCheckPermission *mACLClientMockCheckPermission) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) (b1 bool, err error)) *ACLClientMock {
	if mmCheckPermission.defaultExpectation != nil {
		mmCheckPermission.mock.t.Fatalf("Default expectation is already set for the ACLClient.CheckPermission method")
	}

	if len(mmCheckPermission.expectations) > 0 {
		mmCheckPermission.mock.t.Fatalf("Some expectations are already set for the ACLClient.CheckPermission method")
	}

	mmCheckPermission.mock.funcCheckPermission = f
	mmCheckPermission.mock.funcCheckPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// When sets expectation for the ACLClient.CheckPermission which will trigger the result defined by the following
// Then helper
func (mmCheckPermission *mACLClientMockCheckPermission) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) *ACLClientMockCheckPermissionExpectation {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientMock.CheckPermission mock is already set by Set")
	}

	expectation := &ACLClientMockCheckPermissionExpectation{
		mock:               mmCheckPermission.mock,
		params:             &ACLClientMockCheckPermissionParams{ctx, objectType, objectUID, role},
		expectationOrigins: ACLClientMockCheckPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPermission.expectations = append(mmCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.CheckPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientMockCheckPermissionExpectation) Then(b1 bool, err error) *ACLClientMock {
	e.results = &ACLClientMockCheckPermissionResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClient.CheckPermission should be invoked
func (mmCheckPermission *mACLClientMockCheckPermission) Times(n uint64) *mACLClientMockCheckPermission {
	if n == 0 {
		mmCheckPermission.mock.t.Fatalf("Times of ACLClientMock.CheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPermission.expectedInvocations, n)
	mmCheckPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPermission
}

func (mmCheckPermission *mACLClientMockCheckPermission) invocationsDone() bool {
	if len(mmCheckPermission.expectations) == 0 && mmCheckPermission.defaultExpectation == nil && mmCheckPermission.mock.funcCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPermission.mock.afterCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPermission implements mm_acl.ACLClient
func (mmCheckPermission *ACLClientMock) CheckPermission(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPermission.beforeCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPermission.afterCheckPermissionCounter, 1)

	mmCheckPermission.t.Helper()

	if mmCheckPermission.inspectFuncCheckPermission != nil {
		mmCheckPermission.inspectFuncCheckPermission(ctx, objectType, objectUID, role)
	}

	mm_params := ACLClientMockCheckPermissionParams{ctx, objectType, objectUID, role}

	// Record call args
	mmCheckPermission.CheckPermissionMock.mutex.Lock()
	mmCheckPermission.CheckPermissionMock.callArgs = append(mmCheckPermission.CheckPermissionMock.callArgs, &mm_params)
	mmCheckPermission.CheckPermissionMock.mutex.Unlock()

	for _, e := range mmCheckPermission.CheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPermission.CheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPermission.CheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPermission.CheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPermission.CheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockCheckPermissionParams{ctx, objectType, objectUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPermission.t.Errorf("ACLClientMock.CheckPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPermission.t.Errorf("ACLClientMock.CheckPermission got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPermission.t.Errorf("ACLClientMock.CheckPermission got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckPermission.t.Errorf("ACLClientMock.CheckPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPermission.t.Errorf("ACLClientMock.CheckPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPermission.CheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPermission.t.Fatal("No results are set for the ACLClientMock.CheckPermission")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPermission.funcCheckPermission != nil {
		return mmCheckPermission.funcCheckPermission(ctx, objectType, objectUID, role)
	}
	mmCheckPermission.t.Fatalf("Unexpected call to ACLClientMock.CheckPermission. %v %v %v %v", ctx, objectType, objectUID, role)
	return
}

// CheckPermissionAfterCounter returns a count of finished ACLClientMock.CheckPermission invocations
func (mmCheckPermission *ACLClientMock) CheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.afterCheckPermissionCounter)
}

// CheckPermissionBeforeCounter returns a count of ACLClientMock.CheckPermission invocations
func (mmCheckPermission *ACLClientMock) CheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.beforeCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.CheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPermission *mACLClientMockCheckPermission) Calls() []*ACLClientMockCheckPermissionParams {
	mmCheckPermission.mutex.RLock()

	argCopy := make([]*ACLClientMockCheckPermissionParams, len(mmCheckPermission.callArgs))
	copy(argCopy, mmCheckPermission.callArgs)

	mmCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPermissionDone returns true if the count of the CheckPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockCheckPermissionDone() bool {
	if m.CheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPermissionMock.invocationsDone()
}

// MinimockCheckPermissionInspect logs each unmet expectation
func (m *ACLClientMock) MinimockCheckPermissionInspect() {
	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.CheckPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPermissionMock.defaultExpectation != nil && afterCheckPermissionCounter < 1 {
		if m.CheckPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.CheckPermission at\n%s", m.CheckPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.CheckPermission at\n%s with params: %#v", m.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPermission != nil && afterCheckPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.CheckPermission at\n%s", m.funcCheckPermissionOrigin)
	}

	if !m.CheckPermissionMock.invocationsDone() && afterCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.CheckPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPermissionMock.expectedInvocations), m.CheckPermissionMock.expectedInvocationsOrigin, afterCheckPermissionCounter)
	}
}

type mACLClientMockCheckPermissionByUser struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockCheckPermissionByUserExpectation
	expectations       []*ACLClientMockCheckPermissionByUserExpectation

	callArgs []*ACLClientMockCheckPermissionByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockCheckPermissionByUserExpectation specifies expectation struct of the ACLClient.CheckPermissionByUser
type ACLClientMockCheckPermissionByUserExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockCheckPermissionByUserParams
	paramPtrs          *ACLClientMockCheckPermissionByUserParamPtrs
	expectationOrigins ACLClientMockCheckPermissionByUserExpectationOrigins
	results            *ACLClientMockCheckPermissionByUserResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockCheckPermissionByUserParams contains parameters of the ACLClient.CheckPermissionByUser
type ACLClientMockCheckPermissionByUserParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
	userType   openfga.UserType
	userUID    string
	role       string
}

// ACLClientMockCheckPermissionByUserParamPtrs contains pointers to parameters of the ACLClient.CheckPermissionByUser
type ACLClientMockCheckPermissionByUserParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
	userType   *openfga.UserType
	userUID    *string
	role       *string
}

// ACLClientMockCheckPermissionByUserResults contains results of the ACLClient.CheckPermissionByUser
type ACLClientMockCheckPermissionByUserResults struct {
	b1  bool
	err error
}

// ACLClientMockCheckPermissionByUserOrigins contains origins of expectations of the ACLClient.CheckPermissionByUser
type ACLClientMockCheckPermissionByUserExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originUserType   string
	originUserUID    string
	originRole       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) Optional() *mACLClientMockCheckPermissionByUser {
	mmCheckPermissionByUser.optional = true
	return mmCheckPermissionByUser
}

// Expect sets up expected params for ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by ExpectParams functions")
	}

	mmCheckPermissionByUser.defaultExpectation.params = &ACLClientMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role}
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPermissionByUser.expectations {
		if minimock.Equal(e.params, mmCheckPermissionByUser.defaultExpectation.params) {
			mmCheckPermissionByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPermissionByUser.defaultExpectation.params)
		}
	}

	return mmCheckPermissionByUser
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) ExpectCtxParam1(ctx context.Context) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectUserTypeParam4 sets up expected param userType for ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) ExpectUserTypeParam4(userType openfga.UserType) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.userType = &userType
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originUserType = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectUserUIDParam5 sets up expected param userUID for ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) ExpectUserUIDParam5(userUID string) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.userUID = &userUID
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectRoleParam6 sets up expected param role for ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) ExpectRoleParam6(role string) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.role = &role
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string)) *mACLClientMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.inspectFuncCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("Inspect function is already set for ACLClientMock.CheckPermissionByUser")
	}

	mmCheckPermissionByUser.mock.inspectFuncCheckPermissionByUser = f

	return mmCheckPermissionByUser
}

// Return sets up results that will be returned by ACLClient.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) Return(b1 bool, err error) *ACLClientMock {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientMockCheckPermissionByUserExpectation{mock: mmCheckPermissionByUser.mock}
	}
	mmCheckPermissionByUser.defaultExpectation.results = &ACLClientMockCheckPermissionByUserResults{b1, err}
	mmCheckPermissionByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPermissionByUser.mock
}

// Set uses given function f to mock the ACLClient.CheckPermissionByUser method
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) (b1 bool, err error)) *ACLClientMock {
	if mmCheckPermissionByUser.defaultExpectation != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("Default expectation is already set for the ACLClient.CheckPermissionByUser method")
	}

	if len(mmCheckPermissionByUser.expectations) > 0 {
		mmCheckPermissionByUser.mock.t.Fatalf("Some expectations are already set for the ACLClient.CheckPermissionByUser method")
	}

	mmCheckPermissionByUser.mock.funcCheckPermissionByUser = f
	mmCheckPermissionByUser.mock.funcCheckPermissionByUserOrigin = minimock.CallerInfo(1)
	return mmCheckPermissionByUser.mock
}

// When sets expectation for the ACLClient.CheckPermissionByUser which will trigger the result defined by the following
// Then helper
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) *ACLClientMockCheckPermissionByUserExpectation {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientMock.CheckPermissionByUser mock is already set by Set")
	}

	expectation := &ACLClientMockCheckPermissionByUserExpectation{
		mock:               mmCheckPermissionByUser.mock,
		params:             &ACLClientMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role},
		expectationOrigins: ACLClientMockCheckPermissionByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPermissionByUser.expectations = append(mmCheckPermissionByUser.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.CheckPermissionByUser return parameters for the expectation previously defined by the When method
func (e *ACLClientMockCheckPermissionByUserExpectation) Then(b1 bool, err error) *ACLClientMock {
	e.results = &ACLClientMockCheckPermissionByUserResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClient.CheckPermissionByUser should be invoked
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) Times(n uint64) *mACLClientMockCheckPermissionByUser {
	if n == 0 {
		mmCheckPermissionByUser.mock.t.Fatalf("Times of ACLClientMock.CheckPermissionByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPermissionByUser.expectedInvocations, n)
	mmCheckPermissionByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPermissionByUser
}

func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) invocationsDone() bool {
	if len(mmCheckPermissionByUser.expectations) == 0 && mmCheckPermissionByUser.defaultExpectation == nil && mmCheckPermissionByUser.mock.funcCheckPermissionByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPermissionByUser.mock.afterCheckPermissionByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPermissionByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPermissionByUser implements mm_acl.ACLClient
func (mmCheckPermissionByUser *ACLClientMock) CheckPermissionByUser(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPermissionByUser.beforeCheckPermissionByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPermissionByUser.afterCheckPermissionByUserCounter, 1)

	mmCheckPermissionByUser.t.Helper()

	if mmCheckPermissionByUser.inspectFuncCheckPermissionByUser != nil {
		mmCheckPermissionByUser.inspectFuncCheckPermissionByUser(ctx, objectType, objectUID, userType, userUID, role)
	}

	mm_params := ACLClientMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role}

	// Record call args
	mmCheckPermissionByUser.CheckPermissionByUserMock.mutex.Lock()
	mmCheckPermissionByUser.CheckPermissionByUserMock.callArgs = append(mmCheckPermissionByUser.CheckPermissionByUserMock.callArgs, &mm_params)
	mmCheckPermissionByUser.CheckPermissionByUserMock.mutex.Unlock()

	for _, e := range mmCheckPermissionByUser.CheckPermissionByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPermissionByUser.t.Errorf("ACLClientMock.CheckPermissionByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPermissionByUser.t.Errorf("ACLClientMock.CheckPermissionByUser got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPermissionByUser.t.Errorf("ACLClientMock.CheckPermissionByUser got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.userType != nil && !minimock.Equal(*mm_want_ptrs.userType, mm_got.userType) {
				mmCheckPermissionByUser.t.Errorf("ACLClientMock.CheckPermissionByUser got unexpected parameter userType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originUserType, *mm_want_ptrs.userType, mm_got.userType, minimock.Diff(*mm_want_ptrs.userType, mm_got.userType))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmCheckPermissionByUser.t.Errorf("ACLClientMock.CheckPermissionByUser got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckPermissionByUser.t.Errorf("ACLClientMock.CheckPermissionByUser got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPermissionByUser.t.Errorf("ACLClientMock.CheckPermissionByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPermissionByUser.t.Fatal("No results are set for the ACLClientMock.CheckPermissionByUser")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPermissionByUser.funcCheckPermissionByUser != nil {
		return mmCheckPermissionByUser.funcCheckPermissionByUser(ctx, objectType, objectUID, userType, userUID, role)
	}
	mmCheckPermissionByUser.t.Fatalf("Unexpected call to ACLClientMock.CheckPermissionByUser. %v %v %v %v %v %v", ctx, objectType, objectUID, userType, userUID, role)
	return
}

// CheckPermissionByUserAfterCounter returns a count of finished ACLClientMock.CheckPermissionByUser invocations
func (mmCheckPermissionByUser *ACLClientMock) CheckPermissionByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermissionByUser.afterCheckPermissionByUserCounter)
}

// CheckPermissionByUserBeforeCounter returns a count of ACLClientMock.CheckPermissionByUser invocations
func (mmCheckPermissionByUser *ACLClientMock) CheckPermissionByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermissionByUser.beforeCheckPermissionByUserCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.CheckPermissionByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPermissionByUser *mACLClientMockCheckPermissionByUser) Calls() []*ACLClientMockCheckPermissionByUserParams {
	mmCheckPermissionByUser.mutex.RLock()

	argCopy := make([]*ACLClientMockCheckPermissionByUserParams, len(mmCheckPermissionByUser.callArgs))
	copy(argCopy, mmCheckPermissionByUser.callArgs)

	mmCheckPermissionByUser.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPermissionByUserDone returns true if the count of the CheckPermissionByUser invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockCheckPermissionByUserDone() bool {
	if m.CheckPermissionByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPermissionByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPermissionByUserMock.invocationsDone()
}

// MinimockCheckPermissionByUserInspect logs each unmet expectation
func (m *ACLClientMock) MinimockCheckPermissionByUserInspect() {
	for _, e := range m.CheckPermissionByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.CheckPermissionByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPermissionByUserCounter := mm_atomic.LoadUint64(&m.afterCheckPermissionByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPermissionByUserMock.defaultExpectation != nil && afterCheckPermissionByUserCounter < 1 {
		if m.CheckPermissionByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.CheckPermissionByUser at\n%s", m.CheckPermissionByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.CheckPermissionByUser at\n%s with params: %#v", m.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.origin, *m.CheckPermissionByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPermissionByUser != nil && afterCheckPermissionByUserCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.CheckPermissionByUser at\n%s", m.funcCheckPermissionByUserOrigin)
	}

	if !m.CheckPermissionByUserMock.invocationsDone() && afterCheckPermissionByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.CheckPermissionByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPermissionByUserMock.expectedInvocations), m.CheckPermissionByUserMock.expectedInvocationsOrigin, afterCheckPermissionByUserCounter)
	}
}

type mACLClientMockCheckPublicExecutable struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockCheckPublicExecutableExpectation
	expectations       []*ACLClientMockCheckPublicExecutableExpectation

	callArgs []*ACLClientMockCheckPublicExecutableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockCheckPublicExecutableExpectation specifies expectation struct of the ACLClient.CheckPublicExecutable
type ACLClientMockCheckPublicExecutableExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockCheckPublicExecutableParams
	paramPtrs          *ACLClientMockCheckPublicExecutableParamPtrs
	expectationOrigins ACLClientMockCheckPublicExecutableExpectationOrigins
	results            *ACLClientMockCheckPublicExecutableResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockCheckPublicExecutableParams contains parameters of the ACLClient.CheckPublicExecutable
type ACLClientMockCheckPublicExecutableParams struct {
	ctx        context.Context
	objectType openfgax.ObjectType
	objectUID  uuid.UUID
}

// ACLClientMockCheckPublicExecutableParamPtrs contains pointers to parameters of the ACLClient.CheckPublicExecutable
type ACLClientMockCheckPublicExecutableParamPtrs struct {
	ctx        *context.Context
	objectType *openfgax.ObjectType
	objectUID  *uuid.UUID
}

// ACLClientMockCheckPublicExecutableResults contains results of the ACLClient.CheckPublicExecutable
type ACLClientMockCheckPublicExecutableResults struct {
	b1  bool
	err error
}

// ACLClientMockCheckPublicExecutableOrigins contains origins of expectations of the ACLClient.CheckPublicExecutable
type ACLClientMockCheckPublicExecutableExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) Optional() *mACLClientMockCheckPublicExecutable {
	mmCheckPublicExecutable.optional = true
	return mmCheckPublicExecutable
}

// Expect sets up expected params for ACLClient.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) Expect(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) *mACLClientMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by ExpectParams functions")
	}

	mmCheckPublicExecutable.defaultExpectation.params = &ACLClientMockCheckPublicExecutableParams{ctx, objectType, objectUID}
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPublicExecutable.expectations {
		if minimock.Equal(e.params, mmCheckPublicExecutable.defaultExpectation.params) {
			mmCheckPublicExecutable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPublicExecutable.defaultExpectation.params)
		}
	}

	return mmCheckPublicExecutable
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) ExpectCtxParam1(ctx context.Context) *mACLClientMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClient.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) ExpectObjectTypeParam2(objectType openfgax.ObjectType) *mACLClientMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClient.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) Inspect(f func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID)) *mACLClientMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Inspect function is already set for ACLClientMock.CheckPublicExecutable")
	}

	mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable = f

	return mmCheckPublicExecutable
}

// Return sets up results that will be returned by ACLClient.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) Return(b1 bool, err error) *ACLClientMock {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientMockCheckPublicExecutableExpectation{mock: mmCheckPublicExecutable.mock}
	}
	mmCheckPublicExecutable.defaultExpectation.results = &ACLClientMockCheckPublicExecutableResults{b1, err}
	mmCheckPublicExecutable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// Set uses given function f to mock the ACLClient.CheckPublicExecutable method
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) Set(f func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) (b1 bool, err error)) *ACLClientMock {
	if mmCheckPublicExecutable.defaultExpectation != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Default expectation is already set for the ACLClient.CheckPublicExecutable method")
	}

	if len(mmCheckPublicExecutable.expectations) > 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Some expectations are already set for the ACLClient.CheckPublicExecutable method")
	}

	mmCheckPublicExecutable.mock.funcCheckPublicExecutable = f
	mmCheckPublicExecutable.mock.funcCheckPublicExecutableOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// When sets expectation for the ACLClient.CheckPublicExecutable which will trigger the result defined by the following
// Then helper
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) When(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) *ACLClientMockCheckPublicExecutableExpectation {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientMock.CheckPublicExecutable mock is already set by Set")
	}

	expectation := &ACLClientMockCheckPublicExecutableExpectation{
		mock:               mmCheckPublicExecutable.mock,
		params:             &ACLClientMockCheckPublicExecutableParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientMockCheckPublicExecutableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPublicExecutable.expectations = append(mmCheckPublicExecutable.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.CheckPublicExecutable return parameters for the expectation previously defined by the When method
func (e *ACLClientMockCheckPublicExecutableExpectation) Then(b1 bool, err error) *ACLClientMock {
	e.results = &ACLClientMockCheckPublicExecutableResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClient.CheckPublicExecutable should be invoked
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) Times(n uint64) *mACLClientMockCheckPublicExecutable {
	if n == 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Times of ACLClientMock.CheckPublicExecutable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPublicExecutable.expectedInvocations, n)
	mmCheckPublicExecutable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable
}

func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) invocationsDone() bool {
	if len(mmCheckPublicExecutable.expectations) == 0 && mmCheckPublicExecutable.defaultExpectation == nil && mmCheckPublicExecutable.mock.funcCheckPublicExecutable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.mock.afterCheckPublicExecutableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPublicExecutable implements mm_acl.ACLClient
func (mmCheckPublicExecutable *ACLClientMock) CheckPublicExecutable(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter, 1)

	mmCheckPublicExecutable.t.Helper()

	if mmCheckPublicExecutable.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.inspectFuncCheckPublicExecutable(ctx, objectType, objectUID)
	}

	mm_params := ACLClientMockCheckPublicExecutableParams{ctx, objectType, objectUID}

	// Record call args
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Lock()
	mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs = append(mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs, &mm_params)
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Unlock()

	for _, e := range mmCheckPublicExecutable.CheckPublicExecutableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockCheckPublicExecutableParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPublicExecutable.t.Errorf("ACLClientMock.CheckPublicExecutable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPublicExecutable.t.Errorf("ACLClientMock.CheckPublicExecutable got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPublicExecutable.t.Errorf("ACLClientMock.CheckPublicExecutable got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPublicExecutable.t.Errorf("ACLClientMock.CheckPublicExecutable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPublicExecutable.t.Fatal("No results are set for the ACLClientMock.CheckPublicExecutable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPublicExecutable.funcCheckPublicExecutable != nil {
		return mmCheckPublicExecutable.funcCheckPublicExecutable(ctx, objectType, objectUID)
	}
	mmCheckPublicExecutable.t.Fatalf("Unexpected call to ACLClientMock.CheckPublicExecutable. %v %v %v", ctx, objectType, objectUID)
	return
}

// CheckPublicExecutableAfterCounter returns a count of finished ACLClientMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientMock) CheckPublicExecutableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter)
}

// CheckPublicExecutableBeforeCounter returns a count of ACLClientMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientMock) CheckPublicExecutableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.CheckPublicExecutable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPublicExecutable *mACLClientMockCheckPublicExecutable) Calls() []*ACLClientMockCheckPublicExecutableParams {
	mmCheckPublicExecutable.mutex.RLock()

	argCopy := make([]*ACLClientMockCheckPublicExecutableParams, len(mmCheckPublicExecutable.callArgs))
	copy(argCopy, mmCheckPublicExecutable.callArgs)

	mmCheckPublicExecutable.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPublicExecutableDone returns true if the count of the CheckPublicExecutable invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockCheckPublicExecutableDone() bool {
	if m.CheckPublicExecutableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPublicExecutableMock.invocationsDone()
}

// MinimockCheckPublicExecutableInspect logs each unmet expectation
func (m *ACLClientMock) MinimockCheckPublicExecutableInspect() {
	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.CheckPublicExecutable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPublicExecutableCounter := mm_atomic.LoadUint64(&m.afterCheckPublicExecutableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPublicExecutableMock.defaultExpectation != nil && afterCheckPublicExecutableCounter < 1 {
		if m.CheckPublicExecutableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.CheckPublicExecutable at\n%s", m.CheckPublicExecutableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.CheckPublicExecutable at\n%s with params: %#v", m.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *m.CheckPublicExecutableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPublicExecutable != nil && afterCheckPublicExecutableCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.CheckPublicExecutable at\n%s", m.funcCheckPublicExecutableOrigin)
	}

	if !m.CheckPublicExecutableMock.invocationsDone() && afterCheckPublicExecutableCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.CheckPublicExecutable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPublicExecutableMock.expectedInvocations), m.CheckPublicExecutableMock.expectedInvocationsOrigin, afterCheckPublicExecutableCounter)
	}
}

type mACLClientMockClose struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockCloseExpectation
	expectations       []*ACLClientMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockCloseExpectation specifies expectation struct of the ACLClient.Close
type ACLClientMockCloseExpectation struct {
	mock *ACLClientMock

	results      *ACLClientMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ACLClientMockCloseResults contains results of the ACLClient.Close
type ACLClientMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mACLClientMockClose) Optional() *mACLClientMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for ACLClient.Close
func (mmClose *mACLClientMockClose) Expect() *mACLClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ACLClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ACLClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.Close
func (mmClose *mACLClientMockClose) Inspect(f func()) *mACLClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ACLClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by ACLClient.Close
func (mmClose *mACLClientMockClose) Return(err error) *ACLClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ACLClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ACLClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ACLClientMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the ACLClient.Close method
func (mmClose *mACLClientMockClose) Set(f func() (err error)) *ACLClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the ACLClient.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the ACLClient.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times ACLClient.Close should be invoked
func (mmClose *mACLClientMockClose) Times(n uint64) *mACLClientMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ACLClientMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mACLClientMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_acl.ACLClient
func (mmClose *ACLClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ACLClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ACLClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ACLClientMock.Close invocations
func (mmClose *ACLClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ACLClientMock.Close invocations
func (mmClose *ACLClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ACLClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mACLClientMockDeletePipelinePermission struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockDeletePipelinePermissionExpectation
	expectations       []*ACLClientMockDeletePipelinePermissionExpectation

	callArgs []*ACLClientMockDeletePipelinePermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockDeletePipelinePermissionExpectation specifies expectation struct of the ACLClient.DeletePipelinePermission
type ACLClientMockDeletePipelinePermissionExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockDeletePipelinePermissionParams
	paramPtrs          *ACLClientMockDeletePipelinePermissionParamPtrs
	expectationOrigins ACLClientMockDeletePipelinePermissionExpectationOrigins
	results            *ACLClientMockDeletePipelinePermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockDeletePipelinePermissionParams contains parameters of the ACLClient.DeletePipelinePermission
type ACLClientMockDeletePipelinePermissionParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	user        string
}

// ACLClientMockDeletePipelinePermissionParamPtrs contains pointers to parameters of the ACLClient.DeletePipelinePermission
type ACLClientMockDeletePipelinePermissionParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	user        *string
}

// ACLClientMockDeletePipelinePermissionResults contains results of the ACLClient.DeletePipelinePermission
type ACLClientMockDeletePipelinePermissionResults struct {
	err error
}

// ACLClientMockDeletePipelinePermissionOrigins contains origins of expectations of the ACLClient.DeletePipelinePermission
type ACLClientMockDeletePipelinePermissionExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originUser        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) Optional() *mACLClientMockDeletePipelinePermission {
	mmDeletePipelinePermission.optional = true
	return mmDeletePipelinePermission
}

// Expect sets up expected params for ACLClient.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) Expect(ctx context.Context, pipelineUID uuid.UUID, user string) *mACLClientMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by ExpectParams functions")
	}

	mmDeletePipelinePermission.defaultExpectation.params = &ACLClientMockDeletePipelinePermissionParams{ctx, pipelineUID, user}
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePipelinePermission.expectations {
		if minimock.Equal(e.params, mmDeletePipelinePermission.defaultExpectation.params) {
			mmDeletePipelinePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelinePermission.defaultExpectation.params)
		}
	}

	return mmDeletePipelinePermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) ExpectCtxParam1(ctx context.Context) *mACLClientMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePipelinePermission
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for ACLClient.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mACLClientMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmDeletePipelinePermission
}

// ExpectUserParam3 sets up expected param user for ACLClient.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) ExpectUserParam3(user string) *mACLClientMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.user = &user
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmDeletePipelinePermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, user string)) *mACLClientMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.inspectFuncDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("Inspect function is already set for ACLClientMock.DeletePipelinePermission")
	}

	mmDeletePipelinePermission.mock.inspectFuncDeletePipelinePermission = f

	return mmDeletePipelinePermission
}

// Return sets up results that will be returned by ACLClient.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) Return(err error) *ACLClientMock {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientMockDeletePipelinePermissionExpectation{mock: mmDeletePipelinePermission.mock}
	}
	mmDeletePipelinePermission.defaultExpectation.results = &ACLClientMockDeletePipelinePermissionResults{err}
	mmDeletePipelinePermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelinePermission.mock
}

// Set uses given function f to mock the ACLClient.DeletePipelinePermission method
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) Set(f func(ctx context.Context, pipelineUID uuid.UUID, user string) (err error)) *ACLClientMock {
	if mmDeletePipelinePermission.defaultExpectation != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("Default expectation is already set for the ACLClient.DeletePipelinePermission method")
	}

	if len(mmDeletePipelinePermission.expectations) > 0 {
		mmDeletePipelinePermission.mock.t.Fatalf("Some expectations are already set for the ACLClient.DeletePipelinePermission method")
	}

	mmDeletePipelinePermission.mock.funcDeletePipelinePermission = f
	mmDeletePipelinePermission.mock.funcDeletePipelinePermissionOrigin = minimock.CallerInfo(1)
	return mmDeletePipelinePermission.mock
}

// When sets expectation for the ACLClient.DeletePipelinePermission which will trigger the result defined by the following
// Then helper
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) When(ctx context.Context, pipelineUID uuid.UUID, user string) *ACLClientMockDeletePipelinePermissionExpectation {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientMock.DeletePipelinePermission mock is already set by Set")
	}

	expectation := &ACLClientMockDeletePipelinePermissionExpectation{
		mock:               mmDeletePipelinePermission.mock,
		params:             &ACLClientMockDeletePipelinePermissionParams{ctx, pipelineUID, user},
		expectationOrigins: ACLClientMockDeletePipelinePermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePipelinePermission.expectations = append(mmDeletePipelinePermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.DeletePipelinePermission return parameters for the expectation previously defined by the When method
func (e *ACLClientMockDeletePipelinePermissionExpectation) Then(err error) *ACLClientMock {
	e.results = &ACLClientMockDeletePipelinePermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClient.DeletePipelinePermission should be invoked
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) Times(n uint64) *mACLClientMockDeletePipelinePermission {
	if n == 0 {
		mmDeletePipelinePermission.mock.t.Fatalf("Times of ACLClientMock.DeletePipelinePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelinePermission.expectedInvocations, n)
	mmDeletePipelinePermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelinePermission
}

func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) invocationsDone() bool {
	if len(mmDeletePipelinePermission.expectations) == 0 && mmDeletePipelinePermission.defaultExpectation == nil && mmDeletePipelinePermission.mock.funcDeletePipelinePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelinePermission.mock.afterDeletePipelinePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelinePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelinePermission implements mm_acl.ACLClient
func (mmDeletePipelinePermission *ACLClientMock) DeletePipelinePermission(ctx context.Context, pipelineUID uuid.UUID, user string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelinePermission.beforeDeletePipelinePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelinePermission.afterDeletePipelinePermissionCounter, 1)

	mmDeletePipelinePermission.t.Helper()

	if mmDeletePipelinePermission.inspectFuncDeletePipelinePermission != nil {
		mmDeletePipelinePermission.inspectFuncDeletePipelinePermission(ctx, pipelineUID, user)
	}

	mm_params := ACLClientMockDeletePipelinePermissionParams{ctx, pipelineUID, user}

	// Record call args
	mmDeletePipelinePermission.DeletePipelinePermissionMock.mutex.Lock()
	mmDeletePipelinePermission.DeletePipelinePermissionMock.callArgs = append(mmDeletePipelinePermission.DeletePipelinePermissionMock.callArgs, &mm_params)
	mmDeletePipelinePermission.DeletePipelinePermissionMock.mutex.Unlock()

	for _, e := range mmDeletePipelinePermission.DeletePipelinePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockDeletePipelinePermissionParams{ctx, pipelineUID, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelinePermission.t.Errorf("ACLClientMock.DeletePipelinePermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeletePipelinePermission.t.Errorf("ACLClientMock.DeletePipelinePermission got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmDeletePipelinePermission.t.Errorf("ACLClientMock.DeletePipelinePermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelinePermission.t.Errorf("ACLClientMock.DeletePipelinePermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelinePermission.t.Fatal("No results are set for the ACLClientMock.DeletePipelinePermission")
		}
		return (*mm_results).err
	}
	if mmDeletePipelinePermission.funcDeletePipelinePermission != nil {
		return mmDeletePipelinePermission.funcDeletePipelinePermission(ctx, pipelineUID, user)
	}
	mmDeletePipelinePermission.t.Fatalf("Unexpected call to ACLClientMock.DeletePipelinePermission. %v %v %v", ctx, pipelineUID, user)
	return
}

// DeletePipelinePermissionAfterCounter returns a count of finished ACLClientMock.DeletePipelinePermission invocations
func (mmDeletePipelinePermission *ACLClientMock) DeletePipelinePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelinePermission.afterDeletePipelinePermissionCounter)
}

// DeletePipelinePermissionBeforeCounter returns a count of ACLClientMock.DeletePipelinePermission invocations
func (mmDeletePipelinePermission *ACLClientMock) DeletePipelinePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelinePermission.beforeDeletePipelinePermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.DeletePipelinePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelinePermission *mACLClientMockDeletePipelinePermission) Calls() []*ACLClientMockDeletePipelinePermissionParams {
	mmDeletePipelinePermission.mutex.RLock()

	argCopy := make([]*ACLClientMockDeletePipelinePermissionParams, len(mmDeletePipelinePermission.callArgs))
	copy(argCopy, mmDeletePipelinePermission.callArgs)

	mmDeletePipelinePermission.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelinePermissionDone returns true if the count of the DeletePipelinePermission invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockDeletePipelinePermissionDone() bool {
	if m.DeletePipelinePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelinePermissionMock.invocationsDone()
}

// MinimockDeletePipelinePermissionInspect logs each unmet expectation
func (m *ACLClientMock) MinimockDeletePipelinePermissionInspect() {
	for _, e := range m.DeletePipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.DeletePipelinePermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePipelinePermissionCounter := mm_atomic.LoadUint64(&m.afterDeletePipelinePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelinePermissionMock.defaultExpectation != nil && afterDeletePipelinePermissionCounter < 1 {
		if m.DeletePipelinePermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.DeletePipelinePermission at\n%s", m.DeletePipelinePermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.DeletePipelinePermission at\n%s with params: %#v", m.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *m.DeletePipelinePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelinePermission != nil && afterDeletePipelinePermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.DeletePipelinePermission at\n%s", m.funcDeletePipelinePermissionOrigin)
	}

	if !m.DeletePipelinePermissionMock.invocationsDone() && afterDeletePipelinePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.DeletePipelinePermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelinePermissionMock.expectedInvocations), m.DeletePipelinePermissionMock.expectedInvocationsOrigin, afterDeletePipelinePermissionCounter)
	}
}

type mACLClientMockGetAuthorizationModelID struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockGetAuthorizationModelIDExpectation
	expectations       []*ACLClientMockGetAuthorizationModelIDExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockGetAuthorizationModelIDExpectation specifies expectation struct of the ACLClient.GetAuthorizationModelID
type ACLClientMockGetAuthorizationModelIDExpectation struct {
	mock *ACLClientMock

	results      *ACLClientMockGetAuthorizationModelIDResults
	returnOrigin string
	Counter      uint64
}

// ACLClientMockGetAuthorizationModelIDResults contains results of the ACLClient.GetAuthorizationModelID
type ACLClientMockGetAuthorizationModelIDResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAuthorizationModelID *mACLClientMockGetAuthorizationModelID) Optional() *mACLClientMockGetAuthorizationModelID {
	mmGetAuthorizationModelID.optional = true
	return mmGetAuthorizationModelID
}

// Expect sets up expected params for ACLClient.GetAuthorizationModelID
func (mmGetAuthorizationModelID *mACLClientMockGetAuthorizationModelID) Expect() *mACLClientMockGetAuthorizationModelID {
	if mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.GetAuthorizationModelID mock is already set by Set")
	}

	if mmGetAuthorizationModelID.defaultExpectation == nil {
		mmGetAuthorizationModelID.defaultExpectation = &ACLClientMockGetAuthorizationModelIDExpectation{}
	}

	return mmGetAuthorizationModelID
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.GetAuthorizationModelID
func (mmGetAuthorizationModelID *mACLClientMockGetAuthorizationModelID) Inspect(f func()) *mACLClientMockGetAuthorizationModelID {
	if mmGetAuthorizationModelID.mock.inspectFuncGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("Inspect function is already set for ACLClientMock.GetAuthorizationModelID")
	}

	mmGetAuthorizationModelID.mock.inspectFuncGetAuthorizationModelID = f

	return mmGetAuthorizationModelID
}

// Return sets up results that will be returned by ACLClient.GetAuthorizationModelID
func (mmGetAuthorizationModelID *mACLClientMockGetAuthorizationModelID) Return(s1 string) *ACLClientMock {
	if mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.GetAuthorizationModelID mock is already set by Set")
	}

	if mmGetAuthorizationModelID.defaultExpectation == nil {
		mmGetAuthorizationModelID.defaultExpectation = &ACLClientMockGetAuthorizationModelIDExpectation{mock: mmGetAuthorizationModelID.mock}
	}
	mmGetAuthorizationModelID.defaultExpectation.results = &ACLClientMockGetAuthorizationModelIDResults{s1}
	mmGetAuthorizationModelID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAuthorizationModelID.mock
}

// Set uses given function f to mock the ACLClient.GetAuthorizationModelID method
func (mmGetAuthorizationModelID *mACLClientMockGetAuthorizationModelID) Set(f func() (s1 string)) *ACLClientMock {
	if mmGetAuthorizationModelID.defaultExpectation != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("Default expectation is already set for the ACLClient.GetAuthorizationModelID method")
	}

	if len(mmGetAuthorizationModelID.expectations) > 0 {
		mmGetAuthorizationModelID.mock.t.Fatalf("Some expectations are already set for the ACLClient.GetAuthorizationModelID method")
	}

	mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID = f
	mmGetAuthorizationModelID.mock.funcGetAuthorizationModelIDOrigin = minimock.CallerInfo(1)
	return mmGetAuthorizationModelID.mock
}

// Times sets number of times ACLClient.GetAuthorizationModelID should be invoked
func (mmGetAuthorizationModelID *mACLClientMockGetAuthorizationModelID) Times(n uint64) *mACLClientMockGetAuthorizationModelID {
	if n == 0 {
		mmGetAuthorizationModelID.mock.t.Fatalf("Times of ACLClientMock.GetAuthorizationModelID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAuthorizationModelID.expectedInvocations, n)
	mmGetAuthorizationModelID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAuthorizationModelID
}

func (mmGetAuthorizationModelID *mACLClientMockGetAuthorizationModelID) invocationsDone() bool {
	if len(mmGetAuthorizationModelID.expectations) == 0 && mmGetAuthorizationModelID.defaultExpectation == nil && mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAuthorizationModelID.mock.afterGetAuthorizationModelIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAuthorizationModelID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAuthorizationModelID implements mm_acl.ACLClient
func (mmGetAuthorizationModelID *ACLClientMock) GetAuthorizationModelID() (s1 string) {
	mm_atomic.AddUint64(&mmGetAuthorizationModelID.beforeGetAuthorizationModelIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthorizationModelID.afterGetAuthorizationModelIDCounter, 1)

	mmGetAuthorizationModelID.t.Helper()

	if mmGetAuthorizationModelID.inspectFuncGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.inspectFuncGetAuthorizationModelID()
	}

	if mmGetAuthorizationModelID.GetAuthorizationModelIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthorizationModelID.GetAuthorizationModelIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetAuthorizationModelID.GetAuthorizationModelIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthorizationModelID.t.Fatal("No results are set for the ACLClientMock.GetAuthorizationModelID")
		}
		return (*mm_results).s1
	}
	if mmGetAuthorizationModelID.funcGetAuthorizationModelID != nil {
		return mmGetAuthorizationModelID.funcGetAuthorizationModelID()
	}
	mmGetAuthorizationModelID.t.Fatalf("Unexpected call to ACLClientMock.GetAuthorizationModelID.")
	return
}

// GetAuthorizationModelIDAfterCounter returns a count of finished ACLClientMock.GetAuthorizationModelID invocations
func (mmGetAuthorizationModelID *ACLClientMock) GetAuthorizationModelIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorizationModelID.afterGetAuthorizationModelIDCounter)
}

// GetAuthorizationModelIDBeforeCounter returns a count of ACLClientMock.GetAuthorizationModelID invocations
func (mmGetAuthorizationModelID *ACLClientMock) GetAuthorizationModelIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorizationModelID.beforeGetAuthorizationModelIDCounter)
}

// MinimockGetAuthorizationModelIDDone returns true if the count of the GetAuthorizationModelID invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockGetAuthorizationModelIDDone() bool {
	if m.GetAuthorizationModelIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAuthorizationModelIDMock.invocationsDone()
}

// MinimockGetAuthorizationModelIDInspect logs each unmet expectation
func (m *ACLClientMock) MinimockGetAuthorizationModelIDInspect() {
	for _, e := range m.GetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientMock.GetAuthorizationModelID")
		}
	}

	afterGetAuthorizationModelIDCounter := mm_atomic.LoadUint64(&m.afterGetAuthorizationModelIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthorizationModelIDMock.defaultExpectation != nil && afterGetAuthorizationModelIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.GetAuthorizationModelID at\n%s", m.GetAuthorizationModelIDMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthorizationModelID != nil && afterGetAuthorizationModelIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.GetAuthorizationModelID at\n%s", m.funcGetAuthorizationModelIDOrigin)
	}

	if !m.GetAuthorizationModelIDMock.invocationsDone() && afterGetAuthorizationModelIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.GetAuthorizationModelID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAuthorizationModelIDMock.expectedInvocations), m.GetAuthorizationModelIDMock.expectedInvocationsOrigin, afterGetAuthorizationModelIDCounter)
	}
}

type mACLClientMockGetStoreID struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockGetStoreIDExpectation
	expectations       []*ACLClientMockGetStoreIDExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockGetStoreIDExpectation specifies expectation struct of the ACLClient.GetStoreID
type ACLClientMockGetStoreIDExpectation struct {
	mock *ACLClientMock

	results      *ACLClientMockGetStoreIDResults
	returnOrigin string
	Counter      uint64
}

// ACLClientMockGetStoreIDResults contains results of the ACLClient.GetStoreID
type ACLClientMockGetStoreIDResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStoreID *mACLClientMockGetStoreID) Optional() *mACLClientMockGetStoreID {
	mmGetStoreID.optional = true
	return mmGetStoreID
}

// Expect sets up expected params for ACLClient.GetStoreID
func (mmGetStoreID *mACLClientMockGetStoreID) Expect() *mACLClientMockGetStoreID {
	if mmGetStoreID.mock.funcGetStoreID != nil {
		mmGetStoreID.mock.t.Fatalf("ACLClientMock.GetStoreID mock is already set by Set")
	}

	if mmGetStoreID.defaultExpectation == nil {
		mmGetStoreID.defaultExpectation = &ACLClientMockGetStoreIDExpectation{}
	}

	return mmGetStoreID
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.GetStoreID
func (mmGetStoreID *mACLClientMockGetStoreID) Inspect(f func()) *mACLClientMockGetStoreID {
	if mmGetStoreID.mock.inspectFuncGetStoreID != nil {
		mmGetStoreID.mock.t.Fatalf("Inspect function is already set for ACLClientMock.GetStoreID")
	}

	mmGetStoreID.mock.inspectFuncGetStoreID = f

	return mmGetStoreID
}

// Return sets up results that will be returned by ACLClient.GetStoreID
func (mmGetStoreID *mACLClientMockGetStoreID) Return(s1 string) *ACLClientMock {
	if mmGetStoreID.mock.funcGetStoreID != nil {
		mmGetStoreID.mock.t.Fatalf("ACLClientMock.GetStoreID mock is already set by Set")
	}

	if mmGetStoreID.defaultExpectation == nil {
		mmGetStoreID.defaultExpectation = &ACLClientMockGetStoreIDExpectation{mock: mmGetStoreID.mock}
	}
	mmGetStoreID.defaultExpectation.results = &ACLClientMockGetStoreIDResults{s1}
	mmGetStoreID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStoreID.mock
}

// Set uses given function f to mock the ACLClient.GetStoreID method
func (mmGetStoreID *mACLClientMockGetStoreID) Set(f func() (s1 string)) *ACLClientMock {
	if mmGetStoreID.defaultExpectation != nil {
		mmGetStoreID.mock.t.Fatalf("Default expectation is already set for the ACLClient.GetStoreID method")
	}

	if len(mmGetStoreID.expectations) > 0 {
		mmGetStoreID.mock.t.Fatalf("Some expectations are already set for the ACLClient.GetStoreID method")
	}

	mmGetStoreID.mock.funcGetStoreID = f
	mmGetStoreID.mock.funcGetStoreIDOrigin = minimock.CallerInfo(1)
	return mmGetStoreID.mock
}

// Times sets number of times ACLClient.GetStoreID should be invoked
func (mmGetStoreID *mACLClientMockGetStoreID) Times(n uint64) *mACLClientMockGetStoreID {
	if n == 0 {
		mmGetStoreID.mock.t.Fatalf("Times of ACLClientMock.GetStoreID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStoreID.expectedInvocations, n)
	mmGetStoreID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStoreID
}

func (mmGetStoreID *mACLClientMockGetStoreID) invocationsDone() bool {
	if len(mmGetStoreID.expectations) == 0 && mmGetStoreID.defaultExpectation == nil && mmGetStoreID.mock.funcGetStoreID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStoreID.mock.afterGetStoreIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStoreID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStoreID implements mm_acl.ACLClient
func (mmGetStoreID *ACLClientMock) GetStoreID() (s1 string) {
	mm_atomic.AddUint64(&mmGetStoreID.beforeGetStoreIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStoreID.afterGetStoreIDCounter, 1)

	mmGetStoreID.t.Helper()

	if mmGetStoreID.inspectFuncGetStoreID != nil {
		mmGetStoreID.inspectFuncGetStoreID()
	}

	if mmGetStoreID.GetStoreIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStoreID.GetStoreIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetStoreID.GetStoreIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStoreID.t.Fatal("No results are set for the ACLClientMock.GetStoreID")
		}
		return (*mm_results).s1
	}
	if mmGetStoreID.funcGetStoreID != nil {
		return mmGetStoreID.funcGetStoreID()
	}
	mmGetStoreID.t.Fatalf("Unexpected call to ACLClientMock.GetStoreID.")
	return
}

// GetStoreIDAfterCounter returns a count of finished ACLClientMock.GetStoreID invocations
func (mmGetStoreID *ACLClientMock) GetStoreIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStoreID.afterGetStoreIDCounter)
}

// GetStoreIDBeforeCounter returns a count of ACLClientMock.GetStoreID invocations
func (mmGetStoreID *ACLClientMock) GetStoreIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStoreID.beforeGetStoreIDCounter)
}

// MinimockGetStoreIDDone returns true if the count of the GetStoreID invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockGetStoreIDDone() bool {
	if m.GetStoreIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStoreIDMock.invocationsDone()
}

// MinimockGetStoreIDInspect logs each unmet expectation
func (m *ACLClientMock) MinimockGetStoreIDInspect() {
	for _, e := range m.GetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientMock.GetStoreID")
		}
	}

	afterGetStoreIDCounter := mm_atomic.LoadUint64(&m.afterGetStoreIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStoreIDMock.defaultExpectation != nil && afterGetStoreIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.GetStoreID at\n%s", m.GetStoreIDMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStoreID != nil && afterGetStoreIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.GetStoreID at\n%s", m.funcGetStoreIDOrigin)
	}

	if !m.GetStoreIDMock.invocationsDone() && afterGetStoreIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.GetStoreID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStoreIDMock.expectedInvocations), m.GetStoreIDMock.expectedInvocationsOrigin, afterGetStoreIDCounter)
	}
}

type mACLClientMockListPermissions struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockListPermissionsExpectation
	expectations       []*ACLClientMockListPermissionsExpectation

	callArgs []*ACLClientMockListPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockListPermissionsExpectation specifies expectation struct of the ACLClient.ListPermissions
type ACLClientMockListPermissionsExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockListPermissionsParams
	paramPtrs          *ACLClientMockListPermissionsParamPtrs
	expectationOrigins ACLClientMockListPermissionsExpectationOrigins
	results            *ACLClientMockListPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockListPermissionsParams contains parameters of the ACLClient.ListPermissions
type ACLClientMockListPermissionsParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	role       string
	isPublic   bool
}

// ACLClientMockListPermissionsParamPtrs contains pointers to parameters of the ACLClient.ListPermissions
type ACLClientMockListPermissionsParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	role       *string
	isPublic   *bool
}

// ACLClientMockListPermissionsResults contains results of the ACLClient.ListPermissions
type ACLClientMockListPermissionsResults struct {
	ua1 []uuid.UUID
	err error
}

// ACLClientMockListPermissionsOrigins contains origins of expectations of the ACLClient.ListPermissions
type ACLClientMockListPermissionsExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originRole       string
	originIsPublic   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPermissions *mACLClientMockListPermissions) Optional() *mACLClientMockListPermissions {
	mmListPermissions.optional = true
	return mmListPermissions
}

// Expect sets up expected params for ACLClient.ListPermissions
func (mmListPermissions *mACLClientMockListPermissions) Expect(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) *mACLClientMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.paramPtrs != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by ExpectParams functions")
	}

	mmListPermissions.defaultExpectation.params = &ACLClientMockListPermissionsParams{ctx, objectType, role, isPublic}
	mmListPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPermissions.expectations {
		if minimock.Equal(e.params, mmListPermissions.defaultExpectation.params) {
			mmListPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPermissions.defaultExpectation.params)
		}
	}

	return mmListPermissions
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.ListPermissions
func (mmListPermissions *mACLClientMockListPermissions) ExpectCtxParam1(ctx context.Context) *mACLClientMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClient.ListPermissions
func (mmListPermissions *mACLClientMockListPermissions) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.objectType = &objectType
	mmListPermissions.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectRoleParam3 sets up expected param role for ACLClient.ListPermissions
func (mmListPermissions *mACLClientMockListPermissions) ExpectRoleParam3(role string) *mACLClientMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.role = &role
	mmListPermissions.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectIsPublicParam4 sets up expected param isPublic for ACLClient.ListPermissions
func (mmListPermissions *mACLClientMockListPermissions) ExpectIsPublicParam4(isPublic bool) *mACLClientMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.isPublic = &isPublic
	mmListPermissions.defaultExpectation.expectationOrigins.originIsPublic = minimock.CallerInfo(1)

	return mmListPermissions
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.ListPermissions
func (mmListPermissions *mACLClientMockListPermissions) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool)) *mACLClientMockListPermissions {
	if mmListPermissions.mock.inspectFuncListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("Inspect function is already set for ACLClientMock.ListPermissions")
	}

	mmListPermissions.mock.inspectFuncListPermissions = f

	return mmListPermissions
}

// Return sets up results that will be returned by ACLClient.ListPermissions
func (mmListPermissions *mACLClientMockListPermissions) Return(ua1 []uuid.UUID, err error) *ACLClientMock {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientMockListPermissionsExpectation{mock: mmListPermissions.mock}
	}
	mmListPermissions.defaultExpectation.results = &ACLClientMockListPermissionsResults{ua1, err}
	mmListPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// Set uses given function f to mock the ACLClient.ListPermissions method
func (mmListPermissions *mACLClientMockListPermissions) Set(f func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) (ua1 []uuid.UUID, err error)) *ACLClientMock {
	if mmListPermissions.defaultExpectation != nil {
		mmListPermissions.mock.t.Fatalf("Default expectation is already set for the ACLClient.ListPermissions method")
	}

	if len(mmListPermissions.expectations) > 0 {
		mmListPermissions.mock.t.Fatalf("Some expectations are already set for the ACLClient.ListPermissions method")
	}

	mmListPermissions.mock.funcListPermissions = f
	mmListPermissions.mock.funcListPermissionsOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// When sets expectation for the ACLClient.ListPermissions which will trigger the result defined by the following
// Then helper
func (mmListPermissions *mACLClientMockListPermissions) When(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) *ACLClientMockListPermissionsExpectation {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientMock.ListPermissions mock is already set by Set")
	}

	expectation := &ACLClientMockListPermissionsExpectation{
		mock:               mmListPermissions.mock,
		params:             &ACLClientMockListPermissionsParams{ctx, objectType, role, isPublic},
		expectationOrigins: ACLClientMockListPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPermissions.expectations = append(mmListPermissions.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.ListPermissions return parameters for the expectation previously defined by the When method
func (e *ACLClientMockListPermissionsExpectation) Then(ua1 []uuid.UUID, err error) *ACLClientMock {
	e.results = &ACLClientMockListPermissionsResults{ua1, err}
	return e.mock
}

// Times sets number of times ACLClient.ListPermissions should be invoked
func (mmListPermissions *mACLClientMockListPermissions) Times(n uint64) *mACLClientMockListPermissions {
	if n == 0 {
		mmListPermissions.mock.t.Fatalf("Times of ACLClientMock.ListPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPermissions.expectedInvocations, n)
	mmListPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPermissions
}

func (mmListPermissions *mACLClientMockListPermissions) invocationsDone() bool {
	if len(mmListPermissions.expectations) == 0 && mmListPermissions.defaultExpectation == nil && mmListPermissions.mock.funcListPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPermissions.mock.afterListPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPermissions implements mm_acl.ACLClient
func (mmListPermissions *ACLClientMock) ListPermissions(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) (ua1 []uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmListPermissions.beforeListPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPermissions.afterListPermissionsCounter, 1)

	mmListPermissions.t.Helper()

	if mmListPermissions.inspectFuncListPermissions != nil {
		mmListPermissions.inspectFuncListPermissions(ctx, objectType, role, isPublic)
	}

	mm_params := ACLClientMockListPermissionsParams{ctx, objectType, role, isPublic}

	// Record call args
	mmListPermissions.ListPermissionsMock.mutex.Lock()
	mmListPermissions.ListPermissionsMock.callArgs = append(mmListPermissions.ListPermissionsMock.callArgs, &mm_params)
	mmListPermissions.ListPermissionsMock.mutex.Unlock()

	for _, e := range mmListPermissions.ListPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListPermissions.ListPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPermissions.ListPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPermissions.ListPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmListPermissions.ListPermissionsMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockListPermissionsParams{ctx, objectType, role, isPublic}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPermissions.t.Errorf("ACLClientMock.ListPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmListPermissions.t.Errorf("ACLClientMock.ListPermissions got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmListPermissions.t.Errorf("ACLClientMock.ListPermissions got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.isPublic != nil && !minimock.Equal(*mm_want_ptrs.isPublic, mm_got.isPublic) {
				mmListPermissions.t.Errorf("ACLClientMock.ListPermissions got unexpected parameter isPublic, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originIsPublic, *mm_want_ptrs.isPublic, mm_got.isPublic, minimock.Diff(*mm_want_ptrs.isPublic, mm_got.isPublic))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPermissions.t.Errorf("ACLClientMock.ListPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPermissions.ListPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPermissions.t.Fatal("No results are set for the ACLClientMock.ListPermissions")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListPermissions.funcListPermissions != nil {
		return mmListPermissions.funcListPermissions(ctx, objectType, role, isPublic)
	}
	mmListPermissions.t.Fatalf("Unexpected call to ACLClientMock.ListPermissions. %v %v %v %v", ctx, objectType, role, isPublic)
	return
}

// ListPermissionsAfterCounter returns a count of finished ACLClientMock.ListPermissions invocations
func (mmListPermissions *ACLClientMock) ListPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.afterListPermissionsCounter)
}

// ListPermissionsBeforeCounter returns a count of ACLClientMock.ListPermissions invocations
func (mmListPermissions *ACLClientMock) ListPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.beforeListPermissionsCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.ListPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPermissions *mACLClientMockListPermissions) Calls() []*ACLClientMockListPermissionsParams {
	mmListPermissions.mutex.RLock()

	argCopy := make([]*ACLClientMockListPermissionsParams, len(mmListPermissions.callArgs))
	copy(argCopy, mmListPermissions.callArgs)

	mmListPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockListPermissionsDone returns true if the count of the ListPermissions invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockListPermissionsDone() bool {
	if m.ListPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPermissionsMock.invocationsDone()
}

// MinimockListPermissionsInspect logs each unmet expectation
func (m *ACLClientMock) MinimockListPermissionsInspect() {
	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.ListPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPermissionsCounter := mm_atomic.LoadUint64(&m.afterListPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPermissionsMock.defaultExpectation != nil && afterListPermissionsCounter < 1 {
		if m.ListPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.ListPermissions at\n%s", m.ListPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.ListPermissions at\n%s with params: %#v", m.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.ListPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPermissions != nil && afterListPermissionsCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.ListPermissions at\n%s", m.funcListPermissionsOrigin)
	}

	if !m.ListPermissionsMock.invocationsDone() && afterListPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.ListPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPermissionsMock.expectedInvocations), m.ListPermissionsMock.expectedInvocationsOrigin, afterListPermissionsCounter)
	}
}

type mACLClientMockPurge struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockPurgeExpectation
	expectations       []*ACLClientMockPurgeExpectation

	callArgs []*ACLClientMockPurgeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockPurgeExpectation specifies expectation struct of the ACLClient.Purge
type ACLClientMockPurgeExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockPurgeParams
	paramPtrs          *ACLClientMockPurgeParamPtrs
	expectationOrigins ACLClientMockPurgeExpectationOrigins
	results            *ACLClientMockPurgeResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockPurgeParams contains parameters of the ACLClient.Purge
type ACLClientMockPurgeParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
}

// ACLClientMockPurgeParamPtrs contains pointers to parameters of the ACLClient.Purge
type ACLClientMockPurgeParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
}

// ACLClientMockPurgeResults contains results of the ACLClient.Purge
type ACLClientMockPurgeResults struct {
	err error
}

// ACLClientMockPurgeOrigins contains origins of expectations of the ACLClient.Purge
type ACLClientMockPurgeExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPurge *mACLClientMockPurge) Optional() *mACLClientMockPurge {
	mmPurge.optional = true
	return mmPurge
}

// Expect sets up expected params for ACLClient.Purge
func (mmPurge *mACLClientMockPurge) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) *mACLClientMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.paramPtrs != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by ExpectParams functions")
	}

	mmPurge.defaultExpectation.params = &ACLClientMockPurgeParams{ctx, objectType, objectUID}
	mmPurge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPurge.expectations {
		if minimock.Equal(e.params, mmPurge.defaultExpectation.params) {
			mmPurge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurge.defaultExpectation.params)
		}
	}

	return mmPurge
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.Purge
func (mmPurge *mACLClientMockPurge) ExpectCtxParam1(ctx context.Context) *mACLClientMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.ctx = &ctx
	mmPurge.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClient.Purge
func (mmPurge *mACLClientMockPurge) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectType = &objectType
	mmPurge.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClient.Purge
func (mmPurge *mACLClientMockPurge) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmPurge.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmPurge
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.Purge
func (mmPurge *mACLClientMockPurge) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID)) *mACLClientMockPurge {
	if mmPurge.mock.inspectFuncPurge != nil {
		mmPurge.mock.t.Fatalf("Inspect function is already set for ACLClientMock.Purge")
	}

	mmPurge.mock.inspectFuncPurge = f

	return mmPurge
}

// Return sets up results that will be returned by ACLClient.Purge
func (mmPurge *mACLClientMockPurge) Return(err error) *ACLClientMock {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientMockPurgeExpectation{mock: mmPurge.mock}
	}
	mmPurge.defaultExpectation.results = &ACLClientMockPurgeResults{err}
	mmPurge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// Set uses given function f to mock the ACLClient.Purge method
func (mmPurge *mACLClientMockPurge) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) (err error)) *ACLClientMock {
	if mmPurge.defaultExpectation != nil {
		mmPurge.mock.t.Fatalf("Default expectation is already set for the ACLClient.Purge method")
	}

	if len(mmPurge.expectations) > 0 {
		mmPurge.mock.t.Fatalf("Some expectations are already set for the ACLClient.Purge method")
	}

	mmPurge.mock.funcPurge = f
	mmPurge.mock.funcPurgeOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// When sets expectation for the ACLClient.Purge which will trigger the result defined by the following
// Then helper
func (mmPurge *mACLClientMockPurge) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) *ACLClientMockPurgeExpectation {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientMock.Purge mock is already set by Set")
	}

	expectation := &ACLClientMockPurgeExpectation{
		mock:               mmPurge.mock,
		params:             &ACLClientMockPurgeParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientMockPurgeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPurge.expectations = append(mmPurge.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.Purge return parameters for the expectation previously defined by the When method
func (e *ACLClientMockPurgeExpectation) Then(err error) *ACLClientMock {
	e.results = &ACLClientMockPurgeResults{err}
	return e.mock
}

// Times sets number of times ACLClient.Purge should be invoked
func (mmPurge *mACLClientMockPurge) Times(n uint64) *mACLClientMockPurge {
	if n == 0 {
		mmPurge.mock.t.Fatalf("Times of ACLClientMock.Purge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPurge.expectedInvocations, n)
	mmPurge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPurge
}

func (mmPurge *mACLClientMockPurge) invocationsDone() bool {
	if len(mmPurge.expectations) == 0 && mmPurge.defaultExpectation == nil && mmPurge.mock.funcPurge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPurge.mock.afterPurgeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPurge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Purge implements mm_acl.ACLClient
func (mmPurge *ACLClientMock) Purge(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmPurge.beforePurgeCounter, 1)
	defer mm_atomic.AddUint64(&mmPurge.afterPurgeCounter, 1)

	mmPurge.t.Helper()

	if mmPurge.inspectFuncPurge != nil {
		mmPurge.inspectFuncPurge(ctx, objectType, objectUID)
	}

	mm_params := ACLClientMockPurgeParams{ctx, objectType, objectUID}

	// Record call args
	mmPurge.PurgeMock.mutex.Lock()
	mmPurge.PurgeMock.callArgs = append(mmPurge.PurgeMock.callArgs, &mm_params)
	mmPurge.PurgeMock.mutex.Unlock()

	for _, e := range mmPurge.PurgeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurge.PurgeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurge.PurgeMock.defaultExpectation.Counter, 1)
		mm_want := mmPurge.PurgeMock.defaultExpectation.params
		mm_want_ptrs := mmPurge.PurgeMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockPurgeParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPurge.t.Errorf("ACLClientMock.Purge got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmPurge.t.Errorf("ACLClientMock.Purge got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmPurge.t.Errorf("ACLClientMock.Purge got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurge.t.Errorf("ACLClientMock.Purge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPurge.PurgeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurge.PurgeMock.defaultExpectation.results
		if mm_results == nil {
			mmPurge.t.Fatal("No results are set for the ACLClientMock.Purge")
		}
		return (*mm_results).err
	}
	if mmPurge.funcPurge != nil {
		return mmPurge.funcPurge(ctx, objectType, objectUID)
	}
	mmPurge.t.Fatalf("Unexpected call to ACLClientMock.Purge. %v %v %v", ctx, objectType, objectUID)
	return
}

// PurgeAfterCounter returns a count of finished ACLClientMock.Purge invocations
func (mmPurge *ACLClientMock) PurgeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.afterPurgeCounter)
}

// PurgeBeforeCounter returns a count of ACLClientMock.Purge invocations
func (mmPurge *ACLClientMock) PurgeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.beforePurgeCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.Purge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurge *mACLClientMockPurge) Calls() []*ACLClientMockPurgeParams {
	mmPurge.mutex.RLock()

	argCopy := make([]*ACLClientMockPurgeParams, len(mmPurge.callArgs))
	copy(argCopy, mmPurge.callArgs)

	mmPurge.mutex.RUnlock()

	return argCopy
}

// MinimockPurgeDone returns true if the count of the Purge invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockPurgeDone() bool {
	if m.PurgeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PurgeMock.invocationsDone()
}

// MinimockPurgeInspect logs each unmet expectation
func (m *ACLClientMock) MinimockPurgeInspect() {
	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.Purge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPurgeCounter := mm_atomic.LoadUint64(&m.afterPurgeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeMock.defaultExpectation != nil && afterPurgeCounter < 1 {
		if m.PurgeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.Purge at\n%s", m.PurgeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.Purge at\n%s with params: %#v", m.PurgeMock.defaultExpectation.expectationOrigins.origin, *m.PurgeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurge != nil && afterPurgeCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.Purge at\n%s", m.funcPurgeOrigin)
	}

	if !m.PurgeMock.invocationsDone() && afterPurgeCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.Purge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PurgeMock.expectedInvocations), m.PurgeMock.expectedInvocationsOrigin, afterPurgeCounter)
	}
}

type mACLClientMockSDKClient struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockSDKClientExpectation
	expectations       []*ACLClientMockSDKClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockSDKClientExpectation specifies expectation struct of the ACLClient.SDKClient
type ACLClientMockSDKClientExpectation struct {
	mock *ACLClientMock

	results      *ACLClientMockSDKClientResults
	returnOrigin string
	Counter      uint64
}

// ACLClientMockSDKClientResults contains results of the ACLClient.SDKClient
type ACLClientMockSDKClientResults struct {
	op1 *openfgaclient.OpenFgaClient
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSDKClient *mACLClientMockSDKClient) Optional() *mACLClientMockSDKClient {
	mmSDKClient.optional = true
	return mmSDKClient
}

// Expect sets up expected params for ACLClient.SDKClient
func (mmSDKClient *mACLClientMockSDKClient) Expect() *mACLClientMockSDKClient {
	if mmSDKClient.mock.funcSDKClient != nil {
		mmSDKClient.mock.t.Fatalf("ACLClientMock.SDKClient mock is already set by Set")
	}

	if mmSDKClient.defaultExpectation == nil {
		mmSDKClient.defaultExpectation = &ACLClientMockSDKClientExpectation{}
	}

	return mmSDKClient
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.SDKClient
func (mmSDKClient *mACLClientMockSDKClient) Inspect(f func()) *mACLClientMockSDKClient {
	if mmSDKClient.mock.inspectFuncSDKClient != nil {
		mmSDKClient.mock.t.Fatalf("Inspect function is already set for ACLClientMock.SDKClient")
	}

	mmSDKClient.mock.inspectFuncSDKClient = f

	return mmSDKClient
}

// Return sets up results that will be returned by ACLClient.SDKClient
func (mmSDKClient *mACLClientMockSDKClient) Return(op1 *openfgaclient.OpenFgaClient) *ACLClientMock {
	if mmSDKClient.mock.funcSDKClient != nil {
		mmSDKClient.mock.t.Fatalf("ACLClientMock.SDKClient mock is already set by Set")
	}

	if mmSDKClient.defaultExpectation == nil {
		mmSDKClient.defaultExpectation = &ACLClientMockSDKClientExpectation{mock: mmSDKClient.mock}
	}
	mmSDKClient.defaultExpectation.results = &ACLClientMockSDKClientResults{op1}
	mmSDKClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSDKClient.mock
}

// Set uses given function f to mock the ACLClient.SDKClient method
func (mmSDKClient *mACLClientMockSDKClient) Set(f func() (op1 *openfgaclient.OpenFgaClient)) *ACLClientMock {
	if mmSDKClient.defaultExpectation != nil {
		mmSDKClient.mock.t.Fatalf("Default expectation is already set for the ACLClient.SDKClient method")
	}

	if len(mmSDKClient.expectations) > 0 {
		mmSDKClient.mock.t.Fatalf("Some expectations are already set for the ACLClient.SDKClient method")
	}

	mmSDKClient.mock.funcSDKClient = f
	mmSDKClient.mock.funcSDKClientOrigin = minimock.CallerInfo(1)
	return mmSDKClient.mock
}

// Times sets number of times ACLClient.SDKClient should be invoked
func (mmSDKClient *mACLClientMockSDKClient) Times(n uint64) *mACLClientMockSDKClient {
	if n == 0 {
		mmSDKClient.mock.t.Fatalf("Times of ACLClientMock.SDKClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSDKClient.expectedInvocations, n)
	mmSDKClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSDKClient
}

func (mmSDKClient *mACLClientMockSDKClient) invocationsDone() bool {
	if len(mmSDKClient.expectations) == 0 && mmSDKClient.defaultExpectation == nil && mmSDKClient.mock.funcSDKClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSDKClient.mock.afterSDKClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSDKClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SDKClient implements mm_acl.ACLClient
func (mmSDKClient *ACLClientMock) SDKClient() (op1 *openfgaclient.OpenFgaClient) {
	mm_atomic.AddUint64(&mmSDKClient.beforeSDKClientCounter, 1)
	defer mm_atomic.AddUint64(&mmSDKClient.afterSDKClientCounter, 1)

	mmSDKClient.t.Helper()

	if mmSDKClient.inspectFuncSDKClient != nil {
		mmSDKClient.inspectFuncSDKClient()
	}

	if mmSDKClient.SDKClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSDKClient.SDKClientMock.defaultExpectation.Counter, 1)

		mm_results := mmSDKClient.SDKClientMock.defaultExpectation.results
		if mm_results == nil {
			mmSDKClient.t.Fatal("No results are set for the ACLClientMock.SDKClient")
		}
		return (*mm_results).op1
	}
	if mmSDKClient.funcSDKClient != nil {
		return mmSDKClient.funcSDKClient()
	}
	mmSDKClient.t.Fatalf("Unexpected call to ACLClientMock.SDKClient.")
	return
}

// SDKClientAfterCounter returns a count of finished ACLClientMock.SDKClient invocations
func (mmSDKClient *ACLClientMock) SDKClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSDKClient.afterSDKClientCounter)
}

// SDKClientBeforeCounter returns a count of ACLClientMock.SDKClient invocations
func (mmSDKClient *ACLClientMock) SDKClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSDKClient.beforeSDKClientCounter)
}

// MinimockSDKClientDone returns true if the count of the SDKClient invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockSDKClientDone() bool {
	if m.SDKClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SDKClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SDKClientMock.invocationsDone()
}

// MinimockSDKClientInspect logs each unmet expectation
func (m *ACLClientMock) MinimockSDKClientInspect() {
	for _, e := range m.SDKClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientMock.SDKClient")
		}
	}

	afterSDKClientCounter := mm_atomic.LoadUint64(&m.afterSDKClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SDKClientMock.defaultExpectation != nil && afterSDKClientCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.SDKClient at\n%s", m.SDKClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSDKClient != nil && afterSDKClientCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.SDKClient at\n%s", m.funcSDKClientOrigin)
	}

	if !m.SDKClientMock.invocationsDone() && afterSDKClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.SDKClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SDKClientMock.expectedInvocations), m.SDKClientMock.expectedInvocationsOrigin, afterSDKClientCounter)
	}
}

type mACLClientMockSetAuthorizationModelID struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockSetAuthorizationModelIDExpectation
	expectations       []*ACLClientMockSetAuthorizationModelIDExpectation

	callArgs []*ACLClientMockSetAuthorizationModelIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockSetAuthorizationModelIDExpectation specifies expectation struct of the ACLClient.SetAuthorizationModelID
type ACLClientMockSetAuthorizationModelIDExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockSetAuthorizationModelIDParams
	paramPtrs          *ACLClientMockSetAuthorizationModelIDParamPtrs
	expectationOrigins ACLClientMockSetAuthorizationModelIDExpectationOrigins
	results            *ACLClientMockSetAuthorizationModelIDResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockSetAuthorizationModelIDParams contains parameters of the ACLClient.SetAuthorizationModelID
type ACLClientMockSetAuthorizationModelIDParams struct {
	modelID string
}

// ACLClientMockSetAuthorizationModelIDParamPtrs contains pointers to parameters of the ACLClient.SetAuthorizationModelID
type ACLClientMockSetAuthorizationModelIDParamPtrs struct {
	modelID *string
}

// ACLClientMockSetAuthorizationModelIDResults contains results of the ACLClient.SetAuthorizationModelID
type ACLClientMockSetAuthorizationModelIDResults struct {
	err error
}

// ACLClientMockSetAuthorizationModelIDOrigins contains origins of expectations of the ACLClient.SetAuthorizationModelID
type ACLClientMockSetAuthorizationModelIDExpectationOrigins struct {
	origin        string
	originModelID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) Optional() *mACLClientMockSetAuthorizationModelID {
	mmSetAuthorizationModelID.optional = true
	return mmSetAuthorizationModelID
}

// Expect sets up expected params for ACLClient.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) Expect(modelID string) *mACLClientMockSetAuthorizationModelID {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.SetAuthorizationModelID mock is already set by Set")
	}

	if mmSetAuthorizationModelID.defaultExpectation == nil {
		mmSetAuthorizationModelID.defaultExpectation = &ACLClientMockSetAuthorizationModelIDExpectation{}
	}

	if mmSetAuthorizationModelID.defaultExpectation.paramPtrs != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.SetAuthorizationModelID mock is already set by ExpectParams functions")
	}

	mmSetAuthorizationModelID.defaultExpectation.params = &ACLClientMockSetAuthorizationModelIDParams{modelID}
	mmSetAuthorizationModelID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetAuthorizationModelID.expectations {
		if minimock.Equal(e.params, mmSetAuthorizationModelID.defaultExpectation.params) {
			mmSetAuthorizationModelID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetAuthorizationModelID.defaultExpectation.params)
		}
	}

	return mmSetAuthorizationModelID
}

// ExpectModelIDParam1 sets up expected param modelID for ACLClient.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) ExpectModelIDParam1(modelID string) *mACLClientMockSetAuthorizationModelID {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.SetAuthorizationModelID mock is already set by Set")
	}

	if mmSetAuthorizationModelID.defaultExpectation == nil {
		mmSetAuthorizationModelID.defaultExpectation = &ACLClientMockSetAuthorizationModelIDExpectation{}
	}

	if mmSetAuthorizationModelID.defaultExpectation.params != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.SetAuthorizationModelID mock is already set by Expect")
	}

	if mmSetAuthorizationModelID.defaultExpectation.paramPtrs == nil {
		mmSetAuthorizationModelID.defaultExpectation.paramPtrs = &ACLClientMockSetAuthorizationModelIDParamPtrs{}
	}
	mmSetAuthorizationModelID.defaultExpectation.paramPtrs.modelID = &modelID
	mmSetAuthorizationModelID.defaultExpectation.expectationOrigins.originModelID = minimock.CallerInfo(1)

	return mmSetAuthorizationModelID
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) Inspect(f func(modelID string)) *mACLClientMockSetAuthorizationModelID {
	if mmSetAuthorizationModelID.mock.inspectFuncSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("Inspect function is already set for ACLClientMock.SetAuthorizationModelID")
	}

	mmSetAuthorizationModelID.mock.inspectFuncSetAuthorizationModelID = f

	return mmSetAuthorizationModelID
}

// Return sets up results that will be returned by ACLClient.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) Return(err error) *ACLClientMock {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.SetAuthorizationModelID mock is already set by Set")
	}

	if mmSetAuthorizationModelID.defaultExpectation == nil {
		mmSetAuthorizationModelID.defaultExpectation = &ACLClientMockSetAuthorizationModelIDExpectation{mock: mmSetAuthorizationModelID.mock}
	}
	mmSetAuthorizationModelID.defaultExpectation.results = &ACLClientMockSetAuthorizationModelIDResults{err}
	mmSetAuthorizationModelID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetAuthorizationModelID.mock
}

// Set uses given function f to mock the ACLClient.SetAuthorizationModelID method
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) Set(f func(modelID string) (err error)) *ACLClientMock {
	if mmSetAuthorizationModelID.defaultExpectation != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("Default expectation is already set for the ACLClient.SetAuthorizationModelID method")
	}

	if len(mmSetAuthorizationModelID.expectations) > 0 {
		mmSetAuthorizationModelID.mock.t.Fatalf("Some expectations are already set for the ACLClient.SetAuthorizationModelID method")
	}

	mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID = f
	mmSetAuthorizationModelID.mock.funcSetAuthorizationModelIDOrigin = minimock.CallerInfo(1)
	return mmSetAuthorizationModelID.mock
}

// When sets expectation for the ACLClient.SetAuthorizationModelID which will trigger the result defined by the following
// Then helper
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) When(modelID string) *ACLClientMockSetAuthorizationModelIDExpectation {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientMock.SetAuthorizationModelID mock is already set by Set")
	}

	expectation := &ACLClientMockSetAuthorizationModelIDExpectation{
		mock:               mmSetAuthorizationModelID.mock,
		params:             &ACLClientMockSetAuthorizationModelIDParams{modelID},
		expectationOrigins: ACLClientMockSetAuthorizationModelIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetAuthorizationModelID.expectations = append(mmSetAuthorizationModelID.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.SetAuthorizationModelID return parameters for the expectation previously defined by the When method
func (e *ACLClientMockSetAuthorizationModelIDExpectation) Then(err error) *ACLClientMock {
	e.results = &ACLClientMockSetAuthorizationModelIDResults{err}
	return e.mock
}

// Times sets number of times ACLClient.SetAuthorizationModelID should be invoked
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) Times(n uint64) *mACLClientMockSetAuthorizationModelID {
	if n == 0 {
		mmSetAuthorizationModelID.mock.t.Fatalf("Times of ACLClientMock.SetAuthorizationModelID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetAuthorizationModelID.expectedInvocations, n)
	mmSetAuthorizationModelID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetAuthorizationModelID
}

func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) invocationsDone() bool {
	if len(mmSetAuthorizationModelID.expectations) == 0 && mmSetAuthorizationModelID.defaultExpectation == nil && mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetAuthorizationModelID.mock.afterSetAuthorizationModelIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetAuthorizationModelID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetAuthorizationModelID implements mm_acl.ACLClient
func (mmSetAuthorizationModelID *ACLClientMock) SetAuthorizationModelID(modelID string) (err error) {
	mm_atomic.AddUint64(&mmSetAuthorizationModelID.beforeSetAuthorizationModelIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetAuthorizationModelID.afterSetAuthorizationModelIDCounter, 1)

	mmSetAuthorizationModelID.t.Helper()

	if mmSetAuthorizationModelID.inspectFuncSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.inspectFuncSetAuthorizationModelID(modelID)
	}

	mm_params := ACLClientMockSetAuthorizationModelIDParams{modelID}

	// Record call args
	mmSetAuthorizationModelID.SetAuthorizationModelIDMock.mutex.Lock()
	mmSetAuthorizationModelID.SetAuthorizationModelIDMock.callArgs = append(mmSetAuthorizationModelID.SetAuthorizationModelIDMock.callArgs, &mm_params)
	mmSetAuthorizationModelID.SetAuthorizationModelIDMock.mutex.Unlock()

	for _, e := range mmSetAuthorizationModelID.SetAuthorizationModelIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockSetAuthorizationModelIDParams{modelID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.modelID != nil && !minimock.Equal(*mm_want_ptrs.modelID, mm_got.modelID) {
				mmSetAuthorizationModelID.t.Errorf("ACLClientMock.SetAuthorizationModelID got unexpected parameter modelID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.expectationOrigins.originModelID, *mm_want_ptrs.modelID, mm_got.modelID, minimock.Diff(*mm_want_ptrs.modelID, mm_got.modelID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetAuthorizationModelID.t.Errorf("ACLClientMock.SetAuthorizationModelID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetAuthorizationModelID.t.Fatal("No results are set for the ACLClientMock.SetAuthorizationModelID")
		}
		return (*mm_results).err
	}
	if mmSetAuthorizationModelID.funcSetAuthorizationModelID != nil {
		return mmSetAuthorizationModelID.funcSetAuthorizationModelID(modelID)
	}
	mmSetAuthorizationModelID.t.Fatalf("Unexpected call to ACLClientMock.SetAuthorizationModelID. %v", modelID)
	return
}

// SetAuthorizationModelIDAfterCounter returns a count of finished ACLClientMock.SetAuthorizationModelID invocations
func (mmSetAuthorizationModelID *ACLClientMock) SetAuthorizationModelIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetAuthorizationModelID.afterSetAuthorizationModelIDCounter)
}

// SetAuthorizationModelIDBeforeCounter returns a count of ACLClientMock.SetAuthorizationModelID invocations
func (mmSetAuthorizationModelID *ACLClientMock) SetAuthorizationModelIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetAuthorizationModelID.beforeSetAuthorizationModelIDCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.SetAuthorizationModelID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetAuthorizationModelID *mACLClientMockSetAuthorizationModelID) Calls() []*ACLClientMockSetAuthorizationModelIDParams {
	mmSetAuthorizationModelID.mutex.RLock()

	argCopy := make([]*ACLClientMockSetAuthorizationModelIDParams, len(mmSetAuthorizationModelID.callArgs))
	copy(argCopy, mmSetAuthorizationModelID.callArgs)

	mmSetAuthorizationModelID.mutex.RUnlock()

	return argCopy
}

// MinimockSetAuthorizationModelIDDone returns true if the count of the SetAuthorizationModelID invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockSetAuthorizationModelIDDone() bool {
	if m.SetAuthorizationModelIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetAuthorizationModelIDMock.invocationsDone()
}

// MinimockSetAuthorizationModelIDInspect logs each unmet expectation
func (m *ACLClientMock) MinimockSetAuthorizationModelIDInspect() {
	for _, e := range m.SetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.SetAuthorizationModelID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetAuthorizationModelIDCounter := mm_atomic.LoadUint64(&m.afterSetAuthorizationModelIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetAuthorizationModelIDMock.defaultExpectation != nil && afterSetAuthorizationModelIDCounter < 1 {
		if m.SetAuthorizationModelIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.SetAuthorizationModelID at\n%s", m.SetAuthorizationModelIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.SetAuthorizationModelID at\n%s with params: %#v", m.SetAuthorizationModelIDMock.defaultExpectation.expectationOrigins.origin, *m.SetAuthorizationModelIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetAuthorizationModelID != nil && afterSetAuthorizationModelIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.SetAuthorizationModelID at\n%s", m.funcSetAuthorizationModelIDOrigin)
	}

	if !m.SetAuthorizationModelIDMock.invocationsDone() && afterSetAuthorizationModelIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.SetAuthorizationModelID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetAuthorizationModelIDMock.expectedInvocations), m.SetAuthorizationModelIDMock.expectedInvocationsOrigin, afterSetAuthorizationModelIDCounter)
	}
}

type mACLClientMockSetOwner struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockSetOwnerExpectation
	expectations       []*ACLClientMockSetOwnerExpectation

	callArgs []*ACLClientMockSetOwnerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockSetOwnerExpectation specifies expectation struct of the ACLClient.SetOwner
type ACLClientMockSetOwnerExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockSetOwnerParams
	paramPtrs          *ACLClientMockSetOwnerParamPtrs
	expectationOrigins ACLClientMockSetOwnerExpectationOrigins
	results            *ACLClientMockSetOwnerResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockSetOwnerParams contains parameters of the ACLClient.SetOwner
type ACLClientMockSetOwnerParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
	ownerType  openfga.OwnerType
	ownerUID   uuid.UUID
}

// ACLClientMockSetOwnerParamPtrs contains pointers to parameters of the ACLClient.SetOwner
type ACLClientMockSetOwnerParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
	ownerType  *openfga.OwnerType
	ownerUID   *uuid.UUID
}

// ACLClientMockSetOwnerResults contains results of the ACLClient.SetOwner
type ACLClientMockSetOwnerResults struct {
	err error
}

// ACLClientMockSetOwnerOrigins contains origins of expectations of the ACLClient.SetOwner
type ACLClientMockSetOwnerExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originOwnerType  string
	originOwnerUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOwner *mACLClientMockSetOwner) Optional() *mACLClientMockSetOwner {
	mmSetOwner.optional = true
	return mmSetOwner
}

// Expect sets up expected params for ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) *mACLClientMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.paramPtrs != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by ExpectParams functions")
	}

	mmSetOwner.defaultExpectation.params = &ACLClientMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}
	mmSetOwner.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOwner.expectations {
		if minimock.Equal(e.params, mmSetOwner.defaultExpectation.params) {
			mmSetOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOwner.defaultExpectation.params)
		}
	}

	return mmSetOwner
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) ExpectCtxParam1(ctx context.Context) *mACLClientMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetOwner.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectType = &objectType
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerTypeParam4 sets up expected param ownerType for ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) ExpectOwnerTypeParam4(ownerType openfga.OwnerType) *mACLClientMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerType = &ownerType
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerUIDParam5 sets up expected param ownerUID for ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) ExpectOwnerUIDParam5(ownerUID uuid.UUID) *mACLClientMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID)) *mACLClientMockSetOwner {
	if mmSetOwner.mock.inspectFuncSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("Inspect function is already set for ACLClientMock.SetOwner")
	}

	mmSetOwner.mock.inspectFuncSetOwner = f

	return mmSetOwner
}

// Return sets up results that will be returned by ACLClient.SetOwner
func (mmSetOwner *mACLClientMockSetOwner) Return(err error) *ACLClientMock {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientMockSetOwnerExpectation{mock: mmSetOwner.mock}
	}
	mmSetOwner.defaultExpectation.results = &ACLClientMockSetOwnerResults{err}
	mmSetOwner.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// Set uses given function f to mock the ACLClient.SetOwner method
func (mmSetOwner *mACLClientMockSetOwner) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) (err error)) *ACLClientMock {
	if mmSetOwner.defaultExpectation != nil {
		mmSetOwner.mock.t.Fatalf("Default expectation is already set for the ACLClient.SetOwner method")
	}

	if len(mmSetOwner.expectations) > 0 {
		mmSetOwner.mock.t.Fatalf("Some expectations are already set for the ACLClient.SetOwner method")
	}

	mmSetOwner.mock.funcSetOwner = f
	mmSetOwner.mock.funcSetOwnerOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// When sets expectation for the ACLClient.SetOwner which will trigger the result defined by the following
// Then helper
func (mmSetOwner *mACLClientMockSetOwner) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) *ACLClientMockSetOwnerExpectation {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientMock.SetOwner mock is already set by Set")
	}

	expectation := &ACLClientMockSetOwnerExpectation{
		mock:               mmSetOwner.mock,
		params:             &ACLClientMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID},
		expectationOrigins: ACLClientMockSetOwnerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOwner.expectations = append(mmSetOwner.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.SetOwner return parameters for the expectation previously defined by the When method
func (e *ACLClientMockSetOwnerExpectation) Then(err error) *ACLClientMock {
	e.results = &ACLClientMockSetOwnerResults{err}
	return e.mock
}

// Times sets number of times ACLClient.SetOwner should be invoked
func (mmSetOwner *mACLClientMockSetOwner) Times(n uint64) *mACLClientMockSetOwner {
	if n == 0 {
		mmSetOwner.mock.t.Fatalf("Times of ACLClientMock.SetOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOwner.expectedInvocations, n)
	mmSetOwner.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOwner
}

func (mmSetOwner *mACLClientMockSetOwner) invocationsDone() bool {
	if len(mmSetOwner.expectations) == 0 && mmSetOwner.defaultExpectation == nil && mmSetOwner.mock.funcSetOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOwner.mock.afterSetOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOwner implements mm_acl.ACLClient
func (mmSetOwner *ACLClientMock) SetOwner(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSetOwner.beforeSetOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOwner.afterSetOwnerCounter, 1)

	mmSetOwner.t.Helper()

	if mmSetOwner.inspectFuncSetOwner != nil {
		mmSetOwner.inspectFuncSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}

	mm_params := ACLClientMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

	// Record call args
	mmSetOwner.SetOwnerMock.mutex.Lock()
	mmSetOwner.SetOwnerMock.callArgs = append(mmSetOwner.SetOwnerMock.callArgs, &mm_params)
	mmSetOwner.SetOwnerMock.mutex.Unlock()

	for _, e := range mmSetOwner.SetOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOwner.SetOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOwner.SetOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOwner.SetOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmSetOwner.SetOwnerMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOwner.t.Errorf("ACLClientMock.SetOwner got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmSetOwner.t.Errorf("ACLClientMock.SetOwner got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmSetOwner.t.Errorf("ACLClientMock.SetOwner got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.ownerType != nil && !minimock.Equal(*mm_want_ptrs.ownerType, mm_got.ownerType) {
				mmSetOwner.t.Errorf("ACLClientMock.SetOwner got unexpected parameter ownerType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerType, *mm_want_ptrs.ownerType, mm_got.ownerType, minimock.Diff(*mm_want_ptrs.ownerType, mm_got.ownerType))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmSetOwner.t.Errorf("ACLClientMock.SetOwner got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOwner.t.Errorf("ACLClientMock.SetOwner got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOwner.SetOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOwner.t.Fatal("No results are set for the ACLClientMock.SetOwner")
		}
		return (*mm_results).err
	}
	if mmSetOwner.funcSetOwner != nil {
		return mmSetOwner.funcSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}
	mmSetOwner.t.Fatalf("Unexpected call to ACLClientMock.SetOwner. %v %v %v %v %v", ctx, objectType, objectUID, ownerType, ownerUID)
	return
}

// SetOwnerAfterCounter returns a count of finished ACLClientMock.SetOwner invocations
func (mmSetOwner *ACLClientMock) SetOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.afterSetOwnerCounter)
}

// SetOwnerBeforeCounter returns a count of ACLClientMock.SetOwner invocations
func (mmSetOwner *ACLClientMock) SetOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.beforeSetOwnerCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.SetOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOwner *mACLClientMockSetOwner) Calls() []*ACLClientMockSetOwnerParams {
	mmSetOwner.mutex.RLock()

	argCopy := make([]*ACLClientMockSetOwnerParams, len(mmSetOwner.callArgs))
	copy(argCopy, mmSetOwner.callArgs)

	mmSetOwner.mutex.RUnlock()

	return argCopy
}

// MinimockSetOwnerDone returns true if the count of the SetOwner invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockSetOwnerDone() bool {
	if m.SetOwnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOwnerMock.invocationsDone()
}

// MinimockSetOwnerInspect logs each unmet expectation
func (m *ACLClientMock) MinimockSetOwnerInspect() {
	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.SetOwner at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOwnerCounter := mm_atomic.LoadUint64(&m.afterSetOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOwnerMock.defaultExpectation != nil && afterSetOwnerCounter < 1 {
		if m.SetOwnerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.SetOwner at\n%s", m.SetOwnerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.SetOwner at\n%s with params: %#v", m.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *m.SetOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOwner != nil && afterSetOwnerCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.SetOwner at\n%s", m.funcSetOwnerOrigin)
	}

	if !m.SetOwnerMock.invocationsDone() && afterSetOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.SetOwner at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOwnerMock.expectedInvocations), m.SetOwnerMock.expectedInvocationsOrigin, afterSetOwnerCounter)
	}
}

type mACLClientMockSetPipelinePermission struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockSetPipelinePermissionExpectation
	expectations       []*ACLClientMockSetPipelinePermissionExpectation

	callArgs []*ACLClientMockSetPipelinePermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockSetPipelinePermissionExpectation specifies expectation struct of the ACLClient.SetPipelinePermission
type ACLClientMockSetPipelinePermissionExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockSetPipelinePermissionParams
	paramPtrs          *ACLClientMockSetPipelinePermissionParamPtrs
	expectationOrigins ACLClientMockSetPipelinePermissionExpectationOrigins
	results            *ACLClientMockSetPipelinePermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockSetPipelinePermissionParams contains parameters of the ACLClient.SetPipelinePermission
type ACLClientMockSetPipelinePermissionParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	user        string
	role        string
	enable      bool
}

// ACLClientMockSetPipelinePermissionParamPtrs contains pointers to parameters of the ACLClient.SetPipelinePermission
type ACLClientMockSetPipelinePermissionParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	user        *string
	role        *string
	enable      *bool
}

// ACLClientMockSetPipelinePermissionResults contains results of the ACLClient.SetPipelinePermission
type ACLClientMockSetPipelinePermissionResults struct {
	err error
}

// ACLClientMockSetPipelinePermissionOrigins contains origins of expectations of the ACLClient.SetPipelinePermission
type ACLClientMockSetPipelinePermissionExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originUser        string
	originRole        string
	originEnable      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) Optional() *mACLClientMockSetPipelinePermission {
	mmSetPipelinePermission.optional = true
	return mmSetPipelinePermission
}

// Expect sets up expected params for ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) Expect(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) *mACLClientMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by ExpectParams functions")
	}

	mmSetPipelinePermission.defaultExpectation.params = &ACLClientMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetPipelinePermission.expectations {
		if minimock.Equal(e.params, mmSetPipelinePermission.defaultExpectation.params) {
			mmSetPipelinePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPipelinePermission.defaultExpectation.params)
		}
	}

	return mmSetPipelinePermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) ExpectCtxParam1(ctx context.Context) *mACLClientMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mACLClientMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectUserParam3 sets up expected param user for ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) ExpectUserParam3(user string) *mACLClientMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.user = &user
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectRoleParam4 sets up expected param role for ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) ExpectRoleParam4(role string) *mACLClientMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.role = &role
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectEnableParam5 sets up expected param enable for ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) ExpectEnableParam5(enable bool) *mACLClientMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.enable = &enable
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originEnable = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool)) *mACLClientMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.inspectFuncSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("Inspect function is already set for ACLClientMock.SetPipelinePermission")
	}

	mmSetPipelinePermission.mock.inspectFuncSetPipelinePermission = f

	return mmSetPipelinePermission
}

// Return sets up results that will be returned by ACLClient.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) Return(err error) *ACLClientMock {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientMockSetPipelinePermissionExpectation{mock: mmSetPipelinePermission.mock}
	}
	mmSetPipelinePermission.defaultExpectation.results = &ACLClientMockSetPipelinePermissionResults{err}
	mmSetPipelinePermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermission.mock
}

// Set uses given function f to mock the ACLClient.SetPipelinePermission method
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) Set(f func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error)) *ACLClientMock {
	if mmSetPipelinePermission.defaultExpectation != nil {
		mmSetPipelinePermission.mock.t.Fatalf("Default expectation is already set for the ACLClient.SetPipelinePermission method")
	}

	if len(mmSetPipelinePermission.expectations) > 0 {
		mmSetPipelinePermission.mock.t.Fatalf("Some expectations are already set for the ACLClient.SetPipelinePermission method")
	}

	mmSetPipelinePermission.mock.funcSetPipelinePermission = f
	mmSetPipelinePermission.mock.funcSetPipelinePermissionOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermission.mock
}

// When sets expectation for the ACLClient.SetPipelinePermission which will trigger the result defined by the following
// Then helper
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) When(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) *ACLClientMockSetPipelinePermissionExpectation {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientMock.SetPipelinePermission mock is already set by Set")
	}

	expectation := &ACLClientMockSetPipelinePermissionExpectation{
		mock:               mmSetPipelinePermission.mock,
		params:             &ACLClientMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable},
		expectationOrigins: ACLClientMockSetPipelinePermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetPipelinePermission.expectations = append(mmSetPipelinePermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.SetPipelinePermission return parameters for the expectation previously defined by the When method
func (e *ACLClientMockSetPipelinePermissionExpectation) Then(err error) *ACLClientMock {
	e.results = &ACLClientMockSetPipelinePermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClient.SetPipelinePermission should be invoked
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) Times(n uint64) *mACLClientMockSetPipelinePermission {
	if n == 0 {
		mmSetPipelinePermission.mock.t.Fatalf("Times of ACLClientMock.SetPipelinePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPipelinePermission.expectedInvocations, n)
	mmSetPipelinePermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermission
}

func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) invocationsDone() bool {
	if len(mmSetPipelinePermission.expectations) == 0 && mmSetPipelinePermission.defaultExpectation == nil && mmSetPipelinePermission.mock.funcSetPipelinePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermission.mock.afterSetPipelinePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPipelinePermission implements mm_acl.ACLClient
func (mmSetPipelinePermission *ACLClientMock) SetPipelinePermission(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error) {
	mm_atomic.AddUint64(&mmSetPipelinePermission.beforeSetPipelinePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPipelinePermission.afterSetPipelinePermissionCounter, 1)

	mmSetPipelinePermission.t.Helper()

	if mmSetPipelinePermission.inspectFuncSetPipelinePermission != nil {
		mmSetPipelinePermission.inspectFuncSetPipelinePermission(ctx, pipelineUID, user, role, enable)
	}

	mm_params := ACLClientMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}

	// Record call args
	mmSetPipelinePermission.SetPipelinePermissionMock.mutex.Lock()
	mmSetPipelinePermission.SetPipelinePermissionMock.callArgs = append(mmSetPipelinePermission.SetPipelinePermissionMock.callArgs, &mm_params)
	mmSetPipelinePermission.SetPipelinePermissionMock.mutex.Unlock()

	for _, e := range mmSetPipelinePermission.SetPipelinePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPipelinePermission.t.Errorf("ACLClientMock.SetPipelinePermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmSetPipelinePermission.t.Errorf("ACLClientMock.SetPipelinePermission got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSetPipelinePermission.t.Errorf("ACLClientMock.SetPipelinePermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmSetPipelinePermission.t.Errorf("ACLClientMock.SetPipelinePermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.enable != nil && !minimock.Equal(*mm_want_ptrs.enable, mm_got.enable) {
				mmSetPipelinePermission.t.Errorf("ACLClientMock.SetPipelinePermission got unexpected parameter enable, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originEnable, *mm_want_ptrs.enable, mm_got.enable, minimock.Diff(*mm_want_ptrs.enable, mm_got.enable))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPipelinePermission.t.Errorf("ACLClientMock.SetPipelinePermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPipelinePermission.t.Fatal("No results are set for the ACLClientMock.SetPipelinePermission")
		}
		return (*mm_results).err
	}
	if mmSetPipelinePermission.funcSetPipelinePermission != nil {
		return mmSetPipelinePermission.funcSetPipelinePermission(ctx, pipelineUID, user, role, enable)
	}
	mmSetPipelinePermission.t.Fatalf("Unexpected call to ACLClientMock.SetPipelinePermission. %v %v %v %v %v", ctx, pipelineUID, user, role, enable)
	return
}

// SetPipelinePermissionAfterCounter returns a count of finished ACLClientMock.SetPipelinePermission invocations
func (mmSetPipelinePermission *ACLClientMock) SetPipelinePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermission.afterSetPipelinePermissionCounter)
}

// SetPipelinePermissionBeforeCounter returns a count of ACLClientMock.SetPipelinePermission invocations
func (mmSetPipelinePermission *ACLClientMock) SetPipelinePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermission.beforeSetPipelinePermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.SetPipelinePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPipelinePermission *mACLClientMockSetPipelinePermission) Calls() []*ACLClientMockSetPipelinePermissionParams {
	mmSetPipelinePermission.mutex.RLock()

	argCopy := make([]*ACLClientMockSetPipelinePermissionParams, len(mmSetPipelinePermission.callArgs))
	copy(argCopy, mmSetPipelinePermission.callArgs)

	mmSetPipelinePermission.mutex.RUnlock()

	return argCopy
}

// MinimockSetPipelinePermissionDone returns true if the count of the SetPipelinePermission invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockSetPipelinePermissionDone() bool {
	if m.SetPipelinePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPipelinePermissionMock.invocationsDone()
}

// MinimockSetPipelinePermissionInspect logs each unmet expectation
func (m *ACLClientMock) MinimockSetPipelinePermissionInspect() {
	for _, e := range m.SetPipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetPipelinePermissionCounter := mm_atomic.LoadUint64(&m.afterSetPipelinePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPipelinePermissionMock.defaultExpectation != nil && afterSetPipelinePermissionCounter < 1 {
		if m.SetPipelinePermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermission at\n%s", m.SetPipelinePermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermission at\n%s with params: %#v", m.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *m.SetPipelinePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPipelinePermission != nil && afterSetPipelinePermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermission at\n%s", m.funcSetPipelinePermissionOrigin)
	}

	if !m.SetPipelinePermissionMock.invocationsDone() && afterSetPipelinePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.SetPipelinePermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetPipelinePermissionMock.expectedInvocations), m.SetPipelinePermissionMock.expectedInvocationsOrigin, afterSetPipelinePermissionCounter)
	}
}

type mACLClientMockSetPipelinePermissionMap struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockSetPipelinePermissionMapExpectation
	expectations       []*ACLClientMockSetPipelinePermissionMapExpectation

	callArgs []*ACLClientMockSetPipelinePermissionMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockSetPipelinePermissionMapExpectation specifies expectation struct of the ACLClient.SetPipelinePermissionMap
type ACLClientMockSetPipelinePermissionMapExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockSetPipelinePermissionMapParams
	paramPtrs          *ACLClientMockSetPipelinePermissionMapParamPtrs
	expectationOrigins ACLClientMockSetPipelinePermissionMapExpectationOrigins
	results            *ACLClientMockSetPipelinePermissionMapResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockSetPipelinePermissionMapParams contains parameters of the ACLClient.SetPipelinePermissionMap
type ACLClientMockSetPipelinePermissionMapParams struct {
	ctx      context.Context
	pipeline *datamodel.Pipeline
}

// ACLClientMockSetPipelinePermissionMapParamPtrs contains pointers to parameters of the ACLClient.SetPipelinePermissionMap
type ACLClientMockSetPipelinePermissionMapParamPtrs struct {
	ctx      *context.Context
	pipeline **datamodel.Pipeline
}

// ACLClientMockSetPipelinePermissionMapResults contains results of the ACLClient.SetPipelinePermissionMap
type ACLClientMockSetPipelinePermissionMapResults struct {
	err error
}

// ACLClientMockSetPipelinePermissionMapOrigins contains origins of expectations of the ACLClient.SetPipelinePermissionMap
type ACLClientMockSetPipelinePermissionMapExpectationOrigins struct {
	origin         string
	originCtx      string
	originPipeline string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) Optional() *mACLClientMockSetPipelinePermissionMap {
	mmSetPipelinePermissionMap.optional = true
	return mmSetPipelinePermissionMap
}

// Expect sets up expected params for ACLClient.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) Expect(ctx context.Context, pipeline *datamodel.Pipeline) *mACLClientMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by ExpectParams functions")
	}

	mmSetPipelinePermissionMap.defaultExpectation.params = &ACLClientMockSetPipelinePermissionMapParams{ctx, pipeline}
	mmSetPipelinePermissionMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetPipelinePermissionMap.expectations {
		if minimock.Equal(e.params, mmSetPipelinePermissionMap.defaultExpectation.params) {
			mmSetPipelinePermissionMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPipelinePermissionMap.defaultExpectation.params)
		}
	}

	return mmSetPipelinePermissionMap
}

// ExpectCtxParam1 sets up expected param ctx for ACLClient.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) ExpectCtxParam1(ctx context.Context) *mACLClientMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.params != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by Expect")
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermissionMap.defaultExpectation.paramPtrs = &ACLClientMockSetPipelinePermissionMapParamPtrs{}
	}
	mmSetPipelinePermissionMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetPipelinePermissionMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetPipelinePermissionMap
}

// ExpectPipelineParam2 sets up expected param pipeline for ACLClient.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) ExpectPipelineParam2(pipeline *datamodel.Pipeline) *mACLClientMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.params != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by Expect")
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermissionMap.defaultExpectation.paramPtrs = &ACLClientMockSetPipelinePermissionMapParamPtrs{}
	}
	mmSetPipelinePermissionMap.defaultExpectation.paramPtrs.pipeline = &pipeline
	mmSetPipelinePermissionMap.defaultExpectation.expectationOrigins.originPipeline = minimock.CallerInfo(1)

	return mmSetPipelinePermissionMap
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) Inspect(f func(ctx context.Context, pipeline *datamodel.Pipeline)) *mACLClientMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.inspectFuncSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Inspect function is already set for ACLClientMock.SetPipelinePermissionMap")
	}

	mmSetPipelinePermissionMap.mock.inspectFuncSetPipelinePermissionMap = f

	return mmSetPipelinePermissionMap
}

// Return sets up results that will be returned by ACLClient.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) Return(err error) *ACLClientMock {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientMockSetPipelinePermissionMapExpectation{mock: mmSetPipelinePermissionMap.mock}
	}
	mmSetPipelinePermissionMap.defaultExpectation.results = &ACLClientMockSetPipelinePermissionMapResults{err}
	mmSetPipelinePermissionMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermissionMap.mock
}

// Set uses given function f to mock the ACLClient.SetPipelinePermissionMap method
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) Set(f func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)) *ACLClientMock {
	if mmSetPipelinePermissionMap.defaultExpectation != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Default expectation is already set for the ACLClient.SetPipelinePermissionMap method")
	}

	if len(mmSetPipelinePermissionMap.expectations) > 0 {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Some expectations are already set for the ACLClient.SetPipelinePermissionMap method")
	}

	mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap = f
	mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMapOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermissionMap.mock
}

// When sets expectation for the ACLClient.SetPipelinePermissionMap which will trigger the result defined by the following
// Then helper
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) When(ctx context.Context, pipeline *datamodel.Pipeline) *ACLClientMockSetPipelinePermissionMapExpectation {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientMock.SetPipelinePermissionMap mock is already set by Set")
	}

	expectation := &ACLClientMockSetPipelinePermissionMapExpectation{
		mock:               mmSetPipelinePermissionMap.mock,
		params:             &ACLClientMockSetPipelinePermissionMapParams{ctx, pipeline},
		expectationOrigins: ACLClientMockSetPipelinePermissionMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetPipelinePermissionMap.expectations = append(mmSetPipelinePermissionMap.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.SetPipelinePermissionMap return parameters for the expectation previously defined by the When method
func (e *ACLClientMockSetPipelinePermissionMapExpectation) Then(err error) *ACLClientMock {
	e.results = &ACLClientMockSetPipelinePermissionMapResults{err}
	return e.mock
}

// Times sets number of times ACLClient.SetPipelinePermissionMap should be invoked
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) Times(n uint64) *mACLClientMockSetPipelinePermissionMap {
	if n == 0 {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Times of ACLClientMock.SetPipelinePermissionMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPipelinePermissionMap.expectedInvocations, n)
	mmSetPipelinePermissionMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermissionMap
}

func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) invocationsDone() bool {
	if len(mmSetPipelinePermissionMap.expectations) == 0 && mmSetPipelinePermissionMap.defaultExpectation == nil && mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.mock.afterSetPipelinePermissionMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPipelinePermissionMap implements mm_acl.ACLClient
func (mmSetPipelinePermissionMap *ACLClientMock) SetPipelinePermissionMap(ctx context.Context, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmSetPipelinePermissionMap.beforeSetPipelinePermissionMapCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPipelinePermissionMap.afterSetPipelinePermissionMapCounter, 1)

	mmSetPipelinePermissionMap.t.Helper()

	if mmSetPipelinePermissionMap.inspectFuncSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.inspectFuncSetPipelinePermissionMap(ctx, pipeline)
	}

	mm_params := ACLClientMockSetPipelinePermissionMapParams{ctx, pipeline}

	// Record call args
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.mutex.Lock()
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.callArgs = append(mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.callArgs, &mm_params)
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.mutex.Unlock()

	for _, e := range mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.params
		mm_want_ptrs := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockSetPipelinePermissionMapParams{ctx, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPipelinePermissionMap.t.Errorf("ACLClientMock.SetPipelinePermissionMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmSetPipelinePermissionMap.t.Errorf("ACLClientMock.SetPipelinePermissionMap got unexpected parameter pipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.originPipeline, *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPipelinePermissionMap.t.Errorf("ACLClientMock.SetPipelinePermissionMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPipelinePermissionMap.t.Fatal("No results are set for the ACLClientMock.SetPipelinePermissionMap")
		}
		return (*mm_results).err
	}
	if mmSetPipelinePermissionMap.funcSetPipelinePermissionMap != nil {
		return mmSetPipelinePermissionMap.funcSetPipelinePermissionMap(ctx, pipeline)
	}
	mmSetPipelinePermissionMap.t.Fatalf("Unexpected call to ACLClientMock.SetPipelinePermissionMap. %v %v", ctx, pipeline)
	return
}

// SetPipelinePermissionMapAfterCounter returns a count of finished ACLClientMock.SetPipelinePermissionMap invocations
func (mmSetPipelinePermissionMap *ACLClientMock) SetPipelinePermissionMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.afterSetPipelinePermissionMapCounter)
}

// SetPipelinePermissionMapBeforeCounter returns a count of ACLClientMock.SetPipelinePermissionMap invocations
func (mmSetPipelinePermissionMap *ACLClientMock) SetPipelinePermissionMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.beforeSetPipelinePermissionMapCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.SetPipelinePermissionMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPipelinePermissionMap *mACLClientMockSetPipelinePermissionMap) Calls() []*ACLClientMockSetPipelinePermissionMapParams {
	mmSetPipelinePermissionMap.mutex.RLock()

	argCopy := make([]*ACLClientMockSetPipelinePermissionMapParams, len(mmSetPipelinePermissionMap.callArgs))
	copy(argCopy, mmSetPipelinePermissionMap.callArgs)

	mmSetPipelinePermissionMap.mutex.RUnlock()

	return argCopy
}

// MinimockSetPipelinePermissionMapDone returns true if the count of the SetPipelinePermissionMap invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockSetPipelinePermissionMapDone() bool {
	if m.SetPipelinePermissionMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPipelinePermissionMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPipelinePermissionMapMock.invocationsDone()
}

// MinimockSetPipelinePermissionMapInspect logs each unmet expectation
func (m *ACLClientMock) MinimockSetPipelinePermissionMapInspect() {
	for _, e := range m.SetPipelinePermissionMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermissionMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetPipelinePermissionMapCounter := mm_atomic.LoadUint64(&m.afterSetPipelinePermissionMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPipelinePermissionMapMock.defaultExpectation != nil && afterSetPipelinePermissionMapCounter < 1 {
		if m.SetPipelinePermissionMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermissionMap at\n%s", m.SetPipelinePermissionMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermissionMap at\n%s with params: %#v", m.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.origin, *m.SetPipelinePermissionMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPipelinePermissionMap != nil && afterSetPipelinePermissionMapCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.SetPipelinePermissionMap at\n%s", m.funcSetPipelinePermissionMapOrigin)
	}

	if !m.SetPipelinePermissionMapMock.invocationsDone() && afterSetPipelinePermissionMapCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.SetPipelinePermissionMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetPipelinePermissionMapMock.expectedInvocations), m.SetPipelinePermissionMapMock.expectedInvocationsOrigin, afterSetPipelinePermissionMapCounter)
	}
}

type mACLClientMockSetStoreID struct {
	optional           bool
	mock               *ACLClientMock
	defaultExpectation *ACLClientMockSetStoreIDExpectation
	expectations       []*ACLClientMockSetStoreIDExpectation

	callArgs []*ACLClientMockSetStoreIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientMockSetStoreIDExpectation specifies expectation struct of the ACLClient.SetStoreID
type ACLClientMockSetStoreIDExpectation struct {
	mock               *ACLClientMock
	params             *ACLClientMockSetStoreIDParams
	paramPtrs          *ACLClientMockSetStoreIDParamPtrs
	expectationOrigins ACLClientMockSetStoreIDExpectationOrigins
	results            *ACLClientMockSetStoreIDResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientMockSetStoreIDParams contains parameters of the ACLClient.SetStoreID
type ACLClientMockSetStoreIDParams struct {
	storeID string
}

// ACLClientMockSetStoreIDParamPtrs contains pointers to parameters of the ACLClient.SetStoreID
type ACLClientMockSetStoreIDParamPtrs struct {
	storeID *string
}

// ACLClientMockSetStoreIDResults contains results of the ACLClient.SetStoreID
type ACLClientMockSetStoreIDResults struct {
	err error
}

// ACLClientMockSetStoreIDOrigins contains origins of expectations of the ACLClient.SetStoreID
type ACLClientMockSetStoreIDExpectationOrigins struct {
	origin        string
	originStoreID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStoreID *mACLClientMockSetStoreID) Optional() *mACLClientMockSetStoreID {
	mmSetStoreID.optional = true
	return mmSetStoreID
}

// Expect sets up expected params for ACLClient.SetStoreID
func (mmSetStoreID *mACLClientMockSetStoreID) Expect(storeID string) *mACLClientMockSetStoreID {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientMock.SetStoreID mock is already set by Set")
	}

	if mmSetStoreID.defaultExpectation == nil {
		mmSetStoreID.defaultExpectation = &ACLClientMockSetStoreIDExpectation{}
	}

	if mmSetStoreID.defaultExpectation.paramPtrs != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientMock.SetStoreID mock is already set by ExpectParams functions")
	}

	mmSetStoreID.defaultExpectation.params = &ACLClientMockSetStoreIDParams{storeID}
	mmSetStoreID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStoreID.expectations {
		if minimock.Equal(e.params, mmSetStoreID.defaultExpectation.params) {
			mmSetStoreID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStoreID.defaultExpectation.params)
		}
	}

	return mmSetStoreID
}

// ExpectStoreIDParam1 sets up expected param storeID for ACLClient.SetStoreID
func (mmSetStoreID *mACLClientMockSetStoreID) ExpectStoreIDParam1(storeID string) *mACLClientMockSetStoreID {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientMock.SetStoreID mock is already set by Set")
	}

	if mmSetStoreID.defaultExpectation == nil {
		mmSetStoreID.defaultExpectation = &ACLClientMockSetStoreIDExpectation{}
	}

	if mmSetStoreID.defaultExpectation.params != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientMock.SetStoreID mock is already set by Expect")
	}

	if mmSetStoreID.defaultExpectation.paramPtrs == nil {
		mmSetStoreID.defaultExpectation.paramPtrs = &ACLClientMockSetStoreIDParamPtrs{}
	}
	mmSetStoreID.defaultExpectation.paramPtrs.storeID = &storeID
	mmSetStoreID.defaultExpectation.expectationOrigins.originStoreID = minimock.CallerInfo(1)

	return mmSetStoreID
}

// Inspect accepts an inspector function that has same arguments as the ACLClient.SetStoreID
func (mmSetStoreID *mACLClientMockSetStoreID) Inspect(f func(storeID string)) *mACLClientMockSetStoreID {
	if mmSetStoreID.mock.inspectFuncSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("Inspect function is already set for ACLClientMock.SetStoreID")
	}

	mmSetStoreID.mock.inspectFuncSetStoreID = f

	return mmSetStoreID
}

// Return sets up results that will be returned by ACLClient.SetStoreID
func (mmSetStoreID *mACLClientMockSetStoreID) Return(err error) *ACLClientMock {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientMock.SetStoreID mock is already set by Set")
	}

	if mmSetStoreID.defaultExpectation == nil {
		mmSetStoreID.defaultExpectation = &ACLClientMockSetStoreIDExpectation{mock: mmSetStoreID.mock}
	}
	mmSetStoreID.defaultExpectation.results = &ACLClientMockSetStoreIDResults{err}
	mmSetStoreID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStoreID.mock
}

// Set uses given function f to mock the ACLClient.SetStoreID method
func (mmSetStoreID *mACLClientMockSetStoreID) Set(f func(storeID string) (err error)) *ACLClientMock {
	if mmSetStoreID.defaultExpectation != nil {
		mmSetStoreID.mock.t.Fatalf("Default expectation is already set for the ACLClient.SetStoreID method")
	}

	if len(mmSetStoreID.expectations) > 0 {
		mmSetStoreID.mock.t.Fatalf("Some expectations are already set for the ACLClient.SetStoreID method")
	}

	mmSetStoreID.mock.funcSetStoreID = f
	mmSetStoreID.mock.funcSetStoreIDOrigin = minimock.CallerInfo(1)
	return mmSetStoreID.mock
}

// When sets expectation for the ACLClient.SetStoreID which will trigger the result defined by the following
// Then helper
func (mmSetStoreID *mACLClientMockSetStoreID) When(storeID string) *ACLClientMockSetStoreIDExpectation {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientMock.SetStoreID mock is already set by Set")
	}

	expectation := &ACLClientMockSetStoreIDExpectation{
		mock:               mmSetStoreID.mock,
		params:             &ACLClientMockSetStoreIDParams{storeID},
		expectationOrigins: ACLClientMockSetStoreIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStoreID.expectations = append(mmSetStoreID.expectations, expectation)
	return expectation
}

// Then sets up ACLClient.SetStoreID return parameters for the expectation previously defined by the When method
func (e *ACLClientMockSetStoreIDExpectation) Then(err error) *ACLClientMock {
	e.results = &ACLClientMockSetStoreIDResults{err}
	return e.mock
}

// Times sets number of times ACLClient.SetStoreID should be invoked
func (mmSetStoreID *mACLClientMockSetStoreID) Times(n uint64) *mACLClientMockSetStoreID {
	if n == 0 {
		mmSetStoreID.mock.t.Fatalf("Times of ACLClientMock.SetStoreID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStoreID.expectedInvocations, n)
	mmSetStoreID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStoreID
}

func (mmSetStoreID *mACLClientMockSetStoreID) invocationsDone() bool {
	if len(mmSetStoreID.expectations) == 0 && mmSetStoreID.defaultExpectation == nil && mmSetStoreID.mock.funcSetStoreID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStoreID.mock.afterSetStoreIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStoreID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStoreID implements mm_acl.ACLClient
func (mmSetStoreID *ACLClientMock) SetStoreID(storeID string) (err error) {
	mm_atomic.AddUint64(&mmSetStoreID.beforeSetStoreIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStoreID.afterSetStoreIDCounter, 1)

	mmSetStoreID.t.Helper()

	if mmSetStoreID.inspectFuncSetStoreID != nil {
		mmSetStoreID.inspectFuncSetStoreID(storeID)
	}

	mm_params := ACLClientMockSetStoreIDParams{storeID}

	// Record call args
	mmSetStoreID.SetStoreIDMock.mutex.Lock()
	mmSetStoreID.SetStoreIDMock.callArgs = append(mmSetStoreID.SetStoreIDMock.callArgs, &mm_params)
	mmSetStoreID.SetStoreIDMock.mutex.Unlock()

	for _, e := range mmSetStoreID.SetStoreIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStoreID.SetStoreIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStoreID.SetStoreIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStoreID.SetStoreIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetStoreID.SetStoreIDMock.defaultExpectation.paramPtrs

		mm_got := ACLClientMockSetStoreIDParams{storeID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.storeID != nil && !minimock.Equal(*mm_want_ptrs.storeID, mm_got.storeID) {
				mmSetStoreID.t.Errorf("ACLClientMock.SetStoreID got unexpected parameter storeID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStoreID.SetStoreIDMock.defaultExpectation.expectationOrigins.originStoreID, *mm_want_ptrs.storeID, mm_got.storeID, minimock.Diff(*mm_want_ptrs.storeID, mm_got.storeID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStoreID.t.Errorf("ACLClientMock.SetStoreID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStoreID.SetStoreIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStoreID.SetStoreIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStoreID.t.Fatal("No results are set for the ACLClientMock.SetStoreID")
		}
		return (*mm_results).err
	}
	if mmSetStoreID.funcSetStoreID != nil {
		return mmSetStoreID.funcSetStoreID(storeID)
	}
	mmSetStoreID.t.Fatalf("Unexpected call to ACLClientMock.SetStoreID. %v", storeID)
	return
}

// SetStoreIDAfterCounter returns a count of finished ACLClientMock.SetStoreID invocations
func (mmSetStoreID *ACLClientMock) SetStoreIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStoreID.afterSetStoreIDCounter)
}

// SetStoreIDBeforeCounter returns a count of ACLClientMock.SetStoreID invocations
func (mmSetStoreID *ACLClientMock) SetStoreIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStoreID.beforeSetStoreIDCounter)
}

// Calls returns a list of arguments used in each call to ACLClientMock.SetStoreID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStoreID *mACLClientMockSetStoreID) Calls() []*ACLClientMockSetStoreIDParams {
	mmSetStoreID.mutex.RLock()

	argCopy := make([]*ACLClientMockSetStoreIDParams, len(mmSetStoreID.callArgs))
	copy(argCopy, mmSetStoreID.callArgs)

	mmSetStoreID.mutex.RUnlock()

	return argCopy
}

// MinimockSetStoreIDDone returns true if the count of the SetStoreID invocations corresponds
// the number of defined expectations
func (m *ACLClientMock) MinimockSetStoreIDDone() bool {
	if m.SetStoreIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStoreIDMock.invocationsDone()
}

// MinimockSetStoreIDInspect logs each unmet expectation
func (m *ACLClientMock) MinimockSetStoreIDInspect() {
	for _, e := range m.SetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientMock.SetStoreID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStoreIDCounter := mm_atomic.LoadUint64(&m.afterSetStoreIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStoreIDMock.defaultExpectation != nil && afterSetStoreIDCounter < 1 {
		if m.SetStoreIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientMock.SetStoreID at\n%s", m.SetStoreIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientMock.SetStoreID at\n%s with params: %#v", m.SetStoreIDMock.defaultExpectation.expectationOrigins.origin, *m.SetStoreIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStoreID != nil && afterSetStoreIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientMock.SetStoreID at\n%s", m.funcSetStoreIDOrigin)
	}

	if !m.SetStoreIDMock.invocationsDone() && afterSetStoreIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientMock.SetStoreID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStoreIDMock.expectedInvocations), m.SetStoreIDMock.expectedInvocationsOrigin, afterSetStoreIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ACLClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckPermissionInspect()

			m.MinimockCheckPermissionByUserInspect()

			m.MinimockCheckPublicExecutableInspect()

			m.MinimockCloseInspect()

			m.MinimockDeletePipelinePermissionInspect()

			m.MinimockGetAuthorizationModelIDInspect()

			m.MinimockGetStoreIDInspect()

			m.MinimockListPermissionsInspect()

			m.MinimockPurgeInspect()

			m.MinimockSDKClientInspect()

			m.MinimockSetAuthorizationModelIDInspect()

			m.MinimockSetOwnerInspect()

			m.MinimockSetPipelinePermissionInspect()

			m.MinimockSetPipelinePermissionMapInspect()

			m.MinimockSetStoreIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ACLClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ACLClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckPermissionDone() &&
		m.MinimockCheckPermissionByUserDone() &&
		m.MinimockCheckPublicExecutableDone() &&
		m.MinimockCloseDone() &&
		m.MinimockDeletePipelinePermissionDone() &&
		m.MinimockGetAuthorizationModelIDDone() &&
		m.MinimockGetStoreIDDone() &&
		m.MinimockListPermissionsDone() &&
		m.MinimockPurgeDone() &&
		m.MinimockSDKClientDone() &&
		m.MinimockSetAuthorizationModelIDDone() &&
		m.MinimockSetOwnerDone() &&
		m.MinimockSetPipelinePermissionDone() &&
		m.MinimockSetPipelinePermissionMapDone() &&
		m.MinimockSetStoreIDDone()
}
