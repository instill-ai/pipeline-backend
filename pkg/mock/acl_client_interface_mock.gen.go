// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"context"
	"sync"

	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"

	"github.com/instill-ai/pipeline-backend/pkg/datamodel"
)

// ACLClientInterfaceMock implements mm_acl.ACLClientInterface
type ACLClientInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckLinkPermission          func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)
	funcCheckLinkPermissionOrigin    string
	inspectFuncCheckLinkPermission   func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)
	afterCheckLinkPermissionCounter  uint64
	beforeCheckLinkPermissionCounter uint64
	CheckLinkPermissionMock          mACLClientInterfaceMockCheckLinkPermission

	funcCheckPermission          func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)
	funcCheckPermissionOrigin    string
	inspectFuncCheckPermission   func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)
	afterCheckPermissionCounter  uint64
	beforeCheckPermissionCounter uint64
	CheckPermissionMock          mACLClientInterfaceMockCheckPermission

	funcCheckPublicExecutable          func(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error)
	funcCheckPublicExecutableOrigin    string
	inspectFuncCheckPublicExecutable   func(ctx context.Context, objectType string, objectUID uuid.UUID)
	afterCheckPublicExecutableCounter  uint64
	beforeCheckPublicExecutableCounter uint64
	CheckPublicExecutableMock          mACLClientInterfaceMockCheckPublicExecutable

	funcDeletePipelinePermission          func(ctx context.Context, pipelineUID uuid.UUID, user string) (err error)
	funcDeletePipelinePermissionOrigin    string
	inspectFuncDeletePipelinePermission   func(ctx context.Context, pipelineUID uuid.UUID, user string)
	afterDeletePipelinePermissionCounter  uint64
	beforeDeletePipelinePermissionCounter uint64
	DeletePipelinePermissionMock          mACLClientInterfaceMockDeletePipelinePermission

	funcListPermissions          func(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error)
	funcListPermissionsOrigin    string
	inspectFuncListPermissions   func(ctx context.Context, objectType string, role string, isPublic bool)
	afterListPermissionsCounter  uint64
	beforeListPermissionsCounter uint64
	ListPermissionsMock          mACLClientInterfaceMockListPermissions

	funcPurge          func(ctx context.Context, objectType string, objectUID uuid.UUID) (err error)
	funcPurgeOrigin    string
	inspectFuncPurge   func(ctx context.Context, objectType string, objectUID uuid.UUID)
	afterPurgeCounter  uint64
	beforePurgeCounter uint64
	PurgeMock          mACLClientInterfaceMockPurge

	funcSetOwner          func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error)
	funcSetOwnerOrigin    string
	inspectFuncSetOwner   func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID)
	afterSetOwnerCounter  uint64
	beforeSetOwnerCounter uint64
	SetOwnerMock          mACLClientInterfaceMockSetOwner

	funcSetPipelinePermission          func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error)
	funcSetPipelinePermissionOrigin    string
	inspectFuncSetPipelinePermission   func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool)
	afterSetPipelinePermissionCounter  uint64
	beforeSetPipelinePermissionCounter uint64
	SetPipelinePermissionMock          mACLClientInterfaceMockSetPipelinePermission

	funcSetPipelinePermissionMap          func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)
	funcSetPipelinePermissionMapOrigin    string
	inspectFuncSetPipelinePermissionMap   func(ctx context.Context, pipeline *datamodel.Pipeline)
	afterSetPipelinePermissionMapCounter  uint64
	beforeSetPipelinePermissionMapCounter uint64
	SetPipelinePermissionMapMock          mACLClientInterfaceMockSetPipelinePermissionMap
}

// NewACLClientInterfaceMock returns a mock for mm_acl.ACLClientInterface
func NewACLClientInterfaceMock(t minimock.Tester) *ACLClientInterfaceMock {
	m := &ACLClientInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckLinkPermissionMock = mACLClientInterfaceMockCheckLinkPermission{mock: m}
	m.CheckLinkPermissionMock.callArgs = []*ACLClientInterfaceMockCheckLinkPermissionParams{}

	m.CheckPermissionMock = mACLClientInterfaceMockCheckPermission{mock: m}
	m.CheckPermissionMock.callArgs = []*ACLClientInterfaceMockCheckPermissionParams{}

	m.CheckPublicExecutableMock = mACLClientInterfaceMockCheckPublicExecutable{mock: m}
	m.CheckPublicExecutableMock.callArgs = []*ACLClientInterfaceMockCheckPublicExecutableParams{}

	m.DeletePipelinePermissionMock = mACLClientInterfaceMockDeletePipelinePermission{mock: m}
	m.DeletePipelinePermissionMock.callArgs = []*ACLClientInterfaceMockDeletePipelinePermissionParams{}

	m.ListPermissionsMock = mACLClientInterfaceMockListPermissions{mock: m}
	m.ListPermissionsMock.callArgs = []*ACLClientInterfaceMockListPermissionsParams{}

	m.PurgeMock = mACLClientInterfaceMockPurge{mock: m}
	m.PurgeMock.callArgs = []*ACLClientInterfaceMockPurgeParams{}

	m.SetOwnerMock = mACLClientInterfaceMockSetOwner{mock: m}
	m.SetOwnerMock.callArgs = []*ACLClientInterfaceMockSetOwnerParams{}

	m.SetPipelinePermissionMock = mACLClientInterfaceMockSetPipelinePermission{mock: m}
	m.SetPipelinePermissionMock.callArgs = []*ACLClientInterfaceMockSetPipelinePermissionParams{}

	m.SetPipelinePermissionMapMock = mACLClientInterfaceMockSetPipelinePermissionMap{mock: m}
	m.SetPipelinePermissionMapMock.callArgs = []*ACLClientInterfaceMockSetPipelinePermissionMapParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mACLClientInterfaceMockCheckLinkPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckLinkPermissionExpectation
	expectations       []*ACLClientInterfaceMockCheckLinkPermissionExpectation

	callArgs []*ACLClientInterfaceMockCheckLinkPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckLinkPermissionExpectation specifies expectation struct of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckLinkPermissionParams
	paramPtrs          *ACLClientInterfaceMockCheckLinkPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckLinkPermissionExpectationOrigins
	results            *ACLClientInterfaceMockCheckLinkPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckLinkPermissionParams contains parameters of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	role       string
}

// ACLClientInterfaceMockCheckLinkPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	role       *string
}

// ACLClientInterfaceMockCheckLinkPermissionResults contains results of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckLinkPermissionOrigins contains origins of expectations of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originRole       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Optional() *mACLClientInterfaceMockCheckLinkPermission {
	mmCheckLinkPermission.optional = true
	return mmCheckLinkPermission
}

// Expect sets up expected params for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by ExpectParams functions")
	}

	mmCheckLinkPermission.defaultExpectation.params = &ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role}
	mmCheckLinkPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckLinkPermission.expectations {
		if minimock.Equal(e.params, mmCheckLinkPermission.defaultExpectation.params) {
			mmCheckLinkPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckLinkPermission.defaultExpectation.params)
		}
	}

	return mmCheckLinkPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckLinkPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckLinkPermission
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckLinkPermission.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckLinkPermission
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckLinkPermission.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckLinkPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.role = &role
	mmCheckLinkPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckLinkPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.inspectFuncCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckLinkPermission")
	}

	mmCheckLinkPermission.mock.inspectFuncCheckLinkPermission = f

	return mmCheckLinkPermission
}

// Return sets up results that will be returned by ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{mock: mmCheckLinkPermission.mock}
	}
	mmCheckLinkPermission.defaultExpectation.results = &ACLClientInterfaceMockCheckLinkPermissionResults{b1, err}
	mmCheckLinkPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckLinkPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckLinkPermission method
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckLinkPermission.defaultExpectation != nil {
		mmCheckLinkPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckLinkPermission method")
	}

	if len(mmCheckLinkPermission.expectations) > 0 {
		mmCheckLinkPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckLinkPermission method")
	}

	mmCheckLinkPermission.mock.funcCheckLinkPermission = f
	mmCheckLinkPermission.mock.funcCheckLinkPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckLinkPermission.mock
}

// When sets expectation for the ACLClientInterface.CheckLinkPermission which will trigger the result defined by the following
// Then helper
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) When(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *ACLClientInterfaceMockCheckLinkPermissionExpectation {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckLinkPermissionExpectation{
		mock:               mmCheckLinkPermission.mock,
		params:             &ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role},
		expectationOrigins: ACLClientInterfaceMockCheckLinkPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckLinkPermission.expectations = append(mmCheckLinkPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckLinkPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckLinkPermissionExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckLinkPermissionResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckLinkPermission should be invoked
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Times(n uint64) *mACLClientInterfaceMockCheckLinkPermission {
	if n == 0 {
		mmCheckLinkPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckLinkPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckLinkPermission.expectedInvocations, n)
	mmCheckLinkPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckLinkPermission
}

func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) invocationsDone() bool {
	if len(mmCheckLinkPermission.expectations) == 0 && mmCheckLinkPermission.defaultExpectation == nil && mmCheckLinkPermission.mock.funcCheckLinkPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckLinkPermission.mock.afterCheckLinkPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckLinkPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckLinkPermission implements mm_acl.ACLClientInterface
func (mmCheckLinkPermission *ACLClientInterfaceMock) CheckLinkPermission(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckLinkPermission.beforeCheckLinkPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckLinkPermission.afterCheckLinkPermissionCounter, 1)

	mmCheckLinkPermission.t.Helper()

	if mmCheckLinkPermission.inspectFuncCheckLinkPermission != nil {
		mmCheckLinkPermission.inspectFuncCheckLinkPermission(ctx, objectType, objectUID, role)
	}

	mm_params := ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role}

	// Record call args
	mmCheckLinkPermission.CheckLinkPermissionMock.mutex.Lock()
	mmCheckLinkPermission.CheckLinkPermissionMock.callArgs = append(mmCheckLinkPermission.CheckLinkPermissionMock.callArgs, &mm_params)
	mmCheckLinkPermission.CheckLinkPermissionMock.mutex.Unlock()

	for _, e := range mmCheckLinkPermission.CheckLinkPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckLinkPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckLinkPermission")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckLinkPermission.funcCheckLinkPermission != nil {
		return mmCheckLinkPermission.funcCheckLinkPermission(ctx, objectType, objectUID, role)
	}
	mmCheckLinkPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckLinkPermission. %v %v %v %v", ctx, objectType, objectUID, role)
	return
}

// CheckLinkPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.CheckLinkPermission invocations
func (mmCheckLinkPermission *ACLClientInterfaceMock) CheckLinkPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckLinkPermission.afterCheckLinkPermissionCounter)
}

// CheckLinkPermissionBeforeCounter returns a count of ACLClientInterfaceMock.CheckLinkPermission invocations
func (mmCheckLinkPermission *ACLClientInterfaceMock) CheckLinkPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckLinkPermission.beforeCheckLinkPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckLinkPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Calls() []*ACLClientInterfaceMockCheckLinkPermissionParams {
	mmCheckLinkPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckLinkPermissionParams, len(mmCheckLinkPermission.callArgs))
	copy(argCopy, mmCheckLinkPermission.callArgs)

	mmCheckLinkPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckLinkPermissionDone returns true if the count of the CheckLinkPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckLinkPermissionDone() bool {
	if m.CheckLinkPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckLinkPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckLinkPermissionMock.invocationsDone()
}

// MinimockCheckLinkPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckLinkPermissionInspect() {
	for _, e := range m.CheckLinkPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckLinkPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckLinkPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckLinkPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckLinkPermissionMock.defaultExpectation != nil && afterCheckLinkPermissionCounter < 1 {
		if m.CheckLinkPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckLinkPermission at\n%s", m.CheckLinkPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckLinkPermission at\n%s with params: %#v", m.CheckLinkPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckLinkPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckLinkPermission != nil && afterCheckLinkPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckLinkPermission at\n%s", m.funcCheckLinkPermissionOrigin)
	}

	if !m.CheckLinkPermissionMock.invocationsDone() && afterCheckLinkPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckLinkPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckLinkPermissionMock.expectedInvocations), m.CheckLinkPermissionMock.expectedInvocationsOrigin, afterCheckLinkPermissionCounter)
	}
}

type mACLClientInterfaceMockCheckPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPermissionExpectation
	expectations       []*ACLClientInterfaceMockCheckPermissionExpectation

	callArgs []*ACLClientInterfaceMockCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckPermissionExpectation specifies expectation struct of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckPermissionParams
	paramPtrs          *ACLClientInterfaceMockCheckPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckPermissionExpectationOrigins
	results            *ACLClientInterfaceMockCheckPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckPermissionParams contains parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	role       string
}

// ACLClientInterfaceMockCheckPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	role       *string
}

// ACLClientInterfaceMockCheckPermissionResults contains results of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckPermissionOrigins contains origins of expectations of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originRole       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Optional() *mACLClientInterfaceMockCheckPermission {
	mmCheckPermission.optional = true
	return mmCheckPermission
}

// Expect sets up expected params for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.paramPtrs != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by ExpectParams functions")
	}

	mmCheckPermission.defaultExpectation.params = &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}
	mmCheckPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPermission.expectations {
		if minimock.Equal(e.params, mmCheckPermission.defaultExpectation.params) {
			mmCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPermission.defaultExpectation.params)
		}
	}

	return mmCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.role = &role
	mmCheckPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.inspectFuncCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPermission")
	}

	mmCheckPermission.mock.inspectFuncCheckPermission = f

	return mmCheckPermission
}

// Return sets up results that will be returned by ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{mock: mmCheckPermission.mock}
	}
	mmCheckPermission.defaultExpectation.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	mmCheckPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPermission method
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPermission.defaultExpectation != nil {
		mmCheckPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPermission method")
	}

	if len(mmCheckPermission.expectations) > 0 {
		mmCheckPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPermission method")
	}

	mmCheckPermission.mock.funcCheckPermission = f
	mmCheckPermission.mock.funcCheckPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// When sets expectation for the ACLClientInterface.CheckPermission which will trigger the result defined by the following
// Then helper
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) When(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *ACLClientInterfaceMockCheckPermissionExpectation {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPermissionExpectation{
		mock:               mmCheckPermission.mock,
		params:             &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role},
		expectationOrigins: ACLClientInterfaceMockCheckPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPermission.expectations = append(mmCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPermissionExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPermission should be invoked
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Times(n uint64) *mACLClientInterfaceMockCheckPermission {
	if n == 0 {
		mmCheckPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPermission.expectedInvocations, n)
	mmCheckPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPermission
}

func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) invocationsDone() bool {
	if len(mmCheckPermission.expectations) == 0 && mmCheckPermission.defaultExpectation == nil && mmCheckPermission.mock.funcCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPermission.mock.afterCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPermission implements mm_acl.ACLClientInterface
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermission(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPermission.beforeCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPermission.afterCheckPermissionCounter, 1)

	mmCheckPermission.t.Helper()

	if mmCheckPermission.inspectFuncCheckPermission != nil {
		mmCheckPermission.inspectFuncCheckPermission(ctx, objectType, objectUID, role)
	}

	mm_params := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

	// Record call args
	mmCheckPermission.CheckPermissionMock.mutex.Lock()
	mmCheckPermission.CheckPermissionMock.callArgs = append(mmCheckPermission.CheckPermissionMock.callArgs, &mm_params)
	mmCheckPermission.CheckPermissionMock.mutex.Unlock()

	for _, e := range mmCheckPermission.CheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPermission.CheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPermission.CheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPermission.CheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPermission.CheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPermission.CheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPermission")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPermission.funcCheckPermission != nil {
		return mmCheckPermission.funcCheckPermission(ctx, objectType, objectUID, role)
	}
	mmCheckPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPermission. %v %v %v %v", ctx, objectType, objectUID, role)
	return
}

// CheckPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.afterCheckPermissionCounter)
}

// CheckPermissionBeforeCounter returns a count of ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.beforeCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Calls() []*ACLClientInterfaceMockCheckPermissionParams {
	mmCheckPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPermissionParams, len(mmCheckPermission.callArgs))
	copy(argCopy, mmCheckPermission.callArgs)

	mmCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPermissionDone returns true if the count of the CheckPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPermissionDone() bool {
	if m.CheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPermissionMock.invocationsDone()
}

// MinimockCheckPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPermissionInspect() {
	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPermissionMock.defaultExpectation != nil && afterCheckPermissionCounter < 1 {
		if m.CheckPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s", m.CheckPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s with params: %#v", m.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPermission != nil && afterCheckPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s", m.funcCheckPermissionOrigin)
	}

	if !m.CheckPermissionMock.invocationsDone() && afterCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPermissionMock.expectedInvocations), m.CheckPermissionMock.expectedInvocationsOrigin, afterCheckPermissionCounter)
	}
}

type mACLClientInterfaceMockCheckPublicExecutable struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPublicExecutableExpectation
	expectations       []*ACLClientInterfaceMockCheckPublicExecutableExpectation

	callArgs []*ACLClientInterfaceMockCheckPublicExecutableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckPublicExecutableExpectation specifies expectation struct of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckPublicExecutableParams
	paramPtrs          *ACLClientInterfaceMockCheckPublicExecutableParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins
	results            *ACLClientInterfaceMockCheckPublicExecutableResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckPublicExecutableParams contains parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableResults contains results of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckPublicExecutableOrigins contains origins of expectations of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Optional() *mACLClientInterfaceMockCheckPublicExecutable {
	mmCheckPublicExecutable.optional = true
	return mmCheckPublicExecutable
}

// Expect sets up expected params for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Expect(ctx context.Context, objectType string, objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by ExpectParams functions")
	}

	mmCheckPublicExecutable.defaultExpectation.params = &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPublicExecutable.expectations {
		if minimock.Equal(e.params, mmCheckPublicExecutable.defaultExpectation.params) {
			mmCheckPublicExecutable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPublicExecutable.defaultExpectation.params)
		}
	}

	return mmCheckPublicExecutable
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID)) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPublicExecutable")
	}

	mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable = f

	return mmCheckPublicExecutable
}

// Return sets up results that will be returned by ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{mock: mmCheckPublicExecutable.mock}
	}
	mmCheckPublicExecutable.defaultExpectation.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	mmCheckPublicExecutable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPublicExecutable method
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.defaultExpectation != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	if len(mmCheckPublicExecutable.expectations) > 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	mmCheckPublicExecutable.mock.funcCheckPublicExecutable = f
	mmCheckPublicExecutable.mock.funcCheckPublicExecutableOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// When sets expectation for the ACLClientInterface.CheckPublicExecutable which will trigger the result defined by the following
// Then helper
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) When(ctx context.Context, objectType string, objectUID uuid.UUID) *ACLClientInterfaceMockCheckPublicExecutableExpectation {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPublicExecutableExpectation{
		mock:               mmCheckPublicExecutable.mock,
		params:             &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPublicExecutable.expectations = append(mmCheckPublicExecutable.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPublicExecutable return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPublicExecutableExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPublicExecutable should be invoked
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Times(n uint64) *mACLClientInterfaceMockCheckPublicExecutable {
	if n == 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPublicExecutable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPublicExecutable.expectedInvocations, n)
	mmCheckPublicExecutable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable
}

func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) invocationsDone() bool {
	if len(mmCheckPublicExecutable.expectations) == 0 && mmCheckPublicExecutable.defaultExpectation == nil && mmCheckPublicExecutable.mock.funcCheckPublicExecutable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.mock.afterCheckPublicExecutableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPublicExecutable implements mm_acl.ACLClientInterface
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutable(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter, 1)

	mmCheckPublicExecutable.t.Helper()

	if mmCheckPublicExecutable.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.inspectFuncCheckPublicExecutable(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

	// Record call args
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Lock()
	mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs = append(mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs, &mm_params)
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Unlock()

	for _, e := range mmCheckPublicExecutable.CheckPublicExecutableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPublicExecutable.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPublicExecutable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPublicExecutable.funcCheckPublicExecutable != nil {
		return mmCheckPublicExecutable.funcCheckPublicExecutable(ctx, objectType, objectUID)
	}
	mmCheckPublicExecutable.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPublicExecutable. %v %v %v", ctx, objectType, objectUID)
	return
}

// CheckPublicExecutableAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter)
}

// CheckPublicExecutableBeforeCounter returns a count of ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPublicExecutable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Calls() []*ACLClientInterfaceMockCheckPublicExecutableParams {
	mmCheckPublicExecutable.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPublicExecutableParams, len(mmCheckPublicExecutable.callArgs))
	copy(argCopy, mmCheckPublicExecutable.callArgs)

	mmCheckPublicExecutable.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPublicExecutableDone returns true if the count of the CheckPublicExecutable invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableDone() bool {
	if m.CheckPublicExecutableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPublicExecutableMock.invocationsDone()
}

// MinimockCheckPublicExecutableInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableInspect() {
	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPublicExecutableCounter := mm_atomic.LoadUint64(&m.afterCheckPublicExecutableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPublicExecutableMock.defaultExpectation != nil && afterCheckPublicExecutableCounter < 1 {
		if m.CheckPublicExecutableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s", m.CheckPublicExecutableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s with params: %#v", m.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *m.CheckPublicExecutableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPublicExecutable != nil && afterCheckPublicExecutableCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s", m.funcCheckPublicExecutableOrigin)
	}

	if !m.CheckPublicExecutableMock.invocationsDone() && afterCheckPublicExecutableCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPublicExecutable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPublicExecutableMock.expectedInvocations), m.CheckPublicExecutableMock.expectedInvocationsOrigin, afterCheckPublicExecutableCounter)
	}
}

type mACLClientInterfaceMockDeletePipelinePermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockDeletePipelinePermissionExpectation
	expectations       []*ACLClientInterfaceMockDeletePipelinePermissionExpectation

	callArgs []*ACLClientInterfaceMockDeletePipelinePermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockDeletePipelinePermissionExpectation specifies expectation struct of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockDeletePipelinePermissionParams
	paramPtrs          *ACLClientInterfaceMockDeletePipelinePermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockDeletePipelinePermissionExpectationOrigins
	results            *ACLClientInterfaceMockDeletePipelinePermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockDeletePipelinePermissionParams contains parameters of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	user        string
}

// ACLClientInterfaceMockDeletePipelinePermissionParamPtrs contains pointers to parameters of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	user        *string
}

// ACLClientInterfaceMockDeletePipelinePermissionResults contains results of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionResults struct {
	err error
}

// ACLClientInterfaceMockDeletePipelinePermissionOrigins contains origins of expectations of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originUser        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Optional() *mACLClientInterfaceMockDeletePipelinePermission {
	mmDeletePipelinePermission.optional = true
	return mmDeletePipelinePermission
}

// Expect sets up expected params for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Expect(ctx context.Context, pipelineUID uuid.UUID, user string) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by ExpectParams functions")
	}

	mmDeletePipelinePermission.defaultExpectation.params = &ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user}
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePipelinePermission.expectations {
		if minimock.Equal(e.params, mmDeletePipelinePermission.defaultExpectation.params) {
			mmDeletePipelinePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelinePermission.defaultExpectation.params)
		}
	}

	return mmDeletePipelinePermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePipelinePermission
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmDeletePipelinePermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) ExpectUserParam3(user string) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.user = &user
	mmDeletePipelinePermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmDeletePipelinePermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, user string)) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.inspectFuncDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.DeletePipelinePermission")
	}

	mmDeletePipelinePermission.mock.inspectFuncDeletePipelinePermission = f

	return mmDeletePipelinePermission
}

// Return sets up results that will be returned by ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Return(err error) *ACLClientInterfaceMock {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{mock: mmDeletePipelinePermission.mock}
	}
	mmDeletePipelinePermission.defaultExpectation.results = &ACLClientInterfaceMockDeletePipelinePermissionResults{err}
	mmDeletePipelinePermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelinePermission.mock
}

// Set uses given function f to mock the ACLClientInterface.DeletePipelinePermission method
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Set(f func(ctx context.Context, pipelineUID uuid.UUID, user string) (err error)) *ACLClientInterfaceMock {
	if mmDeletePipelinePermission.defaultExpectation != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.DeletePipelinePermission method")
	}

	if len(mmDeletePipelinePermission.expectations) > 0 {
		mmDeletePipelinePermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.DeletePipelinePermission method")
	}

	mmDeletePipelinePermission.mock.funcDeletePipelinePermission = f
	mmDeletePipelinePermission.mock.funcDeletePipelinePermissionOrigin = minimock.CallerInfo(1)
	return mmDeletePipelinePermission.mock
}

// When sets expectation for the ACLClientInterface.DeletePipelinePermission which will trigger the result defined by the following
// Then helper
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) When(ctx context.Context, pipelineUID uuid.UUID, user string) *ACLClientInterfaceMockDeletePipelinePermissionExpectation {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockDeletePipelinePermissionExpectation{
		mock:               mmDeletePipelinePermission.mock,
		params:             &ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user},
		expectationOrigins: ACLClientInterfaceMockDeletePipelinePermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePipelinePermission.expectations = append(mmDeletePipelinePermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.DeletePipelinePermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockDeletePipelinePermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockDeletePipelinePermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.DeletePipelinePermission should be invoked
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Times(n uint64) *mACLClientInterfaceMockDeletePipelinePermission {
	if n == 0 {
		mmDeletePipelinePermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.DeletePipelinePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelinePermission.expectedInvocations, n)
	mmDeletePipelinePermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelinePermission
}

func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) invocationsDone() bool {
	if len(mmDeletePipelinePermission.expectations) == 0 && mmDeletePipelinePermission.defaultExpectation == nil && mmDeletePipelinePermission.mock.funcDeletePipelinePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelinePermission.mock.afterDeletePipelinePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelinePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelinePermission implements mm_acl.ACLClientInterface
func (mmDeletePipelinePermission *ACLClientInterfaceMock) DeletePipelinePermission(ctx context.Context, pipelineUID uuid.UUID, user string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelinePermission.beforeDeletePipelinePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelinePermission.afterDeletePipelinePermissionCounter, 1)

	mmDeletePipelinePermission.t.Helper()

	if mmDeletePipelinePermission.inspectFuncDeletePipelinePermission != nil {
		mmDeletePipelinePermission.inspectFuncDeletePipelinePermission(ctx, pipelineUID, user)
	}

	mm_params := ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user}

	// Record call args
	mmDeletePipelinePermission.DeletePipelinePermissionMock.mutex.Lock()
	mmDeletePipelinePermission.DeletePipelinePermissionMock.callArgs = append(mmDeletePipelinePermission.DeletePipelinePermissionMock.callArgs, &mm_params)
	mmDeletePipelinePermission.DeletePipelinePermissionMock.mutex.Unlock()

	for _, e := range mmDeletePipelinePermission.DeletePipelinePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelinePermission.t.Fatal("No results are set for the ACLClientInterfaceMock.DeletePipelinePermission")
		}
		return (*mm_results).err
	}
	if mmDeletePipelinePermission.funcDeletePipelinePermission != nil {
		return mmDeletePipelinePermission.funcDeletePipelinePermission(ctx, pipelineUID, user)
	}
	mmDeletePipelinePermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.DeletePipelinePermission. %v %v %v", ctx, pipelineUID, user)
	return
}

// DeletePipelinePermissionAfterCounter returns a count of finished ACLClientInterfaceMock.DeletePipelinePermission invocations
func (mmDeletePipelinePermission *ACLClientInterfaceMock) DeletePipelinePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelinePermission.afterDeletePipelinePermissionCounter)
}

// DeletePipelinePermissionBeforeCounter returns a count of ACLClientInterfaceMock.DeletePipelinePermission invocations
func (mmDeletePipelinePermission *ACLClientInterfaceMock) DeletePipelinePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelinePermission.beforeDeletePipelinePermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.DeletePipelinePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Calls() []*ACLClientInterfaceMockDeletePipelinePermissionParams {
	mmDeletePipelinePermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockDeletePipelinePermissionParams, len(mmDeletePipelinePermission.callArgs))
	copy(argCopy, mmDeletePipelinePermission.callArgs)

	mmDeletePipelinePermission.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelinePermissionDone returns true if the count of the DeletePipelinePermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockDeletePipelinePermissionDone() bool {
	if m.DeletePipelinePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelinePermissionMock.invocationsDone()
}

// MinimockDeletePipelinePermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockDeletePipelinePermissionInspect() {
	for _, e := range m.DeletePipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePipelinePermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePipelinePermissionCounter := mm_atomic.LoadUint64(&m.afterDeletePipelinePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelinePermissionMock.defaultExpectation != nil && afterDeletePipelinePermissionCounter < 1 {
		if m.DeletePipelinePermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePipelinePermission at\n%s", m.DeletePipelinePermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePipelinePermission at\n%s with params: %#v", m.DeletePipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *m.DeletePipelinePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelinePermission != nil && afterDeletePipelinePermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePipelinePermission at\n%s", m.funcDeletePipelinePermissionOrigin)
	}

	if !m.DeletePipelinePermissionMock.invocationsDone() && afterDeletePipelinePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.DeletePipelinePermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelinePermissionMock.expectedInvocations), m.DeletePipelinePermissionMock.expectedInvocationsOrigin, afterDeletePipelinePermissionCounter)
	}
}

type mACLClientInterfaceMockListPermissions struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockListPermissionsExpectation
	expectations       []*ACLClientInterfaceMockListPermissionsExpectation

	callArgs []*ACLClientInterfaceMockListPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockListPermissionsExpectation specifies expectation struct of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockListPermissionsParams
	paramPtrs          *ACLClientInterfaceMockListPermissionsParamPtrs
	expectationOrigins ACLClientInterfaceMockListPermissionsExpectationOrigins
	results            *ACLClientInterfaceMockListPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockListPermissionsParams contains parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParams struct {
	ctx        context.Context
	objectType string
	role       string
	isPublic   bool
}

// ACLClientInterfaceMockListPermissionsParamPtrs contains pointers to parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParamPtrs struct {
	ctx        *context.Context
	objectType *string
	role       *string
	isPublic   *bool
}

// ACLClientInterfaceMockListPermissionsResults contains results of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsResults struct {
	ua1 []uuid.UUID
	err error
}

// ACLClientInterfaceMockListPermissionsOrigins contains origins of expectations of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originRole       string
	originIsPublic   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Optional() *mACLClientInterfaceMockListPermissions {
	mmListPermissions.optional = true
	return mmListPermissions
}

// Expect sets up expected params for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Expect(ctx context.Context, objectType string, role string, isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.paramPtrs != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by ExpectParams functions")
	}

	mmListPermissions.defaultExpectation.params = &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}
	mmListPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPermissions.expectations {
		if minimock.Equal(e.params, mmListPermissions.defaultExpectation.params) {
			mmListPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPermissions.defaultExpectation.params)
		}
	}

	return mmListPermissions
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.objectType = &objectType
	mmListPermissions.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectRoleParam3 sets up expected param role for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectRoleParam3(role string) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.role = &role
	mmListPermissions.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectIsPublicParam4 sets up expected param isPublic for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectIsPublicParam4(isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.isPublic = &isPublic
	mmListPermissions.defaultExpectation.expectationOrigins.originIsPublic = minimock.CallerInfo(1)

	return mmListPermissions
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Inspect(f func(ctx context.Context, objectType string, role string, isPublic bool)) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.inspectFuncListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.ListPermissions")
	}

	mmListPermissions.mock.inspectFuncListPermissions = f

	return mmListPermissions
}

// Return sets up results that will be returned by ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Return(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{mock: mmListPermissions.mock}
	}
	mmListPermissions.defaultExpectation.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	mmListPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// Set uses given function f to mock the ACLClientInterface.ListPermissions method
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Set(f func(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error)) *ACLClientInterfaceMock {
	if mmListPermissions.defaultExpectation != nil {
		mmListPermissions.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.ListPermissions method")
	}

	if len(mmListPermissions.expectations) > 0 {
		mmListPermissions.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.ListPermissions method")
	}

	mmListPermissions.mock.funcListPermissions = f
	mmListPermissions.mock.funcListPermissionsOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// When sets expectation for the ACLClientInterface.ListPermissions which will trigger the result defined by the following
// Then helper
func (mmListPermissions *mACLClientInterfaceMockListPermissions) When(ctx context.Context, objectType string, role string, isPublic bool) *ACLClientInterfaceMockListPermissionsExpectation {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockListPermissionsExpectation{
		mock:               mmListPermissions.mock,
		params:             &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic},
		expectationOrigins: ACLClientInterfaceMockListPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPermissions.expectations = append(mmListPermissions.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.ListPermissions return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockListPermissionsExpectation) Then(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.ListPermissions should be invoked
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Times(n uint64) *mACLClientInterfaceMockListPermissions {
	if n == 0 {
		mmListPermissions.mock.t.Fatalf("Times of ACLClientInterfaceMock.ListPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPermissions.expectedInvocations, n)
	mmListPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPermissions
}

func (mmListPermissions *mACLClientInterfaceMockListPermissions) invocationsDone() bool {
	if len(mmListPermissions.expectations) == 0 && mmListPermissions.defaultExpectation == nil && mmListPermissions.mock.funcListPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPermissions.mock.afterListPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPermissions implements mm_acl.ACLClientInterface
func (mmListPermissions *ACLClientInterfaceMock) ListPermissions(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmListPermissions.beforeListPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPermissions.afterListPermissionsCounter, 1)

	mmListPermissions.t.Helper()

	if mmListPermissions.inspectFuncListPermissions != nil {
		mmListPermissions.inspectFuncListPermissions(ctx, objectType, role, isPublic)
	}

	mm_params := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

	// Record call args
	mmListPermissions.ListPermissionsMock.mutex.Lock()
	mmListPermissions.ListPermissionsMock.callArgs = append(mmListPermissions.ListPermissionsMock.callArgs, &mm_params)
	mmListPermissions.ListPermissionsMock.mutex.Unlock()

	for _, e := range mmListPermissions.ListPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListPermissions.ListPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPermissions.ListPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPermissions.ListPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmListPermissions.ListPermissionsMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.isPublic != nil && !minimock.Equal(*mm_want_ptrs.isPublic, mm_got.isPublic) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter isPublic, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originIsPublic, *mm_want_ptrs.isPublic, mm_got.isPublic, minimock.Diff(*mm_want_ptrs.isPublic, mm_got.isPublic))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPermissions.ListPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPermissions.t.Fatal("No results are set for the ACLClientInterfaceMock.ListPermissions")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListPermissions.funcListPermissions != nil {
		return mmListPermissions.funcListPermissions(ctx, objectType, role, isPublic)
	}
	mmListPermissions.t.Fatalf("Unexpected call to ACLClientInterfaceMock.ListPermissions. %v %v %v %v", ctx, objectType, role, isPublic)
	return
}

// ListPermissionsAfterCounter returns a count of finished ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.afterListPermissionsCounter)
}

// ListPermissionsBeforeCounter returns a count of ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.beforeListPermissionsCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.ListPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Calls() []*ACLClientInterfaceMockListPermissionsParams {
	mmListPermissions.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockListPermissionsParams, len(mmListPermissions.callArgs))
	copy(argCopy, mmListPermissions.callArgs)

	mmListPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockListPermissionsDone returns true if the count of the ListPermissions invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockListPermissionsDone() bool {
	if m.ListPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPermissionsMock.invocationsDone()
}

// MinimockListPermissionsInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockListPermissionsInspect() {
	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPermissionsCounter := mm_atomic.LoadUint64(&m.afterListPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPermissionsMock.defaultExpectation != nil && afterListPermissionsCounter < 1 {
		if m.ListPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s", m.ListPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s with params: %#v", m.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.ListPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPermissions != nil && afterListPermissionsCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s", m.funcListPermissionsOrigin)
	}

	if !m.ListPermissionsMock.invocationsDone() && afterListPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.ListPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPermissionsMock.expectedInvocations), m.ListPermissionsMock.expectedInvocationsOrigin, afterListPermissionsCounter)
	}
}

type mACLClientInterfaceMockPurge struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockPurgeExpectation
	expectations       []*ACLClientInterfaceMockPurgeExpectation

	callArgs []*ACLClientInterfaceMockPurgeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockPurgeExpectation specifies expectation struct of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockPurgeParams
	paramPtrs          *ACLClientInterfaceMockPurgeParamPtrs
	expectationOrigins ACLClientInterfaceMockPurgeExpectationOrigins
	results            *ACLClientInterfaceMockPurgeResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockPurgeParams contains parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockPurgeParamPtrs contains pointers to parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockPurgeResults contains results of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeResults struct {
	err error
}

// ACLClientInterfaceMockPurgeOrigins contains origins of expectations of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPurge *mACLClientInterfaceMockPurge) Optional() *mACLClientInterfaceMockPurge {
	mmPurge.optional = true
	return mmPurge
}

// Expect sets up expected params for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Expect(ctx context.Context, objectType string, objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.paramPtrs != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by ExpectParams functions")
	}

	mmPurge.defaultExpectation.params = &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}
	mmPurge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPurge.expectations {
		if minimock.Equal(e.params, mmPurge.defaultExpectation.params) {
			mmPurge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurge.defaultExpectation.params)
		}
	}

	return mmPurge
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.ctx = &ctx
	mmPurge.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectType = &objectType
	mmPurge.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmPurge.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmPurge
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID)) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.inspectFuncPurge != nil {
		mmPurge.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.Purge")
	}

	mmPurge.mock.inspectFuncPurge = f

	return mmPurge
}

// Return sets up results that will be returned by ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Return(err error) *ACLClientInterfaceMock {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{mock: mmPurge.mock}
	}
	mmPurge.defaultExpectation.results = &ACLClientInterfaceMockPurgeResults{err}
	mmPurge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// Set uses given function f to mock the ACLClientInterface.Purge method
func (mmPurge *mACLClientInterfaceMockPurge) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmPurge.defaultExpectation != nil {
		mmPurge.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.Purge method")
	}

	if len(mmPurge.expectations) > 0 {
		mmPurge.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.Purge method")
	}

	mmPurge.mock.funcPurge = f
	mmPurge.mock.funcPurgeOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// When sets expectation for the ACLClientInterface.Purge which will trigger the result defined by the following
// Then helper
func (mmPurge *mACLClientInterfaceMockPurge) When(ctx context.Context, objectType string, objectUID uuid.UUID) *ACLClientInterfaceMockPurgeExpectation {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockPurgeExpectation{
		mock:               mmPurge.mock,
		params:             &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientInterfaceMockPurgeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPurge.expectations = append(mmPurge.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.Purge return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockPurgeExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockPurgeResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.Purge should be invoked
func (mmPurge *mACLClientInterfaceMockPurge) Times(n uint64) *mACLClientInterfaceMockPurge {
	if n == 0 {
		mmPurge.mock.t.Fatalf("Times of ACLClientInterfaceMock.Purge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPurge.expectedInvocations, n)
	mmPurge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPurge
}

func (mmPurge *mACLClientInterfaceMockPurge) invocationsDone() bool {
	if len(mmPurge.expectations) == 0 && mmPurge.defaultExpectation == nil && mmPurge.mock.funcPurge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPurge.mock.afterPurgeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPurge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Purge implements mm_acl.ACLClientInterface
func (mmPurge *ACLClientInterfaceMock) Purge(ctx context.Context, objectType string, objectUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmPurge.beforePurgeCounter, 1)
	defer mm_atomic.AddUint64(&mmPurge.afterPurgeCounter, 1)

	mmPurge.t.Helper()

	if mmPurge.inspectFuncPurge != nil {
		mmPurge.inspectFuncPurge(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

	// Record call args
	mmPurge.PurgeMock.mutex.Lock()
	mmPurge.PurgeMock.callArgs = append(mmPurge.PurgeMock.callArgs, &mm_params)
	mmPurge.PurgeMock.mutex.Unlock()

	for _, e := range mmPurge.PurgeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurge.PurgeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurge.PurgeMock.defaultExpectation.Counter, 1)
		mm_want := mmPurge.PurgeMock.defaultExpectation.params
		mm_want_ptrs := mmPurge.PurgeMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPurge.PurgeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurge.PurgeMock.defaultExpectation.results
		if mm_results == nil {
			mmPurge.t.Fatal("No results are set for the ACLClientInterfaceMock.Purge")
		}
		return (*mm_results).err
	}
	if mmPurge.funcPurge != nil {
		return mmPurge.funcPurge(ctx, objectType, objectUID)
	}
	mmPurge.t.Fatalf("Unexpected call to ACLClientInterfaceMock.Purge. %v %v %v", ctx, objectType, objectUID)
	return
}

// PurgeAfterCounter returns a count of finished ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.afterPurgeCounter)
}

// PurgeBeforeCounter returns a count of ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.beforePurgeCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.Purge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurge *mACLClientInterfaceMockPurge) Calls() []*ACLClientInterfaceMockPurgeParams {
	mmPurge.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockPurgeParams, len(mmPurge.callArgs))
	copy(argCopy, mmPurge.callArgs)

	mmPurge.mutex.RUnlock()

	return argCopy
}

// MinimockPurgeDone returns true if the count of the Purge invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockPurgeDone() bool {
	if m.PurgeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PurgeMock.invocationsDone()
}

// MinimockPurgeInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockPurgeInspect() {
	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPurgeCounter := mm_atomic.LoadUint64(&m.afterPurgeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeMock.defaultExpectation != nil && afterPurgeCounter < 1 {
		if m.PurgeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s", m.PurgeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s with params: %#v", m.PurgeMock.defaultExpectation.expectationOrigins.origin, *m.PurgeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurge != nil && afterPurgeCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s", m.funcPurgeOrigin)
	}

	if !m.PurgeMock.invocationsDone() && afterPurgeCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.Purge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PurgeMock.expectedInvocations), m.PurgeMock.expectedInvocationsOrigin, afterPurgeCounter)
	}
}

type mACLClientInterfaceMockSetOwner struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetOwnerExpectation
	expectations       []*ACLClientInterfaceMockSetOwnerExpectation

	callArgs []*ACLClientInterfaceMockSetOwnerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetOwnerExpectation specifies expectation struct of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetOwnerParams
	paramPtrs          *ACLClientInterfaceMockSetOwnerParamPtrs
	expectationOrigins ACLClientInterfaceMockSetOwnerExpectationOrigins
	results            *ACLClientInterfaceMockSetOwnerResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetOwnerParams contains parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	ownerType  string
	ownerUID   uuid.UUID
}

// ACLClientInterfaceMockSetOwnerParamPtrs contains pointers to parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	ownerType  *string
	ownerUID   *uuid.UUID
}

// ACLClientInterfaceMockSetOwnerResults contains results of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerResults struct {
	err error
}

// ACLClientInterfaceMockSetOwnerOrigins contains origins of expectations of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originOwnerType  string
	originOwnerUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Optional() *mACLClientInterfaceMockSetOwner {
	mmSetOwner.optional = true
	return mmSetOwner
}

// Expect sets up expected params for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.paramPtrs != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by ExpectParams functions")
	}

	mmSetOwner.defaultExpectation.params = &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}
	mmSetOwner.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOwner.expectations {
		if minimock.Equal(e.params, mmSetOwner.defaultExpectation.params) {
			mmSetOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOwner.defaultExpectation.params)
		}
	}

	return mmSetOwner
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetOwner.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectType = &objectType
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerTypeParam4 sets up expected param ownerType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerTypeParam4(ownerType string) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerType = &ownerType
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerUIDParam5 sets up expected param ownerUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerUIDParam5(ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID)) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.inspectFuncSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetOwner")
	}

	mmSetOwner.mock.inspectFuncSetOwner = f

	return mmSetOwner
}

// Return sets up results that will be returned by ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Return(err error) *ACLClientInterfaceMock {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{mock: mmSetOwner.mock}
	}
	mmSetOwner.defaultExpectation.results = &ACLClientInterfaceMockSetOwnerResults{err}
	mmSetOwner.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// Set uses given function f to mock the ACLClientInterface.SetOwner method
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmSetOwner.defaultExpectation != nil {
		mmSetOwner.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetOwner method")
	}

	if len(mmSetOwner.expectations) > 0 {
		mmSetOwner.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetOwner method")
	}

	mmSetOwner.mock.funcSetOwner = f
	mmSetOwner.mock.funcSetOwnerOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// When sets expectation for the ACLClientInterface.SetOwner which will trigger the result defined by the following
// Then helper
func (mmSetOwner *mACLClientInterfaceMockSetOwner) When(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) *ACLClientInterfaceMockSetOwnerExpectation {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetOwnerExpectation{
		mock:               mmSetOwner.mock,
		params:             &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID},
		expectationOrigins: ACLClientInterfaceMockSetOwnerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOwner.expectations = append(mmSetOwner.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetOwner return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetOwnerExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetOwnerResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetOwner should be invoked
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Times(n uint64) *mACLClientInterfaceMockSetOwner {
	if n == 0 {
		mmSetOwner.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOwner.expectedInvocations, n)
	mmSetOwner.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOwner
}

func (mmSetOwner *mACLClientInterfaceMockSetOwner) invocationsDone() bool {
	if len(mmSetOwner.expectations) == 0 && mmSetOwner.defaultExpectation == nil && mmSetOwner.mock.funcSetOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOwner.mock.afterSetOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOwner implements mm_acl.ACLClientInterface
func (mmSetOwner *ACLClientInterfaceMock) SetOwner(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSetOwner.beforeSetOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOwner.afterSetOwnerCounter, 1)

	mmSetOwner.t.Helper()

	if mmSetOwner.inspectFuncSetOwner != nil {
		mmSetOwner.inspectFuncSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}

	mm_params := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

	// Record call args
	mmSetOwner.SetOwnerMock.mutex.Lock()
	mmSetOwner.SetOwnerMock.callArgs = append(mmSetOwner.SetOwnerMock.callArgs, &mm_params)
	mmSetOwner.SetOwnerMock.mutex.Unlock()

	for _, e := range mmSetOwner.SetOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOwner.SetOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOwner.SetOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOwner.SetOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmSetOwner.SetOwnerMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.ownerType != nil && !minimock.Equal(*mm_want_ptrs.ownerType, mm_got.ownerType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerType, *mm_want_ptrs.ownerType, mm_got.ownerType, minimock.Diff(*mm_want_ptrs.ownerType, mm_got.ownerType))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOwner.SetOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOwner.t.Fatal("No results are set for the ACLClientInterfaceMock.SetOwner")
		}
		return (*mm_results).err
	}
	if mmSetOwner.funcSetOwner != nil {
		return mmSetOwner.funcSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}
	mmSetOwner.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetOwner. %v %v %v %v %v", ctx, objectType, objectUID, ownerType, ownerUID)
	return
}

// SetOwnerAfterCounter returns a count of finished ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.afterSetOwnerCounter)
}

// SetOwnerBeforeCounter returns a count of ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.beforeSetOwnerCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Calls() []*ACLClientInterfaceMockSetOwnerParams {
	mmSetOwner.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetOwnerParams, len(mmSetOwner.callArgs))
	copy(argCopy, mmSetOwner.callArgs)

	mmSetOwner.mutex.RUnlock()

	return argCopy
}

// MinimockSetOwnerDone returns true if the count of the SetOwner invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetOwnerDone() bool {
	if m.SetOwnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOwnerMock.invocationsDone()
}

// MinimockSetOwnerInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetOwnerInspect() {
	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOwnerCounter := mm_atomic.LoadUint64(&m.afterSetOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOwnerMock.defaultExpectation != nil && afterSetOwnerCounter < 1 {
		if m.SetOwnerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s", m.SetOwnerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s with params: %#v", m.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *m.SetOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOwner != nil && afterSetOwnerCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s", m.funcSetOwnerOrigin)
	}

	if !m.SetOwnerMock.invocationsDone() && afterSetOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetOwner at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOwnerMock.expectedInvocations), m.SetOwnerMock.expectedInvocationsOrigin, afterSetOwnerCounter)
	}
}

type mACLClientInterfaceMockSetPipelinePermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetPipelinePermissionExpectation
	expectations       []*ACLClientInterfaceMockSetPipelinePermissionExpectation

	callArgs []*ACLClientInterfaceMockSetPipelinePermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetPipelinePermissionExpectation specifies expectation struct of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetPipelinePermissionParams
	paramPtrs          *ACLClientInterfaceMockSetPipelinePermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockSetPipelinePermissionExpectationOrigins
	results            *ACLClientInterfaceMockSetPipelinePermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetPipelinePermissionParams contains parameters of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	user        string
	role        string
	enable      bool
}

// ACLClientInterfaceMockSetPipelinePermissionParamPtrs contains pointers to parameters of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	user        *string
	role        *string
	enable      *bool
}

// ACLClientInterfaceMockSetPipelinePermissionResults contains results of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionResults struct {
	err error
}

// ACLClientInterfaceMockSetPipelinePermissionOrigins contains origins of expectations of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originUser        string
	originRole        string
	originEnable      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Optional() *mACLClientInterfaceMockSetPipelinePermission {
	mmSetPipelinePermission.optional = true
	return mmSetPipelinePermission
}

// Expect sets up expected params for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Expect(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by ExpectParams functions")
	}

	mmSetPipelinePermission.defaultExpectation.params = &ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetPipelinePermission.expectations {
		if minimock.Equal(e.params, mmSetPipelinePermission.defaultExpectation.params) {
			mmSetPipelinePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPipelinePermission.defaultExpectation.params)
		}
	}

	return mmSetPipelinePermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectUserParam3(user string) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.user = &user
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.role = &role
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// ExpectEnableParam5 sets up expected param enable for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectEnableParam5(enable bool) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.enable = &enable
	mmSetPipelinePermission.defaultExpectation.expectationOrigins.originEnable = minimock.CallerInfo(1)

	return mmSetPipelinePermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool)) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.inspectFuncSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetPipelinePermission")
	}

	mmSetPipelinePermission.mock.inspectFuncSetPipelinePermission = f

	return mmSetPipelinePermission
}

// Return sets up results that will be returned by ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Return(err error) *ACLClientInterfaceMock {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{mock: mmSetPipelinePermission.mock}
	}
	mmSetPipelinePermission.defaultExpectation.results = &ACLClientInterfaceMockSetPipelinePermissionResults{err}
	mmSetPipelinePermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermission.mock
}

// Set uses given function f to mock the ACLClientInterface.SetPipelinePermission method
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Set(f func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error)) *ACLClientInterfaceMock {
	if mmSetPipelinePermission.defaultExpectation != nil {
		mmSetPipelinePermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetPipelinePermission method")
	}

	if len(mmSetPipelinePermission.expectations) > 0 {
		mmSetPipelinePermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetPipelinePermission method")
	}

	mmSetPipelinePermission.mock.funcSetPipelinePermission = f
	mmSetPipelinePermission.mock.funcSetPipelinePermissionOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermission.mock
}

// When sets expectation for the ACLClientInterface.SetPipelinePermission which will trigger the result defined by the following
// Then helper
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) When(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) *ACLClientInterfaceMockSetPipelinePermissionExpectation {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetPipelinePermissionExpectation{
		mock:               mmSetPipelinePermission.mock,
		params:             &ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable},
		expectationOrigins: ACLClientInterfaceMockSetPipelinePermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetPipelinePermission.expectations = append(mmSetPipelinePermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetPipelinePermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetPipelinePermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetPipelinePermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetPipelinePermission should be invoked
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Times(n uint64) *mACLClientInterfaceMockSetPipelinePermission {
	if n == 0 {
		mmSetPipelinePermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetPipelinePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPipelinePermission.expectedInvocations, n)
	mmSetPipelinePermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermission
}

func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) invocationsDone() bool {
	if len(mmSetPipelinePermission.expectations) == 0 && mmSetPipelinePermission.defaultExpectation == nil && mmSetPipelinePermission.mock.funcSetPipelinePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermission.mock.afterSetPipelinePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPipelinePermission implements mm_acl.ACLClientInterface
func (mmSetPipelinePermission *ACLClientInterfaceMock) SetPipelinePermission(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error) {
	mm_atomic.AddUint64(&mmSetPipelinePermission.beforeSetPipelinePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPipelinePermission.afterSetPipelinePermissionCounter, 1)

	mmSetPipelinePermission.t.Helper()

	if mmSetPipelinePermission.inspectFuncSetPipelinePermission != nil {
		mmSetPipelinePermission.inspectFuncSetPipelinePermission(ctx, pipelineUID, user, role, enable)
	}

	mm_params := ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}

	// Record call args
	mmSetPipelinePermission.SetPipelinePermissionMock.mutex.Lock()
	mmSetPipelinePermission.SetPipelinePermissionMock.callArgs = append(mmSetPipelinePermission.SetPipelinePermissionMock.callArgs, &mm_params)
	mmSetPipelinePermission.SetPipelinePermissionMock.mutex.Unlock()

	for _, e := range mmSetPipelinePermission.SetPipelinePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.enable != nil && !minimock.Equal(*mm_want_ptrs.enable, mm_got.enable) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter enable, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.originEnable, *mm_want_ptrs.enable, mm_got.enable, minimock.Diff(*mm_want_ptrs.enable, mm_got.enable))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPipelinePermission.t.Fatal("No results are set for the ACLClientInterfaceMock.SetPipelinePermission")
		}
		return (*mm_results).err
	}
	if mmSetPipelinePermission.funcSetPipelinePermission != nil {
		return mmSetPipelinePermission.funcSetPipelinePermission(ctx, pipelineUID, user, role, enable)
	}
	mmSetPipelinePermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetPipelinePermission. %v %v %v %v %v", ctx, pipelineUID, user, role, enable)
	return
}

// SetPipelinePermissionAfterCounter returns a count of finished ACLClientInterfaceMock.SetPipelinePermission invocations
func (mmSetPipelinePermission *ACLClientInterfaceMock) SetPipelinePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermission.afterSetPipelinePermissionCounter)
}

// SetPipelinePermissionBeforeCounter returns a count of ACLClientInterfaceMock.SetPipelinePermission invocations
func (mmSetPipelinePermission *ACLClientInterfaceMock) SetPipelinePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermission.beforeSetPipelinePermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetPipelinePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Calls() []*ACLClientInterfaceMockSetPipelinePermissionParams {
	mmSetPipelinePermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetPipelinePermissionParams, len(mmSetPipelinePermission.callArgs))
	copy(argCopy, mmSetPipelinePermission.callArgs)

	mmSetPipelinePermission.mutex.RUnlock()

	return argCopy
}

// MinimockSetPipelinePermissionDone returns true if the count of the SetPipelinePermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionDone() bool {
	if m.SetPipelinePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPipelinePermissionMock.invocationsDone()
}

// MinimockSetPipelinePermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionInspect() {
	for _, e := range m.SetPipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetPipelinePermissionCounter := mm_atomic.LoadUint64(&m.afterSetPipelinePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPipelinePermissionMock.defaultExpectation != nil && afterSetPipelinePermissionCounter < 1 {
		if m.SetPipelinePermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermission at\n%s", m.SetPipelinePermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermission at\n%s with params: %#v", m.SetPipelinePermissionMock.defaultExpectation.expectationOrigins.origin, *m.SetPipelinePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPipelinePermission != nil && afterSetPipelinePermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermission at\n%s", m.funcSetPipelinePermissionOrigin)
	}

	if !m.SetPipelinePermissionMock.invocationsDone() && afterSetPipelinePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetPipelinePermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetPipelinePermissionMock.expectedInvocations), m.SetPipelinePermissionMock.expectedInvocationsOrigin, afterSetPipelinePermissionCounter)
	}
}

type mACLClientInterfaceMockSetPipelinePermissionMap struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetPipelinePermissionMapExpectation
	expectations       []*ACLClientInterfaceMockSetPipelinePermissionMapExpectation

	callArgs []*ACLClientInterfaceMockSetPipelinePermissionMapParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetPipelinePermissionMapExpectation specifies expectation struct of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetPipelinePermissionMapParams
	paramPtrs          *ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs
	expectationOrigins ACLClientInterfaceMockSetPipelinePermissionMapExpectationOrigins
	results            *ACLClientInterfaceMockSetPipelinePermissionMapResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetPipelinePermissionMapParams contains parameters of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapParams struct {
	ctx      context.Context
	pipeline *datamodel.Pipeline
}

// ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs contains pointers to parameters of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs struct {
	ctx      *context.Context
	pipeline **datamodel.Pipeline
}

// ACLClientInterfaceMockSetPipelinePermissionMapResults contains results of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapResults struct {
	err error
}

// ACLClientInterfaceMockSetPipelinePermissionMapOrigins contains origins of expectations of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapExpectationOrigins struct {
	origin         string
	originCtx      string
	originPipeline string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Optional() *mACLClientInterfaceMockSetPipelinePermissionMap {
	mmSetPipelinePermissionMap.optional = true
	return mmSetPipelinePermissionMap
}

// Expect sets up expected params for ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Expect(ctx context.Context, pipeline *datamodel.Pipeline) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by ExpectParams functions")
	}

	mmSetPipelinePermissionMap.defaultExpectation.params = &ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline}
	mmSetPipelinePermissionMap.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetPipelinePermissionMap.expectations {
		if minimock.Equal(e.params, mmSetPipelinePermissionMap.defaultExpectation.params) {
			mmSetPipelinePermissionMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPipelinePermissionMap.defaultExpectation.params)
		}
	}

	return mmSetPipelinePermissionMap
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.params != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Expect")
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermissionMap.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs{}
	}
	mmSetPipelinePermissionMap.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetPipelinePermissionMap.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetPipelinePermissionMap
}

// ExpectPipelineParam2 sets up expected param pipeline for ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) ExpectPipelineParam2(pipeline *datamodel.Pipeline) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.params != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Expect")
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermissionMap.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs{}
	}
	mmSetPipelinePermissionMap.defaultExpectation.paramPtrs.pipeline = &pipeline
	mmSetPipelinePermissionMap.defaultExpectation.expectationOrigins.originPipeline = minimock.CallerInfo(1)

	return mmSetPipelinePermissionMap
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Inspect(f func(ctx context.Context, pipeline *datamodel.Pipeline)) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.inspectFuncSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetPipelinePermissionMap")
	}

	mmSetPipelinePermissionMap.mock.inspectFuncSetPipelinePermissionMap = f

	return mmSetPipelinePermissionMap
}

// Return sets up results that will be returned by ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Return(err error) *ACLClientInterfaceMock {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{mock: mmSetPipelinePermissionMap.mock}
	}
	mmSetPipelinePermissionMap.defaultExpectation.results = &ACLClientInterfaceMockSetPipelinePermissionMapResults{err}
	mmSetPipelinePermissionMap.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermissionMap.mock
}

// Set uses given function f to mock the ACLClientInterface.SetPipelinePermissionMap method
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Set(f func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)) *ACLClientInterfaceMock {
	if mmSetPipelinePermissionMap.defaultExpectation != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetPipelinePermissionMap method")
	}

	if len(mmSetPipelinePermissionMap.expectations) > 0 {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetPipelinePermissionMap method")
	}

	mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap = f
	mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMapOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermissionMap.mock
}

// When sets expectation for the ACLClientInterface.SetPipelinePermissionMap which will trigger the result defined by the following
// Then helper
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) When(ctx context.Context, pipeline *datamodel.Pipeline) *ACLClientInterfaceMockSetPipelinePermissionMapExpectation {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{
		mock:               mmSetPipelinePermissionMap.mock,
		params:             &ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline},
		expectationOrigins: ACLClientInterfaceMockSetPipelinePermissionMapExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetPipelinePermissionMap.expectations = append(mmSetPipelinePermissionMap.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetPipelinePermissionMap return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetPipelinePermissionMapExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetPipelinePermissionMapResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetPipelinePermissionMap should be invoked
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Times(n uint64) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if n == 0 {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetPipelinePermissionMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPipelinePermissionMap.expectedInvocations, n)
	mmSetPipelinePermissionMap.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetPipelinePermissionMap
}

func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) invocationsDone() bool {
	if len(mmSetPipelinePermissionMap.expectations) == 0 && mmSetPipelinePermissionMap.defaultExpectation == nil && mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.mock.afterSetPipelinePermissionMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPipelinePermissionMap implements mm_acl.ACLClientInterface
func (mmSetPipelinePermissionMap *ACLClientInterfaceMock) SetPipelinePermissionMap(ctx context.Context, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmSetPipelinePermissionMap.beforeSetPipelinePermissionMapCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPipelinePermissionMap.afterSetPipelinePermissionMapCounter, 1)

	mmSetPipelinePermissionMap.t.Helper()

	if mmSetPipelinePermissionMap.inspectFuncSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.inspectFuncSetPipelinePermissionMap(ctx, pipeline)
	}

	mm_params := ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline}

	// Record call args
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.mutex.Lock()
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.callArgs = append(mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.callArgs, &mm_params)
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.mutex.Unlock()

	for _, e := range mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.params
		mm_want_ptrs := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPipelinePermissionMap.t.Errorf("ACLClientInterfaceMock.SetPipelinePermissionMap got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmSetPipelinePermissionMap.t.Errorf("ACLClientInterfaceMock.SetPipelinePermissionMap got unexpected parameter pipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.originPipeline, *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPipelinePermissionMap.t.Errorf("ACLClientInterfaceMock.SetPipelinePermissionMap got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPipelinePermissionMap.t.Fatal("No results are set for the ACLClientInterfaceMock.SetPipelinePermissionMap")
		}
		return (*mm_results).err
	}
	if mmSetPipelinePermissionMap.funcSetPipelinePermissionMap != nil {
		return mmSetPipelinePermissionMap.funcSetPipelinePermissionMap(ctx, pipeline)
	}
	mmSetPipelinePermissionMap.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetPipelinePermissionMap. %v %v", ctx, pipeline)
	return
}

// SetPipelinePermissionMapAfterCounter returns a count of finished ACLClientInterfaceMock.SetPipelinePermissionMap invocations
func (mmSetPipelinePermissionMap *ACLClientInterfaceMock) SetPipelinePermissionMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.afterSetPipelinePermissionMapCounter)
}

// SetPipelinePermissionMapBeforeCounter returns a count of ACLClientInterfaceMock.SetPipelinePermissionMap invocations
func (mmSetPipelinePermissionMap *ACLClientInterfaceMock) SetPipelinePermissionMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.beforeSetPipelinePermissionMapCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetPipelinePermissionMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Calls() []*ACLClientInterfaceMockSetPipelinePermissionMapParams {
	mmSetPipelinePermissionMap.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetPipelinePermissionMapParams, len(mmSetPipelinePermissionMap.callArgs))
	copy(argCopy, mmSetPipelinePermissionMap.callArgs)

	mmSetPipelinePermissionMap.mutex.RUnlock()

	return argCopy
}

// MinimockSetPipelinePermissionMapDone returns true if the count of the SetPipelinePermissionMap invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionMapDone() bool {
	if m.SetPipelinePermissionMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPipelinePermissionMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPipelinePermissionMapMock.invocationsDone()
}

// MinimockSetPipelinePermissionMapInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionMapInspect() {
	for _, e := range m.SetPipelinePermissionMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetPipelinePermissionMapCounter := mm_atomic.LoadUint64(&m.afterSetPipelinePermissionMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPipelinePermissionMapMock.defaultExpectation != nil && afterSetPipelinePermissionMapCounter < 1 {
		if m.SetPipelinePermissionMapMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap at\n%s", m.SetPipelinePermissionMapMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap at\n%s with params: %#v", m.SetPipelinePermissionMapMock.defaultExpectation.expectationOrigins.origin, *m.SetPipelinePermissionMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPipelinePermissionMap != nil && afterSetPipelinePermissionMapCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap at\n%s", m.funcSetPipelinePermissionMapOrigin)
	}

	if !m.SetPipelinePermissionMapMock.invocationsDone() && afterSetPipelinePermissionMapCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetPipelinePermissionMap at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetPipelinePermissionMapMock.expectedInvocations), m.SetPipelinePermissionMapMock.expectedInvocationsOrigin, afterSetPipelinePermissionMapCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ACLClientInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckLinkPermissionInspect()

			m.MinimockCheckPermissionInspect()

			m.MinimockCheckPublicExecutableInspect()

			m.MinimockDeletePipelinePermissionInspect()

			m.MinimockListPermissionsInspect()

			m.MinimockPurgeInspect()

			m.MinimockSetOwnerInspect()

			m.MinimockSetPipelinePermissionInspect()

			m.MinimockSetPipelinePermissionMapInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ACLClientInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ACLClientInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckLinkPermissionDone() &&
		m.MinimockCheckPermissionDone() &&
		m.MinimockCheckPublicExecutableDone() &&
		m.MinimockDeletePipelinePermissionDone() &&
		m.MinimockListPermissionsDone() &&
		m.MinimockPurgeDone() &&
		m.MinimockSetOwnerDone() &&
		m.MinimockSetPipelinePermissionDone() &&
		m.MinimockSetPipelinePermissionMapDone()
}
