// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/pipeline-backend/pkg/datamodel"
)

// ACLClientInterfaceMock implements acl.ACLClientInterface
type ACLClientInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckLinkPermission          func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)
	inspectFuncCheckLinkPermission   func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)
	afterCheckLinkPermissionCounter  uint64
	beforeCheckLinkPermissionCounter uint64
	CheckLinkPermissionMock          mACLClientInterfaceMockCheckLinkPermission

	funcCheckPermission          func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)
	inspectFuncCheckPermission   func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)
	afterCheckPermissionCounter  uint64
	beforeCheckPermissionCounter uint64
	CheckPermissionMock          mACLClientInterfaceMockCheckPermission

	funcCheckPublicExecutable          func(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error)
	inspectFuncCheckPublicExecutable   func(ctx context.Context, objectType string, objectUID uuid.UUID)
	afterCheckPublicExecutableCounter  uint64
	beforeCheckPublicExecutableCounter uint64
	CheckPublicExecutableMock          mACLClientInterfaceMockCheckPublicExecutable

	funcDeletePipelinePermission          func(ctx context.Context, pipelineUID uuid.UUID, user string) (err error)
	inspectFuncDeletePipelinePermission   func(ctx context.Context, pipelineUID uuid.UUID, user string)
	afterDeletePipelinePermissionCounter  uint64
	beforeDeletePipelinePermissionCounter uint64
	DeletePipelinePermissionMock          mACLClientInterfaceMockDeletePipelinePermission

	funcListPermissions          func(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error)
	inspectFuncListPermissions   func(ctx context.Context, objectType string, role string, isPublic bool)
	afterListPermissionsCounter  uint64
	beforeListPermissionsCounter uint64
	ListPermissionsMock          mACLClientInterfaceMockListPermissions

	funcPurge          func(ctx context.Context, objectType string, objectUID uuid.UUID) (err error)
	inspectFuncPurge   func(ctx context.Context, objectType string, objectUID uuid.UUID)
	afterPurgeCounter  uint64
	beforePurgeCounter uint64
	PurgeMock          mACLClientInterfaceMockPurge

	funcSetOwner          func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error)
	inspectFuncSetOwner   func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID)
	afterSetOwnerCounter  uint64
	beforeSetOwnerCounter uint64
	SetOwnerMock          mACLClientInterfaceMockSetOwner

	funcSetPipelinePermission          func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error)
	inspectFuncSetPipelinePermission   func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool)
	afterSetPipelinePermissionCounter  uint64
	beforeSetPipelinePermissionCounter uint64
	SetPipelinePermissionMock          mACLClientInterfaceMockSetPipelinePermission

	funcSetPipelinePermissionMap          func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)
	inspectFuncSetPipelinePermissionMap   func(ctx context.Context, pipeline *datamodel.Pipeline)
	afterSetPipelinePermissionMapCounter  uint64
	beforeSetPipelinePermissionMapCounter uint64
	SetPipelinePermissionMapMock          mACLClientInterfaceMockSetPipelinePermissionMap
}

// NewACLClientInterfaceMock returns a mock for acl.ACLClientInterface
func NewACLClientInterfaceMock(t minimock.Tester) *ACLClientInterfaceMock {
	m := &ACLClientInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckLinkPermissionMock = mACLClientInterfaceMockCheckLinkPermission{mock: m}
	m.CheckLinkPermissionMock.callArgs = []*ACLClientInterfaceMockCheckLinkPermissionParams{}

	m.CheckPermissionMock = mACLClientInterfaceMockCheckPermission{mock: m}
	m.CheckPermissionMock.callArgs = []*ACLClientInterfaceMockCheckPermissionParams{}

	m.CheckPublicExecutableMock = mACLClientInterfaceMockCheckPublicExecutable{mock: m}
	m.CheckPublicExecutableMock.callArgs = []*ACLClientInterfaceMockCheckPublicExecutableParams{}

	m.DeletePipelinePermissionMock = mACLClientInterfaceMockDeletePipelinePermission{mock: m}
	m.DeletePipelinePermissionMock.callArgs = []*ACLClientInterfaceMockDeletePipelinePermissionParams{}

	m.ListPermissionsMock = mACLClientInterfaceMockListPermissions{mock: m}
	m.ListPermissionsMock.callArgs = []*ACLClientInterfaceMockListPermissionsParams{}

	m.PurgeMock = mACLClientInterfaceMockPurge{mock: m}
	m.PurgeMock.callArgs = []*ACLClientInterfaceMockPurgeParams{}

	m.SetOwnerMock = mACLClientInterfaceMockSetOwner{mock: m}
	m.SetOwnerMock.callArgs = []*ACLClientInterfaceMockSetOwnerParams{}

	m.SetPipelinePermissionMock = mACLClientInterfaceMockSetPipelinePermission{mock: m}
	m.SetPipelinePermissionMock.callArgs = []*ACLClientInterfaceMockSetPipelinePermissionParams{}

	m.SetPipelinePermissionMapMock = mACLClientInterfaceMockSetPipelinePermissionMap{mock: m}
	m.SetPipelinePermissionMapMock.callArgs = []*ACLClientInterfaceMockSetPipelinePermissionMapParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mACLClientInterfaceMockCheckLinkPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckLinkPermissionExpectation
	expectations       []*ACLClientInterfaceMockCheckLinkPermissionExpectation

	callArgs []*ACLClientInterfaceMockCheckLinkPermissionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockCheckLinkPermissionExpectation specifies expectation struct of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockCheckLinkPermissionParams
	paramPtrs *ACLClientInterfaceMockCheckLinkPermissionParamPtrs
	results   *ACLClientInterfaceMockCheckLinkPermissionResults
	Counter   uint64
}

// ACLClientInterfaceMockCheckLinkPermissionParams contains parameters of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	role       string
}

// ACLClientInterfaceMockCheckLinkPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	role       *string
}

// ACLClientInterfaceMockCheckLinkPermissionResults contains results of the ACLClientInterface.CheckLinkPermission
type ACLClientInterfaceMockCheckLinkPermissionResults struct {
	b1  bool
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Optional() *mACLClientInterfaceMockCheckLinkPermission {
	mmCheckLinkPermission.optional = true
	return mmCheckLinkPermission
}

// Expect sets up expected params for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by ExpectParams functions")
	}

	mmCheckLinkPermission.defaultExpectation.params = &ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role}
	for _, e := range mmCheckLinkPermission.expectations {
		if minimock.Equal(e.params, mmCheckLinkPermission.defaultExpectation.params) {
			mmCheckLinkPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckLinkPermission.defaultExpectation.params)
		}
	}

	return mmCheckLinkPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheckLinkPermission
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.objectType = &objectType

	return mmCheckLinkPermission
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmCheckLinkPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{}
	}

	if mmCheckLinkPermission.defaultExpectation.params != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Expect")
	}

	if mmCheckLinkPermission.defaultExpectation.paramPtrs == nil {
		mmCheckLinkPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckLinkPermissionParamPtrs{}
	}
	mmCheckLinkPermission.defaultExpectation.paramPtrs.role = &role

	return mmCheckLinkPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)) *mACLClientInterfaceMockCheckLinkPermission {
	if mmCheckLinkPermission.mock.inspectFuncCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckLinkPermission")
	}

	mmCheckLinkPermission.mock.inspectFuncCheckLinkPermission = f

	return mmCheckLinkPermission
}

// Return sets up results that will be returned by ACLClientInterface.CheckLinkPermission
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	if mmCheckLinkPermission.defaultExpectation == nil {
		mmCheckLinkPermission.defaultExpectation = &ACLClientInterfaceMockCheckLinkPermissionExpectation{mock: mmCheckLinkPermission.mock}
	}
	mmCheckLinkPermission.defaultExpectation.results = &ACLClientInterfaceMockCheckLinkPermissionResults{b1, err}
	return mmCheckLinkPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckLinkPermission method
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckLinkPermission.defaultExpectation != nil {
		mmCheckLinkPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckLinkPermission method")
	}

	if len(mmCheckLinkPermission.expectations) > 0 {
		mmCheckLinkPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckLinkPermission method")
	}

	mmCheckLinkPermission.mock.funcCheckLinkPermission = f
	return mmCheckLinkPermission.mock
}

// When sets expectation for the ACLClientInterface.CheckLinkPermission which will trigger the result defined by the following
// Then helper
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) When(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *ACLClientInterfaceMockCheckLinkPermissionExpectation {
	if mmCheckLinkPermission.mock.funcCheckLinkPermission != nil {
		mmCheckLinkPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckLinkPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckLinkPermissionExpectation{
		mock:   mmCheckLinkPermission.mock,
		params: &ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role},
	}
	mmCheckLinkPermission.expectations = append(mmCheckLinkPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckLinkPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckLinkPermissionExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckLinkPermissionResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckLinkPermission should be invoked
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Times(n uint64) *mACLClientInterfaceMockCheckLinkPermission {
	if n == 0 {
		mmCheckLinkPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckLinkPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckLinkPermission.expectedInvocations, n)
	return mmCheckLinkPermission
}

func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) invocationsDone() bool {
	if len(mmCheckLinkPermission.expectations) == 0 && mmCheckLinkPermission.defaultExpectation == nil && mmCheckLinkPermission.mock.funcCheckLinkPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckLinkPermission.mock.afterCheckLinkPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckLinkPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckLinkPermission implements acl.ACLClientInterface
func (mmCheckLinkPermission *ACLClientInterfaceMock) CheckLinkPermission(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckLinkPermission.beforeCheckLinkPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckLinkPermission.afterCheckLinkPermissionCounter, 1)

	if mmCheckLinkPermission.inspectFuncCheckLinkPermission != nil {
		mmCheckLinkPermission.inspectFuncCheckLinkPermission(ctx, objectType, objectUID, role)
	}

	mm_params := ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role}

	// Record call args
	mmCheckLinkPermission.CheckLinkPermissionMock.mutex.Lock()
	mmCheckLinkPermission.CheckLinkPermissionMock.callArgs = append(mmCheckLinkPermission.CheckLinkPermissionMock.callArgs, &mm_params)
	mmCheckLinkPermission.CheckLinkPermissionMock.mutex.Unlock()

	for _, e := range mmCheckLinkPermission.CheckLinkPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckLinkPermissionParams{ctx, objectType, objectUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter objectType, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameter role, want: %#v, got: %#v%s\n", *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckLinkPermission.t.Errorf("ACLClientInterfaceMock.CheckLinkPermission got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckLinkPermission.CheckLinkPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckLinkPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckLinkPermission")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckLinkPermission.funcCheckLinkPermission != nil {
		return mmCheckLinkPermission.funcCheckLinkPermission(ctx, objectType, objectUID, role)
	}
	mmCheckLinkPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckLinkPermission. %v %v %v %v", ctx, objectType, objectUID, role)
	return
}

// CheckLinkPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.CheckLinkPermission invocations
func (mmCheckLinkPermission *ACLClientInterfaceMock) CheckLinkPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckLinkPermission.afterCheckLinkPermissionCounter)
}

// CheckLinkPermissionBeforeCounter returns a count of ACLClientInterfaceMock.CheckLinkPermission invocations
func (mmCheckLinkPermission *ACLClientInterfaceMock) CheckLinkPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckLinkPermission.beforeCheckLinkPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckLinkPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckLinkPermission *mACLClientInterfaceMockCheckLinkPermission) Calls() []*ACLClientInterfaceMockCheckLinkPermissionParams {
	mmCheckLinkPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckLinkPermissionParams, len(mmCheckLinkPermission.callArgs))
	copy(argCopy, mmCheckLinkPermission.callArgs)

	mmCheckLinkPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckLinkPermissionDone returns true if the count of the CheckLinkPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckLinkPermissionDone() bool {
	if m.CheckLinkPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckLinkPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckLinkPermissionMock.invocationsDone()
}

// MinimockCheckLinkPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckLinkPermissionInspect() {
	for _, e := range m.CheckLinkPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckLinkPermission with params: %#v", *e.params)
		}
	}

	afterCheckLinkPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckLinkPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckLinkPermissionMock.defaultExpectation != nil && afterCheckLinkPermissionCounter < 1 {
		if m.CheckLinkPermissionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.CheckLinkPermission")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckLinkPermission with params: %#v", *m.CheckLinkPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckLinkPermission != nil && afterCheckLinkPermissionCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.CheckLinkPermission")
	}

	if !m.CheckLinkPermissionMock.invocationsDone() && afterCheckLinkPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckLinkPermission but found %d calls",
			mm_atomic.LoadUint64(&m.CheckLinkPermissionMock.expectedInvocations), afterCheckLinkPermissionCounter)
	}
}

type mACLClientInterfaceMockCheckPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPermissionExpectation
	expectations       []*ACLClientInterfaceMockCheckPermissionExpectation

	callArgs []*ACLClientInterfaceMockCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockCheckPermissionExpectation specifies expectation struct of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockCheckPermissionParams
	paramPtrs *ACLClientInterfaceMockCheckPermissionParamPtrs
	results   *ACLClientInterfaceMockCheckPermissionResults
	Counter   uint64
}

// ACLClientInterfaceMockCheckPermissionParams contains parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	role       string
}

// ACLClientInterfaceMockCheckPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	role       *string
}

// ACLClientInterfaceMockCheckPermissionResults contains results of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionResults struct {
	b1  bool
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Optional() *mACLClientInterfaceMockCheckPermission {
	mmCheckPermission.optional = true
	return mmCheckPermission
}

// Expect sets up expected params for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.paramPtrs != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by ExpectParams functions")
	}

	mmCheckPermission.defaultExpectation.params = &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}
	for _, e := range mmCheckPermission.expectations {
		if minimock.Equal(e.params, mmCheckPermission.defaultExpectation.params) {
			mmCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPermission.defaultExpectation.params)
		}
	}

	return mmCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheckPermission
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectType = &objectType

	return mmCheckPermission
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmCheckPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.role = &role

	return mmCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.inspectFuncCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPermission")
	}

	mmCheckPermission.mock.inspectFuncCheckPermission = f

	return mmCheckPermission
}

// Return sets up results that will be returned by ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{mock: mmCheckPermission.mock}
	}
	mmCheckPermission.defaultExpectation.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	return mmCheckPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPermission method
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPermission.defaultExpectation != nil {
		mmCheckPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPermission method")
	}

	if len(mmCheckPermission.expectations) > 0 {
		mmCheckPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPermission method")
	}

	mmCheckPermission.mock.funcCheckPermission = f
	return mmCheckPermission.mock
}

// When sets expectation for the ACLClientInterface.CheckPermission which will trigger the result defined by the following
// Then helper
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) When(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *ACLClientInterfaceMockCheckPermissionExpectation {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPermissionExpectation{
		mock:   mmCheckPermission.mock,
		params: &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role},
	}
	mmCheckPermission.expectations = append(mmCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPermissionExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPermission should be invoked
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Times(n uint64) *mACLClientInterfaceMockCheckPermission {
	if n == 0 {
		mmCheckPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPermission.expectedInvocations, n)
	return mmCheckPermission
}

func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) invocationsDone() bool {
	if len(mmCheckPermission.expectations) == 0 && mmCheckPermission.defaultExpectation == nil && mmCheckPermission.mock.funcCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPermission.mock.afterCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPermission implements acl.ACLClientInterface
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermission(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPermission.beforeCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPermission.afterCheckPermissionCounter, 1)

	if mmCheckPermission.inspectFuncCheckPermission != nil {
		mmCheckPermission.inspectFuncCheckPermission(ctx, objectType, objectUID, role)
	}

	mm_params := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

	// Record call args
	mmCheckPermission.CheckPermissionMock.mutex.Lock()
	mmCheckPermission.CheckPermissionMock.callArgs = append(mmCheckPermission.CheckPermissionMock.callArgs, &mm_params)
	mmCheckPermission.CheckPermissionMock.mutex.Unlock()

	for _, e := range mmCheckPermission.CheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPermission.CheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPermission.CheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPermission.CheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPermission.CheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectType, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter role, want: %#v, got: %#v%s\n", *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPermission.CheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPermission")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPermission.funcCheckPermission != nil {
		return mmCheckPermission.funcCheckPermission(ctx, objectType, objectUID, role)
	}
	mmCheckPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPermission. %v %v %v %v", ctx, objectType, objectUID, role)
	return
}

// CheckPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.afterCheckPermissionCounter)
}

// CheckPermissionBeforeCounter returns a count of ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.beforeCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Calls() []*ACLClientInterfaceMockCheckPermissionParams {
	mmCheckPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPermissionParams, len(mmCheckPermission.callArgs))
	copy(argCopy, mmCheckPermission.callArgs)

	mmCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPermissionDone returns true if the count of the CheckPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPermissionDone() bool {
	if m.CheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPermissionMock.invocationsDone()
}

// MinimockCheckPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPermissionInspect() {
	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission with params: %#v", *e.params)
		}
	}

	afterCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPermissionMock.defaultExpectation != nil && afterCheckPermissionCounter < 1 {
		if m.CheckPermissionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.CheckPermission")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission with params: %#v", *m.CheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPermission != nil && afterCheckPermissionCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.CheckPermission")
	}

	if !m.CheckPermissionMock.invocationsDone() && afterCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPermission but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPermissionMock.expectedInvocations), afterCheckPermissionCounter)
	}
}

type mACLClientInterfaceMockCheckPublicExecutable struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPublicExecutableExpectation
	expectations       []*ACLClientInterfaceMockCheckPublicExecutableExpectation

	callArgs []*ACLClientInterfaceMockCheckPublicExecutableParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockCheckPublicExecutableExpectation specifies expectation struct of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockCheckPublicExecutableParams
	paramPtrs *ACLClientInterfaceMockCheckPublicExecutableParamPtrs
	results   *ACLClientInterfaceMockCheckPublicExecutableResults
	Counter   uint64
}

// ACLClientInterfaceMockCheckPublicExecutableParams contains parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableResults contains results of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableResults struct {
	b1  bool
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Optional() *mACLClientInterfaceMockCheckPublicExecutable {
	mmCheckPublicExecutable.optional = true
	return mmCheckPublicExecutable
}

// Expect sets up expected params for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Expect(ctx context.Context, objectType string, objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by ExpectParams functions")
	}

	mmCheckPublicExecutable.defaultExpectation.params = &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}
	for _, e := range mmCheckPublicExecutable.expectations {
		if minimock.Equal(e.params, mmCheckPublicExecutable.defaultExpectation.params) {
			mmCheckPublicExecutable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPublicExecutable.defaultExpectation.params)
		}
	}

	return mmCheckPublicExecutable
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheckPublicExecutable
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectType = &objectType

	return mmCheckPublicExecutable
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmCheckPublicExecutable
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID)) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPublicExecutable")
	}

	mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable = f

	return mmCheckPublicExecutable
}

// Return sets up results that will be returned by ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{mock: mmCheckPublicExecutable.mock}
	}
	mmCheckPublicExecutable.defaultExpectation.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	return mmCheckPublicExecutable.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPublicExecutable method
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.defaultExpectation != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	if len(mmCheckPublicExecutable.expectations) > 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	mmCheckPublicExecutable.mock.funcCheckPublicExecutable = f
	return mmCheckPublicExecutable.mock
}

// When sets expectation for the ACLClientInterface.CheckPublicExecutable which will trigger the result defined by the following
// Then helper
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) When(ctx context.Context, objectType string, objectUID uuid.UUID) *ACLClientInterfaceMockCheckPublicExecutableExpectation {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPublicExecutableExpectation{
		mock:   mmCheckPublicExecutable.mock,
		params: &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID},
	}
	mmCheckPublicExecutable.expectations = append(mmCheckPublicExecutable.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPublicExecutable return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPublicExecutableExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPublicExecutable should be invoked
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Times(n uint64) *mACLClientInterfaceMockCheckPublicExecutable {
	if n == 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPublicExecutable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPublicExecutable.expectedInvocations, n)
	return mmCheckPublicExecutable
}

func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) invocationsDone() bool {
	if len(mmCheckPublicExecutable.expectations) == 0 && mmCheckPublicExecutable.defaultExpectation == nil && mmCheckPublicExecutable.mock.funcCheckPublicExecutable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.mock.afterCheckPublicExecutableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPublicExecutable implements acl.ACLClientInterface
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutable(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter, 1)

	if mmCheckPublicExecutable.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.inspectFuncCheckPublicExecutable(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

	// Record call args
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Lock()
	mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs = append(mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs, &mm_params)
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Unlock()

	for _, e := range mmCheckPublicExecutable.CheckPublicExecutableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectType, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPublicExecutable.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPublicExecutable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPublicExecutable.funcCheckPublicExecutable != nil {
		return mmCheckPublicExecutable.funcCheckPublicExecutable(ctx, objectType, objectUID)
	}
	mmCheckPublicExecutable.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPublicExecutable. %v %v %v", ctx, objectType, objectUID)
	return
}

// CheckPublicExecutableAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter)
}

// CheckPublicExecutableBeforeCounter returns a count of ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPublicExecutable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Calls() []*ACLClientInterfaceMockCheckPublicExecutableParams {
	mmCheckPublicExecutable.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPublicExecutableParams, len(mmCheckPublicExecutable.callArgs))
	copy(argCopy, mmCheckPublicExecutable.callArgs)

	mmCheckPublicExecutable.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPublicExecutableDone returns true if the count of the CheckPublicExecutable invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableDone() bool {
	if m.CheckPublicExecutableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPublicExecutableMock.invocationsDone()
}

// MinimockCheckPublicExecutableInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableInspect() {
	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable with params: %#v", *e.params)
		}
	}

	afterCheckPublicExecutableCounter := mm_atomic.LoadUint64(&m.afterCheckPublicExecutableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPublicExecutableMock.defaultExpectation != nil && afterCheckPublicExecutableCounter < 1 {
		if m.CheckPublicExecutableMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.CheckPublicExecutable")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable with params: %#v", *m.CheckPublicExecutableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPublicExecutable != nil && afterCheckPublicExecutableCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.CheckPublicExecutable")
	}

	if !m.CheckPublicExecutableMock.invocationsDone() && afterCheckPublicExecutableCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPublicExecutable but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPublicExecutableMock.expectedInvocations), afterCheckPublicExecutableCounter)
	}
}

type mACLClientInterfaceMockDeletePipelinePermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockDeletePipelinePermissionExpectation
	expectations       []*ACLClientInterfaceMockDeletePipelinePermissionExpectation

	callArgs []*ACLClientInterfaceMockDeletePipelinePermissionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockDeletePipelinePermissionExpectation specifies expectation struct of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockDeletePipelinePermissionParams
	paramPtrs *ACLClientInterfaceMockDeletePipelinePermissionParamPtrs
	results   *ACLClientInterfaceMockDeletePipelinePermissionResults
	Counter   uint64
}

// ACLClientInterfaceMockDeletePipelinePermissionParams contains parameters of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	user        string
}

// ACLClientInterfaceMockDeletePipelinePermissionParamPtrs contains pointers to parameters of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	user        *string
}

// ACLClientInterfaceMockDeletePipelinePermissionResults contains results of the ACLClientInterface.DeletePipelinePermission
type ACLClientInterfaceMockDeletePipelinePermissionResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Optional() *mACLClientInterfaceMockDeletePipelinePermission {
	mmDeletePipelinePermission.optional = true
	return mmDeletePipelinePermission
}

// Expect sets up expected params for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Expect(ctx context.Context, pipelineUID uuid.UUID, user string) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by ExpectParams functions")
	}

	mmDeletePipelinePermission.defaultExpectation.params = &ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user}
	for _, e := range mmDeletePipelinePermission.expectations {
		if minimock.Equal(e.params, mmDeletePipelinePermission.defaultExpectation.params) {
			mmDeletePipelinePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelinePermission.defaultExpectation.params)
		}
	}

	return mmDeletePipelinePermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeletePipelinePermission
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmDeletePipelinePermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) ExpectUserParam3(user string) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{}
	}

	if mmDeletePipelinePermission.defaultExpectation.params != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Expect")
	}

	if mmDeletePipelinePermission.defaultExpectation.paramPtrs == nil {
		mmDeletePipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePipelinePermissionParamPtrs{}
	}
	mmDeletePipelinePermission.defaultExpectation.paramPtrs.user = &user

	return mmDeletePipelinePermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, user string)) *mACLClientInterfaceMockDeletePipelinePermission {
	if mmDeletePipelinePermission.mock.inspectFuncDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.DeletePipelinePermission")
	}

	mmDeletePipelinePermission.mock.inspectFuncDeletePipelinePermission = f

	return mmDeletePipelinePermission
}

// Return sets up results that will be returned by ACLClientInterface.DeletePipelinePermission
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Return(err error) *ACLClientInterfaceMock {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	if mmDeletePipelinePermission.defaultExpectation == nil {
		mmDeletePipelinePermission.defaultExpectation = &ACLClientInterfaceMockDeletePipelinePermissionExpectation{mock: mmDeletePipelinePermission.mock}
	}
	mmDeletePipelinePermission.defaultExpectation.results = &ACLClientInterfaceMockDeletePipelinePermissionResults{err}
	return mmDeletePipelinePermission.mock
}

// Set uses given function f to mock the ACLClientInterface.DeletePipelinePermission method
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Set(f func(ctx context.Context, pipelineUID uuid.UUID, user string) (err error)) *ACLClientInterfaceMock {
	if mmDeletePipelinePermission.defaultExpectation != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.DeletePipelinePermission method")
	}

	if len(mmDeletePipelinePermission.expectations) > 0 {
		mmDeletePipelinePermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.DeletePipelinePermission method")
	}

	mmDeletePipelinePermission.mock.funcDeletePipelinePermission = f
	return mmDeletePipelinePermission.mock
}

// When sets expectation for the ACLClientInterface.DeletePipelinePermission which will trigger the result defined by the following
// Then helper
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) When(ctx context.Context, pipelineUID uuid.UUID, user string) *ACLClientInterfaceMockDeletePipelinePermissionExpectation {
	if mmDeletePipelinePermission.mock.funcDeletePipelinePermission != nil {
		mmDeletePipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePipelinePermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockDeletePipelinePermissionExpectation{
		mock:   mmDeletePipelinePermission.mock,
		params: &ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user},
	}
	mmDeletePipelinePermission.expectations = append(mmDeletePipelinePermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.DeletePipelinePermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockDeletePipelinePermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockDeletePipelinePermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.DeletePipelinePermission should be invoked
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Times(n uint64) *mACLClientInterfaceMockDeletePipelinePermission {
	if n == 0 {
		mmDeletePipelinePermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.DeletePipelinePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelinePermission.expectedInvocations, n)
	return mmDeletePipelinePermission
}

func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) invocationsDone() bool {
	if len(mmDeletePipelinePermission.expectations) == 0 && mmDeletePipelinePermission.defaultExpectation == nil && mmDeletePipelinePermission.mock.funcDeletePipelinePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelinePermission.mock.afterDeletePipelinePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelinePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelinePermission implements acl.ACLClientInterface
func (mmDeletePipelinePermission *ACLClientInterfaceMock) DeletePipelinePermission(ctx context.Context, pipelineUID uuid.UUID, user string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelinePermission.beforeDeletePipelinePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelinePermission.afterDeletePipelinePermissionCounter, 1)

	if mmDeletePipelinePermission.inspectFuncDeletePipelinePermission != nil {
		mmDeletePipelinePermission.inspectFuncDeletePipelinePermission(ctx, pipelineUID, user)
	}

	mm_params := ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user}

	// Record call args
	mmDeletePipelinePermission.DeletePipelinePermissionMock.mutex.Lock()
	mmDeletePipelinePermission.DeletePipelinePermissionMock.callArgs = append(mmDeletePipelinePermission.DeletePipelinePermissionMock.callArgs, &mm_params)
	mmDeletePipelinePermission.DeletePipelinePermissionMock.mutex.Unlock()

	for _, e := range mmDeletePipelinePermission.DeletePipelinePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockDeletePipelinePermissionParams{ctx, pipelineUID, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelinePermission.t.Errorf("ACLClientInterfaceMock.DeletePipelinePermission got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelinePermission.DeletePipelinePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelinePermission.t.Fatal("No results are set for the ACLClientInterfaceMock.DeletePipelinePermission")
		}
		return (*mm_results).err
	}
	if mmDeletePipelinePermission.funcDeletePipelinePermission != nil {
		return mmDeletePipelinePermission.funcDeletePipelinePermission(ctx, pipelineUID, user)
	}
	mmDeletePipelinePermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.DeletePipelinePermission. %v %v %v", ctx, pipelineUID, user)
	return
}

// DeletePipelinePermissionAfterCounter returns a count of finished ACLClientInterfaceMock.DeletePipelinePermission invocations
func (mmDeletePipelinePermission *ACLClientInterfaceMock) DeletePipelinePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelinePermission.afterDeletePipelinePermissionCounter)
}

// DeletePipelinePermissionBeforeCounter returns a count of ACLClientInterfaceMock.DeletePipelinePermission invocations
func (mmDeletePipelinePermission *ACLClientInterfaceMock) DeletePipelinePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelinePermission.beforeDeletePipelinePermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.DeletePipelinePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelinePermission *mACLClientInterfaceMockDeletePipelinePermission) Calls() []*ACLClientInterfaceMockDeletePipelinePermissionParams {
	mmDeletePipelinePermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockDeletePipelinePermissionParams, len(mmDeletePipelinePermission.callArgs))
	copy(argCopy, mmDeletePipelinePermission.callArgs)

	mmDeletePipelinePermission.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelinePermissionDone returns true if the count of the DeletePipelinePermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockDeletePipelinePermissionDone() bool {
	if m.DeletePipelinePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelinePermissionMock.invocationsDone()
}

// MinimockDeletePipelinePermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockDeletePipelinePermissionInspect() {
	for _, e := range m.DeletePipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePipelinePermission with params: %#v", *e.params)
		}
	}

	afterDeletePipelinePermissionCounter := mm_atomic.LoadUint64(&m.afterDeletePipelinePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelinePermissionMock.defaultExpectation != nil && afterDeletePipelinePermissionCounter < 1 {
		if m.DeletePipelinePermissionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.DeletePipelinePermission")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePipelinePermission with params: %#v", *m.DeletePipelinePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelinePermission != nil && afterDeletePipelinePermissionCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.DeletePipelinePermission")
	}

	if !m.DeletePipelinePermissionMock.invocationsDone() && afterDeletePipelinePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.DeletePipelinePermission but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelinePermissionMock.expectedInvocations), afterDeletePipelinePermissionCounter)
	}
}

type mACLClientInterfaceMockListPermissions struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockListPermissionsExpectation
	expectations       []*ACLClientInterfaceMockListPermissionsExpectation

	callArgs []*ACLClientInterfaceMockListPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockListPermissionsExpectation specifies expectation struct of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockListPermissionsParams
	paramPtrs *ACLClientInterfaceMockListPermissionsParamPtrs
	results   *ACLClientInterfaceMockListPermissionsResults
	Counter   uint64
}

// ACLClientInterfaceMockListPermissionsParams contains parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParams struct {
	ctx        context.Context
	objectType string
	role       string
	isPublic   bool
}

// ACLClientInterfaceMockListPermissionsParamPtrs contains pointers to parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParamPtrs struct {
	ctx        *context.Context
	objectType *string
	role       *string
	isPublic   *bool
}

// ACLClientInterfaceMockListPermissionsResults contains results of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsResults struct {
	ua1 []uuid.UUID
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Optional() *mACLClientInterfaceMockListPermissions {
	mmListPermissions.optional = true
	return mmListPermissions
}

// Expect sets up expected params for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Expect(ctx context.Context, objectType string, role string, isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.paramPtrs != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by ExpectParams functions")
	}

	mmListPermissions.defaultExpectation.params = &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}
	for _, e := range mmListPermissions.expectations {
		if minimock.Equal(e.params, mmListPermissions.defaultExpectation.params) {
			mmListPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPermissions.defaultExpectation.params)
		}
	}

	return mmListPermissions
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListPermissions
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.objectType = &objectType

	return mmListPermissions
}

// ExpectRoleParam3 sets up expected param role for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectRoleParam3(role string) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.role = &role

	return mmListPermissions
}

// ExpectIsPublicParam4 sets up expected param isPublic for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectIsPublicParam4(isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.isPublic = &isPublic

	return mmListPermissions
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Inspect(f func(ctx context.Context, objectType string, role string, isPublic bool)) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.inspectFuncListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.ListPermissions")
	}

	mmListPermissions.mock.inspectFuncListPermissions = f

	return mmListPermissions
}

// Return sets up results that will be returned by ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Return(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{mock: mmListPermissions.mock}
	}
	mmListPermissions.defaultExpectation.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	return mmListPermissions.mock
}

// Set uses given function f to mock the ACLClientInterface.ListPermissions method
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Set(f func(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error)) *ACLClientInterfaceMock {
	if mmListPermissions.defaultExpectation != nil {
		mmListPermissions.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.ListPermissions method")
	}

	if len(mmListPermissions.expectations) > 0 {
		mmListPermissions.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.ListPermissions method")
	}

	mmListPermissions.mock.funcListPermissions = f
	return mmListPermissions.mock
}

// When sets expectation for the ACLClientInterface.ListPermissions which will trigger the result defined by the following
// Then helper
func (mmListPermissions *mACLClientInterfaceMockListPermissions) When(ctx context.Context, objectType string, role string, isPublic bool) *ACLClientInterfaceMockListPermissionsExpectation {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockListPermissionsExpectation{
		mock:   mmListPermissions.mock,
		params: &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic},
	}
	mmListPermissions.expectations = append(mmListPermissions.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.ListPermissions return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockListPermissionsExpectation) Then(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.ListPermissions should be invoked
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Times(n uint64) *mACLClientInterfaceMockListPermissions {
	if n == 0 {
		mmListPermissions.mock.t.Fatalf("Times of ACLClientInterfaceMock.ListPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPermissions.expectedInvocations, n)
	return mmListPermissions
}

func (mmListPermissions *mACLClientInterfaceMockListPermissions) invocationsDone() bool {
	if len(mmListPermissions.expectations) == 0 && mmListPermissions.defaultExpectation == nil && mmListPermissions.mock.funcListPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPermissions.mock.afterListPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPermissions implements acl.ACLClientInterface
func (mmListPermissions *ACLClientInterfaceMock) ListPermissions(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmListPermissions.beforeListPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPermissions.afterListPermissionsCounter, 1)

	if mmListPermissions.inspectFuncListPermissions != nil {
		mmListPermissions.inspectFuncListPermissions(ctx, objectType, role, isPublic)
	}

	mm_params := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

	// Record call args
	mmListPermissions.ListPermissionsMock.mutex.Lock()
	mmListPermissions.ListPermissionsMock.callArgs = append(mmListPermissions.ListPermissionsMock.callArgs, &mm_params)
	mmListPermissions.ListPermissionsMock.mutex.Unlock()

	for _, e := range mmListPermissions.ListPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListPermissions.ListPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPermissions.ListPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPermissions.ListPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmListPermissions.ListPermissionsMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter objectType, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter role, want: %#v, got: %#v%s\n", *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.isPublic != nil && !minimock.Equal(*mm_want_ptrs.isPublic, mm_got.isPublic) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter isPublic, want: %#v, got: %#v%s\n", *mm_want_ptrs.isPublic, mm_got.isPublic, minimock.Diff(*mm_want_ptrs.isPublic, mm_got.isPublic))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPermissions.ListPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPermissions.t.Fatal("No results are set for the ACLClientInterfaceMock.ListPermissions")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListPermissions.funcListPermissions != nil {
		return mmListPermissions.funcListPermissions(ctx, objectType, role, isPublic)
	}
	mmListPermissions.t.Fatalf("Unexpected call to ACLClientInterfaceMock.ListPermissions. %v %v %v %v", ctx, objectType, role, isPublic)
	return
}

// ListPermissionsAfterCounter returns a count of finished ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.afterListPermissionsCounter)
}

// ListPermissionsBeforeCounter returns a count of ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.beforeListPermissionsCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.ListPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Calls() []*ACLClientInterfaceMockListPermissionsParams {
	mmListPermissions.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockListPermissionsParams, len(mmListPermissions.callArgs))
	copy(argCopy, mmListPermissions.callArgs)

	mmListPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockListPermissionsDone returns true if the count of the ListPermissions invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockListPermissionsDone() bool {
	if m.ListPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPermissionsMock.invocationsDone()
}

// MinimockListPermissionsInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockListPermissionsInspect() {
	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions with params: %#v", *e.params)
		}
	}

	afterListPermissionsCounter := mm_atomic.LoadUint64(&m.afterListPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPermissionsMock.defaultExpectation != nil && afterListPermissionsCounter < 1 {
		if m.ListPermissionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.ListPermissions")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions with params: %#v", *m.ListPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPermissions != nil && afterListPermissionsCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.ListPermissions")
	}

	if !m.ListPermissionsMock.invocationsDone() && afterListPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.ListPermissions but found %d calls",
			mm_atomic.LoadUint64(&m.ListPermissionsMock.expectedInvocations), afterListPermissionsCounter)
	}
}

type mACLClientInterfaceMockPurge struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockPurgeExpectation
	expectations       []*ACLClientInterfaceMockPurgeExpectation

	callArgs []*ACLClientInterfaceMockPurgeParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockPurgeExpectation specifies expectation struct of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockPurgeParams
	paramPtrs *ACLClientInterfaceMockPurgeParamPtrs
	results   *ACLClientInterfaceMockPurgeResults
	Counter   uint64
}

// ACLClientInterfaceMockPurgeParams contains parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockPurgeParamPtrs contains pointers to parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockPurgeResults contains results of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPurge *mACLClientInterfaceMockPurge) Optional() *mACLClientInterfaceMockPurge {
	mmPurge.optional = true
	return mmPurge
}

// Expect sets up expected params for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Expect(ctx context.Context, objectType string, objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.paramPtrs != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by ExpectParams functions")
	}

	mmPurge.defaultExpectation.params = &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}
	for _, e := range mmPurge.expectations {
		if minimock.Equal(e.params, mmPurge.defaultExpectation.params) {
			mmPurge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurge.defaultExpectation.params)
		}
	}

	return mmPurge
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPurge
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectType = &objectType

	return mmPurge
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmPurge
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID)) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.inspectFuncPurge != nil {
		mmPurge.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.Purge")
	}

	mmPurge.mock.inspectFuncPurge = f

	return mmPurge
}

// Return sets up results that will be returned by ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Return(err error) *ACLClientInterfaceMock {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{mock: mmPurge.mock}
	}
	mmPurge.defaultExpectation.results = &ACLClientInterfaceMockPurgeResults{err}
	return mmPurge.mock
}

// Set uses given function f to mock the ACLClientInterface.Purge method
func (mmPurge *mACLClientInterfaceMockPurge) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmPurge.defaultExpectation != nil {
		mmPurge.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.Purge method")
	}

	if len(mmPurge.expectations) > 0 {
		mmPurge.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.Purge method")
	}

	mmPurge.mock.funcPurge = f
	return mmPurge.mock
}

// When sets expectation for the ACLClientInterface.Purge which will trigger the result defined by the following
// Then helper
func (mmPurge *mACLClientInterfaceMockPurge) When(ctx context.Context, objectType string, objectUID uuid.UUID) *ACLClientInterfaceMockPurgeExpectation {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockPurgeExpectation{
		mock:   mmPurge.mock,
		params: &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID},
	}
	mmPurge.expectations = append(mmPurge.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.Purge return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockPurgeExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockPurgeResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.Purge should be invoked
func (mmPurge *mACLClientInterfaceMockPurge) Times(n uint64) *mACLClientInterfaceMockPurge {
	if n == 0 {
		mmPurge.mock.t.Fatalf("Times of ACLClientInterfaceMock.Purge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPurge.expectedInvocations, n)
	return mmPurge
}

func (mmPurge *mACLClientInterfaceMockPurge) invocationsDone() bool {
	if len(mmPurge.expectations) == 0 && mmPurge.defaultExpectation == nil && mmPurge.mock.funcPurge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPurge.mock.afterPurgeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPurge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Purge implements acl.ACLClientInterface
func (mmPurge *ACLClientInterfaceMock) Purge(ctx context.Context, objectType string, objectUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmPurge.beforePurgeCounter, 1)
	defer mm_atomic.AddUint64(&mmPurge.afterPurgeCounter, 1)

	if mmPurge.inspectFuncPurge != nil {
		mmPurge.inspectFuncPurge(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

	// Record call args
	mmPurge.PurgeMock.mutex.Lock()
	mmPurge.PurgeMock.callArgs = append(mmPurge.PurgeMock.callArgs, &mm_params)
	mmPurge.PurgeMock.mutex.Unlock()

	for _, e := range mmPurge.PurgeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurge.PurgeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurge.PurgeMock.defaultExpectation.Counter, 1)
		mm_want := mmPurge.PurgeMock.defaultExpectation.params
		mm_want_ptrs := mmPurge.PurgeMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectType, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurge.PurgeMock.defaultExpectation.results
		if mm_results == nil {
			mmPurge.t.Fatal("No results are set for the ACLClientInterfaceMock.Purge")
		}
		return (*mm_results).err
	}
	if mmPurge.funcPurge != nil {
		return mmPurge.funcPurge(ctx, objectType, objectUID)
	}
	mmPurge.t.Fatalf("Unexpected call to ACLClientInterfaceMock.Purge. %v %v %v", ctx, objectType, objectUID)
	return
}

// PurgeAfterCounter returns a count of finished ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.afterPurgeCounter)
}

// PurgeBeforeCounter returns a count of ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.beforePurgeCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.Purge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurge *mACLClientInterfaceMockPurge) Calls() []*ACLClientInterfaceMockPurgeParams {
	mmPurge.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockPurgeParams, len(mmPurge.callArgs))
	copy(argCopy, mmPurge.callArgs)

	mmPurge.mutex.RUnlock()

	return argCopy
}

// MinimockPurgeDone returns true if the count of the Purge invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockPurgeDone() bool {
	if m.PurgeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PurgeMock.invocationsDone()
}

// MinimockPurgeInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockPurgeInspect() {
	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge with params: %#v", *e.params)
		}
	}

	afterPurgeCounter := mm_atomic.LoadUint64(&m.afterPurgeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeMock.defaultExpectation != nil && afterPurgeCounter < 1 {
		if m.PurgeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.Purge")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge with params: %#v", *m.PurgeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurge != nil && afterPurgeCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.Purge")
	}

	if !m.PurgeMock.invocationsDone() && afterPurgeCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.Purge but found %d calls",
			mm_atomic.LoadUint64(&m.PurgeMock.expectedInvocations), afterPurgeCounter)
	}
}

type mACLClientInterfaceMockSetOwner struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetOwnerExpectation
	expectations       []*ACLClientInterfaceMockSetOwnerExpectation

	callArgs []*ACLClientInterfaceMockSetOwnerParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockSetOwnerExpectation specifies expectation struct of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockSetOwnerParams
	paramPtrs *ACLClientInterfaceMockSetOwnerParamPtrs
	results   *ACLClientInterfaceMockSetOwnerResults
	Counter   uint64
}

// ACLClientInterfaceMockSetOwnerParams contains parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	ownerType  string
	ownerUID   uuid.UUID
}

// ACLClientInterfaceMockSetOwnerParamPtrs contains pointers to parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	ownerType  *string
	ownerUID   *uuid.UUID
}

// ACLClientInterfaceMockSetOwnerResults contains results of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Optional() *mACLClientInterfaceMockSetOwner {
	mmSetOwner.optional = true
	return mmSetOwner
}

// Expect sets up expected params for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.paramPtrs != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by ExpectParams functions")
	}

	mmSetOwner.defaultExpectation.params = &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}
	for _, e := range mmSetOwner.expectations {
		if minimock.Equal(e.params, mmSetOwner.defaultExpectation.params) {
			mmSetOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOwner.defaultExpectation.params)
		}
	}

	return mmSetOwner
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetOwner
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectType = &objectType

	return mmSetOwner
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectUID = &objectUID

	return mmSetOwner
}

// ExpectOwnerTypeParam4 sets up expected param ownerType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerTypeParam4(ownerType string) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerType = &ownerType

	return mmSetOwner
}

// ExpectOwnerUIDParam5 sets up expected param ownerUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerUIDParam5(ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID

	return mmSetOwner
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID)) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.inspectFuncSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetOwner")
	}

	mmSetOwner.mock.inspectFuncSetOwner = f

	return mmSetOwner
}

// Return sets up results that will be returned by ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Return(err error) *ACLClientInterfaceMock {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{mock: mmSetOwner.mock}
	}
	mmSetOwner.defaultExpectation.results = &ACLClientInterfaceMockSetOwnerResults{err}
	return mmSetOwner.mock
}

// Set uses given function f to mock the ACLClientInterface.SetOwner method
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmSetOwner.defaultExpectation != nil {
		mmSetOwner.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetOwner method")
	}

	if len(mmSetOwner.expectations) > 0 {
		mmSetOwner.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetOwner method")
	}

	mmSetOwner.mock.funcSetOwner = f
	return mmSetOwner.mock
}

// When sets expectation for the ACLClientInterface.SetOwner which will trigger the result defined by the following
// Then helper
func (mmSetOwner *mACLClientInterfaceMockSetOwner) When(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) *ACLClientInterfaceMockSetOwnerExpectation {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetOwnerExpectation{
		mock:   mmSetOwner.mock,
		params: &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID},
	}
	mmSetOwner.expectations = append(mmSetOwner.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetOwner return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetOwnerExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetOwnerResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetOwner should be invoked
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Times(n uint64) *mACLClientInterfaceMockSetOwner {
	if n == 0 {
		mmSetOwner.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOwner.expectedInvocations, n)
	return mmSetOwner
}

func (mmSetOwner *mACLClientInterfaceMockSetOwner) invocationsDone() bool {
	if len(mmSetOwner.expectations) == 0 && mmSetOwner.defaultExpectation == nil && mmSetOwner.mock.funcSetOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOwner.mock.afterSetOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOwner implements acl.ACLClientInterface
func (mmSetOwner *ACLClientInterfaceMock) SetOwner(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSetOwner.beforeSetOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOwner.afterSetOwnerCounter, 1)

	if mmSetOwner.inspectFuncSetOwner != nil {
		mmSetOwner.inspectFuncSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}

	mm_params := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

	// Record call args
	mmSetOwner.SetOwnerMock.mutex.Lock()
	mmSetOwner.SetOwnerMock.callArgs = append(mmSetOwner.SetOwnerMock.callArgs, &mm_params)
	mmSetOwner.SetOwnerMock.mutex.Unlock()

	for _, e := range mmSetOwner.SetOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOwner.SetOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOwner.SetOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOwner.SetOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmSetOwner.SetOwnerMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectType, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.ownerType != nil && !minimock.Equal(*mm_want_ptrs.ownerType, mm_got.ownerType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerType, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerType, mm_got.ownerType, minimock.Diff(*mm_want_ptrs.ownerType, mm_got.ownerType))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOwner.SetOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOwner.t.Fatal("No results are set for the ACLClientInterfaceMock.SetOwner")
		}
		return (*mm_results).err
	}
	if mmSetOwner.funcSetOwner != nil {
		return mmSetOwner.funcSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}
	mmSetOwner.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetOwner. %v %v %v %v %v", ctx, objectType, objectUID, ownerType, ownerUID)
	return
}

// SetOwnerAfterCounter returns a count of finished ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.afterSetOwnerCounter)
}

// SetOwnerBeforeCounter returns a count of ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.beforeSetOwnerCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Calls() []*ACLClientInterfaceMockSetOwnerParams {
	mmSetOwner.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetOwnerParams, len(mmSetOwner.callArgs))
	copy(argCopy, mmSetOwner.callArgs)

	mmSetOwner.mutex.RUnlock()

	return argCopy
}

// MinimockSetOwnerDone returns true if the count of the SetOwner invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetOwnerDone() bool {
	if m.SetOwnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOwnerMock.invocationsDone()
}

// MinimockSetOwnerInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetOwnerInspect() {
	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner with params: %#v", *e.params)
		}
	}

	afterSetOwnerCounter := mm_atomic.LoadUint64(&m.afterSetOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOwnerMock.defaultExpectation != nil && afterSetOwnerCounter < 1 {
		if m.SetOwnerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.SetOwner")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner with params: %#v", *m.SetOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOwner != nil && afterSetOwnerCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.SetOwner")
	}

	if !m.SetOwnerMock.invocationsDone() && afterSetOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetOwner but found %d calls",
			mm_atomic.LoadUint64(&m.SetOwnerMock.expectedInvocations), afterSetOwnerCounter)
	}
}

type mACLClientInterfaceMockSetPipelinePermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetPipelinePermissionExpectation
	expectations       []*ACLClientInterfaceMockSetPipelinePermissionExpectation

	callArgs []*ACLClientInterfaceMockSetPipelinePermissionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockSetPipelinePermissionExpectation specifies expectation struct of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockSetPipelinePermissionParams
	paramPtrs *ACLClientInterfaceMockSetPipelinePermissionParamPtrs
	results   *ACLClientInterfaceMockSetPipelinePermissionResults
	Counter   uint64
}

// ACLClientInterfaceMockSetPipelinePermissionParams contains parameters of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	user        string
	role        string
	enable      bool
}

// ACLClientInterfaceMockSetPipelinePermissionParamPtrs contains pointers to parameters of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	user        *string
	role        *string
	enable      *bool
}

// ACLClientInterfaceMockSetPipelinePermissionResults contains results of the ACLClientInterface.SetPipelinePermission
type ACLClientInterfaceMockSetPipelinePermissionResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Optional() *mACLClientInterfaceMockSetPipelinePermission {
	mmSetPipelinePermission.optional = true
	return mmSetPipelinePermission
}

// Expect sets up expected params for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Expect(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by ExpectParams functions")
	}

	mmSetPipelinePermission.defaultExpectation.params = &ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}
	for _, e := range mmSetPipelinePermission.expectations {
		if minimock.Equal(e.params, mmSetPipelinePermission.defaultExpectation.params) {
			mmSetPipelinePermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPipelinePermission.defaultExpectation.params)
		}
	}

	return mmSetPipelinePermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetPipelinePermission
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmSetPipelinePermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectUserParam3(user string) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.user = &user

	return mmSetPipelinePermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.role = &role

	return mmSetPipelinePermission
}

// ExpectEnableParam5 sets up expected param enable for ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) ExpectEnableParam5(enable bool) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{}
	}

	if mmSetPipelinePermission.defaultExpectation.params != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Expect")
	}

	if mmSetPipelinePermission.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionParamPtrs{}
	}
	mmSetPipelinePermission.defaultExpectation.paramPtrs.enable = &enable

	return mmSetPipelinePermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool)) *mACLClientInterfaceMockSetPipelinePermission {
	if mmSetPipelinePermission.mock.inspectFuncSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetPipelinePermission")
	}

	mmSetPipelinePermission.mock.inspectFuncSetPipelinePermission = f

	return mmSetPipelinePermission
}

// Return sets up results that will be returned by ACLClientInterface.SetPipelinePermission
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Return(err error) *ACLClientInterfaceMock {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	if mmSetPipelinePermission.defaultExpectation == nil {
		mmSetPipelinePermission.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionExpectation{mock: mmSetPipelinePermission.mock}
	}
	mmSetPipelinePermission.defaultExpectation.results = &ACLClientInterfaceMockSetPipelinePermissionResults{err}
	return mmSetPipelinePermission.mock
}

// Set uses given function f to mock the ACLClientInterface.SetPipelinePermission method
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Set(f func(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error)) *ACLClientInterfaceMock {
	if mmSetPipelinePermission.defaultExpectation != nil {
		mmSetPipelinePermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetPipelinePermission method")
	}

	if len(mmSetPipelinePermission.expectations) > 0 {
		mmSetPipelinePermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetPipelinePermission method")
	}

	mmSetPipelinePermission.mock.funcSetPipelinePermission = f
	return mmSetPipelinePermission.mock
}

// When sets expectation for the ACLClientInterface.SetPipelinePermission which will trigger the result defined by the following
// Then helper
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) When(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) *ACLClientInterfaceMockSetPipelinePermissionExpectation {
	if mmSetPipelinePermission.mock.funcSetPipelinePermission != nil {
		mmSetPipelinePermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetPipelinePermissionExpectation{
		mock:   mmSetPipelinePermission.mock,
		params: &ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable},
	}
	mmSetPipelinePermission.expectations = append(mmSetPipelinePermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetPipelinePermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetPipelinePermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetPipelinePermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetPipelinePermission should be invoked
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Times(n uint64) *mACLClientInterfaceMockSetPipelinePermission {
	if n == 0 {
		mmSetPipelinePermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetPipelinePermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPipelinePermission.expectedInvocations, n)
	return mmSetPipelinePermission
}

func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) invocationsDone() bool {
	if len(mmSetPipelinePermission.expectations) == 0 && mmSetPipelinePermission.defaultExpectation == nil && mmSetPipelinePermission.mock.funcSetPipelinePermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermission.mock.afterSetPipelinePermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPipelinePermission implements acl.ACLClientInterface
func (mmSetPipelinePermission *ACLClientInterfaceMock) SetPipelinePermission(ctx context.Context, pipelineUID uuid.UUID, user string, role string, enable bool) (err error) {
	mm_atomic.AddUint64(&mmSetPipelinePermission.beforeSetPipelinePermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPipelinePermission.afterSetPipelinePermissionCounter, 1)

	if mmSetPipelinePermission.inspectFuncSetPipelinePermission != nil {
		mmSetPipelinePermission.inspectFuncSetPipelinePermission(ctx, pipelineUID, user, role, enable)
	}

	mm_params := ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}

	// Record call args
	mmSetPipelinePermission.SetPipelinePermissionMock.mutex.Lock()
	mmSetPipelinePermission.SetPipelinePermissionMock.callArgs = append(mmSetPipelinePermission.SetPipelinePermissionMock.callArgs, &mm_params)
	mmSetPipelinePermission.SetPipelinePermissionMock.mutex.Unlock()

	for _, e := range mmSetPipelinePermission.SetPipelinePermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.params
		mm_want_ptrs := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetPipelinePermissionParams{ctx, pipelineUID, user, role, enable}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter user, want: %#v, got: %#v%s\n", *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter role, want: %#v, got: %#v%s\n", *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.enable != nil && !minimock.Equal(*mm_want_ptrs.enable, mm_got.enable) {
				mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameter enable, want: %#v, got: %#v%s\n", *mm_want_ptrs.enable, mm_got.enable, minimock.Diff(*mm_want_ptrs.enable, mm_got.enable))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPipelinePermission.t.Errorf("ACLClientInterfaceMock.SetPipelinePermission got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPipelinePermission.SetPipelinePermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPipelinePermission.t.Fatal("No results are set for the ACLClientInterfaceMock.SetPipelinePermission")
		}
		return (*mm_results).err
	}
	if mmSetPipelinePermission.funcSetPipelinePermission != nil {
		return mmSetPipelinePermission.funcSetPipelinePermission(ctx, pipelineUID, user, role, enable)
	}
	mmSetPipelinePermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetPipelinePermission. %v %v %v %v %v", ctx, pipelineUID, user, role, enable)
	return
}

// SetPipelinePermissionAfterCounter returns a count of finished ACLClientInterfaceMock.SetPipelinePermission invocations
func (mmSetPipelinePermission *ACLClientInterfaceMock) SetPipelinePermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermission.afterSetPipelinePermissionCounter)
}

// SetPipelinePermissionBeforeCounter returns a count of ACLClientInterfaceMock.SetPipelinePermission invocations
func (mmSetPipelinePermission *ACLClientInterfaceMock) SetPipelinePermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermission.beforeSetPipelinePermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetPipelinePermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPipelinePermission *mACLClientInterfaceMockSetPipelinePermission) Calls() []*ACLClientInterfaceMockSetPipelinePermissionParams {
	mmSetPipelinePermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetPipelinePermissionParams, len(mmSetPipelinePermission.callArgs))
	copy(argCopy, mmSetPipelinePermission.callArgs)

	mmSetPipelinePermission.mutex.RUnlock()

	return argCopy
}

// MinimockSetPipelinePermissionDone returns true if the count of the SetPipelinePermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionDone() bool {
	if m.SetPipelinePermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPipelinePermissionMock.invocationsDone()
}

// MinimockSetPipelinePermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionInspect() {
	for _, e := range m.SetPipelinePermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermission with params: %#v", *e.params)
		}
	}

	afterSetPipelinePermissionCounter := mm_atomic.LoadUint64(&m.afterSetPipelinePermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPipelinePermissionMock.defaultExpectation != nil && afterSetPipelinePermissionCounter < 1 {
		if m.SetPipelinePermissionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.SetPipelinePermission")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermission with params: %#v", *m.SetPipelinePermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPipelinePermission != nil && afterSetPipelinePermissionCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.SetPipelinePermission")
	}

	if !m.SetPipelinePermissionMock.invocationsDone() && afterSetPipelinePermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetPipelinePermission but found %d calls",
			mm_atomic.LoadUint64(&m.SetPipelinePermissionMock.expectedInvocations), afterSetPipelinePermissionCounter)
	}
}

type mACLClientInterfaceMockSetPipelinePermissionMap struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetPipelinePermissionMapExpectation
	expectations       []*ACLClientInterfaceMockSetPipelinePermissionMapExpectation

	callArgs []*ACLClientInterfaceMockSetPipelinePermissionMapParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ACLClientInterfaceMockSetPipelinePermissionMapExpectation specifies expectation struct of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapExpectation struct {
	mock      *ACLClientInterfaceMock
	params    *ACLClientInterfaceMockSetPipelinePermissionMapParams
	paramPtrs *ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs
	results   *ACLClientInterfaceMockSetPipelinePermissionMapResults
	Counter   uint64
}

// ACLClientInterfaceMockSetPipelinePermissionMapParams contains parameters of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapParams struct {
	ctx      context.Context
	pipeline *datamodel.Pipeline
}

// ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs contains pointers to parameters of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs struct {
	ctx      *context.Context
	pipeline **datamodel.Pipeline
}

// ACLClientInterfaceMockSetPipelinePermissionMapResults contains results of the ACLClientInterface.SetPipelinePermissionMap
type ACLClientInterfaceMockSetPipelinePermissionMapResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Optional() *mACLClientInterfaceMockSetPipelinePermissionMap {
	mmSetPipelinePermissionMap.optional = true
	return mmSetPipelinePermissionMap
}

// Expect sets up expected params for ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Expect(ctx context.Context, pipeline *datamodel.Pipeline) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by ExpectParams functions")
	}

	mmSetPipelinePermissionMap.defaultExpectation.params = &ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline}
	for _, e := range mmSetPipelinePermissionMap.expectations {
		if minimock.Equal(e.params, mmSetPipelinePermissionMap.defaultExpectation.params) {
			mmSetPipelinePermissionMap.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPipelinePermissionMap.defaultExpectation.params)
		}
	}

	return mmSetPipelinePermissionMap
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.params != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Expect")
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermissionMap.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs{}
	}
	mmSetPipelinePermissionMap.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetPipelinePermissionMap
}

// ExpectPipelineParam2 sets up expected param pipeline for ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) ExpectPipelineParam2(pipeline *datamodel.Pipeline) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{}
	}

	if mmSetPipelinePermissionMap.defaultExpectation.params != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Expect")
	}

	if mmSetPipelinePermissionMap.defaultExpectation.paramPtrs == nil {
		mmSetPipelinePermissionMap.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPipelinePermissionMapParamPtrs{}
	}
	mmSetPipelinePermissionMap.defaultExpectation.paramPtrs.pipeline = &pipeline

	return mmSetPipelinePermissionMap
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Inspect(f func(ctx context.Context, pipeline *datamodel.Pipeline)) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if mmSetPipelinePermissionMap.mock.inspectFuncSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetPipelinePermissionMap")
	}

	mmSetPipelinePermissionMap.mock.inspectFuncSetPipelinePermissionMap = f

	return mmSetPipelinePermissionMap
}

// Return sets up results that will be returned by ACLClientInterface.SetPipelinePermissionMap
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Return(err error) *ACLClientInterfaceMock {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	if mmSetPipelinePermissionMap.defaultExpectation == nil {
		mmSetPipelinePermissionMap.defaultExpectation = &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{mock: mmSetPipelinePermissionMap.mock}
	}
	mmSetPipelinePermissionMap.defaultExpectation.results = &ACLClientInterfaceMockSetPipelinePermissionMapResults{err}
	return mmSetPipelinePermissionMap.mock
}

// Set uses given function f to mock the ACLClientInterface.SetPipelinePermissionMap method
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Set(f func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)) *ACLClientInterfaceMock {
	if mmSetPipelinePermissionMap.defaultExpectation != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetPipelinePermissionMap method")
	}

	if len(mmSetPipelinePermissionMap.expectations) > 0 {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetPipelinePermissionMap method")
	}

	mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap = f
	return mmSetPipelinePermissionMap.mock
}

// When sets expectation for the ACLClientInterface.SetPipelinePermissionMap which will trigger the result defined by the following
// Then helper
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) When(ctx context.Context, pipeline *datamodel.Pipeline) *ACLClientInterfaceMockSetPipelinePermissionMapExpectation {
	if mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.mock.t.Fatalf("ACLClientInterfaceMock.SetPipelinePermissionMap mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetPipelinePermissionMapExpectation{
		mock:   mmSetPipelinePermissionMap.mock,
		params: &ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline},
	}
	mmSetPipelinePermissionMap.expectations = append(mmSetPipelinePermissionMap.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetPipelinePermissionMap return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetPipelinePermissionMapExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetPipelinePermissionMapResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetPipelinePermissionMap should be invoked
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Times(n uint64) *mACLClientInterfaceMockSetPipelinePermissionMap {
	if n == 0 {
		mmSetPipelinePermissionMap.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetPipelinePermissionMap mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPipelinePermissionMap.expectedInvocations, n)
	return mmSetPipelinePermissionMap
}

func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) invocationsDone() bool {
	if len(mmSetPipelinePermissionMap.expectations) == 0 && mmSetPipelinePermissionMap.defaultExpectation == nil && mmSetPipelinePermissionMap.mock.funcSetPipelinePermissionMap == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.mock.afterSetPipelinePermissionMapCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPipelinePermissionMap implements acl.ACLClientInterface
func (mmSetPipelinePermissionMap *ACLClientInterfaceMock) SetPipelinePermissionMap(ctx context.Context, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmSetPipelinePermissionMap.beforeSetPipelinePermissionMapCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPipelinePermissionMap.afterSetPipelinePermissionMapCounter, 1)

	if mmSetPipelinePermissionMap.inspectFuncSetPipelinePermissionMap != nil {
		mmSetPipelinePermissionMap.inspectFuncSetPipelinePermissionMap(ctx, pipeline)
	}

	mm_params := ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline}

	// Record call args
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.mutex.Lock()
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.callArgs = append(mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.callArgs, &mm_params)
	mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.mutex.Unlock()

	for _, e := range mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.params
		mm_want_ptrs := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetPipelinePermissionMapParams{ctx, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPipelinePermissionMap.t.Errorf("ACLClientInterfaceMock.SetPipelinePermissionMap got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmSetPipelinePermissionMap.t.Errorf("ACLClientInterfaceMock.SetPipelinePermissionMap got unexpected parameter pipeline, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPipelinePermissionMap.t.Errorf("ACLClientInterfaceMock.SetPipelinePermissionMap got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPipelinePermissionMap.SetPipelinePermissionMapMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPipelinePermissionMap.t.Fatal("No results are set for the ACLClientInterfaceMock.SetPipelinePermissionMap")
		}
		return (*mm_results).err
	}
	if mmSetPipelinePermissionMap.funcSetPipelinePermissionMap != nil {
		return mmSetPipelinePermissionMap.funcSetPipelinePermissionMap(ctx, pipeline)
	}
	mmSetPipelinePermissionMap.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetPipelinePermissionMap. %v %v", ctx, pipeline)
	return
}

// SetPipelinePermissionMapAfterCounter returns a count of finished ACLClientInterfaceMock.SetPipelinePermissionMap invocations
func (mmSetPipelinePermissionMap *ACLClientInterfaceMock) SetPipelinePermissionMapAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.afterSetPipelinePermissionMapCounter)
}

// SetPipelinePermissionMapBeforeCounter returns a count of ACLClientInterfaceMock.SetPipelinePermissionMap invocations
func (mmSetPipelinePermissionMap *ACLClientInterfaceMock) SetPipelinePermissionMapBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPipelinePermissionMap.beforeSetPipelinePermissionMapCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetPipelinePermissionMap.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPipelinePermissionMap *mACLClientInterfaceMockSetPipelinePermissionMap) Calls() []*ACLClientInterfaceMockSetPipelinePermissionMapParams {
	mmSetPipelinePermissionMap.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetPipelinePermissionMapParams, len(mmSetPipelinePermissionMap.callArgs))
	copy(argCopy, mmSetPipelinePermissionMap.callArgs)

	mmSetPipelinePermissionMap.mutex.RUnlock()

	return argCopy
}

// MinimockSetPipelinePermissionMapDone returns true if the count of the SetPipelinePermissionMap invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionMapDone() bool {
	if m.SetPipelinePermissionMapMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPipelinePermissionMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPipelinePermissionMapMock.invocationsDone()
}

// MinimockSetPipelinePermissionMapInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetPipelinePermissionMapInspect() {
	for _, e := range m.SetPipelinePermissionMapMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap with params: %#v", *e.params)
		}
	}

	afterSetPipelinePermissionMapCounter := mm_atomic.LoadUint64(&m.afterSetPipelinePermissionMapCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPipelinePermissionMapMock.defaultExpectation != nil && afterSetPipelinePermissionMapCounter < 1 {
		if m.SetPipelinePermissionMapMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap")
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap with params: %#v", *m.SetPipelinePermissionMapMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPipelinePermissionMap != nil && afterSetPipelinePermissionMapCounter < 1 {
		m.t.Error("Expected call to ACLClientInterfaceMock.SetPipelinePermissionMap")
	}

	if !m.SetPipelinePermissionMapMock.invocationsDone() && afterSetPipelinePermissionMapCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetPipelinePermissionMap but found %d calls",
			mm_atomic.LoadUint64(&m.SetPipelinePermissionMapMock.expectedInvocations), afterSetPipelinePermissionMapCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ACLClientInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckLinkPermissionInspect()

			m.MinimockCheckPermissionInspect()

			m.MinimockCheckPublicExecutableInspect()

			m.MinimockDeletePipelinePermissionInspect()

			m.MinimockListPermissionsInspect()

			m.MinimockPurgeInspect()

			m.MinimockSetOwnerInspect()

			m.MinimockSetPipelinePermissionInspect()

			m.MinimockSetPipelinePermissionMapInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ACLClientInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ACLClientInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckLinkPermissionDone() &&
		m.MinimockCheckPermissionDone() &&
		m.MinimockCheckPublicExecutableDone() &&
		m.MinimockDeletePipelinePermissionDone() &&
		m.MinimockListPermissionsDone() &&
		m.MinimockPurgeDone() &&
		m.MinimockSetOwnerDone() &&
		m.MinimockSetPipelinePermissionDone() &&
		m.MinimockSetPipelinePermissionMapDone()
}
