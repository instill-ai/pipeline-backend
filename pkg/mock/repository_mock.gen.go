// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/pipeline-backend/pkg/component/base"
	"github.com/instill-ai/pipeline-backend/pkg/datamodel"
	mm_repository "github.com/instill-ai/pipeline-backend/pkg/repository"
	pipelinepb "github.com/instill-ai/protogen-go/pipeline/v1beta"
	"go.einride.tech/aip/filtering"
	"go.einride.tech/aip/ordering"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// RepositoryMock implements mm_repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddPipelineClones          func(ctx context.Context, uid uuid.UUID) (err error)
	funcAddPipelineClonesOrigin    string
	inspectFuncAddPipelineClones   func(ctx context.Context, uid uuid.UUID)
	afterAddPipelineClonesCounter  uint64
	beforeAddPipelineClonesCounter uint64
	AddPipelineClonesMock          mRepositoryMockAddPipelineClones

	funcAddPipelineRuns          func(ctx context.Context, uid uuid.UUID) (err error)
	funcAddPipelineRunsOrigin    string
	inspectFuncAddPipelineRuns   func(ctx context.Context, uid uuid.UUID)
	afterAddPipelineRunsCounter  uint64
	beforeAddPipelineRunsCounter uint64
	AddPipelineRunsMock          mRepositoryMockAddPipelineRuns

	funcCheckPinnedUser          func(ctx context.Context, dp1 *gorm.DB, table string) (dp2 *gorm.DB)
	funcCheckPinnedUserOrigin    string
	inspectFuncCheckPinnedUser   func(ctx context.Context, dp1 *gorm.DB, table string)
	afterCheckPinnedUserCounter  uint64
	beforeCheckPinnedUserCounter uint64
	CheckPinnedUserMock          mRepositoryMockCheckPinnedUser

	funcCreateNamespaceConnection          func(ctx context.Context, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)
	funcCreateNamespaceConnectionOrigin    string
	inspectFuncCreateNamespaceConnection   func(ctx context.Context, cp1 *datamodel.Connection)
	afterCreateNamespaceConnectionCounter  uint64
	beforeCreateNamespaceConnectionCounter uint64
	CreateNamespaceConnectionMock          mRepositoryMockCreateNamespaceConnection

	funcCreateNamespaceSecret          func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error)
	funcCreateNamespaceSecretOrigin    string
	inspectFuncCreateNamespaceSecret   func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret)
	afterCreateNamespaceSecretCounter  uint64
	beforeCreateNamespaceSecretCounter uint64
	CreateNamespaceSecretMock          mRepositoryMockCreateNamespaceSecret

	funcCreatePipeline          func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)
	funcCreatePipelineOrigin    string
	inspectFuncCreatePipeline   func(ctx context.Context, pipeline *datamodel.Pipeline)
	afterCreatePipelineCounter  uint64
	beforeCreatePipelineCounter uint64
	CreatePipelineMock          mRepositoryMockCreatePipeline

	funcCreatePipelineRelease          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error)
	funcCreatePipelineReleaseOrigin    string
	inspectFuncCreatePipelineRelease   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease)
	afterCreatePipelineReleaseCounter  uint64
	beforeCreatePipelineReleaseCounter uint64
	CreatePipelineReleaseMock          mRepositoryMockCreatePipelineRelease

	funcCreatePipelineRunOn          func(ctx context.Context, pp1 *datamodel.PipelineRunOn) (err error)
	funcCreatePipelineRunOnOrigin    string
	inspectFuncCreatePipelineRunOn   func(ctx context.Context, pp1 *datamodel.PipelineRunOn)
	afterCreatePipelineRunOnCounter  uint64
	beforeCreatePipelineRunOnCounter uint64
	CreatePipelineRunOnMock          mRepositoryMockCreatePipelineRunOn

	funcCreatePipelineTags          func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)
	funcCreatePipelineTagsOrigin    string
	inspectFuncCreatePipelineTags   func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)
	afterCreatePipelineTagsCounter  uint64
	beforeCreatePipelineTagsCounter uint64
	CreatePipelineTagsMock          mRepositoryMockCreatePipelineTags

	funcDeleteComponentDefinition          func(ctx context.Context, u1 uuid.UUID) (err error)
	funcDeleteComponentDefinitionOrigin    string
	inspectFuncDeleteComponentDefinition   func(ctx context.Context, u1 uuid.UUID)
	afterDeleteComponentDefinitionCounter  uint64
	beforeDeleteComponentDefinitionCounter uint64
	DeleteComponentDefinitionMock          mRepositoryMockDeleteComponentDefinition

	funcDeleteNamespaceConnectionByID          func(ctx context.Context, nsUID uuid.UUID, id string) (err error)
	funcDeleteNamespaceConnectionByIDOrigin    string
	inspectFuncDeleteNamespaceConnectionByID   func(ctx context.Context, nsUID uuid.UUID, id string)
	afterDeleteNamespaceConnectionByIDCounter  uint64
	beforeDeleteNamespaceConnectionByIDCounter uint64
	DeleteNamespaceConnectionByIDMock          mRepositoryMockDeleteNamespaceConnectionByID

	funcDeleteNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	funcDeleteNamespaceSecretByIDOrigin    string
	inspectFuncDeleteNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeleteNamespaceSecretByIDCounter  uint64
	beforeDeleteNamespaceSecretByIDCounter uint64
	DeleteNamespaceSecretByIDMock          mRepositoryMockDeleteNamespaceSecretByID

	funcDeletePipelineByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	funcDeletePipelineByIDOrigin    string
	inspectFuncDeletePipelineByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeletePipelineByIDCounter  uint64
	beforeDeletePipelineByIDCounter uint64
	DeletePipelineByIDMock          mRepositoryMockDeletePipelineByID

	funcDeletePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error)
	funcDeletePipelineReleaseByIDOrigin    string
	inspectFuncDeletePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string)
	afterDeletePipelineReleaseByIDCounter  uint64
	beforeDeletePipelineReleaseByIDCounter uint64
	DeletePipelineReleaseByIDMock          mRepositoryMockDeletePipelineReleaseByID

	funcDeletePipelineRunOn          func(ctx context.Context, uid uuid.UUID) (err error)
	funcDeletePipelineRunOnOrigin    string
	inspectFuncDeletePipelineRunOn   func(ctx context.Context, uid uuid.UUID)
	afterDeletePipelineRunOnCounter  uint64
	beforeDeletePipelineRunOnCounter uint64
	DeletePipelineRunOnMock          mRepositoryMockDeletePipelineRunOn

	funcDeletePipelineTags          func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)
	funcDeletePipelineTagsOrigin    string
	inspectFuncDeletePipelineTags   func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)
	afterDeletePipelineTagsCounter  uint64
	beforeDeletePipelineTagsCounter uint64
	DeletePipelineTagsMock          mRepositoryMockDeletePipelineTags

	funcGetConnectionByUID          func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.Connection, err error)
	funcGetConnectionByUIDOrigin    string
	inspectFuncGetConnectionByUID   func(ctx context.Context, u1 uuid.UUID)
	afterGetConnectionByUIDCounter  uint64
	beforeGetConnectionByUIDCounter uint64
	GetConnectionByUIDMock          mRepositoryMockGetConnectionByUID

	funcGetDefinitionByUID          func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error)
	funcGetDefinitionByUIDOrigin    string
	inspectFuncGetDefinitionByUID   func(ctx context.Context, u1 uuid.UUID)
	afterGetDefinitionByUIDCounter  uint64
	beforeGetDefinitionByUIDCounter uint64
	GetDefinitionByUIDMock          mRepositoryMockGetDefinitionByUID

	funcGetHubStats          func(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error)
	funcGetHubStatsOrigin    string
	inspectFuncGetHubStats   func(uidAllowList []uuid.UUID)
	afterGetHubStatsCounter  uint64
	beforeGetHubStatsCounter uint64
	GetHubStatsMock          mRepositoryMockGetHubStats

	funcGetLatestPipelineRelease          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	funcGetLatestPipelineReleaseOrigin    string
	inspectFuncGetLatestPipelineRelease   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool)
	afterGetLatestPipelineReleaseCounter  uint64
	beforeGetLatestPipelineReleaseCounter uint64
	GetLatestPipelineReleaseMock          mRepositoryMockGetLatestPipelineRelease

	funcGetNamespaceConnectionByID          func(ctx context.Context, nsUID uuid.UUID, id string) (cp1 *datamodel.Connection, err error)
	funcGetNamespaceConnectionByIDOrigin    string
	inspectFuncGetNamespaceConnectionByID   func(ctx context.Context, nsUID uuid.UUID, id string)
	afterGetNamespaceConnectionByIDCounter  uint64
	beforeGetNamespaceConnectionByIDCounter uint64
	GetNamespaceConnectionByIDMock          mRepositoryMockGetNamespaceConnectionByID

	funcGetNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error)
	funcGetNamespaceSecretByIDOrigin    string
	inspectFuncGetNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string)
	afterGetNamespaceSecretByIDCounter  uint64
	beforeGetNamespaceSecretByIDCounter uint64
	GetNamespaceSecretByIDMock          mRepositoryMockGetNamespaceSecretByID

	funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions          func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) (ca1 []datamodel.ComponentRun, i1 int64, err error)
	funcGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigin    string
	inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions   func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy)
	afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter  uint64
	beforeGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter uint64
	GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock          mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions

	funcGetPaginatedPipelineRunsByRequester          func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) (pa1 []datamodel.PipelineRun, i1 int64, err error)
	funcGetPaginatedPipelineRunsByRequesterOrigin    string
	inspectFuncGetPaginatedPipelineRunsByRequester   func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams)
	afterGetPaginatedPipelineRunsByRequesterCounter  uint64
	beforeGetPaginatedPipelineRunsByRequesterCounter uint64
	GetPaginatedPipelineRunsByRequesterMock          mRepositoryMockGetPaginatedPipelineRunsByRequester

	funcGetPaginatedPipelineRunsWithPermissions          func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) (pa1 []datamodel.PipelineRun, i1 int64, err error)
	funcGetPaginatedPipelineRunsWithPermissionsOrigin    string
	inspectFuncGetPaginatedPipelineRunsWithPermissions   func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool)
	afterGetPaginatedPipelineRunsWithPermissionsCounter  uint64
	beforeGetPaginatedPipelineRunsWithPermissionsCounter uint64
	GetPaginatedPipelineRunsWithPermissionsMock          mRepositoryMockGetPaginatedPipelineRunsWithPermissions

	funcGetPipelineByID          func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	funcGetPipelineByIDOrigin    string
	inspectFuncGetPipelineByID   func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool)
	afterGetPipelineByIDCounter  uint64
	beforeGetPipelineByIDCounter uint64
	GetPipelineByIDMock          mRepositoryMockGetPipelineByID

	funcGetPipelineByIDAdmin          func(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	funcGetPipelineByIDAdminOrigin    string
	inspectFuncGetPipelineByIDAdmin   func(ctx context.Context, id string, isBasicView bool, embedReleases bool)
	afterGetPipelineByIDAdminCounter  uint64
	beforeGetPipelineByIDAdminCounter uint64
	GetPipelineByIDAdminMock          mRepositoryMockGetPipelineByIDAdmin

	funcGetPipelineByUID          func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	funcGetPipelineByUIDOrigin    string
	inspectFuncGetPipelineByUID   func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)
	afterGetPipelineByUIDCounter  uint64
	beforeGetPipelineByUIDCounter uint64
	GetPipelineByUIDMock          mRepositoryMockGetPipelineByUID

	funcGetPipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	funcGetPipelineReleaseByIDOrigin    string
	inspectFuncGetPipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool)
	afterGetPipelineReleaseByIDCounter  uint64
	beforeGetPipelineReleaseByIDCounter uint64
	GetPipelineReleaseByIDMock          mRepositoryMockGetPipelineReleaseByID

	funcGetPipelineReleaseByUIDAdmin          func(ctx context.Context, uid uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	funcGetPipelineReleaseByUIDAdminOrigin    string
	inspectFuncGetPipelineReleaseByUIDAdmin   func(ctx context.Context, uid uuid.UUID, isBasicView bool)
	afterGetPipelineReleaseByUIDAdminCounter  uint64
	beforeGetPipelineReleaseByUIDAdminCounter uint64
	GetPipelineReleaseByUIDAdminMock          mRepositoryMockGetPipelineReleaseByUIDAdmin

	funcGetPipelineRunByUID          func(ctx context.Context, u1 uuid.UUID) (pp1 *datamodel.PipelineRun, err error)
	funcGetPipelineRunByUIDOrigin    string
	inspectFuncGetPipelineRunByUID   func(ctx context.Context, u1 uuid.UUID)
	afterGetPipelineRunByUIDCounter  uint64
	beforeGetPipelineRunByUIDCounter uint64
	GetPipelineRunByUIDMock          mRepositoryMockGetPipelineRunByUID

	funcListAllComponentDefinitions          func(ctx context.Context) (cpa1 []*datamodel.ComponentDefinition, err error)
	funcListAllComponentDefinitionsOrigin    string
	inspectFuncListAllComponentDefinitions   func(ctx context.Context)
	afterListAllComponentDefinitionsCounter  uint64
	beforeListAllComponentDefinitionsCounter uint64
	ListAllComponentDefinitionsMock          mRepositoryMockListAllComponentDefinitions

	funcListComponentDefinitionUIDs          func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error)
	funcListComponentDefinitionUIDsOrigin    string
	inspectFuncListComponentDefinitionUIDs   func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams)
	afterListComponentDefinitionUIDsCounter  uint64
	beforeListComponentDefinitionUIDsCounter uint64
	ListComponentDefinitionUIDsMock          mRepositoryMockListComponentDefinitionUIDs

	funcListIntegrations          func(ctx context.Context, l1 mm_repository.ListIntegrationsParams) (i1 mm_repository.IntegrationList, err error)
	funcListIntegrationsOrigin    string
	inspectFuncListIntegrations   func(ctx context.Context, l1 mm_repository.ListIntegrationsParams)
	afterListIntegrationsCounter  uint64
	beforeListIntegrationsCounter uint64
	ListIntegrationsMock          mRepositoryMockListIntegrations

	funcListNamespaceConnections          func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) (c2 mm_repository.ConnectionList, err error)
	funcListNamespaceConnectionsOrigin    string
	inspectFuncListNamespaceConnections   func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams)
	afterListNamespaceConnectionsCounter  uint64
	beforeListNamespaceConnectionsCounter uint64
	ListNamespaceConnectionsMock          mRepositoryMockListNamespaceConnections

	funcListNamespaceSecrets          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error)
	funcListNamespaceSecretsOrigin    string
	inspectFuncListNamespaceSecrets   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter)
	afterListNamespaceSecretsCounter  uint64
	beforeListNamespaceSecretsCounter uint64
	ListNamespaceSecretsMock          mRepositoryMockListNamespaceSecrets

	funcListPipelineIDsByConnectionID          func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) (p1 mm_repository.PipelinesByConnectionList, err error)
	funcListPipelineIDsByConnectionIDOrigin    string
	inspectFuncListPipelineIDsByConnectionID   func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams)
	afterListPipelineIDsByConnectionIDCounter  uint64
	beforeListPipelineIDsByConnectionIDCounter uint64
	ListPipelineIDsByConnectionIDMock          mRepositoryMockListPipelineIDsByConnectionID

	funcListPipelineReleases          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error)
	funcListPipelineReleasesOrigin    string
	inspectFuncListPipelineReleases   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool)
	afterListPipelineReleasesCounter  uint64
	beforeListPipelineReleasesCounter uint64
	ListPipelineReleasesMock          mRepositoryMockListPipelineReleases

	funcListPipelineRunOns          func(ctx context.Context, pipelineUID uuid.UUID) (p1 mm_repository.PipelineRunOnList, err error)
	funcListPipelineRunOnsOrigin    string
	inspectFuncListPipelineRunOns   func(ctx context.Context, pipelineUID uuid.UUID)
	afterListPipelineRunOnsCounter  uint64
	beforeListPipelineRunOnsCounter uint64
	ListPipelineRunOnsMock          mRepositoryMockListPipelineRunOns

	funcListPipelineRunOnsByIdentifier          func(ctx context.Context, ComponentType string, Identifier base.Identifier) (p1 mm_repository.PipelineRunOnList, err error)
	funcListPipelineRunOnsByIdentifierOrigin    string
	inspectFuncListPipelineRunOnsByIdentifier   func(ctx context.Context, ComponentType string, Identifier base.Identifier)
	afterListPipelineRunOnsByIdentifierCounter  uint64
	beforeListPipelineRunOnsByIdentifierCounter uint64
	ListPipelineRunOnsByIdentifierMock          mRepositoryMockListPipelineRunOnsByIdentifier

	funcListPipelineTags          func(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error)
	funcListPipelineTagsOrigin    string
	inspectFuncListPipelineTags   func(ctx context.Context, pipelineUID uuid.UUID)
	afterListPipelineTagsCounter  uint64
	beforeListPipelineTagsCounter uint64
	ListPipelineTagsMock          mRepositoryMockListPipelineTags

	funcListPipelines          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	funcListPipelinesOrigin    string
	inspectFuncListPipelines   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)
	afterListPipelinesCounter  uint64
	beforeListPipelinesCounter uint64
	ListPipelinesMock          mRepositoryMockListPipelines

	funcListPipelinesAdmin          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	funcListPipelinesAdminOrigin    string
	inspectFuncListPipelinesAdmin   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool)
	afterListPipelinesAdminCounter  uint64
	beforeListPipelinesAdminCounter uint64
	ListPipelinesAdminMock          mRepositoryMockListPipelinesAdmin

	funcListPublicPipelines          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	funcListPublicPipelinesOrigin    string
	inspectFuncListPublicPipelines   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID)
	afterListPublicPipelinesCounter  uint64
	beforeListPublicPipelinesCounter uint64
	ListPublicPipelinesMock          mRepositoryMockListPublicPipelines

	funcPinUser          func(ctx context.Context, table string)
	funcPinUserOrigin    string
	inspectFuncPinUser   func(ctx context.Context, table string)
	afterPinUserCounter  uint64
	beforePinUserCounter uint64
	PinUserMock          mRepositoryMockPinUser

	funcTranspileFilter          func(f1 filtering.Filter) (ep1 *clause.Expr, err error)
	funcTranspileFilterOrigin    string
	inspectFuncTranspileFilter   func(f1 filtering.Filter)
	afterTranspileFilterCounter  uint64
	beforeTranspileFilterCounter uint64
	TranspileFilterMock          mRepositoryMockTranspileFilter

	funcUpdateComponentRun          func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) (err error)
	funcUpdateComponentRunOrigin    string
	inspectFuncUpdateComponentRun   func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun)
	afterUpdateComponentRunCounter  uint64
	beforeUpdateComponentRunCounter uint64
	UpdateComponentRunMock          mRepositoryMockUpdateComponentRun

	funcUpdateNamespaceConnectionByUID          func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)
	funcUpdateNamespaceConnectionByUIDOrigin    string
	inspectFuncUpdateNamespaceConnectionByUID   func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection)
	afterUpdateNamespaceConnectionByUIDCounter  uint64
	beforeUpdateNamespaceConnectionByUIDCounter uint64
	UpdateNamespaceConnectionByUIDMock          mRepositoryMockUpdateNamespaceConnectionByUID

	funcUpdateNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error)
	funcUpdateNamespaceSecretByIDOrigin    string
	inspectFuncUpdateNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret)
	afterUpdateNamespaceSecretByIDCounter  uint64
	beforeUpdateNamespaceSecretByIDCounter uint64
	UpdateNamespaceSecretByIDMock          mRepositoryMockUpdateNamespaceSecretByID

	funcUpdatePipelineByUID          func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error)
	funcUpdatePipelineByUIDOrigin    string
	inspectFuncUpdatePipelineByUID   func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline)
	afterUpdatePipelineByUIDCounter  uint64
	beforeUpdatePipelineByUIDCounter uint64
	UpdatePipelineByUIDMock          mRepositoryMockUpdatePipelineByUID

	funcUpdatePipelineIDByID          func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)
	funcUpdatePipelineIDByIDOrigin    string
	inspectFuncUpdatePipelineIDByID   func(ctx context.Context, ownerPermalink string, id string, newID string)
	afterUpdatePipelineIDByIDCounter  uint64
	beforeUpdatePipelineIDByIDCounter uint64
	UpdatePipelineIDByIDMock          mRepositoryMockUpdatePipelineIDByID

	funcUpdatePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error)
	funcUpdatePipelineReleaseByIDOrigin    string
	inspectFuncUpdatePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease)
	afterUpdatePipelineReleaseByIDCounter  uint64
	beforeUpdatePipelineReleaseByIDCounter uint64
	UpdatePipelineReleaseByIDMock          mRepositoryMockUpdatePipelineReleaseByID

	funcUpdatePipelineReleaseIDByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error)
	funcUpdatePipelineReleaseIDByIDOrigin    string
	inspectFuncUpdatePipelineReleaseIDByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string)
	afterUpdatePipelineReleaseIDByIDCounter  uint64
	beforeUpdatePipelineReleaseIDByIDCounter uint64
	UpdatePipelineReleaseIDByIDMock          mRepositoryMockUpdatePipelineReleaseIDByID

	funcUpdatePipelineRun          func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) (err error)
	funcUpdatePipelineRunOrigin    string
	inspectFuncUpdatePipelineRun   func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun)
	afterUpdatePipelineRunCounter  uint64
	beforeUpdatePipelineRunCounter uint64
	UpdatePipelineRunMock          mRepositoryMockUpdatePipelineRun

	funcUpsertComponentDefinition          func(ctx context.Context, cp1 *pipelinepb.ComponentDefinition) (err error)
	funcUpsertComponentDefinitionOrigin    string
	inspectFuncUpsertComponentDefinition   func(ctx context.Context, cp1 *pipelinepb.ComponentDefinition)
	afterUpsertComponentDefinitionCounter  uint64
	beforeUpsertComponentDefinitionCounter uint64
	UpsertComponentDefinitionMock          mRepositoryMockUpsertComponentDefinition

	funcUpsertComponentRun          func(ctx context.Context, componentRun *datamodel.ComponentRun) (err error)
	funcUpsertComponentRunOrigin    string
	inspectFuncUpsertComponentRun   func(ctx context.Context, componentRun *datamodel.ComponentRun)
	afterUpsertComponentRunCounter  uint64
	beforeUpsertComponentRunCounter uint64
	UpsertComponentRunMock          mRepositoryMockUpsertComponentRun

	funcUpsertPipelineRun          func(ctx context.Context, pipelineRun *datamodel.PipelineRun) (err error)
	funcUpsertPipelineRunOrigin    string
	inspectFuncUpsertPipelineRun   func(ctx context.Context, pipelineRun *datamodel.PipelineRun)
	afterUpsertPipelineRunCounter  uint64
	beforeUpsertPipelineRunCounter uint64
	UpsertPipelineRunMock          mRepositoryMockUpsertPipelineRun
}

// NewRepositoryMock returns a mock for mm_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddPipelineClonesMock = mRepositoryMockAddPipelineClones{mock: m}
	m.AddPipelineClonesMock.callArgs = []*RepositoryMockAddPipelineClonesParams{}

	m.AddPipelineRunsMock = mRepositoryMockAddPipelineRuns{mock: m}
	m.AddPipelineRunsMock.callArgs = []*RepositoryMockAddPipelineRunsParams{}

	m.CheckPinnedUserMock = mRepositoryMockCheckPinnedUser{mock: m}
	m.CheckPinnedUserMock.callArgs = []*RepositoryMockCheckPinnedUserParams{}

	m.CreateNamespaceConnectionMock = mRepositoryMockCreateNamespaceConnection{mock: m}
	m.CreateNamespaceConnectionMock.callArgs = []*RepositoryMockCreateNamespaceConnectionParams{}

	m.CreateNamespaceSecretMock = mRepositoryMockCreateNamespaceSecret{mock: m}
	m.CreateNamespaceSecretMock.callArgs = []*RepositoryMockCreateNamespaceSecretParams{}

	m.CreatePipelineMock = mRepositoryMockCreatePipeline{mock: m}
	m.CreatePipelineMock.callArgs = []*RepositoryMockCreatePipelineParams{}

	m.CreatePipelineReleaseMock = mRepositoryMockCreatePipelineRelease{mock: m}
	m.CreatePipelineReleaseMock.callArgs = []*RepositoryMockCreatePipelineReleaseParams{}

	m.CreatePipelineRunOnMock = mRepositoryMockCreatePipelineRunOn{mock: m}
	m.CreatePipelineRunOnMock.callArgs = []*RepositoryMockCreatePipelineRunOnParams{}

	m.CreatePipelineTagsMock = mRepositoryMockCreatePipelineTags{mock: m}
	m.CreatePipelineTagsMock.callArgs = []*RepositoryMockCreatePipelineTagsParams{}

	m.DeleteComponentDefinitionMock = mRepositoryMockDeleteComponentDefinition{mock: m}
	m.DeleteComponentDefinitionMock.callArgs = []*RepositoryMockDeleteComponentDefinitionParams{}

	m.DeleteNamespaceConnectionByIDMock = mRepositoryMockDeleteNamespaceConnectionByID{mock: m}
	m.DeleteNamespaceConnectionByIDMock.callArgs = []*RepositoryMockDeleteNamespaceConnectionByIDParams{}

	m.DeleteNamespaceSecretByIDMock = mRepositoryMockDeleteNamespaceSecretByID{mock: m}
	m.DeleteNamespaceSecretByIDMock.callArgs = []*RepositoryMockDeleteNamespaceSecretByIDParams{}

	m.DeletePipelineByIDMock = mRepositoryMockDeletePipelineByID{mock: m}
	m.DeletePipelineByIDMock.callArgs = []*RepositoryMockDeletePipelineByIDParams{}

	m.DeletePipelineReleaseByIDMock = mRepositoryMockDeletePipelineReleaseByID{mock: m}
	m.DeletePipelineReleaseByIDMock.callArgs = []*RepositoryMockDeletePipelineReleaseByIDParams{}

	m.DeletePipelineRunOnMock = mRepositoryMockDeletePipelineRunOn{mock: m}
	m.DeletePipelineRunOnMock.callArgs = []*RepositoryMockDeletePipelineRunOnParams{}

	m.DeletePipelineTagsMock = mRepositoryMockDeletePipelineTags{mock: m}
	m.DeletePipelineTagsMock.callArgs = []*RepositoryMockDeletePipelineTagsParams{}

	m.GetConnectionByUIDMock = mRepositoryMockGetConnectionByUID{mock: m}
	m.GetConnectionByUIDMock.callArgs = []*RepositoryMockGetConnectionByUIDParams{}

	m.GetDefinitionByUIDMock = mRepositoryMockGetDefinitionByUID{mock: m}
	m.GetDefinitionByUIDMock.callArgs = []*RepositoryMockGetDefinitionByUIDParams{}

	m.GetHubStatsMock = mRepositoryMockGetHubStats{mock: m}
	m.GetHubStatsMock.callArgs = []*RepositoryMockGetHubStatsParams{}

	m.GetLatestPipelineReleaseMock = mRepositoryMockGetLatestPipelineRelease{mock: m}
	m.GetLatestPipelineReleaseMock.callArgs = []*RepositoryMockGetLatestPipelineReleaseParams{}

	m.GetNamespaceConnectionByIDMock = mRepositoryMockGetNamespaceConnectionByID{mock: m}
	m.GetNamespaceConnectionByIDMock.callArgs = []*RepositoryMockGetNamespaceConnectionByIDParams{}

	m.GetNamespaceSecretByIDMock = mRepositoryMockGetNamespaceSecretByID{mock: m}
	m.GetNamespaceSecretByIDMock.callArgs = []*RepositoryMockGetNamespaceSecretByIDParams{}

	m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock = mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions{mock: m}
	m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.callArgs = []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{}

	m.GetPaginatedPipelineRunsByRequesterMock = mRepositoryMockGetPaginatedPipelineRunsByRequester{mock: m}
	m.GetPaginatedPipelineRunsByRequesterMock.callArgs = []*RepositoryMockGetPaginatedPipelineRunsByRequesterParams{}

	m.GetPaginatedPipelineRunsWithPermissionsMock = mRepositoryMockGetPaginatedPipelineRunsWithPermissions{mock: m}
	m.GetPaginatedPipelineRunsWithPermissionsMock.callArgs = []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{}

	m.GetPipelineByIDMock = mRepositoryMockGetPipelineByID{mock: m}
	m.GetPipelineByIDMock.callArgs = []*RepositoryMockGetPipelineByIDParams{}

	m.GetPipelineByIDAdminMock = mRepositoryMockGetPipelineByIDAdmin{mock: m}
	m.GetPipelineByIDAdminMock.callArgs = []*RepositoryMockGetPipelineByIDAdminParams{}

	m.GetPipelineByUIDMock = mRepositoryMockGetPipelineByUID{mock: m}
	m.GetPipelineByUIDMock.callArgs = []*RepositoryMockGetPipelineByUIDParams{}

	m.GetPipelineReleaseByIDMock = mRepositoryMockGetPipelineReleaseByID{mock: m}
	m.GetPipelineReleaseByIDMock.callArgs = []*RepositoryMockGetPipelineReleaseByIDParams{}

	m.GetPipelineReleaseByUIDAdminMock = mRepositoryMockGetPipelineReleaseByUIDAdmin{mock: m}
	m.GetPipelineReleaseByUIDAdminMock.callArgs = []*RepositoryMockGetPipelineReleaseByUIDAdminParams{}

	m.GetPipelineRunByUIDMock = mRepositoryMockGetPipelineRunByUID{mock: m}
	m.GetPipelineRunByUIDMock.callArgs = []*RepositoryMockGetPipelineRunByUIDParams{}

	m.ListAllComponentDefinitionsMock = mRepositoryMockListAllComponentDefinitions{mock: m}
	m.ListAllComponentDefinitionsMock.callArgs = []*RepositoryMockListAllComponentDefinitionsParams{}

	m.ListComponentDefinitionUIDsMock = mRepositoryMockListComponentDefinitionUIDs{mock: m}
	m.ListComponentDefinitionUIDsMock.callArgs = []*RepositoryMockListComponentDefinitionUIDsParams{}

	m.ListIntegrationsMock = mRepositoryMockListIntegrations{mock: m}
	m.ListIntegrationsMock.callArgs = []*RepositoryMockListIntegrationsParams{}

	m.ListNamespaceConnectionsMock = mRepositoryMockListNamespaceConnections{mock: m}
	m.ListNamespaceConnectionsMock.callArgs = []*RepositoryMockListNamespaceConnectionsParams{}

	m.ListNamespaceSecretsMock = mRepositoryMockListNamespaceSecrets{mock: m}
	m.ListNamespaceSecretsMock.callArgs = []*RepositoryMockListNamespaceSecretsParams{}

	m.ListPipelineIDsByConnectionIDMock = mRepositoryMockListPipelineIDsByConnectionID{mock: m}
	m.ListPipelineIDsByConnectionIDMock.callArgs = []*RepositoryMockListPipelineIDsByConnectionIDParams{}

	m.ListPipelineReleasesMock = mRepositoryMockListPipelineReleases{mock: m}
	m.ListPipelineReleasesMock.callArgs = []*RepositoryMockListPipelineReleasesParams{}

	m.ListPipelineRunOnsMock = mRepositoryMockListPipelineRunOns{mock: m}
	m.ListPipelineRunOnsMock.callArgs = []*RepositoryMockListPipelineRunOnsParams{}

	m.ListPipelineRunOnsByIdentifierMock = mRepositoryMockListPipelineRunOnsByIdentifier{mock: m}
	m.ListPipelineRunOnsByIdentifierMock.callArgs = []*RepositoryMockListPipelineRunOnsByIdentifierParams{}

	m.ListPipelineTagsMock = mRepositoryMockListPipelineTags{mock: m}
	m.ListPipelineTagsMock.callArgs = []*RepositoryMockListPipelineTagsParams{}

	m.ListPipelinesMock = mRepositoryMockListPipelines{mock: m}
	m.ListPipelinesMock.callArgs = []*RepositoryMockListPipelinesParams{}

	m.ListPipelinesAdminMock = mRepositoryMockListPipelinesAdmin{mock: m}
	m.ListPipelinesAdminMock.callArgs = []*RepositoryMockListPipelinesAdminParams{}

	m.ListPublicPipelinesMock = mRepositoryMockListPublicPipelines{mock: m}
	m.ListPublicPipelinesMock.callArgs = []*RepositoryMockListPublicPipelinesParams{}

	m.PinUserMock = mRepositoryMockPinUser{mock: m}
	m.PinUserMock.callArgs = []*RepositoryMockPinUserParams{}

	m.TranspileFilterMock = mRepositoryMockTranspileFilter{mock: m}
	m.TranspileFilterMock.callArgs = []*RepositoryMockTranspileFilterParams{}

	m.UpdateComponentRunMock = mRepositoryMockUpdateComponentRun{mock: m}
	m.UpdateComponentRunMock.callArgs = []*RepositoryMockUpdateComponentRunParams{}

	m.UpdateNamespaceConnectionByUIDMock = mRepositoryMockUpdateNamespaceConnectionByUID{mock: m}
	m.UpdateNamespaceConnectionByUIDMock.callArgs = []*RepositoryMockUpdateNamespaceConnectionByUIDParams{}

	m.UpdateNamespaceSecretByIDMock = mRepositoryMockUpdateNamespaceSecretByID{mock: m}
	m.UpdateNamespaceSecretByIDMock.callArgs = []*RepositoryMockUpdateNamespaceSecretByIDParams{}

	m.UpdatePipelineByUIDMock = mRepositoryMockUpdatePipelineByUID{mock: m}
	m.UpdatePipelineByUIDMock.callArgs = []*RepositoryMockUpdatePipelineByUIDParams{}

	m.UpdatePipelineIDByIDMock = mRepositoryMockUpdatePipelineIDByID{mock: m}
	m.UpdatePipelineIDByIDMock.callArgs = []*RepositoryMockUpdatePipelineIDByIDParams{}

	m.UpdatePipelineReleaseByIDMock = mRepositoryMockUpdatePipelineReleaseByID{mock: m}
	m.UpdatePipelineReleaseByIDMock.callArgs = []*RepositoryMockUpdatePipelineReleaseByIDParams{}

	m.UpdatePipelineReleaseIDByIDMock = mRepositoryMockUpdatePipelineReleaseIDByID{mock: m}
	m.UpdatePipelineReleaseIDByIDMock.callArgs = []*RepositoryMockUpdatePipelineReleaseIDByIDParams{}

	m.UpdatePipelineRunMock = mRepositoryMockUpdatePipelineRun{mock: m}
	m.UpdatePipelineRunMock.callArgs = []*RepositoryMockUpdatePipelineRunParams{}

	m.UpsertComponentDefinitionMock = mRepositoryMockUpsertComponentDefinition{mock: m}
	m.UpsertComponentDefinitionMock.callArgs = []*RepositoryMockUpsertComponentDefinitionParams{}

	m.UpsertComponentRunMock = mRepositoryMockUpsertComponentRun{mock: m}
	m.UpsertComponentRunMock.callArgs = []*RepositoryMockUpsertComponentRunParams{}

	m.UpsertPipelineRunMock = mRepositoryMockUpsertPipelineRun{mock: m}
	m.UpsertPipelineRunMock.callArgs = []*RepositoryMockUpsertPipelineRunParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddPipelineClones struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddPipelineClonesExpectation
	expectations       []*RepositoryMockAddPipelineClonesExpectation

	callArgs []*RepositoryMockAddPipelineClonesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddPipelineClonesExpectation specifies expectation struct of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddPipelineClonesParams
	paramPtrs          *RepositoryMockAddPipelineClonesParamPtrs
	expectationOrigins RepositoryMockAddPipelineClonesExpectationOrigins
	results            *RepositoryMockAddPipelineClonesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddPipelineClonesParams contains parameters of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockAddPipelineClonesParamPtrs contains pointers to parameters of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryMockAddPipelineClonesResults contains results of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesResults struct {
	err error
}

// RepositoryMockAddPipelineClonesOrigins contains origins of expectations of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Optional() *mRepositoryMockAddPipelineClones {
	mmAddPipelineClones.optional = true
	return mmAddPipelineClones
}

// Expect sets up expected params for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by ExpectParams functions")
	}

	mmAddPipelineClones.defaultExpectation.params = &RepositoryMockAddPipelineClonesParams{ctx, uid}
	mmAddPipelineClones.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPipelineClones.expectations {
		if minimock.Equal(e.params, mmAddPipelineClones.defaultExpectation.params) {
			mmAddPipelineClones.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPipelineClones.defaultExpectation.params)
		}
	}

	return mmAddPipelineClones
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.params != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Expect")
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs == nil {
		mmAddPipelineClones.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineClonesParamPtrs{}
	}
	mmAddPipelineClones.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddPipelineClones.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddPipelineClones
}

// ExpectUidParam2 sets up expected param uid for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.params != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Expect")
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs == nil {
		mmAddPipelineClones.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineClonesParamPtrs{}
	}
	mmAddPipelineClones.defaultExpectation.paramPtrs.uid = &uid
	mmAddPipelineClones.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmAddPipelineClones
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.inspectFuncAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddPipelineClones")
	}

	mmAddPipelineClones.mock.inspectFuncAddPipelineClones = f

	return mmAddPipelineClones
}

// Return sets up results that will be returned by Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Return(err error) *RepositoryMock {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{mock: mmAddPipelineClones.mock}
	}
	mmAddPipelineClones.defaultExpectation.results = &RepositoryMockAddPipelineClonesResults{err}
	mmAddPipelineClones.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPipelineClones.mock
}

// Set uses given function f to mock the Repository.AddPipelineClones method
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmAddPipelineClones.defaultExpectation != nil {
		mmAddPipelineClones.mock.t.Fatalf("Default expectation is already set for the Repository.AddPipelineClones method")
	}

	if len(mmAddPipelineClones.expectations) > 0 {
		mmAddPipelineClones.mock.t.Fatalf("Some expectations are already set for the Repository.AddPipelineClones method")
	}

	mmAddPipelineClones.mock.funcAddPipelineClones = f
	mmAddPipelineClones.mock.funcAddPipelineClonesOrigin = minimock.CallerInfo(1)
	return mmAddPipelineClones.mock
}

// When sets expectation for the Repository.AddPipelineClones which will trigger the result defined by the following
// Then helper
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) When(ctx context.Context, uid uuid.UUID) *RepositoryMockAddPipelineClonesExpectation {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	expectation := &RepositoryMockAddPipelineClonesExpectation{
		mock:               mmAddPipelineClones.mock,
		params:             &RepositoryMockAddPipelineClonesParams{ctx, uid},
		expectationOrigins: RepositoryMockAddPipelineClonesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPipelineClones.expectations = append(mmAddPipelineClones.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddPipelineClones return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddPipelineClonesExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddPipelineClonesResults{err}
	return e.mock
}

// Times sets number of times Repository.AddPipelineClones should be invoked
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Times(n uint64) *mRepositoryMockAddPipelineClones {
	if n == 0 {
		mmAddPipelineClones.mock.t.Fatalf("Times of RepositoryMock.AddPipelineClones mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPipelineClones.expectedInvocations, n)
	mmAddPipelineClones.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPipelineClones
}

func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) invocationsDone() bool {
	if len(mmAddPipelineClones.expectations) == 0 && mmAddPipelineClones.defaultExpectation == nil && mmAddPipelineClones.mock.funcAddPipelineClones == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPipelineClones.mock.afterAddPipelineClonesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPipelineClones.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPipelineClones implements mm_repository.Repository
func (mmAddPipelineClones *RepositoryMock) AddPipelineClones(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmAddPipelineClones.beforeAddPipelineClonesCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPipelineClones.afterAddPipelineClonesCounter, 1)

	mmAddPipelineClones.t.Helper()

	if mmAddPipelineClones.inspectFuncAddPipelineClones != nil {
		mmAddPipelineClones.inspectFuncAddPipelineClones(ctx, uid)
	}

	mm_params := RepositoryMockAddPipelineClonesParams{ctx, uid}

	// Record call args
	mmAddPipelineClones.AddPipelineClonesMock.mutex.Lock()
	mmAddPipelineClones.AddPipelineClonesMock.callArgs = append(mmAddPipelineClones.AddPipelineClonesMock.callArgs, &mm_params)
	mmAddPipelineClones.AddPipelineClonesMock.mutex.Unlock()

	for _, e := range mmAddPipelineClones.AddPipelineClonesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.params
		mm_want_ptrs := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddPipelineClonesParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPipelineClones.t.Fatal("No results are set for the RepositoryMock.AddPipelineClones")
		}
		return (*mm_results).err
	}
	if mmAddPipelineClones.funcAddPipelineClones != nil {
		return mmAddPipelineClones.funcAddPipelineClones(ctx, uid)
	}
	mmAddPipelineClones.t.Fatalf("Unexpected call to RepositoryMock.AddPipelineClones. %v %v", ctx, uid)
	return
}

// AddPipelineClonesAfterCounter returns a count of finished RepositoryMock.AddPipelineClones invocations
func (mmAddPipelineClones *RepositoryMock) AddPipelineClonesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineClones.afterAddPipelineClonesCounter)
}

// AddPipelineClonesBeforeCounter returns a count of RepositoryMock.AddPipelineClones invocations
func (mmAddPipelineClones *RepositoryMock) AddPipelineClonesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineClones.beforeAddPipelineClonesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddPipelineClones.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Calls() []*RepositoryMockAddPipelineClonesParams {
	mmAddPipelineClones.mutex.RLock()

	argCopy := make([]*RepositoryMockAddPipelineClonesParams, len(mmAddPipelineClones.callArgs))
	copy(argCopy, mmAddPipelineClones.callArgs)

	mmAddPipelineClones.mutex.RUnlock()

	return argCopy
}

// MinimockAddPipelineClonesDone returns true if the count of the AddPipelineClones invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddPipelineClonesDone() bool {
	if m.AddPipelineClonesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPipelineClonesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPipelineClonesMock.invocationsDone()
}

// MinimockAddPipelineClonesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddPipelineClonesInspect() {
	for _, e := range m.AddPipelineClonesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPipelineClonesCounter := mm_atomic.LoadUint64(&m.afterAddPipelineClonesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPipelineClonesMock.defaultExpectation != nil && afterAddPipelineClonesCounter < 1 {
		if m.AddPipelineClonesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s", m.AddPipelineClonesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s with params: %#v", m.AddPipelineClonesMock.defaultExpectation.expectationOrigins.origin, *m.AddPipelineClonesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPipelineClones != nil && afterAddPipelineClonesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s", m.funcAddPipelineClonesOrigin)
	}

	if !m.AddPipelineClonesMock.invocationsDone() && afterAddPipelineClonesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddPipelineClones at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPipelineClonesMock.expectedInvocations), m.AddPipelineClonesMock.expectedInvocationsOrigin, afterAddPipelineClonesCounter)
	}
}

type mRepositoryMockAddPipelineRuns struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddPipelineRunsExpectation
	expectations       []*RepositoryMockAddPipelineRunsExpectation

	callArgs []*RepositoryMockAddPipelineRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddPipelineRunsExpectation specifies expectation struct of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddPipelineRunsParams
	paramPtrs          *RepositoryMockAddPipelineRunsParamPtrs
	expectationOrigins RepositoryMockAddPipelineRunsExpectationOrigins
	results            *RepositoryMockAddPipelineRunsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddPipelineRunsParams contains parameters of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockAddPipelineRunsParamPtrs contains pointers to parameters of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryMockAddPipelineRunsResults contains results of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsResults struct {
	err error
}

// RepositoryMockAddPipelineRunsOrigins contains origins of expectations of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Optional() *mRepositoryMockAddPipelineRuns {
	mmAddPipelineRuns.optional = true
	return mmAddPipelineRuns
}

// Expect sets up expected params for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by ExpectParams functions")
	}

	mmAddPipelineRuns.defaultExpectation.params = &RepositoryMockAddPipelineRunsParams{ctx, uid}
	mmAddPipelineRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPipelineRuns.expectations {
		if minimock.Equal(e.params, mmAddPipelineRuns.defaultExpectation.params) {
			mmAddPipelineRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPipelineRuns.defaultExpectation.params)
		}
	}

	return mmAddPipelineRuns
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.params != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Expect")
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs == nil {
		mmAddPipelineRuns.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineRunsParamPtrs{}
	}
	mmAddPipelineRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddPipelineRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddPipelineRuns
}

// ExpectUidParam2 sets up expected param uid for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.params != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Expect")
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs == nil {
		mmAddPipelineRuns.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineRunsParamPtrs{}
	}
	mmAddPipelineRuns.defaultExpectation.paramPtrs.uid = &uid
	mmAddPipelineRuns.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmAddPipelineRuns
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.inspectFuncAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddPipelineRuns")
	}

	mmAddPipelineRuns.mock.inspectFuncAddPipelineRuns = f

	return mmAddPipelineRuns
}

// Return sets up results that will be returned by Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Return(err error) *RepositoryMock {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{mock: mmAddPipelineRuns.mock}
	}
	mmAddPipelineRuns.defaultExpectation.results = &RepositoryMockAddPipelineRunsResults{err}
	mmAddPipelineRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPipelineRuns.mock
}

// Set uses given function f to mock the Repository.AddPipelineRuns method
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmAddPipelineRuns.defaultExpectation != nil {
		mmAddPipelineRuns.mock.t.Fatalf("Default expectation is already set for the Repository.AddPipelineRuns method")
	}

	if len(mmAddPipelineRuns.expectations) > 0 {
		mmAddPipelineRuns.mock.t.Fatalf("Some expectations are already set for the Repository.AddPipelineRuns method")
	}

	mmAddPipelineRuns.mock.funcAddPipelineRuns = f
	mmAddPipelineRuns.mock.funcAddPipelineRunsOrigin = minimock.CallerInfo(1)
	return mmAddPipelineRuns.mock
}

// When sets expectation for the Repository.AddPipelineRuns which will trigger the result defined by the following
// Then helper
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) When(ctx context.Context, uid uuid.UUID) *RepositoryMockAddPipelineRunsExpectation {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	expectation := &RepositoryMockAddPipelineRunsExpectation{
		mock:               mmAddPipelineRuns.mock,
		params:             &RepositoryMockAddPipelineRunsParams{ctx, uid},
		expectationOrigins: RepositoryMockAddPipelineRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPipelineRuns.expectations = append(mmAddPipelineRuns.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddPipelineRuns return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddPipelineRunsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddPipelineRunsResults{err}
	return e.mock
}

// Times sets number of times Repository.AddPipelineRuns should be invoked
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Times(n uint64) *mRepositoryMockAddPipelineRuns {
	if n == 0 {
		mmAddPipelineRuns.mock.t.Fatalf("Times of RepositoryMock.AddPipelineRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPipelineRuns.expectedInvocations, n)
	mmAddPipelineRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPipelineRuns
}

func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) invocationsDone() bool {
	if len(mmAddPipelineRuns.expectations) == 0 && mmAddPipelineRuns.defaultExpectation == nil && mmAddPipelineRuns.mock.funcAddPipelineRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPipelineRuns.mock.afterAddPipelineRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPipelineRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPipelineRuns implements mm_repository.Repository
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRuns(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmAddPipelineRuns.beforeAddPipelineRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPipelineRuns.afterAddPipelineRunsCounter, 1)

	mmAddPipelineRuns.t.Helper()

	if mmAddPipelineRuns.inspectFuncAddPipelineRuns != nil {
		mmAddPipelineRuns.inspectFuncAddPipelineRuns(ctx, uid)
	}

	mm_params := RepositoryMockAddPipelineRunsParams{ctx, uid}

	// Record call args
	mmAddPipelineRuns.AddPipelineRunsMock.mutex.Lock()
	mmAddPipelineRuns.AddPipelineRunsMock.callArgs = append(mmAddPipelineRuns.AddPipelineRunsMock.callArgs, &mm_params)
	mmAddPipelineRuns.AddPipelineRunsMock.mutex.Unlock()

	for _, e := range mmAddPipelineRuns.AddPipelineRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.params
		mm_want_ptrs := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddPipelineRunsParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPipelineRuns.t.Fatal("No results are set for the RepositoryMock.AddPipelineRuns")
		}
		return (*mm_results).err
	}
	if mmAddPipelineRuns.funcAddPipelineRuns != nil {
		return mmAddPipelineRuns.funcAddPipelineRuns(ctx, uid)
	}
	mmAddPipelineRuns.t.Fatalf("Unexpected call to RepositoryMock.AddPipelineRuns. %v %v", ctx, uid)
	return
}

// AddPipelineRunsAfterCounter returns a count of finished RepositoryMock.AddPipelineRuns invocations
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineRuns.afterAddPipelineRunsCounter)
}

// AddPipelineRunsBeforeCounter returns a count of RepositoryMock.AddPipelineRuns invocations
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineRuns.beforeAddPipelineRunsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddPipelineRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Calls() []*RepositoryMockAddPipelineRunsParams {
	mmAddPipelineRuns.mutex.RLock()

	argCopy := make([]*RepositoryMockAddPipelineRunsParams, len(mmAddPipelineRuns.callArgs))
	copy(argCopy, mmAddPipelineRuns.callArgs)

	mmAddPipelineRuns.mutex.RUnlock()

	return argCopy
}

// MinimockAddPipelineRunsDone returns true if the count of the AddPipelineRuns invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddPipelineRunsDone() bool {
	if m.AddPipelineRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPipelineRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPipelineRunsMock.invocationsDone()
}

// MinimockAddPipelineRunsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddPipelineRunsInspect() {
	for _, e := range m.AddPipelineRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPipelineRunsCounter := mm_atomic.LoadUint64(&m.afterAddPipelineRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPipelineRunsMock.defaultExpectation != nil && afterAddPipelineRunsCounter < 1 {
		if m.AddPipelineRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s", m.AddPipelineRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s with params: %#v", m.AddPipelineRunsMock.defaultExpectation.expectationOrigins.origin, *m.AddPipelineRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPipelineRuns != nil && afterAddPipelineRunsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s", m.funcAddPipelineRunsOrigin)
	}

	if !m.AddPipelineRunsMock.invocationsDone() && afterAddPipelineRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddPipelineRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPipelineRunsMock.expectedInvocations), m.AddPipelineRunsMock.expectedInvocationsOrigin, afterAddPipelineRunsCounter)
	}
}

type mRepositoryMockCheckPinnedUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckPinnedUserExpectation
	expectations       []*RepositoryMockCheckPinnedUserExpectation

	callArgs []*RepositoryMockCheckPinnedUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCheckPinnedUserExpectation specifies expectation struct of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCheckPinnedUserParams
	paramPtrs          *RepositoryMockCheckPinnedUserParamPtrs
	expectationOrigins RepositoryMockCheckPinnedUserExpectationOrigins
	results            *RepositoryMockCheckPinnedUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCheckPinnedUserParams contains parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParams struct {
	ctx   context.Context
	dp1   *gorm.DB
	table string
}

// RepositoryMockCheckPinnedUserParamPtrs contains pointers to parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParamPtrs struct {
	ctx   *context.Context
	dp1   **gorm.DB
	table *string
}

// RepositoryMockCheckPinnedUserResults contains results of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserResults struct {
	dp2 *gorm.DB
}

// RepositoryMockCheckPinnedUserOrigins contains origins of expectations of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originDp1   string
	originTable string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Optional() *mRepositoryMockCheckPinnedUser {
	mmCheckPinnedUser.optional = true
	return mmCheckPinnedUser
}

// Expect sets up expected params for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Expect(ctx context.Context, dp1 *gorm.DB, table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by ExpectParams functions")
	}

	mmCheckPinnedUser.defaultExpectation.params = &RepositoryMockCheckPinnedUserParams{ctx, dp1, table}
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPinnedUser.expectations {
		if minimock.Equal(e.params, mmCheckPinnedUser.defaultExpectation.params) {
			mmCheckPinnedUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPinnedUser.defaultExpectation.params)
		}
	}

	return mmCheckPinnedUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// ExpectDp1Param2 sets up expected param dp1 for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectDp1Param2(dp1 *gorm.DB) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.dp1 = &dp1
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// ExpectTableParam3 sets up expected param table for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectTableParam3(table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.table = &table
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originTable = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Inspect(f func(ctx context.Context, dp1 *gorm.DB, table string)) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckPinnedUser")
	}

	mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser = f

	return mmCheckPinnedUser
}

// Return sets up results that will be returned by Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Return(dp2 *gorm.DB) *RepositoryMock {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{mock: mmCheckPinnedUser.mock}
	}
	mmCheckPinnedUser.defaultExpectation.results = &RepositoryMockCheckPinnedUserResults{dp2}
	mmCheckPinnedUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser.mock
}

// Set uses given function f to mock the Repository.CheckPinnedUser method
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Set(f func(ctx context.Context, dp1 *gorm.DB, table string) (dp2 *gorm.DB)) *RepositoryMock {
	if mmCheckPinnedUser.defaultExpectation != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Default expectation is already set for the Repository.CheckPinnedUser method")
	}

	if len(mmCheckPinnedUser.expectations) > 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Some expectations are already set for the Repository.CheckPinnedUser method")
	}

	mmCheckPinnedUser.mock.funcCheckPinnedUser = f
	mmCheckPinnedUser.mock.funcCheckPinnedUserOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser.mock
}

// When sets expectation for the Repository.CheckPinnedUser which will trigger the result defined by the following
// Then helper
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) When(ctx context.Context, dp1 *gorm.DB, table string) *RepositoryMockCheckPinnedUserExpectation {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	expectation := &RepositoryMockCheckPinnedUserExpectation{
		mock:               mmCheckPinnedUser.mock,
		params:             &RepositoryMockCheckPinnedUserParams{ctx, dp1, table},
		expectationOrigins: RepositoryMockCheckPinnedUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPinnedUser.expectations = append(mmCheckPinnedUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckPinnedUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckPinnedUserExpectation) Then(dp2 *gorm.DB) *RepositoryMock {
	e.results = &RepositoryMockCheckPinnedUserResults{dp2}
	return e.mock
}

// Times sets number of times Repository.CheckPinnedUser should be invoked
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Times(n uint64) *mRepositoryMockCheckPinnedUser {
	if n == 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Times of RepositoryMock.CheckPinnedUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPinnedUser.expectedInvocations, n)
	mmCheckPinnedUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser
}

func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) invocationsDone() bool {
	if len(mmCheckPinnedUser.expectations) == 0 && mmCheckPinnedUser.defaultExpectation == nil && mmCheckPinnedUser.mock.funcCheckPinnedUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.mock.afterCheckPinnedUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPinnedUser implements mm_repository.Repository
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUser(ctx context.Context, dp1 *gorm.DB, table string) (dp2 *gorm.DB) {
	mm_atomic.AddUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter, 1)

	mmCheckPinnedUser.t.Helper()

	if mmCheckPinnedUser.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.inspectFuncCheckPinnedUser(ctx, dp1, table)
	}

	mm_params := RepositoryMockCheckPinnedUserParams{ctx, dp1, table}

	// Record call args
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Lock()
	mmCheckPinnedUser.CheckPinnedUserMock.callArgs = append(mmCheckPinnedUser.CheckPinnedUserMock.callArgs, &mm_params)
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Unlock()

	for _, e := range mmCheckPinnedUser.CheckPinnedUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2
		}
	}

	if mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCheckPinnedUserParams{ctx, dp1, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter table, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originTable, *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPinnedUser.t.Fatal("No results are set for the RepositoryMock.CheckPinnedUser")
		}
		return (*mm_results).dp2
	}
	if mmCheckPinnedUser.funcCheckPinnedUser != nil {
		return mmCheckPinnedUser.funcCheckPinnedUser(ctx, dp1, table)
	}
	mmCheckPinnedUser.t.Fatalf("Unexpected call to RepositoryMock.CheckPinnedUser. %v %v %v", ctx, dp1, table)
	return
}

// CheckPinnedUserAfterCounter returns a count of finished RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter)
}

// CheckPinnedUserBeforeCounter returns a count of RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckPinnedUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Calls() []*RepositoryMockCheckPinnedUserParams {
	mmCheckPinnedUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckPinnedUserParams, len(mmCheckPinnedUser.callArgs))
	copy(argCopy, mmCheckPinnedUser.callArgs)

	mmCheckPinnedUser.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPinnedUserDone returns true if the count of the CheckPinnedUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckPinnedUserDone() bool {
	if m.CheckPinnedUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPinnedUserMock.invocationsDone()
}

// MinimockCheckPinnedUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckPinnedUserInspect() {
	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPinnedUserCounter := mm_atomic.LoadUint64(&m.afterCheckPinnedUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPinnedUserMock.defaultExpectation != nil && afterCheckPinnedUserCounter < 1 {
		if m.CheckPinnedUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s", m.CheckPinnedUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s with params: %#v", m.CheckPinnedUserMock.defaultExpectation.expectationOrigins.origin, *m.CheckPinnedUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPinnedUser != nil && afterCheckPinnedUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s", m.funcCheckPinnedUserOrigin)
	}

	if !m.CheckPinnedUserMock.invocationsDone() && afterCheckPinnedUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CheckPinnedUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPinnedUserMock.expectedInvocations), m.CheckPinnedUserMock.expectedInvocationsOrigin, afterCheckPinnedUserCounter)
	}
}

type mRepositoryMockCreateNamespaceConnection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespaceConnectionExpectation
	expectations       []*RepositoryMockCreateNamespaceConnectionExpectation

	callArgs []*RepositoryMockCreateNamespaceConnectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateNamespaceConnectionExpectation specifies expectation struct of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateNamespaceConnectionParams
	paramPtrs          *RepositoryMockCreateNamespaceConnectionParamPtrs
	expectationOrigins RepositoryMockCreateNamespaceConnectionExpectationOrigins
	results            *RepositoryMockCreateNamespaceConnectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateNamespaceConnectionParams contains parameters of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionParams struct {
	ctx context.Context
	cp1 *datamodel.Connection
}

// RepositoryMockCreateNamespaceConnectionParamPtrs contains pointers to parameters of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionParamPtrs struct {
	ctx *context.Context
	cp1 **datamodel.Connection
}

// RepositoryMockCreateNamespaceConnectionResults contains results of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionResults struct {
	cp2 *datamodel.Connection
	err error
}

// RepositoryMockCreateNamespaceConnectionOrigins contains origins of expectations of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Optional() *mRepositoryMockCreateNamespaceConnection {
	mmCreateNamespaceConnection.optional = true
	return mmCreateNamespaceConnection
}

// Expect sets up expected params for Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Expect(ctx context.Context, cp1 *datamodel.Connection) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{}
	}

	if mmCreateNamespaceConnection.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceConnection.defaultExpectation.params = &RepositoryMockCreateNamespaceConnectionParams{ctx, cp1}
	mmCreateNamespaceConnection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespaceConnection.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceConnection.defaultExpectation.params) {
			mmCreateNamespaceConnection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceConnection.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceConnection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{}
	}

	if mmCreateNamespaceConnection.defaultExpectation.params != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Expect")
	}

	if mmCreateNamespaceConnection.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceConnection.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceConnectionParamPtrs{}
	}
	mmCreateNamespaceConnection.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespaceConnection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespaceConnection
}

// ExpectCp1Param2 sets up expected param cp1 for Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) ExpectCp1Param2(cp1 *datamodel.Connection) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{}
	}

	if mmCreateNamespaceConnection.defaultExpectation.params != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Expect")
	}

	if mmCreateNamespaceConnection.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceConnection.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceConnectionParamPtrs{}
	}
	mmCreateNamespaceConnection.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateNamespaceConnection.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateNamespaceConnection
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Inspect(f func(ctx context.Context, cp1 *datamodel.Connection)) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.inspectFuncCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespaceConnection")
	}

	mmCreateNamespaceConnection.mock.inspectFuncCreateNamespaceConnection = f

	return mmCreateNamespaceConnection
}

// Return sets up results that will be returned by Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Return(cp2 *datamodel.Connection, err error) *RepositoryMock {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{mock: mmCreateNamespaceConnection.mock}
	}
	mmCreateNamespaceConnection.defaultExpectation.results = &RepositoryMockCreateNamespaceConnectionResults{cp2, err}
	mmCreateNamespaceConnection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceConnection.mock
}

// Set uses given function f to mock the Repository.CreateNamespaceConnection method
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Set(f func(ctx context.Context, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)) *RepositoryMock {
	if mmCreateNamespaceConnection.defaultExpectation != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespaceConnection method")
	}

	if len(mmCreateNamespaceConnection.expectations) > 0 {
		mmCreateNamespaceConnection.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespaceConnection method")
	}

	mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection = f
	mmCreateNamespaceConnection.mock.funcCreateNamespaceConnectionOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceConnection.mock
}

// When sets expectation for the Repository.CreateNamespaceConnection which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) When(ctx context.Context, cp1 *datamodel.Connection) *RepositoryMockCreateNamespaceConnectionExpectation {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespaceConnectionExpectation{
		mock:               mmCreateNamespaceConnection.mock,
		params:             &RepositoryMockCreateNamespaceConnectionParams{ctx, cp1},
		expectationOrigins: RepositoryMockCreateNamespaceConnectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespaceConnection.expectations = append(mmCreateNamespaceConnection.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespaceConnection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespaceConnectionExpectation) Then(cp2 *datamodel.Connection, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespaceConnectionResults{cp2, err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespaceConnection should be invoked
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Times(n uint64) *mRepositoryMockCreateNamespaceConnection {
	if n == 0 {
		mmCreateNamespaceConnection.mock.t.Fatalf("Times of RepositoryMock.CreateNamespaceConnection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceConnection.expectedInvocations, n)
	mmCreateNamespaceConnection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceConnection
}

func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) invocationsDone() bool {
	if len(mmCreateNamespaceConnection.expectations) == 0 && mmCreateNamespaceConnection.defaultExpectation == nil && mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceConnection.mock.afterCreateNamespaceConnectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceConnection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceConnection implements mm_repository.Repository
func (mmCreateNamespaceConnection *RepositoryMock) CreateNamespaceConnection(ctx context.Context, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceConnection.beforeCreateNamespaceConnectionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceConnection.afterCreateNamespaceConnectionCounter, 1)

	mmCreateNamespaceConnection.t.Helper()

	if mmCreateNamespaceConnection.inspectFuncCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.inspectFuncCreateNamespaceConnection(ctx, cp1)
	}

	mm_params := RepositoryMockCreateNamespaceConnectionParams{ctx, cp1}

	// Record call args
	mmCreateNamespaceConnection.CreateNamespaceConnectionMock.mutex.Lock()
	mmCreateNamespaceConnection.CreateNamespaceConnectionMock.callArgs = append(mmCreateNamespaceConnection.CreateNamespaceConnectionMock.callArgs, &mm_params)
	mmCreateNamespaceConnection.CreateNamespaceConnectionMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceConnection.CreateNamespaceConnectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespaceConnectionParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceConnection.t.Errorf("RepositoryMock.CreateNamespaceConnection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateNamespaceConnection.t.Errorf("RepositoryMock.CreateNamespaceConnection got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceConnection.t.Errorf("RepositoryMock.CreateNamespaceConnection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceConnection.t.Fatal("No results are set for the RepositoryMock.CreateNamespaceConnection")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateNamespaceConnection.funcCreateNamespaceConnection != nil {
		return mmCreateNamespaceConnection.funcCreateNamespaceConnection(ctx, cp1)
	}
	mmCreateNamespaceConnection.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespaceConnection. %v %v", ctx, cp1)
	return
}

// CreateNamespaceConnectionAfterCounter returns a count of finished RepositoryMock.CreateNamespaceConnection invocations
func (mmCreateNamespaceConnection *RepositoryMock) CreateNamespaceConnectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceConnection.afterCreateNamespaceConnectionCounter)
}

// CreateNamespaceConnectionBeforeCounter returns a count of RepositoryMock.CreateNamespaceConnection invocations
func (mmCreateNamespaceConnection *RepositoryMock) CreateNamespaceConnectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceConnection.beforeCreateNamespaceConnectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespaceConnection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Calls() []*RepositoryMockCreateNamespaceConnectionParams {
	mmCreateNamespaceConnection.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespaceConnectionParams, len(mmCreateNamespaceConnection.callArgs))
	copy(argCopy, mmCreateNamespaceConnection.callArgs)

	mmCreateNamespaceConnection.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceConnectionDone returns true if the count of the CreateNamespaceConnection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespaceConnectionDone() bool {
	if m.CreateNamespaceConnectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceConnectionMock.invocationsDone()
}

// MinimockCreateNamespaceConnectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespaceConnectionInspect() {
	for _, e := range m.CreateNamespaceConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespaceConnectionCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceConnectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceConnectionMock.defaultExpectation != nil && afterCreateNamespaceConnectionCounter < 1 {
		if m.CreateNamespaceConnectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s", m.CreateNamespaceConnectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s with params: %#v", m.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespaceConnectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceConnection != nil && afterCreateNamespaceConnectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s", m.funcCreateNamespaceConnectionOrigin)
	}

	if !m.CreateNamespaceConnectionMock.invocationsDone() && afterCreateNamespaceConnectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespaceConnection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceConnectionMock.expectedInvocations), m.CreateNamespaceConnectionMock.expectedInvocationsOrigin, afterCreateNamespaceConnectionCounter)
	}
}

type mRepositoryMockCreateNamespaceSecret struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespaceSecretExpectation
	expectations       []*RepositoryMockCreateNamespaceSecretExpectation

	callArgs []*RepositoryMockCreateNamespaceSecretParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateNamespaceSecretExpectation specifies expectation struct of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateNamespaceSecretParams
	paramPtrs          *RepositoryMockCreateNamespaceSecretParamPtrs
	expectationOrigins RepositoryMockCreateNamespaceSecretExpectationOrigins
	results            *RepositoryMockCreateNamespaceSecretResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateNamespaceSecretParams contains parameters of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretParams struct {
	ctx            context.Context
	ownerPermalink string
	secret         *datamodel.Secret
}

// RepositoryMockCreateNamespaceSecretParamPtrs contains pointers to parameters of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	secret         **datamodel.Secret
}

// RepositoryMockCreateNamespaceSecretResults contains results of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretResults struct {
	err error
}

// RepositoryMockCreateNamespaceSecretOrigins contains origins of expectations of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originSecret         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Optional() *mRepositoryMockCreateNamespaceSecret {
	mmCreateNamespaceSecret.optional = true
	return mmCreateNamespaceSecret
}

// Expect sets up expected params for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Expect(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceSecret.defaultExpectation.params = &RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespaceSecret.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceSecret.defaultExpectation.params) {
			mmCreateNamespaceSecret.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceSecret.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceSecret
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespaceSecret
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmCreateNamespaceSecret
}

// ExpectSecretParam3 sets up expected param secret for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectSecretParam3(secret *datamodel.Secret) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.secret = &secret
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.originSecret = minimock.CallerInfo(1)

	return mmCreateNamespaceSecret
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Inspect(f func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret)) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.inspectFuncCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespaceSecret")
	}

	mmCreateNamespaceSecret.mock.inspectFuncCreateNamespaceSecret = f

	return mmCreateNamespaceSecret
}

// Return sets up results that will be returned by Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Return(err error) *RepositoryMock {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{mock: mmCreateNamespaceSecret.mock}
	}
	mmCreateNamespaceSecret.defaultExpectation.results = &RepositoryMockCreateNamespaceSecretResults{err}
	mmCreateNamespaceSecret.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceSecret.mock
}

// Set uses given function f to mock the Repository.CreateNamespaceSecret method
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Set(f func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error)) *RepositoryMock {
	if mmCreateNamespaceSecret.defaultExpectation != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespaceSecret method")
	}

	if len(mmCreateNamespaceSecret.expectations) > 0 {
		mmCreateNamespaceSecret.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespaceSecret method")
	}

	mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret = f
	mmCreateNamespaceSecret.mock.funcCreateNamespaceSecretOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceSecret.mock
}

// When sets expectation for the Repository.CreateNamespaceSecret which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) When(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) *RepositoryMockCreateNamespaceSecretExpectation {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespaceSecretExpectation{
		mock:               mmCreateNamespaceSecret.mock,
		params:             &RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret},
		expectationOrigins: RepositoryMockCreateNamespaceSecretExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespaceSecret.expectations = append(mmCreateNamespaceSecret.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespaceSecret return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespaceSecretExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespaceSecretResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespaceSecret should be invoked
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Times(n uint64) *mRepositoryMockCreateNamespaceSecret {
	if n == 0 {
		mmCreateNamespaceSecret.mock.t.Fatalf("Times of RepositoryMock.CreateNamespaceSecret mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceSecret.expectedInvocations, n)
	mmCreateNamespaceSecret.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceSecret
}

func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) invocationsDone() bool {
	if len(mmCreateNamespaceSecret.expectations) == 0 && mmCreateNamespaceSecret.defaultExpectation == nil && mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceSecret.mock.afterCreateNamespaceSecretCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceSecret.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceSecret implements mm_repository.Repository
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecret(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceSecret.beforeCreateNamespaceSecretCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceSecret.afterCreateNamespaceSecretCounter, 1)

	mmCreateNamespaceSecret.t.Helper()

	if mmCreateNamespaceSecret.inspectFuncCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.inspectFuncCreateNamespaceSecret(ctx, ownerPermalink, secret)
	}

	mm_params := RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}

	// Record call args
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.mutex.Lock()
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.callArgs = append(mmCreateNamespaceSecret.CreateNamespaceSecretMock.callArgs, &mm_params)
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceSecret.CreateNamespaceSecretMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.secret != nil && !minimock.Equal(*mm_want_ptrs.secret, mm_got.secret) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter secret, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.originSecret, *mm_want_ptrs.secret, mm_got.secret, minimock.Diff(*mm_want_ptrs.secret, mm_got.secret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceSecret.t.Fatal("No results are set for the RepositoryMock.CreateNamespaceSecret")
		}
		return (*mm_results).err
	}
	if mmCreateNamespaceSecret.funcCreateNamespaceSecret != nil {
		return mmCreateNamespaceSecret.funcCreateNamespaceSecret(ctx, ownerPermalink, secret)
	}
	mmCreateNamespaceSecret.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespaceSecret. %v %v %v", ctx, ownerPermalink, secret)
	return
}

// CreateNamespaceSecretAfterCounter returns a count of finished RepositoryMock.CreateNamespaceSecret invocations
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecretAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceSecret.afterCreateNamespaceSecretCounter)
}

// CreateNamespaceSecretBeforeCounter returns a count of RepositoryMock.CreateNamespaceSecret invocations
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecretBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceSecret.beforeCreateNamespaceSecretCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespaceSecret.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Calls() []*RepositoryMockCreateNamespaceSecretParams {
	mmCreateNamespaceSecret.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespaceSecretParams, len(mmCreateNamespaceSecret.callArgs))
	copy(argCopy, mmCreateNamespaceSecret.callArgs)

	mmCreateNamespaceSecret.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceSecretDone returns true if the count of the CreateNamespaceSecret invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespaceSecretDone() bool {
	if m.CreateNamespaceSecretMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceSecretMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceSecretMock.invocationsDone()
}

// MinimockCreateNamespaceSecretInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespaceSecretInspect() {
	for _, e := range m.CreateNamespaceSecretMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespaceSecretCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceSecretCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceSecretMock.defaultExpectation != nil && afterCreateNamespaceSecretCounter < 1 {
		if m.CreateNamespaceSecretMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s", m.CreateNamespaceSecretMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s with params: %#v", m.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespaceSecretMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceSecret != nil && afterCreateNamespaceSecretCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s", m.funcCreateNamespaceSecretOrigin)
	}

	if !m.CreateNamespaceSecretMock.invocationsDone() && afterCreateNamespaceSecretCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespaceSecret at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceSecretMock.expectedInvocations), m.CreateNamespaceSecretMock.expectedInvocationsOrigin, afterCreateNamespaceSecretCounter)
	}
}

type mRepositoryMockCreatePipeline struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreatePipelineExpectation
	expectations       []*RepositoryMockCreatePipelineExpectation

	callArgs []*RepositoryMockCreatePipelineParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreatePipelineExpectation specifies expectation struct of the Repository.CreatePipeline
type RepositoryMockCreatePipelineExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreatePipelineParams
	paramPtrs          *RepositoryMockCreatePipelineParamPtrs
	expectationOrigins RepositoryMockCreatePipelineExpectationOrigins
	results            *RepositoryMockCreatePipelineResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreatePipelineParams contains parameters of the Repository.CreatePipeline
type RepositoryMockCreatePipelineParams struct {
	ctx      context.Context
	pipeline *datamodel.Pipeline
}

// RepositoryMockCreatePipelineParamPtrs contains pointers to parameters of the Repository.CreatePipeline
type RepositoryMockCreatePipelineParamPtrs struct {
	ctx      *context.Context
	pipeline **datamodel.Pipeline
}

// RepositoryMockCreatePipelineResults contains results of the Repository.CreatePipeline
type RepositoryMockCreatePipelineResults struct {
	err error
}

// RepositoryMockCreatePipelineOrigins contains origins of expectations of the Repository.CreatePipeline
type RepositoryMockCreatePipelineExpectationOrigins struct {
	origin         string
	originCtx      string
	originPipeline string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePipeline *mRepositoryMockCreatePipeline) Optional() *mRepositoryMockCreatePipeline {
	mmCreatePipeline.optional = true
	return mmCreatePipeline
}

// Expect sets up expected params for Repository.CreatePipeline
func (mmCreatePipeline *mRepositoryMockCreatePipeline) Expect(ctx context.Context, pipeline *datamodel.Pipeline) *mRepositoryMockCreatePipeline {
	if mmCreatePipeline.mock.funcCreatePipeline != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by Set")
	}

	if mmCreatePipeline.defaultExpectation == nil {
		mmCreatePipeline.defaultExpectation = &RepositoryMockCreatePipelineExpectation{}
	}

	if mmCreatePipeline.defaultExpectation.paramPtrs != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by ExpectParams functions")
	}

	mmCreatePipeline.defaultExpectation.params = &RepositoryMockCreatePipelineParams{ctx, pipeline}
	mmCreatePipeline.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePipeline.expectations {
		if minimock.Equal(e.params, mmCreatePipeline.defaultExpectation.params) {
			mmCreatePipeline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePipeline.defaultExpectation.params)
		}
	}

	return mmCreatePipeline
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreatePipeline
func (mmCreatePipeline *mRepositoryMockCreatePipeline) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreatePipeline {
	if mmCreatePipeline.mock.funcCreatePipeline != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by Set")
	}

	if mmCreatePipeline.defaultExpectation == nil {
		mmCreatePipeline.defaultExpectation = &RepositoryMockCreatePipelineExpectation{}
	}

	if mmCreatePipeline.defaultExpectation.params != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by Expect")
	}

	if mmCreatePipeline.defaultExpectation.paramPtrs == nil {
		mmCreatePipeline.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineParamPtrs{}
	}
	mmCreatePipeline.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePipeline.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePipeline
}

// ExpectPipelineParam2 sets up expected param pipeline for Repository.CreatePipeline
func (mmCreatePipeline *mRepositoryMockCreatePipeline) ExpectPipelineParam2(pipeline *datamodel.Pipeline) *mRepositoryMockCreatePipeline {
	if mmCreatePipeline.mock.funcCreatePipeline != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by Set")
	}

	if mmCreatePipeline.defaultExpectation == nil {
		mmCreatePipeline.defaultExpectation = &RepositoryMockCreatePipelineExpectation{}
	}

	if mmCreatePipeline.defaultExpectation.params != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by Expect")
	}

	if mmCreatePipeline.defaultExpectation.paramPtrs == nil {
		mmCreatePipeline.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineParamPtrs{}
	}
	mmCreatePipeline.defaultExpectation.paramPtrs.pipeline = &pipeline
	mmCreatePipeline.defaultExpectation.expectationOrigins.originPipeline = minimock.CallerInfo(1)

	return mmCreatePipeline
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreatePipeline
func (mmCreatePipeline *mRepositoryMockCreatePipeline) Inspect(f func(ctx context.Context, pipeline *datamodel.Pipeline)) *mRepositoryMockCreatePipeline {
	if mmCreatePipeline.mock.inspectFuncCreatePipeline != nil {
		mmCreatePipeline.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreatePipeline")
	}

	mmCreatePipeline.mock.inspectFuncCreatePipeline = f

	return mmCreatePipeline
}

// Return sets up results that will be returned by Repository.CreatePipeline
func (mmCreatePipeline *mRepositoryMockCreatePipeline) Return(err error) *RepositoryMock {
	if mmCreatePipeline.mock.funcCreatePipeline != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by Set")
	}

	if mmCreatePipeline.defaultExpectation == nil {
		mmCreatePipeline.defaultExpectation = &RepositoryMockCreatePipelineExpectation{mock: mmCreatePipeline.mock}
	}
	mmCreatePipeline.defaultExpectation.results = &RepositoryMockCreatePipelineResults{err}
	mmCreatePipeline.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePipeline.mock
}

// Set uses given function f to mock the Repository.CreatePipeline method
func (mmCreatePipeline *mRepositoryMockCreatePipeline) Set(f func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)) *RepositoryMock {
	if mmCreatePipeline.defaultExpectation != nil {
		mmCreatePipeline.mock.t.Fatalf("Default expectation is already set for the Repository.CreatePipeline method")
	}

	if len(mmCreatePipeline.expectations) > 0 {
		mmCreatePipeline.mock.t.Fatalf("Some expectations are already set for the Repository.CreatePipeline method")
	}

	mmCreatePipeline.mock.funcCreatePipeline = f
	mmCreatePipeline.mock.funcCreatePipelineOrigin = minimock.CallerInfo(1)
	return mmCreatePipeline.mock
}

// When sets expectation for the Repository.CreatePipeline which will trigger the result defined by the following
// Then helper
func (mmCreatePipeline *mRepositoryMockCreatePipeline) When(ctx context.Context, pipeline *datamodel.Pipeline) *RepositoryMockCreatePipelineExpectation {
	if mmCreatePipeline.mock.funcCreatePipeline != nil {
		mmCreatePipeline.mock.t.Fatalf("RepositoryMock.CreatePipeline mock is already set by Set")
	}

	expectation := &RepositoryMockCreatePipelineExpectation{
		mock:               mmCreatePipeline.mock,
		params:             &RepositoryMockCreatePipelineParams{ctx, pipeline},
		expectationOrigins: RepositoryMockCreatePipelineExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePipeline.expectations = append(mmCreatePipeline.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreatePipeline return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreatePipelineExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreatePipelineResults{err}
	return e.mock
}

// Times sets number of times Repository.CreatePipeline should be invoked
func (mmCreatePipeline *mRepositoryMockCreatePipeline) Times(n uint64) *mRepositoryMockCreatePipeline {
	if n == 0 {
		mmCreatePipeline.mock.t.Fatalf("Times of RepositoryMock.CreatePipeline mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePipeline.expectedInvocations, n)
	mmCreatePipeline.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePipeline
}

func (mmCreatePipeline *mRepositoryMockCreatePipeline) invocationsDone() bool {
	if len(mmCreatePipeline.expectations) == 0 && mmCreatePipeline.defaultExpectation == nil && mmCreatePipeline.mock.funcCreatePipeline == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePipeline.mock.afterCreatePipelineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePipeline.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePipeline implements mm_repository.Repository
func (mmCreatePipeline *RepositoryMock) CreatePipeline(ctx context.Context, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmCreatePipeline.beforeCreatePipelineCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePipeline.afterCreatePipelineCounter, 1)

	mmCreatePipeline.t.Helper()

	if mmCreatePipeline.inspectFuncCreatePipeline != nil {
		mmCreatePipeline.inspectFuncCreatePipeline(ctx, pipeline)
	}

	mm_params := RepositoryMockCreatePipelineParams{ctx, pipeline}

	// Record call args
	mmCreatePipeline.CreatePipelineMock.mutex.Lock()
	mmCreatePipeline.CreatePipelineMock.callArgs = append(mmCreatePipeline.CreatePipelineMock.callArgs, &mm_params)
	mmCreatePipeline.CreatePipelineMock.mutex.Unlock()

	for _, e := range mmCreatePipeline.CreatePipelineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePipeline.CreatePipelineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePipeline.CreatePipelineMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePipeline.CreatePipelineMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePipeline.CreatePipelineMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreatePipelineParams{ctx, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePipeline.t.Errorf("RepositoryMock.CreatePipeline got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipeline.CreatePipelineMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmCreatePipeline.t.Errorf("RepositoryMock.CreatePipeline got unexpected parameter pipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipeline.CreatePipelineMock.defaultExpectation.expectationOrigins.originPipeline, *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePipeline.t.Errorf("RepositoryMock.CreatePipeline got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePipeline.CreatePipelineMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePipeline.CreatePipelineMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePipeline.t.Fatal("No results are set for the RepositoryMock.CreatePipeline")
		}
		return (*mm_results).err
	}
	if mmCreatePipeline.funcCreatePipeline != nil {
		return mmCreatePipeline.funcCreatePipeline(ctx, pipeline)
	}
	mmCreatePipeline.t.Fatalf("Unexpected call to RepositoryMock.CreatePipeline. %v %v", ctx, pipeline)
	return
}

// CreatePipelineAfterCounter returns a count of finished RepositoryMock.CreatePipeline invocations
func (mmCreatePipeline *RepositoryMock) CreatePipelineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipeline.afterCreatePipelineCounter)
}

// CreatePipelineBeforeCounter returns a count of RepositoryMock.CreatePipeline invocations
func (mmCreatePipeline *RepositoryMock) CreatePipelineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipeline.beforeCreatePipelineCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreatePipeline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePipeline *mRepositoryMockCreatePipeline) Calls() []*RepositoryMockCreatePipelineParams {
	mmCreatePipeline.mutex.RLock()

	argCopy := make([]*RepositoryMockCreatePipelineParams, len(mmCreatePipeline.callArgs))
	copy(argCopy, mmCreatePipeline.callArgs)

	mmCreatePipeline.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePipelineDone returns true if the count of the CreatePipeline invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreatePipelineDone() bool {
	if m.CreatePipelineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePipelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePipelineMock.invocationsDone()
}

// MinimockCreatePipelineInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreatePipelineInspect() {
	for _, e := range m.CreatePipelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipeline at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePipelineCounter := mm_atomic.LoadUint64(&m.afterCreatePipelineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePipelineMock.defaultExpectation != nil && afterCreatePipelineCounter < 1 {
		if m.CreatePipelineMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipeline at\n%s", m.CreatePipelineMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipeline at\n%s with params: %#v", m.CreatePipelineMock.defaultExpectation.expectationOrigins.origin, *m.CreatePipelineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePipeline != nil && afterCreatePipelineCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreatePipeline at\n%s", m.funcCreatePipelineOrigin)
	}

	if !m.CreatePipelineMock.invocationsDone() && afterCreatePipelineCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreatePipeline at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePipelineMock.expectedInvocations), m.CreatePipelineMock.expectedInvocationsOrigin, afterCreatePipelineCounter)
	}
}

type mRepositoryMockCreatePipelineRelease struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreatePipelineReleaseExpectation
	expectations       []*RepositoryMockCreatePipelineReleaseExpectation

	callArgs []*RepositoryMockCreatePipelineReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreatePipelineReleaseExpectation specifies expectation struct of the Repository.CreatePipelineRelease
type RepositoryMockCreatePipelineReleaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreatePipelineReleaseParams
	paramPtrs          *RepositoryMockCreatePipelineReleaseParamPtrs
	expectationOrigins RepositoryMockCreatePipelineReleaseExpectationOrigins
	results            *RepositoryMockCreatePipelineReleaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreatePipelineReleaseParams contains parameters of the Repository.CreatePipelineRelease
type RepositoryMockCreatePipelineReleaseParams struct {
	ctx             context.Context
	ownerPermalink  string
	pipelineUID     uuid.UUID
	pipelineRelease *datamodel.PipelineRelease
}

// RepositoryMockCreatePipelineReleaseParamPtrs contains pointers to parameters of the Repository.CreatePipelineRelease
type RepositoryMockCreatePipelineReleaseParamPtrs struct {
	ctx             *context.Context
	ownerPermalink  *string
	pipelineUID     *uuid.UUID
	pipelineRelease **datamodel.PipelineRelease
}

// RepositoryMockCreatePipelineReleaseResults contains results of the Repository.CreatePipelineRelease
type RepositoryMockCreatePipelineReleaseResults struct {
	err error
}

// RepositoryMockCreatePipelineReleaseOrigins contains origins of expectations of the Repository.CreatePipelineRelease
type RepositoryMockCreatePipelineReleaseExpectationOrigins struct {
	origin                string
	originCtx             string
	originOwnerPermalink  string
	originPipelineUID     string
	originPipelineRelease string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) Optional() *mRepositoryMockCreatePipelineRelease {
	mmCreatePipelineRelease.optional = true
	return mmCreatePipelineRelease
}

// Expect sets up expected params for Repository.CreatePipelineRelease
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockCreatePipelineRelease {
	if mmCreatePipelineRelease.mock.funcCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Set")
	}

	if mmCreatePipelineRelease.defaultExpectation == nil {
		mmCreatePipelineRelease.defaultExpectation = &RepositoryMockCreatePipelineReleaseExpectation{}
	}

	if mmCreatePipelineRelease.defaultExpectation.paramPtrs != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by ExpectParams functions")
	}

	mmCreatePipelineRelease.defaultExpectation.params = &RepositoryMockCreatePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}
	mmCreatePipelineRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePipelineRelease.expectations {
		if minimock.Equal(e.params, mmCreatePipelineRelease.defaultExpectation.params) {
			mmCreatePipelineRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePipelineRelease.defaultExpectation.params)
		}
	}

	return mmCreatePipelineRelease
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreatePipelineRelease
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreatePipelineRelease {
	if mmCreatePipelineRelease.mock.funcCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Set")
	}

	if mmCreatePipelineRelease.defaultExpectation == nil {
		mmCreatePipelineRelease.defaultExpectation = &RepositoryMockCreatePipelineReleaseExpectation{}
	}

	if mmCreatePipelineRelease.defaultExpectation.params != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Expect")
	}

	if mmCreatePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineReleaseParamPtrs{}
	}
	mmCreatePipelineRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePipelineRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePipelineRelease
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreatePipelineRelease
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreatePipelineRelease {
	if mmCreatePipelineRelease.mock.funcCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Set")
	}

	if mmCreatePipelineRelease.defaultExpectation == nil {
		mmCreatePipelineRelease.defaultExpectation = &RepositoryMockCreatePipelineReleaseExpectation{}
	}

	if mmCreatePipelineRelease.defaultExpectation.params != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Expect")
	}

	if mmCreatePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineReleaseParamPtrs{}
	}
	mmCreatePipelineRelease.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmCreatePipelineRelease.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmCreatePipelineRelease
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.CreatePipelineRelease
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockCreatePipelineRelease {
	if mmCreatePipelineRelease.mock.funcCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Set")
	}

	if mmCreatePipelineRelease.defaultExpectation == nil {
		mmCreatePipelineRelease.defaultExpectation = &RepositoryMockCreatePipelineReleaseExpectation{}
	}

	if mmCreatePipelineRelease.defaultExpectation.params != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Expect")
	}

	if mmCreatePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineReleaseParamPtrs{}
	}
	mmCreatePipelineRelease.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmCreatePipelineRelease.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmCreatePipelineRelease
}

// ExpectPipelineReleaseParam4 sets up expected param pipelineRelease for Repository.CreatePipelineRelease
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) ExpectPipelineReleaseParam4(pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockCreatePipelineRelease {
	if mmCreatePipelineRelease.mock.funcCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Set")
	}

	if mmCreatePipelineRelease.defaultExpectation == nil {
		mmCreatePipelineRelease.defaultExpectation = &RepositoryMockCreatePipelineReleaseExpectation{}
	}

	if mmCreatePipelineRelease.defaultExpectation.params != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Expect")
	}

	if mmCreatePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineReleaseParamPtrs{}
	}
	mmCreatePipelineRelease.defaultExpectation.paramPtrs.pipelineRelease = &pipelineRelease
	mmCreatePipelineRelease.defaultExpectation.expectationOrigins.originPipelineRelease = minimock.CallerInfo(1)

	return mmCreatePipelineRelease
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreatePipelineRelease
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease)) *mRepositoryMockCreatePipelineRelease {
	if mmCreatePipelineRelease.mock.inspectFuncCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreatePipelineRelease")
	}

	mmCreatePipelineRelease.mock.inspectFuncCreatePipelineRelease = f

	return mmCreatePipelineRelease
}

// Return sets up results that will be returned by Repository.CreatePipelineRelease
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) Return(err error) *RepositoryMock {
	if mmCreatePipelineRelease.mock.funcCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Set")
	}

	if mmCreatePipelineRelease.defaultExpectation == nil {
		mmCreatePipelineRelease.defaultExpectation = &RepositoryMockCreatePipelineReleaseExpectation{mock: mmCreatePipelineRelease.mock}
	}
	mmCreatePipelineRelease.defaultExpectation.results = &RepositoryMockCreatePipelineReleaseResults{err}
	mmCreatePipelineRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineRelease.mock
}

// Set uses given function f to mock the Repository.CreatePipelineRelease method
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error)) *RepositoryMock {
	if mmCreatePipelineRelease.defaultExpectation != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("Default expectation is already set for the Repository.CreatePipelineRelease method")
	}

	if len(mmCreatePipelineRelease.expectations) > 0 {
		mmCreatePipelineRelease.mock.t.Fatalf("Some expectations are already set for the Repository.CreatePipelineRelease method")
	}

	mmCreatePipelineRelease.mock.funcCreatePipelineRelease = f
	mmCreatePipelineRelease.mock.funcCreatePipelineReleaseOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineRelease.mock
}

// When sets expectation for the Repository.CreatePipelineRelease which will trigger the result defined by the following
// Then helper
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) *RepositoryMockCreatePipelineReleaseExpectation {
	if mmCreatePipelineRelease.mock.funcCreatePipelineRelease != nil {
		mmCreatePipelineRelease.mock.t.Fatalf("RepositoryMock.CreatePipelineRelease mock is already set by Set")
	}

	expectation := &RepositoryMockCreatePipelineReleaseExpectation{
		mock:               mmCreatePipelineRelease.mock,
		params:             &RepositoryMockCreatePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease},
		expectationOrigins: RepositoryMockCreatePipelineReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePipelineRelease.expectations = append(mmCreatePipelineRelease.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreatePipelineRelease return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreatePipelineReleaseExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreatePipelineReleaseResults{err}
	return e.mock
}

// Times sets number of times Repository.CreatePipelineRelease should be invoked
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) Times(n uint64) *mRepositoryMockCreatePipelineRelease {
	if n == 0 {
		mmCreatePipelineRelease.mock.t.Fatalf("Times of RepositoryMock.CreatePipelineRelease mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePipelineRelease.expectedInvocations, n)
	mmCreatePipelineRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineRelease
}

func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) invocationsDone() bool {
	if len(mmCreatePipelineRelease.expectations) == 0 && mmCreatePipelineRelease.defaultExpectation == nil && mmCreatePipelineRelease.mock.funcCreatePipelineRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePipelineRelease.mock.afterCreatePipelineReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePipelineRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePipelineRelease implements mm_repository.Repository
func (mmCreatePipelineRelease *RepositoryMock) CreatePipelineRelease(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error) {
	mm_atomic.AddUint64(&mmCreatePipelineRelease.beforeCreatePipelineReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePipelineRelease.afterCreatePipelineReleaseCounter, 1)

	mmCreatePipelineRelease.t.Helper()

	if mmCreatePipelineRelease.inspectFuncCreatePipelineRelease != nil {
		mmCreatePipelineRelease.inspectFuncCreatePipelineRelease(ctx, ownerPermalink, pipelineUID, pipelineRelease)
	}

	mm_params := RepositoryMockCreatePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}

	// Record call args
	mmCreatePipelineRelease.CreatePipelineReleaseMock.mutex.Lock()
	mmCreatePipelineRelease.CreatePipelineReleaseMock.callArgs = append(mmCreatePipelineRelease.CreatePipelineReleaseMock.callArgs, &mm_params)
	mmCreatePipelineRelease.CreatePipelineReleaseMock.mutex.Unlock()

	for _, e := range mmCreatePipelineRelease.CreatePipelineReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreatePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePipelineRelease.t.Errorf("RepositoryMock.CreatePipelineRelease got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreatePipelineRelease.t.Errorf("RepositoryMock.CreatePipelineRelease got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmCreatePipelineRelease.t.Errorf("RepositoryMock.CreatePipelineRelease got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease) {
				mmCreatePipelineRelease.t.Errorf("RepositoryMock.CreatePipelineRelease got unexpected parameter pipelineRelease, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.expectationOrigins.originPipelineRelease, *mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease, minimock.Diff(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePipelineRelease.t.Errorf("RepositoryMock.CreatePipelineRelease got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePipelineRelease.CreatePipelineReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePipelineRelease.t.Fatal("No results are set for the RepositoryMock.CreatePipelineRelease")
		}
		return (*mm_results).err
	}
	if mmCreatePipelineRelease.funcCreatePipelineRelease != nil {
		return mmCreatePipelineRelease.funcCreatePipelineRelease(ctx, ownerPermalink, pipelineUID, pipelineRelease)
	}
	mmCreatePipelineRelease.t.Fatalf("Unexpected call to RepositoryMock.CreatePipelineRelease. %v %v %v %v", ctx, ownerPermalink, pipelineUID, pipelineRelease)
	return
}

// CreatePipelineReleaseAfterCounter returns a count of finished RepositoryMock.CreatePipelineRelease invocations
func (mmCreatePipelineRelease *RepositoryMock) CreatePipelineReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineRelease.afterCreatePipelineReleaseCounter)
}

// CreatePipelineReleaseBeforeCounter returns a count of RepositoryMock.CreatePipelineRelease invocations
func (mmCreatePipelineRelease *RepositoryMock) CreatePipelineReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineRelease.beforeCreatePipelineReleaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreatePipelineRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePipelineRelease *mRepositoryMockCreatePipelineRelease) Calls() []*RepositoryMockCreatePipelineReleaseParams {
	mmCreatePipelineRelease.mutex.RLock()

	argCopy := make([]*RepositoryMockCreatePipelineReleaseParams, len(mmCreatePipelineRelease.callArgs))
	copy(argCopy, mmCreatePipelineRelease.callArgs)

	mmCreatePipelineRelease.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePipelineReleaseDone returns true if the count of the CreatePipelineRelease invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreatePipelineReleaseDone() bool {
	if m.CreatePipelineReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePipelineReleaseMock.invocationsDone()
}

// MinimockCreatePipelineReleaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreatePipelineReleaseInspect() {
	for _, e := range m.CreatePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRelease at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePipelineReleaseCounter := mm_atomic.LoadUint64(&m.afterCreatePipelineReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePipelineReleaseMock.defaultExpectation != nil && afterCreatePipelineReleaseCounter < 1 {
		if m.CreatePipelineReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRelease at\n%s", m.CreatePipelineReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRelease at\n%s with params: %#v", m.CreatePipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *m.CreatePipelineReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePipelineRelease != nil && afterCreatePipelineReleaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRelease at\n%s", m.funcCreatePipelineReleaseOrigin)
	}

	if !m.CreatePipelineReleaseMock.invocationsDone() && afterCreatePipelineReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreatePipelineRelease at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePipelineReleaseMock.expectedInvocations), m.CreatePipelineReleaseMock.expectedInvocationsOrigin, afterCreatePipelineReleaseCounter)
	}
}

type mRepositoryMockCreatePipelineRunOn struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreatePipelineRunOnExpectation
	expectations       []*RepositoryMockCreatePipelineRunOnExpectation

	callArgs []*RepositoryMockCreatePipelineRunOnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreatePipelineRunOnExpectation specifies expectation struct of the Repository.CreatePipelineRunOn
type RepositoryMockCreatePipelineRunOnExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreatePipelineRunOnParams
	paramPtrs          *RepositoryMockCreatePipelineRunOnParamPtrs
	expectationOrigins RepositoryMockCreatePipelineRunOnExpectationOrigins
	results            *RepositoryMockCreatePipelineRunOnResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreatePipelineRunOnParams contains parameters of the Repository.CreatePipelineRunOn
type RepositoryMockCreatePipelineRunOnParams struct {
	ctx context.Context
	pp1 *datamodel.PipelineRunOn
}

// RepositoryMockCreatePipelineRunOnParamPtrs contains pointers to parameters of the Repository.CreatePipelineRunOn
type RepositoryMockCreatePipelineRunOnParamPtrs struct {
	ctx *context.Context
	pp1 **datamodel.PipelineRunOn
}

// RepositoryMockCreatePipelineRunOnResults contains results of the Repository.CreatePipelineRunOn
type RepositoryMockCreatePipelineRunOnResults struct {
	err error
}

// RepositoryMockCreatePipelineRunOnOrigins contains origins of expectations of the Repository.CreatePipelineRunOn
type RepositoryMockCreatePipelineRunOnExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) Optional() *mRepositoryMockCreatePipelineRunOn {
	mmCreatePipelineRunOn.optional = true
	return mmCreatePipelineRunOn
}

// Expect sets up expected params for Repository.CreatePipelineRunOn
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) Expect(ctx context.Context, pp1 *datamodel.PipelineRunOn) *mRepositoryMockCreatePipelineRunOn {
	if mmCreatePipelineRunOn.mock.funcCreatePipelineRunOn != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by Set")
	}

	if mmCreatePipelineRunOn.defaultExpectation == nil {
		mmCreatePipelineRunOn.defaultExpectation = &RepositoryMockCreatePipelineRunOnExpectation{}
	}

	if mmCreatePipelineRunOn.defaultExpectation.paramPtrs != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by ExpectParams functions")
	}

	mmCreatePipelineRunOn.defaultExpectation.params = &RepositoryMockCreatePipelineRunOnParams{ctx, pp1}
	mmCreatePipelineRunOn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePipelineRunOn.expectations {
		if minimock.Equal(e.params, mmCreatePipelineRunOn.defaultExpectation.params) {
			mmCreatePipelineRunOn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePipelineRunOn.defaultExpectation.params)
		}
	}

	return mmCreatePipelineRunOn
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreatePipelineRunOn
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreatePipelineRunOn {
	if mmCreatePipelineRunOn.mock.funcCreatePipelineRunOn != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by Set")
	}

	if mmCreatePipelineRunOn.defaultExpectation == nil {
		mmCreatePipelineRunOn.defaultExpectation = &RepositoryMockCreatePipelineRunOnExpectation{}
	}

	if mmCreatePipelineRunOn.defaultExpectation.params != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by Expect")
	}

	if mmCreatePipelineRunOn.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineRunOn.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineRunOnParamPtrs{}
	}
	mmCreatePipelineRunOn.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePipelineRunOn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePipelineRunOn
}

// ExpectPp1Param2 sets up expected param pp1 for Repository.CreatePipelineRunOn
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) ExpectPp1Param2(pp1 *datamodel.PipelineRunOn) *mRepositoryMockCreatePipelineRunOn {
	if mmCreatePipelineRunOn.mock.funcCreatePipelineRunOn != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by Set")
	}

	if mmCreatePipelineRunOn.defaultExpectation == nil {
		mmCreatePipelineRunOn.defaultExpectation = &RepositoryMockCreatePipelineRunOnExpectation{}
	}

	if mmCreatePipelineRunOn.defaultExpectation.params != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by Expect")
	}

	if mmCreatePipelineRunOn.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineRunOn.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineRunOnParamPtrs{}
	}
	mmCreatePipelineRunOn.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePipelineRunOn.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePipelineRunOn
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreatePipelineRunOn
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) Inspect(f func(ctx context.Context, pp1 *datamodel.PipelineRunOn)) *mRepositoryMockCreatePipelineRunOn {
	if mmCreatePipelineRunOn.mock.inspectFuncCreatePipelineRunOn != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreatePipelineRunOn")
	}

	mmCreatePipelineRunOn.mock.inspectFuncCreatePipelineRunOn = f

	return mmCreatePipelineRunOn
}

// Return sets up results that will be returned by Repository.CreatePipelineRunOn
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) Return(err error) *RepositoryMock {
	if mmCreatePipelineRunOn.mock.funcCreatePipelineRunOn != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by Set")
	}

	if mmCreatePipelineRunOn.defaultExpectation == nil {
		mmCreatePipelineRunOn.defaultExpectation = &RepositoryMockCreatePipelineRunOnExpectation{mock: mmCreatePipelineRunOn.mock}
	}
	mmCreatePipelineRunOn.defaultExpectation.results = &RepositoryMockCreatePipelineRunOnResults{err}
	mmCreatePipelineRunOn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineRunOn.mock
}

// Set uses given function f to mock the Repository.CreatePipelineRunOn method
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) Set(f func(ctx context.Context, pp1 *datamodel.PipelineRunOn) (err error)) *RepositoryMock {
	if mmCreatePipelineRunOn.defaultExpectation != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("Default expectation is already set for the Repository.CreatePipelineRunOn method")
	}

	if len(mmCreatePipelineRunOn.expectations) > 0 {
		mmCreatePipelineRunOn.mock.t.Fatalf("Some expectations are already set for the Repository.CreatePipelineRunOn method")
	}

	mmCreatePipelineRunOn.mock.funcCreatePipelineRunOn = f
	mmCreatePipelineRunOn.mock.funcCreatePipelineRunOnOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineRunOn.mock
}

// When sets expectation for the Repository.CreatePipelineRunOn which will trigger the result defined by the following
// Then helper
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) When(ctx context.Context, pp1 *datamodel.PipelineRunOn) *RepositoryMockCreatePipelineRunOnExpectation {
	if mmCreatePipelineRunOn.mock.funcCreatePipelineRunOn != nil {
		mmCreatePipelineRunOn.mock.t.Fatalf("RepositoryMock.CreatePipelineRunOn mock is already set by Set")
	}

	expectation := &RepositoryMockCreatePipelineRunOnExpectation{
		mock:               mmCreatePipelineRunOn.mock,
		params:             &RepositoryMockCreatePipelineRunOnParams{ctx, pp1},
		expectationOrigins: RepositoryMockCreatePipelineRunOnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePipelineRunOn.expectations = append(mmCreatePipelineRunOn.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreatePipelineRunOn return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreatePipelineRunOnExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreatePipelineRunOnResults{err}
	return e.mock
}

// Times sets number of times Repository.CreatePipelineRunOn should be invoked
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) Times(n uint64) *mRepositoryMockCreatePipelineRunOn {
	if n == 0 {
		mmCreatePipelineRunOn.mock.t.Fatalf("Times of RepositoryMock.CreatePipelineRunOn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePipelineRunOn.expectedInvocations, n)
	mmCreatePipelineRunOn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineRunOn
}

func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) invocationsDone() bool {
	if len(mmCreatePipelineRunOn.expectations) == 0 && mmCreatePipelineRunOn.defaultExpectation == nil && mmCreatePipelineRunOn.mock.funcCreatePipelineRunOn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePipelineRunOn.mock.afterCreatePipelineRunOnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePipelineRunOn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePipelineRunOn implements mm_repository.Repository
func (mmCreatePipelineRunOn *RepositoryMock) CreatePipelineRunOn(ctx context.Context, pp1 *datamodel.PipelineRunOn) (err error) {
	mm_atomic.AddUint64(&mmCreatePipelineRunOn.beforeCreatePipelineRunOnCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePipelineRunOn.afterCreatePipelineRunOnCounter, 1)

	mmCreatePipelineRunOn.t.Helper()

	if mmCreatePipelineRunOn.inspectFuncCreatePipelineRunOn != nil {
		mmCreatePipelineRunOn.inspectFuncCreatePipelineRunOn(ctx, pp1)
	}

	mm_params := RepositoryMockCreatePipelineRunOnParams{ctx, pp1}

	// Record call args
	mmCreatePipelineRunOn.CreatePipelineRunOnMock.mutex.Lock()
	mmCreatePipelineRunOn.CreatePipelineRunOnMock.callArgs = append(mmCreatePipelineRunOn.CreatePipelineRunOnMock.callArgs, &mm_params)
	mmCreatePipelineRunOn.CreatePipelineRunOnMock.mutex.Unlock()

	for _, e := range mmCreatePipelineRunOn.CreatePipelineRunOnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreatePipelineRunOnParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePipelineRunOn.t.Errorf("RepositoryMock.CreatePipelineRunOn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePipelineRunOn.t.Errorf("RepositoryMock.CreatePipelineRunOn got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePipelineRunOn.t.Errorf("RepositoryMock.CreatePipelineRunOn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePipelineRunOn.CreatePipelineRunOnMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePipelineRunOn.t.Fatal("No results are set for the RepositoryMock.CreatePipelineRunOn")
		}
		return (*mm_results).err
	}
	if mmCreatePipelineRunOn.funcCreatePipelineRunOn != nil {
		return mmCreatePipelineRunOn.funcCreatePipelineRunOn(ctx, pp1)
	}
	mmCreatePipelineRunOn.t.Fatalf("Unexpected call to RepositoryMock.CreatePipelineRunOn. %v %v", ctx, pp1)
	return
}

// CreatePipelineRunOnAfterCounter returns a count of finished RepositoryMock.CreatePipelineRunOn invocations
func (mmCreatePipelineRunOn *RepositoryMock) CreatePipelineRunOnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineRunOn.afterCreatePipelineRunOnCounter)
}

// CreatePipelineRunOnBeforeCounter returns a count of RepositoryMock.CreatePipelineRunOn invocations
func (mmCreatePipelineRunOn *RepositoryMock) CreatePipelineRunOnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineRunOn.beforeCreatePipelineRunOnCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreatePipelineRunOn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePipelineRunOn *mRepositoryMockCreatePipelineRunOn) Calls() []*RepositoryMockCreatePipelineRunOnParams {
	mmCreatePipelineRunOn.mutex.RLock()

	argCopy := make([]*RepositoryMockCreatePipelineRunOnParams, len(mmCreatePipelineRunOn.callArgs))
	copy(argCopy, mmCreatePipelineRunOn.callArgs)

	mmCreatePipelineRunOn.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePipelineRunOnDone returns true if the count of the CreatePipelineRunOn invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreatePipelineRunOnDone() bool {
	if m.CreatePipelineRunOnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePipelineRunOnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePipelineRunOnMock.invocationsDone()
}

// MinimockCreatePipelineRunOnInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreatePipelineRunOnInspect() {
	for _, e := range m.CreatePipelineRunOnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRunOn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePipelineRunOnCounter := mm_atomic.LoadUint64(&m.afterCreatePipelineRunOnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePipelineRunOnMock.defaultExpectation != nil && afterCreatePipelineRunOnCounter < 1 {
		if m.CreatePipelineRunOnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRunOn at\n%s", m.CreatePipelineRunOnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRunOn at\n%s with params: %#v", m.CreatePipelineRunOnMock.defaultExpectation.expectationOrigins.origin, *m.CreatePipelineRunOnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePipelineRunOn != nil && afterCreatePipelineRunOnCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreatePipelineRunOn at\n%s", m.funcCreatePipelineRunOnOrigin)
	}

	if !m.CreatePipelineRunOnMock.invocationsDone() && afterCreatePipelineRunOnCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreatePipelineRunOn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePipelineRunOnMock.expectedInvocations), m.CreatePipelineRunOnMock.expectedInvocationsOrigin, afterCreatePipelineRunOnCounter)
	}
}

type mRepositoryMockCreatePipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreatePipelineTagsExpectation
	expectations       []*RepositoryMockCreatePipelineTagsExpectation

	callArgs []*RepositoryMockCreatePipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreatePipelineTagsExpectation specifies expectation struct of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreatePipelineTagsParams
	paramPtrs          *RepositoryMockCreatePipelineTagsParamPtrs
	expectationOrigins RepositoryMockCreatePipelineTagsExpectationOrigins
	results            *RepositoryMockCreatePipelineTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreatePipelineTagsParams contains parameters of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	tagNames    []string
}

// RepositoryMockCreatePipelineTagsParamPtrs contains pointers to parameters of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	tagNames    *[]string
}

// RepositoryMockCreatePipelineTagsResults contains results of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsResults struct {
	err error
}

// RepositoryMockCreatePipelineTagsOrigins contains origins of expectations of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originTagNames    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Optional() *mRepositoryMockCreatePipelineTags {
	mmCreatePipelineTags.optional = true
	return mmCreatePipelineTags
}

// Expect sets up expected params for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by ExpectParams functions")
	}

	mmCreatePipelineTags.defaultExpectation.params = &RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePipelineTags.expectations {
		if minimock.Equal(e.params, mmCreatePipelineTags.defaultExpectation.params) {
			mmCreatePipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePipelineTags.defaultExpectation.params)
		}
	}

	return mmCreatePipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmCreatePipelineTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.tagNames = &tagNames
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.originTagNames = minimock.CallerInfo(1)

	return mmCreatePipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.inspectFuncCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreatePipelineTags")
	}

	mmCreatePipelineTags.mock.inspectFuncCreatePipelineTags = f

	return mmCreatePipelineTags
}

// Return sets up results that will be returned by Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Return(err error) *RepositoryMock {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{mock: mmCreatePipelineTags.mock}
	}
	mmCreatePipelineTags.defaultExpectation.results = &RepositoryMockCreatePipelineTagsResults{err}
	mmCreatePipelineTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineTags.mock
}

// Set uses given function f to mock the Repository.CreatePipelineTags method
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmCreatePipelineTags.defaultExpectation != nil {
		mmCreatePipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.CreatePipelineTags method")
	}

	if len(mmCreatePipelineTags.expectations) > 0 {
		mmCreatePipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.CreatePipelineTags method")
	}

	mmCreatePipelineTags.mock.funcCreatePipelineTags = f
	mmCreatePipelineTags.mock.funcCreatePipelineTagsOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineTags.mock
}

// When sets expectation for the Repository.CreatePipelineTags which will trigger the result defined by the following
// Then helper
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) When(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *RepositoryMockCreatePipelineTagsExpectation {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockCreatePipelineTagsExpectation{
		mock:               mmCreatePipelineTags.mock,
		params:             &RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames},
		expectationOrigins: RepositoryMockCreatePipelineTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePipelineTags.expectations = append(mmCreatePipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreatePipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreatePipelineTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreatePipelineTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.CreatePipelineTags should be invoked
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Times(n uint64) *mRepositoryMockCreatePipelineTags {
	if n == 0 {
		mmCreatePipelineTags.mock.t.Fatalf("Times of RepositoryMock.CreatePipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePipelineTags.expectedInvocations, n)
	mmCreatePipelineTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineTags
}

func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) invocationsDone() bool {
	if len(mmCreatePipelineTags.expectations) == 0 && mmCreatePipelineTags.defaultExpectation == nil && mmCreatePipelineTags.mock.funcCreatePipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePipelineTags.mock.afterCreatePipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePipelineTags implements mm_repository.Repository
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTags(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmCreatePipelineTags.beforeCreatePipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePipelineTags.afterCreatePipelineTagsCounter, 1)

	mmCreatePipelineTags.t.Helper()

	if mmCreatePipelineTags.inspectFuncCreatePipelineTags != nil {
		mmCreatePipelineTags.inspectFuncCreatePipelineTags(ctx, pipelineUID, tagNames)
	}

	mm_params := RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}

	// Record call args
	mmCreatePipelineTags.CreatePipelineTagsMock.mutex.Lock()
	mmCreatePipelineTags.CreatePipelineTagsMock.callArgs = append(mmCreatePipelineTags.CreatePipelineTagsMock.callArgs, &mm_params)
	mmCreatePipelineTags.CreatePipelineTagsMock.mutex.Unlock()

	for _, e := range mmCreatePipelineTags.CreatePipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter tagNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.originTagNames, *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePipelineTags.t.Fatal("No results are set for the RepositoryMock.CreatePipelineTags")
		}
		return (*mm_results).err
	}
	if mmCreatePipelineTags.funcCreatePipelineTags != nil {
		return mmCreatePipelineTags.funcCreatePipelineTags(ctx, pipelineUID, tagNames)
	}
	mmCreatePipelineTags.t.Fatalf("Unexpected call to RepositoryMock.CreatePipelineTags. %v %v %v", ctx, pipelineUID, tagNames)
	return
}

// CreatePipelineTagsAfterCounter returns a count of finished RepositoryMock.CreatePipelineTags invocations
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineTags.afterCreatePipelineTagsCounter)
}

// CreatePipelineTagsBeforeCounter returns a count of RepositoryMock.CreatePipelineTags invocations
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineTags.beforeCreatePipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreatePipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Calls() []*RepositoryMockCreatePipelineTagsParams {
	mmCreatePipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockCreatePipelineTagsParams, len(mmCreatePipelineTags.callArgs))
	copy(argCopy, mmCreatePipelineTags.callArgs)

	mmCreatePipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePipelineTagsDone returns true if the count of the CreatePipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreatePipelineTagsDone() bool {
	if m.CreatePipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePipelineTagsMock.invocationsDone()
}

// MinimockCreatePipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreatePipelineTagsInspect() {
	for _, e := range m.CreatePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePipelineTagsCounter := mm_atomic.LoadUint64(&m.afterCreatePipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePipelineTagsMock.defaultExpectation != nil && afterCreatePipelineTagsCounter < 1 {
		if m.CreatePipelineTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s", m.CreatePipelineTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s with params: %#v", m.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *m.CreatePipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePipelineTags != nil && afterCreatePipelineTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s", m.funcCreatePipelineTagsOrigin)
	}

	if !m.CreatePipelineTagsMock.invocationsDone() && afterCreatePipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreatePipelineTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePipelineTagsMock.expectedInvocations), m.CreatePipelineTagsMock.expectedInvocationsOrigin, afterCreatePipelineTagsCounter)
	}
}

type mRepositoryMockDeleteComponentDefinition struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteComponentDefinitionExpectation
	expectations       []*RepositoryMockDeleteComponentDefinitionExpectation

	callArgs []*RepositoryMockDeleteComponentDefinitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteComponentDefinitionExpectation specifies expectation struct of the Repository.DeleteComponentDefinition
type RepositoryMockDeleteComponentDefinitionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteComponentDefinitionParams
	paramPtrs          *RepositoryMockDeleteComponentDefinitionParamPtrs
	expectationOrigins RepositoryMockDeleteComponentDefinitionExpectationOrigins
	results            *RepositoryMockDeleteComponentDefinitionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteComponentDefinitionParams contains parameters of the Repository.DeleteComponentDefinition
type RepositoryMockDeleteComponentDefinitionParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// RepositoryMockDeleteComponentDefinitionParamPtrs contains pointers to parameters of the Repository.DeleteComponentDefinition
type RepositoryMockDeleteComponentDefinitionParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
}

// RepositoryMockDeleteComponentDefinitionResults contains results of the Repository.DeleteComponentDefinition
type RepositoryMockDeleteComponentDefinitionResults struct {
	err error
}

// RepositoryMockDeleteComponentDefinitionOrigins contains origins of expectations of the Repository.DeleteComponentDefinition
type RepositoryMockDeleteComponentDefinitionExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) Optional() *mRepositoryMockDeleteComponentDefinition {
	mmDeleteComponentDefinition.optional = true
	return mmDeleteComponentDefinition
}

// Expect sets up expected params for Repository.DeleteComponentDefinition
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) Expect(ctx context.Context, u1 uuid.UUID) *mRepositoryMockDeleteComponentDefinition {
	if mmDeleteComponentDefinition.mock.funcDeleteComponentDefinition != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by Set")
	}

	if mmDeleteComponentDefinition.defaultExpectation == nil {
		mmDeleteComponentDefinition.defaultExpectation = &RepositoryMockDeleteComponentDefinitionExpectation{}
	}

	if mmDeleteComponentDefinition.defaultExpectation.paramPtrs != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by ExpectParams functions")
	}

	mmDeleteComponentDefinition.defaultExpectation.params = &RepositoryMockDeleteComponentDefinitionParams{ctx, u1}
	mmDeleteComponentDefinition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteComponentDefinition.expectations {
		if minimock.Equal(e.params, mmDeleteComponentDefinition.defaultExpectation.params) {
			mmDeleteComponentDefinition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteComponentDefinition.defaultExpectation.params)
		}
	}

	return mmDeleteComponentDefinition
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteComponentDefinition
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteComponentDefinition {
	if mmDeleteComponentDefinition.mock.funcDeleteComponentDefinition != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by Set")
	}

	if mmDeleteComponentDefinition.defaultExpectation == nil {
		mmDeleteComponentDefinition.defaultExpectation = &RepositoryMockDeleteComponentDefinitionExpectation{}
	}

	if mmDeleteComponentDefinition.defaultExpectation.params != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by Expect")
	}

	if mmDeleteComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmDeleteComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockDeleteComponentDefinitionParamPtrs{}
	}
	mmDeleteComponentDefinition.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteComponentDefinition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteComponentDefinition
}

// ExpectU1Param2 sets up expected param u1 for Repository.DeleteComponentDefinition
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockDeleteComponentDefinition {
	if mmDeleteComponentDefinition.mock.funcDeleteComponentDefinition != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by Set")
	}

	if mmDeleteComponentDefinition.defaultExpectation == nil {
		mmDeleteComponentDefinition.defaultExpectation = &RepositoryMockDeleteComponentDefinitionExpectation{}
	}

	if mmDeleteComponentDefinition.defaultExpectation.params != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by Expect")
	}

	if mmDeleteComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmDeleteComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockDeleteComponentDefinitionParamPtrs{}
	}
	mmDeleteComponentDefinition.defaultExpectation.paramPtrs.u1 = &u1
	mmDeleteComponentDefinition.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmDeleteComponentDefinition
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteComponentDefinition
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mRepositoryMockDeleteComponentDefinition {
	if mmDeleteComponentDefinition.mock.inspectFuncDeleteComponentDefinition != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteComponentDefinition")
	}

	mmDeleteComponentDefinition.mock.inspectFuncDeleteComponentDefinition = f

	return mmDeleteComponentDefinition
}

// Return sets up results that will be returned by Repository.DeleteComponentDefinition
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) Return(err error) *RepositoryMock {
	if mmDeleteComponentDefinition.mock.funcDeleteComponentDefinition != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by Set")
	}

	if mmDeleteComponentDefinition.defaultExpectation == nil {
		mmDeleteComponentDefinition.defaultExpectation = &RepositoryMockDeleteComponentDefinitionExpectation{mock: mmDeleteComponentDefinition.mock}
	}
	mmDeleteComponentDefinition.defaultExpectation.results = &RepositoryMockDeleteComponentDefinitionResults{err}
	mmDeleteComponentDefinition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteComponentDefinition.mock
}

// Set uses given function f to mock the Repository.DeleteComponentDefinition method
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) Set(f func(ctx context.Context, u1 uuid.UUID) (err error)) *RepositoryMock {
	if mmDeleteComponentDefinition.defaultExpectation != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteComponentDefinition method")
	}

	if len(mmDeleteComponentDefinition.expectations) > 0 {
		mmDeleteComponentDefinition.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteComponentDefinition method")
	}

	mmDeleteComponentDefinition.mock.funcDeleteComponentDefinition = f
	mmDeleteComponentDefinition.mock.funcDeleteComponentDefinitionOrigin = minimock.CallerInfo(1)
	return mmDeleteComponentDefinition.mock
}

// When sets expectation for the Repository.DeleteComponentDefinition which will trigger the result defined by the following
// Then helper
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) When(ctx context.Context, u1 uuid.UUID) *RepositoryMockDeleteComponentDefinitionExpectation {
	if mmDeleteComponentDefinition.mock.funcDeleteComponentDefinition != nil {
		mmDeleteComponentDefinition.mock.t.Fatalf("RepositoryMock.DeleteComponentDefinition mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteComponentDefinitionExpectation{
		mock:               mmDeleteComponentDefinition.mock,
		params:             &RepositoryMockDeleteComponentDefinitionParams{ctx, u1},
		expectationOrigins: RepositoryMockDeleteComponentDefinitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteComponentDefinition.expectations = append(mmDeleteComponentDefinition.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteComponentDefinition return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteComponentDefinitionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteComponentDefinitionResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteComponentDefinition should be invoked
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) Times(n uint64) *mRepositoryMockDeleteComponentDefinition {
	if n == 0 {
		mmDeleteComponentDefinition.mock.t.Fatalf("Times of RepositoryMock.DeleteComponentDefinition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteComponentDefinition.expectedInvocations, n)
	mmDeleteComponentDefinition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteComponentDefinition
}

func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) invocationsDone() bool {
	if len(mmDeleteComponentDefinition.expectations) == 0 && mmDeleteComponentDefinition.defaultExpectation == nil && mmDeleteComponentDefinition.mock.funcDeleteComponentDefinition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteComponentDefinition.mock.afterDeleteComponentDefinitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteComponentDefinition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteComponentDefinition implements mm_repository.Repository
func (mmDeleteComponentDefinition *RepositoryMock) DeleteComponentDefinition(ctx context.Context, u1 uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteComponentDefinition.beforeDeleteComponentDefinitionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteComponentDefinition.afterDeleteComponentDefinitionCounter, 1)

	mmDeleteComponentDefinition.t.Helper()

	if mmDeleteComponentDefinition.inspectFuncDeleteComponentDefinition != nil {
		mmDeleteComponentDefinition.inspectFuncDeleteComponentDefinition(ctx, u1)
	}

	mm_params := RepositoryMockDeleteComponentDefinitionParams{ctx, u1}

	// Record call args
	mmDeleteComponentDefinition.DeleteComponentDefinitionMock.mutex.Lock()
	mmDeleteComponentDefinition.DeleteComponentDefinitionMock.callArgs = append(mmDeleteComponentDefinition.DeleteComponentDefinitionMock.callArgs, &mm_params)
	mmDeleteComponentDefinition.DeleteComponentDefinitionMock.mutex.Unlock()

	for _, e := range mmDeleteComponentDefinition.DeleteComponentDefinitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteComponentDefinitionParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteComponentDefinition.t.Errorf("RepositoryMock.DeleteComponentDefinition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmDeleteComponentDefinition.t.Errorf("RepositoryMock.DeleteComponentDefinition got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteComponentDefinition.t.Errorf("RepositoryMock.DeleteComponentDefinition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteComponentDefinition.DeleteComponentDefinitionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteComponentDefinition.t.Fatal("No results are set for the RepositoryMock.DeleteComponentDefinition")
		}
		return (*mm_results).err
	}
	if mmDeleteComponentDefinition.funcDeleteComponentDefinition != nil {
		return mmDeleteComponentDefinition.funcDeleteComponentDefinition(ctx, u1)
	}
	mmDeleteComponentDefinition.t.Fatalf("Unexpected call to RepositoryMock.DeleteComponentDefinition. %v %v", ctx, u1)
	return
}

// DeleteComponentDefinitionAfterCounter returns a count of finished RepositoryMock.DeleteComponentDefinition invocations
func (mmDeleteComponentDefinition *RepositoryMock) DeleteComponentDefinitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComponentDefinition.afterDeleteComponentDefinitionCounter)
}

// DeleteComponentDefinitionBeforeCounter returns a count of RepositoryMock.DeleteComponentDefinition invocations
func (mmDeleteComponentDefinition *RepositoryMock) DeleteComponentDefinitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteComponentDefinition.beforeDeleteComponentDefinitionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteComponentDefinition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteComponentDefinition *mRepositoryMockDeleteComponentDefinition) Calls() []*RepositoryMockDeleteComponentDefinitionParams {
	mmDeleteComponentDefinition.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteComponentDefinitionParams, len(mmDeleteComponentDefinition.callArgs))
	copy(argCopy, mmDeleteComponentDefinition.callArgs)

	mmDeleteComponentDefinition.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteComponentDefinitionDone returns true if the count of the DeleteComponentDefinition invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteComponentDefinitionDone() bool {
	if m.DeleteComponentDefinitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteComponentDefinitionMock.invocationsDone()
}

// MinimockDeleteComponentDefinitionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteComponentDefinitionInspect() {
	for _, e := range m.DeleteComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteComponentDefinition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteComponentDefinitionCounter := mm_atomic.LoadUint64(&m.afterDeleteComponentDefinitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteComponentDefinitionMock.defaultExpectation != nil && afterDeleteComponentDefinitionCounter < 1 {
		if m.DeleteComponentDefinitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteComponentDefinition at\n%s", m.DeleteComponentDefinitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteComponentDefinition at\n%s with params: %#v", m.DeleteComponentDefinitionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteComponentDefinitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteComponentDefinition != nil && afterDeleteComponentDefinitionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteComponentDefinition at\n%s", m.funcDeleteComponentDefinitionOrigin)
	}

	if !m.DeleteComponentDefinitionMock.invocationsDone() && afterDeleteComponentDefinitionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteComponentDefinition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteComponentDefinitionMock.expectedInvocations), m.DeleteComponentDefinitionMock.expectedInvocationsOrigin, afterDeleteComponentDefinitionCounter)
	}
}

type mRepositoryMockDeleteNamespaceConnectionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespaceConnectionByIDExpectation
	expectations       []*RepositoryMockDeleteNamespaceConnectionByIDExpectation

	callArgs []*RepositoryMockDeleteNamespaceConnectionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteNamespaceConnectionByIDExpectation specifies expectation struct of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteNamespaceConnectionByIDParams
	paramPtrs          *RepositoryMockDeleteNamespaceConnectionByIDParamPtrs
	expectationOrigins RepositoryMockDeleteNamespaceConnectionByIDExpectationOrigins
	results            *RepositoryMockDeleteNamespaceConnectionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteNamespaceConnectionByIDParams contains parameters of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDParams struct {
	ctx   context.Context
	nsUID uuid.UUID
	id    string
}

// RepositoryMockDeleteNamespaceConnectionByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDParamPtrs struct {
	ctx   *context.Context
	nsUID *uuid.UUID
	id    *string
}

// RepositoryMockDeleteNamespaceConnectionByIDResults contains results of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDResults struct {
	err error
}

// RepositoryMockDeleteNamespaceConnectionByIDOrigins contains origins of expectations of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originNsUID string
	originId    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Optional() *mRepositoryMockDeleteNamespaceConnectionByID {
	mmDeleteNamespaceConnectionByID.optional = true
	return mmDeleteNamespaceConnectionByID
}

// Expect sets up expected params for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Expect(ctx context.Context, nsUID uuid.UUID, id string) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceConnectionByID.defaultExpectation.params = &RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id}
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespaceConnectionByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceConnectionByID.defaultExpectation.params) {
			mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceConnectionByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceConnectionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.params != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Expect")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceConnectionByIDParamPtrs{}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespaceConnectionByID
}

// ExpectNsUIDParam2 sets up expected param nsUID for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) ExpectNsUIDParam2(nsUID uuid.UUID) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.params != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Expect")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceConnectionByIDParamPtrs{}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs.nsUID = &nsUID
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.originNsUID = minimock.CallerInfo(1)

	return mmDeleteNamespaceConnectionByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.params != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Expect")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceConnectionByIDParamPtrs{}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteNamespaceConnectionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Inspect(f func(ctx context.Context, nsUID uuid.UUID, id string)) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.inspectFuncDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespaceConnectionByID")
	}

	mmDeleteNamespaceConnectionByID.mock.inspectFuncDeleteNamespaceConnectionByID = f

	return mmDeleteNamespaceConnectionByID
}

// Return sets up results that will be returned by Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{mock: mmDeleteNamespaceConnectionByID.mock}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.results = &RepositoryMockDeleteNamespaceConnectionByIDResults{err}
	mmDeleteNamespaceConnectionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceConnectionByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespaceConnectionByID method
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Set(f func(ctx context.Context, nsUID uuid.UUID, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespaceConnectionByID.defaultExpectation != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespaceConnectionByID method")
	}

	if len(mmDeleteNamespaceConnectionByID.expectations) > 0 {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespaceConnectionByID method")
	}

	mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID = f
	mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceConnectionByID.mock
}

// When sets expectation for the Repository.DeleteNamespaceConnectionByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) When(ctx context.Context, nsUID uuid.UUID, id string) *RepositoryMockDeleteNamespaceConnectionByIDExpectation {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespaceConnectionByIDExpectation{
		mock:               mmDeleteNamespaceConnectionByID.mock,
		params:             &RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id},
		expectationOrigins: RepositoryMockDeleteNamespaceConnectionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespaceConnectionByID.expectations = append(mmDeleteNamespaceConnectionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespaceConnectionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespaceConnectionByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespaceConnectionByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespaceConnectionByID should be invoked
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Times(n uint64) *mRepositoryMockDeleteNamespaceConnectionByID {
	if n == 0 {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespaceConnectionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceConnectionByID.expectedInvocations, n)
	mmDeleteNamespaceConnectionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceConnectionByID
}

func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) invocationsDone() bool {
	if len(mmDeleteNamespaceConnectionByID.expectations) == 0 && mmDeleteNamespaceConnectionByID.defaultExpectation == nil && mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.mock.afterDeleteNamespaceConnectionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceConnectionByID implements mm_repository.Repository
func (mmDeleteNamespaceConnectionByID *RepositoryMock) DeleteNamespaceConnectionByID(ctx context.Context, nsUID uuid.UUID, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceConnectionByID.beforeDeleteNamespaceConnectionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceConnectionByID.afterDeleteNamespaceConnectionByIDCounter, 1)

	mmDeleteNamespaceConnectionByID.t.Helper()

	if mmDeleteNamespaceConnectionByID.inspectFuncDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.inspectFuncDeleteNamespaceConnectionByID(ctx, nsUID, id)
	}

	mm_params := RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id}

	// Record call args
	mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.mutex.Lock()
	mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.callArgs = append(mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.callArgs, &mm_params)
	mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.nsUID != nil && !minimock.Equal(*mm_want_ptrs.nsUID, mm_got.nsUID) {
				mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameter nsUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originNsUID, *mm_want_ptrs.nsUID, mm_got.nsUID, minimock.Diff(*mm_want_ptrs.nsUID, mm_got.nsUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceConnectionByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespaceConnectionByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespaceConnectionByID.funcDeleteNamespaceConnectionByID != nil {
		return mmDeleteNamespaceConnectionByID.funcDeleteNamespaceConnectionByID(ctx, nsUID, id)
	}
	mmDeleteNamespaceConnectionByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespaceConnectionByID. %v %v %v", ctx, nsUID, id)
	return
}

// DeleteNamespaceConnectionByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespaceConnectionByID invocations
func (mmDeleteNamespaceConnectionByID *RepositoryMock) DeleteNamespaceConnectionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.afterDeleteNamespaceConnectionByIDCounter)
}

// DeleteNamespaceConnectionByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespaceConnectionByID invocations
func (mmDeleteNamespaceConnectionByID *RepositoryMock) DeleteNamespaceConnectionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.beforeDeleteNamespaceConnectionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespaceConnectionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Calls() []*RepositoryMockDeleteNamespaceConnectionByIDParams {
	mmDeleteNamespaceConnectionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespaceConnectionByIDParams, len(mmDeleteNamespaceConnectionByID.callArgs))
	copy(argCopy, mmDeleteNamespaceConnectionByID.callArgs)

	mmDeleteNamespaceConnectionByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceConnectionByIDDone returns true if the count of the DeleteNamespaceConnectionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespaceConnectionByIDDone() bool {
	if m.DeleteNamespaceConnectionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceConnectionByIDMock.invocationsDone()
}

// MinimockDeleteNamespaceConnectionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespaceConnectionByIDInspect() {
	for _, e := range m.DeleteNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespaceConnectionByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceConnectionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceConnectionByIDMock.defaultExpectation != nil && afterDeleteNamespaceConnectionByIDCounter < 1 {
		if m.DeleteNamespaceConnectionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s", m.DeleteNamespaceConnectionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s with params: %#v", m.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespaceConnectionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceConnectionByID != nil && afterDeleteNamespaceConnectionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s", m.funcDeleteNamespaceConnectionByIDOrigin)
	}

	if !m.DeleteNamespaceConnectionByIDMock.invocationsDone() && afterDeleteNamespaceConnectionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespaceConnectionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceConnectionByIDMock.expectedInvocations), m.DeleteNamespaceConnectionByIDMock.expectedInvocationsOrigin, afterDeleteNamespaceConnectionByIDCounter)
	}
}

type mRepositoryMockDeleteNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockDeleteNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockDeleteNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteNamespaceSecretByIDExpectation specifies expectation struct of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteNamespaceSecretByIDParams
	paramPtrs          *RepositoryMockDeleteNamespaceSecretByIDParamPtrs
	expectationOrigins RepositoryMockDeleteNamespaceSecretByIDExpectationOrigins
	results            *RepositoryMockDeleteNamespaceSecretByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteNamespaceSecretByIDParams contains parameters of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeleteNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeleteNamespaceSecretByIDResults contains results of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDResults struct {
	err error
}

// RepositoryMockDeleteNamespaceSecretByIDOrigins contains origins of expectations of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Optional() *mRepositoryMockDeleteNamespaceSecretByID {
	mmDeleteNamespaceSecretByID.optional = true
	return mmDeleteNamespaceSecretByID
}

// Expect sets up expected params for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceSecretByID.defaultExpectation.params = &RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceSecretByID.defaultExpectation.params) {
			mmDeleteNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmDeleteNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.inspectFuncDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespaceSecretByID")
	}

	mmDeleteNamespaceSecretByID.mock.inspectFuncDeleteNamespaceSecretByID = f

	return mmDeleteNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{mock: mmDeleteNamespaceSecretByID.mock}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.results = &RepositoryMockDeleteNamespaceSecretByIDResults{err}
	mmDeleteNamespaceSecretByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespaceSecretByID method
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespaceSecretByID.defaultExpectation != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespaceSecretByID method")
	}

	if len(mmDeleteNamespaceSecretByID.expectations) > 0 {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespaceSecretByID method")
	}

	mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID = f
	mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceSecretByID.mock
}

// When sets expectation for the Repository.DeleteNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeleteNamespaceSecretByIDExpectation {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespaceSecretByIDExpectation{
		mock:               mmDeleteNamespaceSecretByID.mock,
		params:             &RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id},
		expectationOrigins: RepositoryMockDeleteNamespaceSecretByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespaceSecretByID.expectations = append(mmDeleteNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespaceSecretByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespaceSecretByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespaceSecretByID should be invoked
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Times(n uint64) *mRepositoryMockDeleteNamespaceSecretByID {
	if n == 0 {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceSecretByID.expectedInvocations, n)
	mmDeleteNamespaceSecretByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceSecretByID
}

func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) invocationsDone() bool {
	if len(mmDeleteNamespaceSecretByID.expectations) == 0 && mmDeleteNamespaceSecretByID.defaultExpectation == nil && mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.mock.afterDeleteNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceSecretByID implements mm_repository.Repository
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.beforeDeleteNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.afterDeleteNamespaceSecretByIDCounter, 1)

	mmDeleteNamespaceSecretByID.t.Helper()

	if mmDeleteNamespaceSecretByID.inspectFuncDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.inspectFuncDeleteNamespaceSecretByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.mutex.Lock()
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.callArgs = append(mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.callArgs, &mm_params)
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespaceSecretByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespaceSecretByID.funcDeleteNamespaceSecretByID != nil {
		return mmDeleteNamespaceSecretByID.funcDeleteNamespaceSecretByID(ctx, ownerPermalink, id)
	}
	mmDeleteNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespaceSecretByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeleteNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespaceSecretByID invocations
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.afterDeleteNamespaceSecretByIDCounter)
}

// DeleteNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespaceSecretByID invocations
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.beforeDeleteNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Calls() []*RepositoryMockDeleteNamespaceSecretByIDParams {
	mmDeleteNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespaceSecretByIDParams, len(mmDeleteNamespaceSecretByID.callArgs))
	copy(argCopy, mmDeleteNamespaceSecretByID.callArgs)

	mmDeleteNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceSecretByIDDone returns true if the count of the DeleteNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespaceSecretByIDDone() bool {
	if m.DeleteNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceSecretByIDMock.invocationsDone()
}

// MinimockDeleteNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespaceSecretByIDInspect() {
	for _, e := range m.DeleteNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceSecretByIDMock.defaultExpectation != nil && afterDeleteNamespaceSecretByIDCounter < 1 {
		if m.DeleteNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s", m.DeleteNamespaceSecretByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s with params: %#v", m.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceSecretByID != nil && afterDeleteNamespaceSecretByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s", m.funcDeleteNamespaceSecretByIDOrigin)
	}

	if !m.DeleteNamespaceSecretByIDMock.invocationsDone() && afterDeleteNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespaceSecretByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceSecretByIDMock.expectedInvocations), m.DeleteNamespaceSecretByIDMock.expectedInvocationsOrigin, afterDeleteNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockDeletePipelineByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeletePipelineByIDExpectation
	expectations       []*RepositoryMockDeletePipelineByIDExpectation

	callArgs []*RepositoryMockDeletePipelineByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeletePipelineByIDExpectation specifies expectation struct of the Repository.DeletePipelineByID
type RepositoryMockDeletePipelineByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeletePipelineByIDParams
	paramPtrs          *RepositoryMockDeletePipelineByIDParamPtrs
	expectationOrigins RepositoryMockDeletePipelineByIDExpectationOrigins
	results            *RepositoryMockDeletePipelineByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeletePipelineByIDParams contains parameters of the Repository.DeletePipelineByID
type RepositoryMockDeletePipelineByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeletePipelineByIDParamPtrs contains pointers to parameters of the Repository.DeletePipelineByID
type RepositoryMockDeletePipelineByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeletePipelineByIDResults contains results of the Repository.DeletePipelineByID
type RepositoryMockDeletePipelineByIDResults struct {
	err error
}

// RepositoryMockDeletePipelineByIDOrigins contains origins of expectations of the Repository.DeletePipelineByID
type RepositoryMockDeletePipelineByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) Optional() *mRepositoryMockDeletePipelineByID {
	mmDeletePipelineByID.optional = true
	return mmDeletePipelineByID
}

// Expect sets up expected params for Repository.DeletePipelineByID
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeletePipelineByID {
	if mmDeletePipelineByID.mock.funcDeletePipelineByID != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Set")
	}

	if mmDeletePipelineByID.defaultExpectation == nil {
		mmDeletePipelineByID.defaultExpectation = &RepositoryMockDeletePipelineByIDExpectation{}
	}

	if mmDeletePipelineByID.defaultExpectation.paramPtrs != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by ExpectParams functions")
	}

	mmDeletePipelineByID.defaultExpectation.params = &RepositoryMockDeletePipelineByIDParams{ctx, ownerPermalink, id}
	mmDeletePipelineByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePipelineByID.expectations {
		if minimock.Equal(e.params, mmDeletePipelineByID.defaultExpectation.params) {
			mmDeletePipelineByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelineByID.defaultExpectation.params)
		}
	}

	return mmDeletePipelineByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeletePipelineByID
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeletePipelineByID {
	if mmDeletePipelineByID.mock.funcDeletePipelineByID != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Set")
	}

	if mmDeletePipelineByID.defaultExpectation == nil {
		mmDeletePipelineByID.defaultExpectation = &RepositoryMockDeletePipelineByIDExpectation{}
	}

	if mmDeletePipelineByID.defaultExpectation.params != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Expect")
	}

	if mmDeletePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineByIDParamPtrs{}
	}
	mmDeletePipelineByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePipelineByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePipelineByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeletePipelineByID
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeletePipelineByID {
	if mmDeletePipelineByID.mock.funcDeletePipelineByID != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Set")
	}

	if mmDeletePipelineByID.defaultExpectation == nil {
		mmDeletePipelineByID.defaultExpectation = &RepositoryMockDeletePipelineByIDExpectation{}
	}

	if mmDeletePipelineByID.defaultExpectation.params != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Expect")
	}

	if mmDeletePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineByIDParamPtrs{}
	}
	mmDeletePipelineByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmDeletePipelineByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmDeletePipelineByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeletePipelineByID
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) ExpectIdParam3(id string) *mRepositoryMockDeletePipelineByID {
	if mmDeletePipelineByID.mock.funcDeletePipelineByID != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Set")
	}

	if mmDeletePipelineByID.defaultExpectation == nil {
		mmDeletePipelineByID.defaultExpectation = &RepositoryMockDeletePipelineByIDExpectation{}
	}

	if mmDeletePipelineByID.defaultExpectation.params != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Expect")
	}

	if mmDeletePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineByIDParamPtrs{}
	}
	mmDeletePipelineByID.defaultExpectation.paramPtrs.id = &id
	mmDeletePipelineByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeletePipelineByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeletePipelineByID
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeletePipelineByID {
	if mmDeletePipelineByID.mock.inspectFuncDeletePipelineByID != nil {
		mmDeletePipelineByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeletePipelineByID")
	}

	mmDeletePipelineByID.mock.inspectFuncDeletePipelineByID = f

	return mmDeletePipelineByID
}

// Return sets up results that will be returned by Repository.DeletePipelineByID
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) Return(err error) *RepositoryMock {
	if mmDeletePipelineByID.mock.funcDeletePipelineByID != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Set")
	}

	if mmDeletePipelineByID.defaultExpectation == nil {
		mmDeletePipelineByID.defaultExpectation = &RepositoryMockDeletePipelineByIDExpectation{mock: mmDeletePipelineByID.mock}
	}
	mmDeletePipelineByID.defaultExpectation.results = &RepositoryMockDeletePipelineByIDResults{err}
	mmDeletePipelineByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineByID.mock
}

// Set uses given function f to mock the Repository.DeletePipelineByID method
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeletePipelineByID.defaultExpectation != nil {
		mmDeletePipelineByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeletePipelineByID method")
	}

	if len(mmDeletePipelineByID.expectations) > 0 {
		mmDeletePipelineByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeletePipelineByID method")
	}

	mmDeletePipelineByID.mock.funcDeletePipelineByID = f
	mmDeletePipelineByID.mock.funcDeletePipelineByIDOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineByID.mock
}

// When sets expectation for the Repository.DeletePipelineByID which will trigger the result defined by the following
// Then helper
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeletePipelineByIDExpectation {
	if mmDeletePipelineByID.mock.funcDeletePipelineByID != nil {
		mmDeletePipelineByID.mock.t.Fatalf("RepositoryMock.DeletePipelineByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeletePipelineByIDExpectation{
		mock:               mmDeletePipelineByID.mock,
		params:             &RepositoryMockDeletePipelineByIDParams{ctx, ownerPermalink, id},
		expectationOrigins: RepositoryMockDeletePipelineByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePipelineByID.expectations = append(mmDeletePipelineByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeletePipelineByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeletePipelineByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeletePipelineByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeletePipelineByID should be invoked
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) Times(n uint64) *mRepositoryMockDeletePipelineByID {
	if n == 0 {
		mmDeletePipelineByID.mock.t.Fatalf("Times of RepositoryMock.DeletePipelineByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelineByID.expectedInvocations, n)
	mmDeletePipelineByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineByID
}

func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) invocationsDone() bool {
	if len(mmDeletePipelineByID.expectations) == 0 && mmDeletePipelineByID.defaultExpectation == nil && mmDeletePipelineByID.mock.funcDeletePipelineByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelineByID.mock.afterDeletePipelineByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelineByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelineByID implements mm_repository.Repository
func (mmDeletePipelineByID *RepositoryMock) DeletePipelineByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelineByID.beforeDeletePipelineByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelineByID.afterDeletePipelineByIDCounter, 1)

	mmDeletePipelineByID.t.Helper()

	if mmDeletePipelineByID.inspectFuncDeletePipelineByID != nil {
		mmDeletePipelineByID.inspectFuncDeletePipelineByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeletePipelineByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeletePipelineByID.DeletePipelineByIDMock.mutex.Lock()
	mmDeletePipelineByID.DeletePipelineByIDMock.callArgs = append(mmDeletePipelineByID.DeletePipelineByIDMock.callArgs, &mm_params)
	mmDeletePipelineByID.DeletePipelineByIDMock.mutex.Unlock()

	for _, e := range mmDeletePipelineByID.DeletePipelineByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeletePipelineByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelineByID.t.Errorf("RepositoryMock.DeletePipelineByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeletePipelineByID.t.Errorf("RepositoryMock.DeletePipelineByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeletePipelineByID.t.Errorf("RepositoryMock.DeletePipelineByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelineByID.t.Errorf("RepositoryMock.DeletePipelineByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelineByID.DeletePipelineByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelineByID.t.Fatal("No results are set for the RepositoryMock.DeletePipelineByID")
		}
		return (*mm_results).err
	}
	if mmDeletePipelineByID.funcDeletePipelineByID != nil {
		return mmDeletePipelineByID.funcDeletePipelineByID(ctx, ownerPermalink, id)
	}
	mmDeletePipelineByID.t.Fatalf("Unexpected call to RepositoryMock.DeletePipelineByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeletePipelineByIDAfterCounter returns a count of finished RepositoryMock.DeletePipelineByID invocations
func (mmDeletePipelineByID *RepositoryMock) DeletePipelineByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineByID.afterDeletePipelineByIDCounter)
}

// DeletePipelineByIDBeforeCounter returns a count of RepositoryMock.DeletePipelineByID invocations
func (mmDeletePipelineByID *RepositoryMock) DeletePipelineByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineByID.beforeDeletePipelineByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeletePipelineByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelineByID *mRepositoryMockDeletePipelineByID) Calls() []*RepositoryMockDeletePipelineByIDParams {
	mmDeletePipelineByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeletePipelineByIDParams, len(mmDeletePipelineByID.callArgs))
	copy(argCopy, mmDeletePipelineByID.callArgs)

	mmDeletePipelineByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelineByIDDone returns true if the count of the DeletePipelineByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeletePipelineByIDDone() bool {
	if m.DeletePipelineByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelineByIDMock.invocationsDone()
}

// MinimockDeletePipelineByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeletePipelineByIDInspect() {
	for _, e := range m.DeletePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePipelineByIDCounter := mm_atomic.LoadUint64(&m.afterDeletePipelineByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelineByIDMock.defaultExpectation != nil && afterDeletePipelineByIDCounter < 1 {
		if m.DeletePipelineByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineByID at\n%s", m.DeletePipelineByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineByID at\n%s with params: %#v", m.DeletePipelineByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeletePipelineByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelineByID != nil && afterDeletePipelineByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeletePipelineByID at\n%s", m.funcDeletePipelineByIDOrigin)
	}

	if !m.DeletePipelineByIDMock.invocationsDone() && afterDeletePipelineByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeletePipelineByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelineByIDMock.expectedInvocations), m.DeletePipelineByIDMock.expectedInvocationsOrigin, afterDeletePipelineByIDCounter)
	}
}

type mRepositoryMockDeletePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeletePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockDeletePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockDeletePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeletePipelineReleaseByIDExpectation specifies expectation struct of the Repository.DeletePipelineReleaseByID
type RepositoryMockDeletePipelineReleaseByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeletePipelineReleaseByIDParams
	paramPtrs          *RepositoryMockDeletePipelineReleaseByIDParamPtrs
	expectationOrigins RepositoryMockDeletePipelineReleaseByIDExpectationOrigins
	results            *RepositoryMockDeletePipelineReleaseByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeletePipelineReleaseByIDParams contains parameters of the Repository.DeletePipelineReleaseByID
type RepositoryMockDeletePipelineReleaseByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
}

// RepositoryMockDeletePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.DeletePipelineReleaseByID
type RepositoryMockDeletePipelineReleaseByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
}

// RepositoryMockDeletePipelineReleaseByIDResults contains results of the Repository.DeletePipelineReleaseByID
type RepositoryMockDeletePipelineReleaseByIDResults struct {
	err error
}

// RepositoryMockDeletePipelineReleaseByIDOrigins contains origins of expectations of the Repository.DeletePipelineReleaseByID
type RepositoryMockDeletePipelineReleaseByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) Optional() *mRepositoryMockDeletePipelineReleaseByID {
	mmDeletePipelineReleaseByID.optional = true
	return mmDeletePipelineReleaseByID
}

// Expect sets up expected params for Repository.DeletePipelineReleaseByID
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) *mRepositoryMockDeletePipelineReleaseByID {
	if mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Set")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation == nil {
		mmDeletePipelineReleaseByID.defaultExpectation = &RepositoryMockDeletePipelineReleaseByIDExpectation{}
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmDeletePipelineReleaseByID.defaultExpectation.params = &RepositoryMockDeletePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}
	mmDeletePipelineReleaseByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmDeletePipelineReleaseByID.defaultExpectation.params) {
			mmDeletePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmDeletePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeletePipelineReleaseByID
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeletePipelineReleaseByID {
	if mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Set")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation == nil {
		mmDeletePipelineReleaseByID.defaultExpectation = &RepositoryMockDeletePipelineReleaseByIDExpectation{}
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineReleaseByIDParamPtrs{}
	}
	mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePipelineReleaseByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeletePipelineReleaseByID
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeletePipelineReleaseByID {
	if mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Set")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation == nil {
		mmDeletePipelineReleaseByID.defaultExpectation = &RepositoryMockDeletePipelineReleaseByIDExpectation{}
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineReleaseByIDParamPtrs{}
	}
	mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmDeletePipelineReleaseByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmDeletePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.DeletePipelineReleaseByID
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockDeletePipelineReleaseByID {
	if mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Set")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation == nil {
		mmDeletePipelineReleaseByID.defaultExpectation = &RepositoryMockDeletePipelineReleaseByIDExpectation{}
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineReleaseByIDParamPtrs{}
	}
	mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmDeletePipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmDeletePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.DeletePipelineReleaseByID
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockDeletePipelineReleaseByID {
	if mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Set")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation == nil {
		mmDeletePipelineReleaseByID.defaultExpectation = &RepositoryMockDeletePipelineReleaseByIDExpectation{}
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineReleaseByIDParamPtrs{}
	}
	mmDeletePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id
	mmDeletePipelineReleaseByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeletePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeletePipelineReleaseByID
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string)) *mRepositoryMockDeletePipelineReleaseByID {
	if mmDeletePipelineReleaseByID.mock.inspectFuncDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeletePipelineReleaseByID")
	}

	mmDeletePipelineReleaseByID.mock.inspectFuncDeletePipelineReleaseByID = f

	return mmDeletePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.DeletePipelineReleaseByID
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) Return(err error) *RepositoryMock {
	if mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Set")
	}

	if mmDeletePipelineReleaseByID.defaultExpectation == nil {
		mmDeletePipelineReleaseByID.defaultExpectation = &RepositoryMockDeletePipelineReleaseByIDExpectation{mock: mmDeletePipelineReleaseByID.mock}
	}
	mmDeletePipelineReleaseByID.defaultExpectation.results = &RepositoryMockDeletePipelineReleaseByIDResults{err}
	mmDeletePipelineReleaseByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.DeletePipelineReleaseByID method
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error)) *RepositoryMock {
	if mmDeletePipelineReleaseByID.defaultExpectation != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeletePipelineReleaseByID method")
	}

	if len(mmDeletePipelineReleaseByID.expectations) > 0 {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeletePipelineReleaseByID method")
	}

	mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID = f
	mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByIDOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineReleaseByID.mock
}

// When sets expectation for the Repository.DeletePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) *RepositoryMockDeletePipelineReleaseByIDExpectation {
	if mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeletePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeletePipelineReleaseByIDExpectation{
		mock:               mmDeletePipelineReleaseByID.mock,
		params:             &RepositoryMockDeletePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id},
		expectationOrigins: RepositoryMockDeletePipelineReleaseByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePipelineReleaseByID.expectations = append(mmDeletePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeletePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeletePipelineReleaseByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeletePipelineReleaseByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeletePipelineReleaseByID should be invoked
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) Times(n uint64) *mRepositoryMockDeletePipelineReleaseByID {
	if n == 0 {
		mmDeletePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.DeletePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelineReleaseByID.expectedInvocations, n)
	mmDeletePipelineReleaseByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineReleaseByID
}

func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) invocationsDone() bool {
	if len(mmDeletePipelineReleaseByID.expectations) == 0 && mmDeletePipelineReleaseByID.defaultExpectation == nil && mmDeletePipelineReleaseByID.mock.funcDeletePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelineReleaseByID.mock.afterDeletePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelineReleaseByID implements mm_repository.Repository
func (mmDeletePipelineReleaseByID *RepositoryMock) DeletePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelineReleaseByID.beforeDeletePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelineReleaseByID.afterDeletePipelineReleaseByIDCounter, 1)

	mmDeletePipelineReleaseByID.t.Helper()

	if mmDeletePipelineReleaseByID.inspectFuncDeletePipelineReleaseByID != nil {
		mmDeletePipelineReleaseByID.inspectFuncDeletePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id)
	}

	mm_params := RepositoryMockDeletePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}

	// Record call args
	mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.mutex.Lock()
	mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.callArgs = append(mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.callArgs, &mm_params)
	mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeletePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelineReleaseByID.t.Errorf("RepositoryMock.DeletePipelineReleaseByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeletePipelineReleaseByID.t.Errorf("RepositoryMock.DeletePipelineReleaseByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeletePipelineReleaseByID.t.Errorf("RepositoryMock.DeletePipelineReleaseByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeletePipelineReleaseByID.t.Errorf("RepositoryMock.DeletePipelineReleaseByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelineReleaseByID.t.Errorf("RepositoryMock.DeletePipelineReleaseByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelineReleaseByID.DeletePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.DeletePipelineReleaseByID")
		}
		return (*mm_results).err
	}
	if mmDeletePipelineReleaseByID.funcDeletePipelineReleaseByID != nil {
		return mmDeletePipelineReleaseByID.funcDeletePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id)
	}
	mmDeletePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.DeletePipelineReleaseByID. %v %v %v %v", ctx, ownerPermalink, pipelineUID, id)
	return
}

// DeletePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.DeletePipelineReleaseByID invocations
func (mmDeletePipelineReleaseByID *RepositoryMock) DeletePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineReleaseByID.afterDeletePipelineReleaseByIDCounter)
}

// DeletePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.DeletePipelineReleaseByID invocations
func (mmDeletePipelineReleaseByID *RepositoryMock) DeletePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineReleaseByID.beforeDeletePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeletePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelineReleaseByID *mRepositoryMockDeletePipelineReleaseByID) Calls() []*RepositoryMockDeletePipelineReleaseByIDParams {
	mmDeletePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeletePipelineReleaseByIDParams, len(mmDeletePipelineReleaseByID.callArgs))
	copy(argCopy, mmDeletePipelineReleaseByID.callArgs)

	mmDeletePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelineReleaseByIDDone returns true if the count of the DeletePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeletePipelineReleaseByIDDone() bool {
	if m.DeletePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelineReleaseByIDMock.invocationsDone()
}

// MinimockDeletePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeletePipelineReleaseByIDInspect() {
	for _, e := range m.DeletePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineReleaseByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterDeletePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelineReleaseByIDMock.defaultExpectation != nil && afterDeletePipelineReleaseByIDCounter < 1 {
		if m.DeletePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineReleaseByID at\n%s", m.DeletePipelineReleaseByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineReleaseByID at\n%s with params: %#v", m.DeletePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeletePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelineReleaseByID != nil && afterDeletePipelineReleaseByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeletePipelineReleaseByID at\n%s", m.funcDeletePipelineReleaseByIDOrigin)
	}

	if !m.DeletePipelineReleaseByIDMock.invocationsDone() && afterDeletePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeletePipelineReleaseByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelineReleaseByIDMock.expectedInvocations), m.DeletePipelineReleaseByIDMock.expectedInvocationsOrigin, afterDeletePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockDeletePipelineRunOn struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeletePipelineRunOnExpectation
	expectations       []*RepositoryMockDeletePipelineRunOnExpectation

	callArgs []*RepositoryMockDeletePipelineRunOnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeletePipelineRunOnExpectation specifies expectation struct of the Repository.DeletePipelineRunOn
type RepositoryMockDeletePipelineRunOnExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeletePipelineRunOnParams
	paramPtrs          *RepositoryMockDeletePipelineRunOnParamPtrs
	expectationOrigins RepositoryMockDeletePipelineRunOnExpectationOrigins
	results            *RepositoryMockDeletePipelineRunOnResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeletePipelineRunOnParams contains parameters of the Repository.DeletePipelineRunOn
type RepositoryMockDeletePipelineRunOnParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockDeletePipelineRunOnParamPtrs contains pointers to parameters of the Repository.DeletePipelineRunOn
type RepositoryMockDeletePipelineRunOnParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryMockDeletePipelineRunOnResults contains results of the Repository.DeletePipelineRunOn
type RepositoryMockDeletePipelineRunOnResults struct {
	err error
}

// RepositoryMockDeletePipelineRunOnOrigins contains origins of expectations of the Repository.DeletePipelineRunOn
type RepositoryMockDeletePipelineRunOnExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) Optional() *mRepositoryMockDeletePipelineRunOn {
	mmDeletePipelineRunOn.optional = true
	return mmDeletePipelineRunOn
}

// Expect sets up expected params for Repository.DeletePipelineRunOn
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockDeletePipelineRunOn {
	if mmDeletePipelineRunOn.mock.funcDeletePipelineRunOn != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by Set")
	}

	if mmDeletePipelineRunOn.defaultExpectation == nil {
		mmDeletePipelineRunOn.defaultExpectation = &RepositoryMockDeletePipelineRunOnExpectation{}
	}

	if mmDeletePipelineRunOn.defaultExpectation.paramPtrs != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by ExpectParams functions")
	}

	mmDeletePipelineRunOn.defaultExpectation.params = &RepositoryMockDeletePipelineRunOnParams{ctx, uid}
	mmDeletePipelineRunOn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePipelineRunOn.expectations {
		if minimock.Equal(e.params, mmDeletePipelineRunOn.defaultExpectation.params) {
			mmDeletePipelineRunOn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelineRunOn.defaultExpectation.params)
		}
	}

	return mmDeletePipelineRunOn
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeletePipelineRunOn
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeletePipelineRunOn {
	if mmDeletePipelineRunOn.mock.funcDeletePipelineRunOn != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by Set")
	}

	if mmDeletePipelineRunOn.defaultExpectation == nil {
		mmDeletePipelineRunOn.defaultExpectation = &RepositoryMockDeletePipelineRunOnExpectation{}
	}

	if mmDeletePipelineRunOn.defaultExpectation.params != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by Expect")
	}

	if mmDeletePipelineRunOn.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineRunOn.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineRunOnParamPtrs{}
	}
	mmDeletePipelineRunOn.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePipelineRunOn.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePipelineRunOn
}

// ExpectUidParam2 sets up expected param uid for Repository.DeletePipelineRunOn
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockDeletePipelineRunOn {
	if mmDeletePipelineRunOn.mock.funcDeletePipelineRunOn != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by Set")
	}

	if mmDeletePipelineRunOn.defaultExpectation == nil {
		mmDeletePipelineRunOn.defaultExpectation = &RepositoryMockDeletePipelineRunOnExpectation{}
	}

	if mmDeletePipelineRunOn.defaultExpectation.params != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by Expect")
	}

	if mmDeletePipelineRunOn.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineRunOn.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineRunOnParamPtrs{}
	}
	mmDeletePipelineRunOn.defaultExpectation.paramPtrs.uid = &uid
	mmDeletePipelineRunOn.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmDeletePipelineRunOn
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeletePipelineRunOn
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockDeletePipelineRunOn {
	if mmDeletePipelineRunOn.mock.inspectFuncDeletePipelineRunOn != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeletePipelineRunOn")
	}

	mmDeletePipelineRunOn.mock.inspectFuncDeletePipelineRunOn = f

	return mmDeletePipelineRunOn
}

// Return sets up results that will be returned by Repository.DeletePipelineRunOn
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) Return(err error) *RepositoryMock {
	if mmDeletePipelineRunOn.mock.funcDeletePipelineRunOn != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by Set")
	}

	if mmDeletePipelineRunOn.defaultExpectation == nil {
		mmDeletePipelineRunOn.defaultExpectation = &RepositoryMockDeletePipelineRunOnExpectation{mock: mmDeletePipelineRunOn.mock}
	}
	mmDeletePipelineRunOn.defaultExpectation.results = &RepositoryMockDeletePipelineRunOnResults{err}
	mmDeletePipelineRunOn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineRunOn.mock
}

// Set uses given function f to mock the Repository.DeletePipelineRunOn method
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmDeletePipelineRunOn.defaultExpectation != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("Default expectation is already set for the Repository.DeletePipelineRunOn method")
	}

	if len(mmDeletePipelineRunOn.expectations) > 0 {
		mmDeletePipelineRunOn.mock.t.Fatalf("Some expectations are already set for the Repository.DeletePipelineRunOn method")
	}

	mmDeletePipelineRunOn.mock.funcDeletePipelineRunOn = f
	mmDeletePipelineRunOn.mock.funcDeletePipelineRunOnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineRunOn.mock
}

// When sets expectation for the Repository.DeletePipelineRunOn which will trigger the result defined by the following
// Then helper
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) When(ctx context.Context, uid uuid.UUID) *RepositoryMockDeletePipelineRunOnExpectation {
	if mmDeletePipelineRunOn.mock.funcDeletePipelineRunOn != nil {
		mmDeletePipelineRunOn.mock.t.Fatalf("RepositoryMock.DeletePipelineRunOn mock is already set by Set")
	}

	expectation := &RepositoryMockDeletePipelineRunOnExpectation{
		mock:               mmDeletePipelineRunOn.mock,
		params:             &RepositoryMockDeletePipelineRunOnParams{ctx, uid},
		expectationOrigins: RepositoryMockDeletePipelineRunOnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePipelineRunOn.expectations = append(mmDeletePipelineRunOn.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeletePipelineRunOn return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeletePipelineRunOnExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeletePipelineRunOnResults{err}
	return e.mock
}

// Times sets number of times Repository.DeletePipelineRunOn should be invoked
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) Times(n uint64) *mRepositoryMockDeletePipelineRunOn {
	if n == 0 {
		mmDeletePipelineRunOn.mock.t.Fatalf("Times of RepositoryMock.DeletePipelineRunOn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelineRunOn.expectedInvocations, n)
	mmDeletePipelineRunOn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineRunOn
}

func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) invocationsDone() bool {
	if len(mmDeletePipelineRunOn.expectations) == 0 && mmDeletePipelineRunOn.defaultExpectation == nil && mmDeletePipelineRunOn.mock.funcDeletePipelineRunOn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelineRunOn.mock.afterDeletePipelineRunOnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelineRunOn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelineRunOn implements mm_repository.Repository
func (mmDeletePipelineRunOn *RepositoryMock) DeletePipelineRunOn(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelineRunOn.beforeDeletePipelineRunOnCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelineRunOn.afterDeletePipelineRunOnCounter, 1)

	mmDeletePipelineRunOn.t.Helper()

	if mmDeletePipelineRunOn.inspectFuncDeletePipelineRunOn != nil {
		mmDeletePipelineRunOn.inspectFuncDeletePipelineRunOn(ctx, uid)
	}

	mm_params := RepositoryMockDeletePipelineRunOnParams{ctx, uid}

	// Record call args
	mmDeletePipelineRunOn.DeletePipelineRunOnMock.mutex.Lock()
	mmDeletePipelineRunOn.DeletePipelineRunOnMock.callArgs = append(mmDeletePipelineRunOn.DeletePipelineRunOnMock.callArgs, &mm_params)
	mmDeletePipelineRunOn.DeletePipelineRunOnMock.mutex.Unlock()

	for _, e := range mmDeletePipelineRunOn.DeletePipelineRunOnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeletePipelineRunOnParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelineRunOn.t.Errorf("RepositoryMock.DeletePipelineRunOn got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmDeletePipelineRunOn.t.Errorf("RepositoryMock.DeletePipelineRunOn got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelineRunOn.t.Errorf("RepositoryMock.DeletePipelineRunOn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelineRunOn.DeletePipelineRunOnMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelineRunOn.t.Fatal("No results are set for the RepositoryMock.DeletePipelineRunOn")
		}
		return (*mm_results).err
	}
	if mmDeletePipelineRunOn.funcDeletePipelineRunOn != nil {
		return mmDeletePipelineRunOn.funcDeletePipelineRunOn(ctx, uid)
	}
	mmDeletePipelineRunOn.t.Fatalf("Unexpected call to RepositoryMock.DeletePipelineRunOn. %v %v", ctx, uid)
	return
}

// DeletePipelineRunOnAfterCounter returns a count of finished RepositoryMock.DeletePipelineRunOn invocations
func (mmDeletePipelineRunOn *RepositoryMock) DeletePipelineRunOnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineRunOn.afterDeletePipelineRunOnCounter)
}

// DeletePipelineRunOnBeforeCounter returns a count of RepositoryMock.DeletePipelineRunOn invocations
func (mmDeletePipelineRunOn *RepositoryMock) DeletePipelineRunOnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineRunOn.beforeDeletePipelineRunOnCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeletePipelineRunOn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelineRunOn *mRepositoryMockDeletePipelineRunOn) Calls() []*RepositoryMockDeletePipelineRunOnParams {
	mmDeletePipelineRunOn.mutex.RLock()

	argCopy := make([]*RepositoryMockDeletePipelineRunOnParams, len(mmDeletePipelineRunOn.callArgs))
	copy(argCopy, mmDeletePipelineRunOn.callArgs)

	mmDeletePipelineRunOn.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelineRunOnDone returns true if the count of the DeletePipelineRunOn invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeletePipelineRunOnDone() bool {
	if m.DeletePipelineRunOnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelineRunOnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelineRunOnMock.invocationsDone()
}

// MinimockDeletePipelineRunOnInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeletePipelineRunOnInspect() {
	for _, e := range m.DeletePipelineRunOnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineRunOn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePipelineRunOnCounter := mm_atomic.LoadUint64(&m.afterDeletePipelineRunOnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelineRunOnMock.defaultExpectation != nil && afterDeletePipelineRunOnCounter < 1 {
		if m.DeletePipelineRunOnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineRunOn at\n%s", m.DeletePipelineRunOnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineRunOn at\n%s with params: %#v", m.DeletePipelineRunOnMock.defaultExpectation.expectationOrigins.origin, *m.DeletePipelineRunOnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelineRunOn != nil && afterDeletePipelineRunOnCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeletePipelineRunOn at\n%s", m.funcDeletePipelineRunOnOrigin)
	}

	if !m.DeletePipelineRunOnMock.invocationsDone() && afterDeletePipelineRunOnCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeletePipelineRunOn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelineRunOnMock.expectedInvocations), m.DeletePipelineRunOnMock.expectedInvocationsOrigin, afterDeletePipelineRunOnCounter)
	}
}

type mRepositoryMockDeletePipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeletePipelineTagsExpectation
	expectations       []*RepositoryMockDeletePipelineTagsExpectation

	callArgs []*RepositoryMockDeletePipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeletePipelineTagsExpectation specifies expectation struct of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeletePipelineTagsParams
	paramPtrs          *RepositoryMockDeletePipelineTagsParamPtrs
	expectationOrigins RepositoryMockDeletePipelineTagsExpectationOrigins
	results            *RepositoryMockDeletePipelineTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeletePipelineTagsParams contains parameters of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	tagNames    []string
}

// RepositoryMockDeletePipelineTagsParamPtrs contains pointers to parameters of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	tagNames    *[]string
}

// RepositoryMockDeletePipelineTagsResults contains results of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsResults struct {
	err error
}

// RepositoryMockDeletePipelineTagsOrigins contains origins of expectations of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originTagNames    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Optional() *mRepositoryMockDeletePipelineTags {
	mmDeletePipelineTags.optional = true
	return mmDeletePipelineTags
}

// Expect sets up expected params for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by ExpectParams functions")
	}

	mmDeletePipelineTags.defaultExpectation.params = &RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePipelineTags.expectations {
		if minimock.Equal(e.params, mmDeletePipelineTags.defaultExpectation.params) {
			mmDeletePipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelineTags.defaultExpectation.params)
		}
	}

	return mmDeletePipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmDeletePipelineTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.tagNames = &tagNames
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.originTagNames = minimock.CallerInfo(1)

	return mmDeletePipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.inspectFuncDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeletePipelineTags")
	}

	mmDeletePipelineTags.mock.inspectFuncDeletePipelineTags = f

	return mmDeletePipelineTags
}

// Return sets up results that will be returned by Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Return(err error) *RepositoryMock {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{mock: mmDeletePipelineTags.mock}
	}
	mmDeletePipelineTags.defaultExpectation.results = &RepositoryMockDeletePipelineTagsResults{err}
	mmDeletePipelineTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineTags.mock
}

// Set uses given function f to mock the Repository.DeletePipelineTags method
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmDeletePipelineTags.defaultExpectation != nil {
		mmDeletePipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.DeletePipelineTags method")
	}

	if len(mmDeletePipelineTags.expectations) > 0 {
		mmDeletePipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.DeletePipelineTags method")
	}

	mmDeletePipelineTags.mock.funcDeletePipelineTags = f
	mmDeletePipelineTags.mock.funcDeletePipelineTagsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineTags.mock
}

// When sets expectation for the Repository.DeletePipelineTags which will trigger the result defined by the following
// Then helper
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) When(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *RepositoryMockDeletePipelineTagsExpectation {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockDeletePipelineTagsExpectation{
		mock:               mmDeletePipelineTags.mock,
		params:             &RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames},
		expectationOrigins: RepositoryMockDeletePipelineTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePipelineTags.expectations = append(mmDeletePipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeletePipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeletePipelineTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeletePipelineTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.DeletePipelineTags should be invoked
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Times(n uint64) *mRepositoryMockDeletePipelineTags {
	if n == 0 {
		mmDeletePipelineTags.mock.t.Fatalf("Times of RepositoryMock.DeletePipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelineTags.expectedInvocations, n)
	mmDeletePipelineTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineTags
}

func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) invocationsDone() bool {
	if len(mmDeletePipelineTags.expectations) == 0 && mmDeletePipelineTags.defaultExpectation == nil && mmDeletePipelineTags.mock.funcDeletePipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelineTags.mock.afterDeletePipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelineTags implements mm_repository.Repository
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTags(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelineTags.beforeDeletePipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelineTags.afterDeletePipelineTagsCounter, 1)

	mmDeletePipelineTags.t.Helper()

	if mmDeletePipelineTags.inspectFuncDeletePipelineTags != nil {
		mmDeletePipelineTags.inspectFuncDeletePipelineTags(ctx, pipelineUID, tagNames)
	}

	mm_params := RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}

	// Record call args
	mmDeletePipelineTags.DeletePipelineTagsMock.mutex.Lock()
	mmDeletePipelineTags.DeletePipelineTagsMock.callArgs = append(mmDeletePipelineTags.DeletePipelineTagsMock.callArgs, &mm_params)
	mmDeletePipelineTags.DeletePipelineTagsMock.mutex.Unlock()

	for _, e := range mmDeletePipelineTags.DeletePipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter tagNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.originTagNames, *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelineTags.t.Fatal("No results are set for the RepositoryMock.DeletePipelineTags")
		}
		return (*mm_results).err
	}
	if mmDeletePipelineTags.funcDeletePipelineTags != nil {
		return mmDeletePipelineTags.funcDeletePipelineTags(ctx, pipelineUID, tagNames)
	}
	mmDeletePipelineTags.t.Fatalf("Unexpected call to RepositoryMock.DeletePipelineTags. %v %v %v", ctx, pipelineUID, tagNames)
	return
}

// DeletePipelineTagsAfterCounter returns a count of finished RepositoryMock.DeletePipelineTags invocations
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineTags.afterDeletePipelineTagsCounter)
}

// DeletePipelineTagsBeforeCounter returns a count of RepositoryMock.DeletePipelineTags invocations
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineTags.beforeDeletePipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeletePipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Calls() []*RepositoryMockDeletePipelineTagsParams {
	mmDeletePipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockDeletePipelineTagsParams, len(mmDeletePipelineTags.callArgs))
	copy(argCopy, mmDeletePipelineTags.callArgs)

	mmDeletePipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelineTagsDone returns true if the count of the DeletePipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeletePipelineTagsDone() bool {
	if m.DeletePipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelineTagsMock.invocationsDone()
}

// MinimockDeletePipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeletePipelineTagsInspect() {
	for _, e := range m.DeletePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePipelineTagsCounter := mm_atomic.LoadUint64(&m.afterDeletePipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelineTagsMock.defaultExpectation != nil && afterDeletePipelineTagsCounter < 1 {
		if m.DeletePipelineTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s", m.DeletePipelineTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s with params: %#v", m.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *m.DeletePipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelineTags != nil && afterDeletePipelineTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s", m.funcDeletePipelineTagsOrigin)
	}

	if !m.DeletePipelineTagsMock.invocationsDone() && afterDeletePipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeletePipelineTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelineTagsMock.expectedInvocations), m.DeletePipelineTagsMock.expectedInvocationsOrigin, afterDeletePipelineTagsCounter)
	}
}

type mRepositoryMockGetConnectionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetConnectionByUIDExpectation
	expectations       []*RepositoryMockGetConnectionByUIDExpectation

	callArgs []*RepositoryMockGetConnectionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetConnectionByUIDExpectation specifies expectation struct of the Repository.GetConnectionByUID
type RepositoryMockGetConnectionByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetConnectionByUIDParams
	paramPtrs          *RepositoryMockGetConnectionByUIDParamPtrs
	expectationOrigins RepositoryMockGetConnectionByUIDExpectationOrigins
	results            *RepositoryMockGetConnectionByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetConnectionByUIDParams contains parameters of the Repository.GetConnectionByUID
type RepositoryMockGetConnectionByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// RepositoryMockGetConnectionByUIDParamPtrs contains pointers to parameters of the Repository.GetConnectionByUID
type RepositoryMockGetConnectionByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
}

// RepositoryMockGetConnectionByUIDResults contains results of the Repository.GetConnectionByUID
type RepositoryMockGetConnectionByUIDResults struct {
	cp1 *datamodel.Connection
	err error
}

// RepositoryMockGetConnectionByUIDOrigins contains origins of expectations of the Repository.GetConnectionByUID
type RepositoryMockGetConnectionByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) Optional() *mRepositoryMockGetConnectionByUID {
	mmGetConnectionByUID.optional = true
	return mmGetConnectionByUID
}

// Expect sets up expected params for Repository.GetConnectionByUID
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) Expect(ctx context.Context, u1 uuid.UUID) *mRepositoryMockGetConnectionByUID {
	if mmGetConnectionByUID.mock.funcGetConnectionByUID != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by Set")
	}

	if mmGetConnectionByUID.defaultExpectation == nil {
		mmGetConnectionByUID.defaultExpectation = &RepositoryMockGetConnectionByUIDExpectation{}
	}

	if mmGetConnectionByUID.defaultExpectation.paramPtrs != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by ExpectParams functions")
	}

	mmGetConnectionByUID.defaultExpectation.params = &RepositoryMockGetConnectionByUIDParams{ctx, u1}
	mmGetConnectionByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConnectionByUID.expectations {
		if minimock.Equal(e.params, mmGetConnectionByUID.defaultExpectation.params) {
			mmGetConnectionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConnectionByUID.defaultExpectation.params)
		}
	}

	return mmGetConnectionByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetConnectionByUID
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetConnectionByUID {
	if mmGetConnectionByUID.mock.funcGetConnectionByUID != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by Set")
	}

	if mmGetConnectionByUID.defaultExpectation == nil {
		mmGetConnectionByUID.defaultExpectation = &RepositoryMockGetConnectionByUIDExpectation{}
	}

	if mmGetConnectionByUID.defaultExpectation.params != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by Expect")
	}

	if mmGetConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmGetConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetConnectionByUIDParamPtrs{}
	}
	mmGetConnectionByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConnectionByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConnectionByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.GetConnectionByUID
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockGetConnectionByUID {
	if mmGetConnectionByUID.mock.funcGetConnectionByUID != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by Set")
	}

	if mmGetConnectionByUID.defaultExpectation == nil {
		mmGetConnectionByUID.defaultExpectation = &RepositoryMockGetConnectionByUIDExpectation{}
	}

	if mmGetConnectionByUID.defaultExpectation.params != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by Expect")
	}

	if mmGetConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmGetConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetConnectionByUIDParamPtrs{}
	}
	mmGetConnectionByUID.defaultExpectation.paramPtrs.u1 = &u1
	mmGetConnectionByUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetConnectionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetConnectionByUID
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mRepositoryMockGetConnectionByUID {
	if mmGetConnectionByUID.mock.inspectFuncGetConnectionByUID != nil {
		mmGetConnectionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetConnectionByUID")
	}

	mmGetConnectionByUID.mock.inspectFuncGetConnectionByUID = f

	return mmGetConnectionByUID
}

// Return sets up results that will be returned by Repository.GetConnectionByUID
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) Return(cp1 *datamodel.Connection, err error) *RepositoryMock {
	if mmGetConnectionByUID.mock.funcGetConnectionByUID != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by Set")
	}

	if mmGetConnectionByUID.defaultExpectation == nil {
		mmGetConnectionByUID.defaultExpectation = &RepositoryMockGetConnectionByUIDExpectation{mock: mmGetConnectionByUID.mock}
	}
	mmGetConnectionByUID.defaultExpectation.results = &RepositoryMockGetConnectionByUIDResults{cp1, err}
	mmGetConnectionByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConnectionByUID.mock
}

// Set uses given function f to mock the Repository.GetConnectionByUID method
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) Set(f func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.Connection, err error)) *RepositoryMock {
	if mmGetConnectionByUID.defaultExpectation != nil {
		mmGetConnectionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetConnectionByUID method")
	}

	if len(mmGetConnectionByUID.expectations) > 0 {
		mmGetConnectionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetConnectionByUID method")
	}

	mmGetConnectionByUID.mock.funcGetConnectionByUID = f
	mmGetConnectionByUID.mock.funcGetConnectionByUIDOrigin = minimock.CallerInfo(1)
	return mmGetConnectionByUID.mock
}

// When sets expectation for the Repository.GetConnectionByUID which will trigger the result defined by the following
// Then helper
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) When(ctx context.Context, u1 uuid.UUID) *RepositoryMockGetConnectionByUIDExpectation {
	if mmGetConnectionByUID.mock.funcGetConnectionByUID != nil {
		mmGetConnectionByUID.mock.t.Fatalf("RepositoryMock.GetConnectionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetConnectionByUIDExpectation{
		mock:               mmGetConnectionByUID.mock,
		params:             &RepositoryMockGetConnectionByUIDParams{ctx, u1},
		expectationOrigins: RepositoryMockGetConnectionByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConnectionByUID.expectations = append(mmGetConnectionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetConnectionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetConnectionByUIDExpectation) Then(cp1 *datamodel.Connection, err error) *RepositoryMock {
	e.results = &RepositoryMockGetConnectionByUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetConnectionByUID should be invoked
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) Times(n uint64) *mRepositoryMockGetConnectionByUID {
	if n == 0 {
		mmGetConnectionByUID.mock.t.Fatalf("Times of RepositoryMock.GetConnectionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConnectionByUID.expectedInvocations, n)
	mmGetConnectionByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConnectionByUID
}

func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) invocationsDone() bool {
	if len(mmGetConnectionByUID.expectations) == 0 && mmGetConnectionByUID.defaultExpectation == nil && mmGetConnectionByUID.mock.funcGetConnectionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConnectionByUID.mock.afterGetConnectionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConnectionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConnectionByUID implements mm_repository.Repository
func (mmGetConnectionByUID *RepositoryMock) GetConnectionByUID(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.Connection, err error) {
	mm_atomic.AddUint64(&mmGetConnectionByUID.beforeGetConnectionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConnectionByUID.afterGetConnectionByUIDCounter, 1)

	mmGetConnectionByUID.t.Helper()

	if mmGetConnectionByUID.inspectFuncGetConnectionByUID != nil {
		mmGetConnectionByUID.inspectFuncGetConnectionByUID(ctx, u1)
	}

	mm_params := RepositoryMockGetConnectionByUIDParams{ctx, u1}

	// Record call args
	mmGetConnectionByUID.GetConnectionByUIDMock.mutex.Lock()
	mmGetConnectionByUID.GetConnectionByUIDMock.callArgs = append(mmGetConnectionByUID.GetConnectionByUIDMock.callArgs, &mm_params)
	mmGetConnectionByUID.GetConnectionByUIDMock.mutex.Unlock()

	for _, e := range mmGetConnectionByUID.GetConnectionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetConnectionByUIDParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConnectionByUID.t.Errorf("RepositoryMock.GetConnectionByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetConnectionByUID.t.Errorf("RepositoryMock.GetConnectionByUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConnectionByUID.t.Errorf("RepositoryMock.GetConnectionByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConnectionByUID.GetConnectionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConnectionByUID.t.Fatal("No results are set for the RepositoryMock.GetConnectionByUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetConnectionByUID.funcGetConnectionByUID != nil {
		return mmGetConnectionByUID.funcGetConnectionByUID(ctx, u1)
	}
	mmGetConnectionByUID.t.Fatalf("Unexpected call to RepositoryMock.GetConnectionByUID. %v %v", ctx, u1)
	return
}

// GetConnectionByUIDAfterCounter returns a count of finished RepositoryMock.GetConnectionByUID invocations
func (mmGetConnectionByUID *RepositoryMock) GetConnectionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConnectionByUID.afterGetConnectionByUIDCounter)
}

// GetConnectionByUIDBeforeCounter returns a count of RepositoryMock.GetConnectionByUID invocations
func (mmGetConnectionByUID *RepositoryMock) GetConnectionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConnectionByUID.beforeGetConnectionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetConnectionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConnectionByUID *mRepositoryMockGetConnectionByUID) Calls() []*RepositoryMockGetConnectionByUIDParams {
	mmGetConnectionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetConnectionByUIDParams, len(mmGetConnectionByUID.callArgs))
	copy(argCopy, mmGetConnectionByUID.callArgs)

	mmGetConnectionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetConnectionByUIDDone returns true if the count of the GetConnectionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetConnectionByUIDDone() bool {
	if m.GetConnectionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConnectionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConnectionByUIDMock.invocationsDone()
}

// MinimockGetConnectionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetConnectionByUIDInspect() {
	for _, e := range m.GetConnectionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetConnectionByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConnectionByUIDCounter := mm_atomic.LoadUint64(&m.afterGetConnectionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConnectionByUIDMock.defaultExpectation != nil && afterGetConnectionByUIDCounter < 1 {
		if m.GetConnectionByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetConnectionByUID at\n%s", m.GetConnectionByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetConnectionByUID at\n%s with params: %#v", m.GetConnectionByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetConnectionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConnectionByUID != nil && afterGetConnectionByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetConnectionByUID at\n%s", m.funcGetConnectionByUIDOrigin)
	}

	if !m.GetConnectionByUIDMock.invocationsDone() && afterGetConnectionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetConnectionByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConnectionByUIDMock.expectedInvocations), m.GetConnectionByUIDMock.expectedInvocationsOrigin, afterGetConnectionByUIDCounter)
	}
}

type mRepositoryMockGetDefinitionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetDefinitionByUIDExpectation
	expectations       []*RepositoryMockGetDefinitionByUIDExpectation

	callArgs []*RepositoryMockGetDefinitionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetDefinitionByUIDExpectation specifies expectation struct of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetDefinitionByUIDParams
	paramPtrs          *RepositoryMockGetDefinitionByUIDParamPtrs
	expectationOrigins RepositoryMockGetDefinitionByUIDExpectationOrigins
	results            *RepositoryMockGetDefinitionByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetDefinitionByUIDParams contains parameters of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// RepositoryMockGetDefinitionByUIDParamPtrs contains pointers to parameters of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
}

// RepositoryMockGetDefinitionByUIDResults contains results of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDResults struct {
	cp1 *datamodel.ComponentDefinition
	err error
}

// RepositoryMockGetDefinitionByUIDOrigins contains origins of expectations of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Optional() *mRepositoryMockGetDefinitionByUID {
	mmGetDefinitionByUID.optional = true
	return mmGetDefinitionByUID
}

// Expect sets up expected params for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Expect(ctx context.Context, u1 uuid.UUID) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by ExpectParams functions")
	}

	mmGetDefinitionByUID.defaultExpectation.params = &RepositoryMockGetDefinitionByUIDParams{ctx, u1}
	mmGetDefinitionByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDefinitionByUID.expectations {
		if minimock.Equal(e.params, mmGetDefinitionByUID.defaultExpectation.params) {
			mmGetDefinitionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDefinitionByUID.defaultExpectation.params)
		}
	}

	return mmGetDefinitionByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.params != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Expect")
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetDefinitionByUIDParamPtrs{}
	}
	mmGetDefinitionByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDefinitionByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDefinitionByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.params != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Expect")
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetDefinitionByUIDParamPtrs{}
	}
	mmGetDefinitionByUID.defaultExpectation.paramPtrs.u1 = &u1
	mmGetDefinitionByUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetDefinitionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.inspectFuncGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetDefinitionByUID")
	}

	mmGetDefinitionByUID.mock.inspectFuncGetDefinitionByUID = f

	return mmGetDefinitionByUID
}

// Return sets up results that will be returned by Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Return(cp1 *datamodel.ComponentDefinition, err error) *RepositoryMock {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{mock: mmGetDefinitionByUID.mock}
	}
	mmGetDefinitionByUID.defaultExpectation.results = &RepositoryMockGetDefinitionByUIDResults{cp1, err}
	mmGetDefinitionByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDefinitionByUID.mock
}

// Set uses given function f to mock the Repository.GetDefinitionByUID method
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Set(f func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error)) *RepositoryMock {
	if mmGetDefinitionByUID.defaultExpectation != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetDefinitionByUID method")
	}

	if len(mmGetDefinitionByUID.expectations) > 0 {
		mmGetDefinitionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetDefinitionByUID method")
	}

	mmGetDefinitionByUID.mock.funcGetDefinitionByUID = f
	mmGetDefinitionByUID.mock.funcGetDefinitionByUIDOrigin = minimock.CallerInfo(1)
	return mmGetDefinitionByUID.mock
}

// When sets expectation for the Repository.GetDefinitionByUID which will trigger the result defined by the following
// Then helper
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) When(ctx context.Context, u1 uuid.UUID) *RepositoryMockGetDefinitionByUIDExpectation {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetDefinitionByUIDExpectation{
		mock:               mmGetDefinitionByUID.mock,
		params:             &RepositoryMockGetDefinitionByUIDParams{ctx, u1},
		expectationOrigins: RepositoryMockGetDefinitionByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDefinitionByUID.expectations = append(mmGetDefinitionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetDefinitionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetDefinitionByUIDExpectation) Then(cp1 *datamodel.ComponentDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockGetDefinitionByUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetDefinitionByUID should be invoked
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Times(n uint64) *mRepositoryMockGetDefinitionByUID {
	if n == 0 {
		mmGetDefinitionByUID.mock.t.Fatalf("Times of RepositoryMock.GetDefinitionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDefinitionByUID.expectedInvocations, n)
	mmGetDefinitionByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDefinitionByUID
}

func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) invocationsDone() bool {
	if len(mmGetDefinitionByUID.expectations) == 0 && mmGetDefinitionByUID.defaultExpectation == nil && mmGetDefinitionByUID.mock.funcGetDefinitionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDefinitionByUID.mock.afterGetDefinitionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDefinitionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDefinitionByUID implements mm_repository.Repository
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUID(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error) {
	mm_atomic.AddUint64(&mmGetDefinitionByUID.beforeGetDefinitionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefinitionByUID.afterGetDefinitionByUIDCounter, 1)

	mmGetDefinitionByUID.t.Helper()

	if mmGetDefinitionByUID.inspectFuncGetDefinitionByUID != nil {
		mmGetDefinitionByUID.inspectFuncGetDefinitionByUID(ctx, u1)
	}

	mm_params := RepositoryMockGetDefinitionByUIDParams{ctx, u1}

	// Record call args
	mmGetDefinitionByUID.GetDefinitionByUIDMock.mutex.Lock()
	mmGetDefinitionByUID.GetDefinitionByUIDMock.callArgs = append(mmGetDefinitionByUID.GetDefinitionByUIDMock.callArgs, &mm_params)
	mmGetDefinitionByUID.GetDefinitionByUIDMock.mutex.Unlock()

	for _, e := range mmGetDefinitionByUID.GetDefinitionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetDefinitionByUIDParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefinitionByUID.t.Fatal("No results are set for the RepositoryMock.GetDefinitionByUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetDefinitionByUID.funcGetDefinitionByUID != nil {
		return mmGetDefinitionByUID.funcGetDefinitionByUID(ctx, u1)
	}
	mmGetDefinitionByUID.t.Fatalf("Unexpected call to RepositoryMock.GetDefinitionByUID. %v %v", ctx, u1)
	return
}

// GetDefinitionByUIDAfterCounter returns a count of finished RepositoryMock.GetDefinitionByUID invocations
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefinitionByUID.afterGetDefinitionByUIDCounter)
}

// GetDefinitionByUIDBeforeCounter returns a count of RepositoryMock.GetDefinitionByUID invocations
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefinitionByUID.beforeGetDefinitionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetDefinitionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Calls() []*RepositoryMockGetDefinitionByUIDParams {
	mmGetDefinitionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetDefinitionByUIDParams, len(mmGetDefinitionByUID.callArgs))
	copy(argCopy, mmGetDefinitionByUID.callArgs)

	mmGetDefinitionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetDefinitionByUIDDone returns true if the count of the GetDefinitionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDefinitionByUIDDone() bool {
	if m.GetDefinitionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDefinitionByUIDMock.invocationsDone()
}

// MinimockGetDefinitionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetDefinitionByUIDInspect() {
	for _, e := range m.GetDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDefinitionByUIDCounter := mm_atomic.LoadUint64(&m.afterGetDefinitionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefinitionByUIDMock.defaultExpectation != nil && afterGetDefinitionByUIDCounter < 1 {
		if m.GetDefinitionByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s", m.GetDefinitionByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s with params: %#v", m.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetDefinitionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefinitionByUID != nil && afterGetDefinitionByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s", m.funcGetDefinitionByUIDOrigin)
	}

	if !m.GetDefinitionByUIDMock.invocationsDone() && afterGetDefinitionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetDefinitionByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDefinitionByUIDMock.expectedInvocations), m.GetDefinitionByUIDMock.expectedInvocationsOrigin, afterGetDefinitionByUIDCounter)
	}
}

type mRepositoryMockGetHubStats struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetHubStatsExpectation
	expectations       []*RepositoryMockGetHubStatsExpectation

	callArgs []*RepositoryMockGetHubStatsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetHubStatsExpectation specifies expectation struct of the Repository.GetHubStats
type RepositoryMockGetHubStatsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetHubStatsParams
	paramPtrs          *RepositoryMockGetHubStatsParamPtrs
	expectationOrigins RepositoryMockGetHubStatsExpectationOrigins
	results            *RepositoryMockGetHubStatsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetHubStatsParams contains parameters of the Repository.GetHubStats
type RepositoryMockGetHubStatsParams struct {
	uidAllowList []uuid.UUID
}

// RepositoryMockGetHubStatsParamPtrs contains pointers to parameters of the Repository.GetHubStats
type RepositoryMockGetHubStatsParamPtrs struct {
	uidAllowList *[]uuid.UUID
}

// RepositoryMockGetHubStatsResults contains results of the Repository.GetHubStats
type RepositoryMockGetHubStatsResults struct {
	hp1 *datamodel.HubStats
	err error
}

// RepositoryMockGetHubStatsOrigins contains origins of expectations of the Repository.GetHubStats
type RepositoryMockGetHubStatsExpectationOrigins struct {
	origin             string
	originUidAllowList string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHubStats *mRepositoryMockGetHubStats) Optional() *mRepositoryMockGetHubStats {
	mmGetHubStats.optional = true
	return mmGetHubStats
}

// Expect sets up expected params for Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Expect(uidAllowList []uuid.UUID) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{}
	}

	if mmGetHubStats.defaultExpectation.paramPtrs != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by ExpectParams functions")
	}

	mmGetHubStats.defaultExpectation.params = &RepositoryMockGetHubStatsParams{uidAllowList}
	mmGetHubStats.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHubStats.expectations {
		if minimock.Equal(e.params, mmGetHubStats.defaultExpectation.params) {
			mmGetHubStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHubStats.defaultExpectation.params)
		}
	}

	return mmGetHubStats
}

// ExpectUidAllowListParam1 sets up expected param uidAllowList for Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) ExpectUidAllowListParam1(uidAllowList []uuid.UUID) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{}
	}

	if mmGetHubStats.defaultExpectation.params != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Expect")
	}

	if mmGetHubStats.defaultExpectation.paramPtrs == nil {
		mmGetHubStats.defaultExpectation.paramPtrs = &RepositoryMockGetHubStatsParamPtrs{}
	}
	mmGetHubStats.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmGetHubStats.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmGetHubStats
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Inspect(f func(uidAllowList []uuid.UUID)) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.inspectFuncGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetHubStats")
	}

	mmGetHubStats.mock.inspectFuncGetHubStats = f

	return mmGetHubStats
}

// Return sets up results that will be returned by Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Return(hp1 *datamodel.HubStats, err error) *RepositoryMock {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{mock: mmGetHubStats.mock}
	}
	mmGetHubStats.defaultExpectation.results = &RepositoryMockGetHubStatsResults{hp1, err}
	mmGetHubStats.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHubStats.mock
}

// Set uses given function f to mock the Repository.GetHubStats method
func (mmGetHubStats *mRepositoryMockGetHubStats) Set(f func(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error)) *RepositoryMock {
	if mmGetHubStats.defaultExpectation != nil {
		mmGetHubStats.mock.t.Fatalf("Default expectation is already set for the Repository.GetHubStats method")
	}

	if len(mmGetHubStats.expectations) > 0 {
		mmGetHubStats.mock.t.Fatalf("Some expectations are already set for the Repository.GetHubStats method")
	}

	mmGetHubStats.mock.funcGetHubStats = f
	mmGetHubStats.mock.funcGetHubStatsOrigin = minimock.CallerInfo(1)
	return mmGetHubStats.mock
}

// When sets expectation for the Repository.GetHubStats which will trigger the result defined by the following
// Then helper
func (mmGetHubStats *mRepositoryMockGetHubStats) When(uidAllowList []uuid.UUID) *RepositoryMockGetHubStatsExpectation {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	expectation := &RepositoryMockGetHubStatsExpectation{
		mock:               mmGetHubStats.mock,
		params:             &RepositoryMockGetHubStatsParams{uidAllowList},
		expectationOrigins: RepositoryMockGetHubStatsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHubStats.expectations = append(mmGetHubStats.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetHubStats return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetHubStatsExpectation) Then(hp1 *datamodel.HubStats, err error) *RepositoryMock {
	e.results = &RepositoryMockGetHubStatsResults{hp1, err}
	return e.mock
}

// Times sets number of times Repository.GetHubStats should be invoked
func (mmGetHubStats *mRepositoryMockGetHubStats) Times(n uint64) *mRepositoryMockGetHubStats {
	if n == 0 {
		mmGetHubStats.mock.t.Fatalf("Times of RepositoryMock.GetHubStats mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHubStats.expectedInvocations, n)
	mmGetHubStats.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHubStats
}

func (mmGetHubStats *mRepositoryMockGetHubStats) invocationsDone() bool {
	if len(mmGetHubStats.expectations) == 0 && mmGetHubStats.defaultExpectation == nil && mmGetHubStats.mock.funcGetHubStats == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHubStats.mock.afterGetHubStatsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHubStats.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHubStats implements mm_repository.Repository
func (mmGetHubStats *RepositoryMock) GetHubStats(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error) {
	mm_atomic.AddUint64(&mmGetHubStats.beforeGetHubStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHubStats.afterGetHubStatsCounter, 1)

	mmGetHubStats.t.Helper()

	if mmGetHubStats.inspectFuncGetHubStats != nil {
		mmGetHubStats.inspectFuncGetHubStats(uidAllowList)
	}

	mm_params := RepositoryMockGetHubStatsParams{uidAllowList}

	// Record call args
	mmGetHubStats.GetHubStatsMock.mutex.Lock()
	mmGetHubStats.GetHubStatsMock.callArgs = append(mmGetHubStats.GetHubStatsMock.callArgs, &mm_params)
	mmGetHubStats.GetHubStatsMock.mutex.Unlock()

	for _, e := range mmGetHubStats.GetHubStatsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmGetHubStats.GetHubStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHubStats.GetHubStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHubStats.GetHubStatsMock.defaultExpectation.params
		mm_want_ptrs := mmGetHubStats.GetHubStatsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetHubStatsParams{uidAllowList}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmGetHubStats.t.Errorf("RepositoryMock.GetHubStats got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHubStats.GetHubStatsMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHubStats.t.Errorf("RepositoryMock.GetHubStats got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHubStats.GetHubStatsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHubStats.GetHubStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHubStats.t.Fatal("No results are set for the RepositoryMock.GetHubStats")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmGetHubStats.funcGetHubStats != nil {
		return mmGetHubStats.funcGetHubStats(uidAllowList)
	}
	mmGetHubStats.t.Fatalf("Unexpected call to RepositoryMock.GetHubStats. %v", uidAllowList)
	return
}

// GetHubStatsAfterCounter returns a count of finished RepositoryMock.GetHubStats invocations
func (mmGetHubStats *RepositoryMock) GetHubStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHubStats.afterGetHubStatsCounter)
}

// GetHubStatsBeforeCounter returns a count of RepositoryMock.GetHubStats invocations
func (mmGetHubStats *RepositoryMock) GetHubStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHubStats.beforeGetHubStatsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetHubStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHubStats *mRepositoryMockGetHubStats) Calls() []*RepositoryMockGetHubStatsParams {
	mmGetHubStats.mutex.RLock()

	argCopy := make([]*RepositoryMockGetHubStatsParams, len(mmGetHubStats.callArgs))
	copy(argCopy, mmGetHubStats.callArgs)

	mmGetHubStats.mutex.RUnlock()

	return argCopy
}

// MinimockGetHubStatsDone returns true if the count of the GetHubStats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetHubStatsDone() bool {
	if m.GetHubStatsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHubStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHubStatsMock.invocationsDone()
}

// MinimockGetHubStatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetHubStatsInspect() {
	for _, e := range m.GetHubStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHubStatsCounter := mm_atomic.LoadUint64(&m.afterGetHubStatsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHubStatsMock.defaultExpectation != nil && afterGetHubStatsCounter < 1 {
		if m.GetHubStatsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s", m.GetHubStatsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s with params: %#v", m.GetHubStatsMock.defaultExpectation.expectationOrigins.origin, *m.GetHubStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHubStats != nil && afterGetHubStatsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s", m.funcGetHubStatsOrigin)
	}

	if !m.GetHubStatsMock.invocationsDone() && afterGetHubStatsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetHubStats at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHubStatsMock.expectedInvocations), m.GetHubStatsMock.expectedInvocationsOrigin, afterGetHubStatsCounter)
	}
}

type mRepositoryMockGetLatestPipelineRelease struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestPipelineReleaseExpectation
	expectations       []*RepositoryMockGetLatestPipelineReleaseExpectation

	callArgs []*RepositoryMockGetLatestPipelineReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetLatestPipelineReleaseExpectation specifies expectation struct of the Repository.GetLatestPipelineRelease
type RepositoryMockGetLatestPipelineReleaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetLatestPipelineReleaseParams
	paramPtrs          *RepositoryMockGetLatestPipelineReleaseParamPtrs
	expectationOrigins RepositoryMockGetLatestPipelineReleaseExpectationOrigins
	results            *RepositoryMockGetLatestPipelineReleaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetLatestPipelineReleaseParams contains parameters of the Repository.GetLatestPipelineRelease
type RepositoryMockGetLatestPipelineReleaseParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	isBasicView    bool
}

// RepositoryMockGetLatestPipelineReleaseParamPtrs contains pointers to parameters of the Repository.GetLatestPipelineRelease
type RepositoryMockGetLatestPipelineReleaseParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	isBasicView    *bool
}

// RepositoryMockGetLatestPipelineReleaseResults contains results of the Repository.GetLatestPipelineRelease
type RepositoryMockGetLatestPipelineReleaseResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// RepositoryMockGetLatestPipelineReleaseOrigins contains origins of expectations of the Repository.GetLatestPipelineRelease
type RepositoryMockGetLatestPipelineReleaseExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originIsBasicView    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) Optional() *mRepositoryMockGetLatestPipelineRelease {
	mmGetLatestPipelineRelease.optional = true
	return mmGetLatestPipelineRelease
}

// Expect sets up expected params for Repository.GetLatestPipelineRelease
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) *mRepositoryMockGetLatestPipelineRelease {
	if mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Set")
	}

	if mmGetLatestPipelineRelease.defaultExpectation == nil {
		mmGetLatestPipelineRelease.defaultExpectation = &RepositoryMockGetLatestPipelineReleaseExpectation{}
	}

	if mmGetLatestPipelineRelease.defaultExpectation.paramPtrs != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by ExpectParams functions")
	}

	mmGetLatestPipelineRelease.defaultExpectation.params = &RepositoryMockGetLatestPipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}
	mmGetLatestPipelineRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLatestPipelineRelease.expectations {
		if minimock.Equal(e.params, mmGetLatestPipelineRelease.defaultExpectation.params) {
			mmGetLatestPipelineRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestPipelineRelease.defaultExpectation.params)
		}
	}

	return mmGetLatestPipelineRelease
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestPipelineRelease
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestPipelineRelease {
	if mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Set")
	}

	if mmGetLatestPipelineRelease.defaultExpectation == nil {
		mmGetLatestPipelineRelease.defaultExpectation = &RepositoryMockGetLatestPipelineReleaseExpectation{}
	}

	if mmGetLatestPipelineRelease.defaultExpectation.params != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Expect")
	}

	if mmGetLatestPipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestPipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestPipelineReleaseParamPtrs{}
	}
	mmGetLatestPipelineRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLatestPipelineRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLatestPipelineRelease
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetLatestPipelineRelease
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetLatestPipelineRelease {
	if mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Set")
	}

	if mmGetLatestPipelineRelease.defaultExpectation == nil {
		mmGetLatestPipelineRelease.defaultExpectation = &RepositoryMockGetLatestPipelineReleaseExpectation{}
	}

	if mmGetLatestPipelineRelease.defaultExpectation.params != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Expect")
	}

	if mmGetLatestPipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestPipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestPipelineReleaseParamPtrs{}
	}
	mmGetLatestPipelineRelease.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetLatestPipelineRelease.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetLatestPipelineRelease
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetLatestPipelineRelease
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockGetLatestPipelineRelease {
	if mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Set")
	}

	if mmGetLatestPipelineRelease.defaultExpectation == nil {
		mmGetLatestPipelineRelease.defaultExpectation = &RepositoryMockGetLatestPipelineReleaseExpectation{}
	}

	if mmGetLatestPipelineRelease.defaultExpectation.params != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Expect")
	}

	if mmGetLatestPipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestPipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestPipelineReleaseParamPtrs{}
	}
	mmGetLatestPipelineRelease.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmGetLatestPipelineRelease.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmGetLatestPipelineRelease
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetLatestPipelineRelease
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetLatestPipelineRelease {
	if mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Set")
	}

	if mmGetLatestPipelineRelease.defaultExpectation == nil {
		mmGetLatestPipelineRelease.defaultExpectation = &RepositoryMockGetLatestPipelineReleaseExpectation{}
	}

	if mmGetLatestPipelineRelease.defaultExpectation.params != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Expect")
	}

	if mmGetLatestPipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestPipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestPipelineReleaseParamPtrs{}
	}
	mmGetLatestPipelineRelease.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetLatestPipelineRelease.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetLatestPipelineRelease
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestPipelineRelease
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool)) *mRepositoryMockGetLatestPipelineRelease {
	if mmGetLatestPipelineRelease.mock.inspectFuncGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestPipelineRelease")
	}

	mmGetLatestPipelineRelease.mock.inspectFuncGetLatestPipelineRelease = f

	return mmGetLatestPipelineRelease
}

// Return sets up results that will be returned by Repository.GetLatestPipelineRelease
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Set")
	}

	if mmGetLatestPipelineRelease.defaultExpectation == nil {
		mmGetLatestPipelineRelease.defaultExpectation = &RepositoryMockGetLatestPipelineReleaseExpectation{mock: mmGetLatestPipelineRelease.mock}
	}
	mmGetLatestPipelineRelease.defaultExpectation.results = &RepositoryMockGetLatestPipelineReleaseResults{pp1, err}
	mmGetLatestPipelineRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLatestPipelineRelease.mock
}

// Set uses given function f to mock the Repository.GetLatestPipelineRelease method
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetLatestPipelineRelease.defaultExpectation != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestPipelineRelease method")
	}

	if len(mmGetLatestPipelineRelease.expectations) > 0 {
		mmGetLatestPipelineRelease.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestPipelineRelease method")
	}

	mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease = f
	mmGetLatestPipelineRelease.mock.funcGetLatestPipelineReleaseOrigin = minimock.CallerInfo(1)
	return mmGetLatestPipelineRelease.mock
}

// When sets expectation for the Repository.GetLatestPipelineRelease which will trigger the result defined by the following
// Then helper
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) *RepositoryMockGetLatestPipelineReleaseExpectation {
	if mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestPipelineRelease mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestPipelineReleaseExpectation{
		mock:               mmGetLatestPipelineRelease.mock,
		params:             &RepositoryMockGetLatestPipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView},
		expectationOrigins: RepositoryMockGetLatestPipelineReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLatestPipelineRelease.expectations = append(mmGetLatestPipelineRelease.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestPipelineRelease return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestPipelineReleaseExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestPipelineReleaseResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestPipelineRelease should be invoked
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) Times(n uint64) *mRepositoryMockGetLatestPipelineRelease {
	if n == 0 {
		mmGetLatestPipelineRelease.mock.t.Fatalf("Times of RepositoryMock.GetLatestPipelineRelease mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestPipelineRelease.expectedInvocations, n)
	mmGetLatestPipelineRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLatestPipelineRelease
}

func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) invocationsDone() bool {
	if len(mmGetLatestPipelineRelease.expectations) == 0 && mmGetLatestPipelineRelease.defaultExpectation == nil && mmGetLatestPipelineRelease.mock.funcGetLatestPipelineRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestPipelineRelease.mock.afterGetLatestPipelineReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestPipelineRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestPipelineRelease implements mm_repository.Repository
func (mmGetLatestPipelineRelease *RepositoryMock) GetLatestPipelineRelease(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetLatestPipelineRelease.beforeGetLatestPipelineReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestPipelineRelease.afterGetLatestPipelineReleaseCounter, 1)

	mmGetLatestPipelineRelease.t.Helper()

	if mmGetLatestPipelineRelease.inspectFuncGetLatestPipelineRelease != nil {
		mmGetLatestPipelineRelease.inspectFuncGetLatestPipelineRelease(ctx, ownerPermalink, pipelineUID, isBasicView)
	}

	mm_params := RepositoryMockGetLatestPipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}

	// Record call args
	mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.mutex.Lock()
	mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.callArgs = append(mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.callArgs, &mm_params)
	mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.mutex.Unlock()

	for _, e := range mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestPipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestPipelineRelease.t.Errorf("RepositoryMock.GetLatestPipelineRelease got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetLatestPipelineRelease.t.Errorf("RepositoryMock.GetLatestPipelineRelease got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetLatestPipelineRelease.t.Errorf("RepositoryMock.GetLatestPipelineRelease got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetLatestPipelineRelease.t.Errorf("RepositoryMock.GetLatestPipelineRelease got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestPipelineRelease.t.Errorf("RepositoryMock.GetLatestPipelineRelease got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestPipelineRelease.GetLatestPipelineReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestPipelineRelease.t.Fatal("No results are set for the RepositoryMock.GetLatestPipelineRelease")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetLatestPipelineRelease.funcGetLatestPipelineRelease != nil {
		return mmGetLatestPipelineRelease.funcGetLatestPipelineRelease(ctx, ownerPermalink, pipelineUID, isBasicView)
	}
	mmGetLatestPipelineRelease.t.Fatalf("Unexpected call to RepositoryMock.GetLatestPipelineRelease. %v %v %v %v", ctx, ownerPermalink, pipelineUID, isBasicView)
	return
}

// GetLatestPipelineReleaseAfterCounter returns a count of finished RepositoryMock.GetLatestPipelineRelease invocations
func (mmGetLatestPipelineRelease *RepositoryMock) GetLatestPipelineReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestPipelineRelease.afterGetLatestPipelineReleaseCounter)
}

// GetLatestPipelineReleaseBeforeCounter returns a count of RepositoryMock.GetLatestPipelineRelease invocations
func (mmGetLatestPipelineRelease *RepositoryMock) GetLatestPipelineReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestPipelineRelease.beforeGetLatestPipelineReleaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestPipelineRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestPipelineRelease *mRepositoryMockGetLatestPipelineRelease) Calls() []*RepositoryMockGetLatestPipelineReleaseParams {
	mmGetLatestPipelineRelease.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestPipelineReleaseParams, len(mmGetLatestPipelineRelease.callArgs))
	copy(argCopy, mmGetLatestPipelineRelease.callArgs)

	mmGetLatestPipelineRelease.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestPipelineReleaseDone returns true if the count of the GetLatestPipelineRelease invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestPipelineReleaseDone() bool {
	if m.GetLatestPipelineReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestPipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestPipelineReleaseMock.invocationsDone()
}

// MinimockGetLatestPipelineReleaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestPipelineReleaseInspect() {
	for _, e := range m.GetLatestPipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestPipelineRelease at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLatestPipelineReleaseCounter := mm_atomic.LoadUint64(&m.afterGetLatestPipelineReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestPipelineReleaseMock.defaultExpectation != nil && afterGetLatestPipelineReleaseCounter < 1 {
		if m.GetLatestPipelineReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestPipelineRelease at\n%s", m.GetLatestPipelineReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestPipelineRelease at\n%s with params: %#v", m.GetLatestPipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *m.GetLatestPipelineReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestPipelineRelease != nil && afterGetLatestPipelineReleaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetLatestPipelineRelease at\n%s", m.funcGetLatestPipelineReleaseOrigin)
	}

	if !m.GetLatestPipelineReleaseMock.invocationsDone() && afterGetLatestPipelineReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestPipelineRelease at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestPipelineReleaseMock.expectedInvocations), m.GetLatestPipelineReleaseMock.expectedInvocationsOrigin, afterGetLatestPipelineReleaseCounter)
	}
}

type mRepositoryMockGetNamespaceConnectionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespaceConnectionByIDExpectation
	expectations       []*RepositoryMockGetNamespaceConnectionByIDExpectation

	callArgs []*RepositoryMockGetNamespaceConnectionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNamespaceConnectionByIDExpectation specifies expectation struct of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNamespaceConnectionByIDParams
	paramPtrs          *RepositoryMockGetNamespaceConnectionByIDParamPtrs
	expectationOrigins RepositoryMockGetNamespaceConnectionByIDExpectationOrigins
	results            *RepositoryMockGetNamespaceConnectionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNamespaceConnectionByIDParams contains parameters of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDParams struct {
	ctx   context.Context
	nsUID uuid.UUID
	id    string
}

// RepositoryMockGetNamespaceConnectionByIDParamPtrs contains pointers to parameters of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDParamPtrs struct {
	ctx   *context.Context
	nsUID *uuid.UUID
	id    *string
}

// RepositoryMockGetNamespaceConnectionByIDResults contains results of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDResults struct {
	cp1 *datamodel.Connection
	err error
}

// RepositoryMockGetNamespaceConnectionByIDOrigins contains origins of expectations of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originNsUID string
	originId    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Optional() *mRepositoryMockGetNamespaceConnectionByID {
	mmGetNamespaceConnectionByID.optional = true
	return mmGetNamespaceConnectionByID
}

// Expect sets up expected params for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Expect(ctx context.Context, nsUID uuid.UUID, id string) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceConnectionByID.defaultExpectation.params = &RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id}
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceConnectionByID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceConnectionByID.defaultExpectation.params) {
			mmGetNamespaceConnectionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceConnectionByID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceConnectionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.params != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Expect")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceConnectionByIDParamPtrs{}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceConnectionByID
}

// ExpectNsUIDParam2 sets up expected param nsUID for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) ExpectNsUIDParam2(nsUID uuid.UUID) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.params != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Expect")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceConnectionByIDParamPtrs{}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs.nsUID = &nsUID
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.originNsUID = minimock.CallerInfo(1)

	return mmGetNamespaceConnectionByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.params != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Expect")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceConnectionByIDParamPtrs{}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs.id = &id
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetNamespaceConnectionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Inspect(f func(ctx context.Context, nsUID uuid.UUID, id string)) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.inspectFuncGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespaceConnectionByID")
	}

	mmGetNamespaceConnectionByID.mock.inspectFuncGetNamespaceConnectionByID = f

	return mmGetNamespaceConnectionByID
}

// Return sets up results that will be returned by Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Return(cp1 *datamodel.Connection, err error) *RepositoryMock {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{mock: mmGetNamespaceConnectionByID.mock}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.results = &RepositoryMockGetNamespaceConnectionByIDResults{cp1, err}
	mmGetNamespaceConnectionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceConnectionByID.mock
}

// Set uses given function f to mock the Repository.GetNamespaceConnectionByID method
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Set(f func(ctx context.Context, nsUID uuid.UUID, id string) (cp1 *datamodel.Connection, err error)) *RepositoryMock {
	if mmGetNamespaceConnectionByID.defaultExpectation != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespaceConnectionByID method")
	}

	if len(mmGetNamespaceConnectionByID.expectations) > 0 {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespaceConnectionByID method")
	}

	mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID = f
	mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceConnectionByID.mock
}

// When sets expectation for the Repository.GetNamespaceConnectionByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) When(ctx context.Context, nsUID uuid.UUID, id string) *RepositoryMockGetNamespaceConnectionByIDExpectation {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespaceConnectionByIDExpectation{
		mock:               mmGetNamespaceConnectionByID.mock,
		params:             &RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id},
		expectationOrigins: RepositoryMockGetNamespaceConnectionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceConnectionByID.expectations = append(mmGetNamespaceConnectionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespaceConnectionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespaceConnectionByIDExpectation) Then(cp1 *datamodel.Connection, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespaceConnectionByIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespaceConnectionByID should be invoked
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Times(n uint64) *mRepositoryMockGetNamespaceConnectionByID {
	if n == 0 {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespaceConnectionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceConnectionByID.expectedInvocations, n)
	mmGetNamespaceConnectionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceConnectionByID
}

func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) invocationsDone() bool {
	if len(mmGetNamespaceConnectionByID.expectations) == 0 && mmGetNamespaceConnectionByID.defaultExpectation == nil && mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.mock.afterGetNamespaceConnectionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceConnectionByID implements mm_repository.Repository
func (mmGetNamespaceConnectionByID *RepositoryMock) GetNamespaceConnectionByID(ctx context.Context, nsUID uuid.UUID, id string) (cp1 *datamodel.Connection, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceConnectionByID.beforeGetNamespaceConnectionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceConnectionByID.afterGetNamespaceConnectionByIDCounter, 1)

	mmGetNamespaceConnectionByID.t.Helper()

	if mmGetNamespaceConnectionByID.inspectFuncGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.inspectFuncGetNamespaceConnectionByID(ctx, nsUID, id)
	}

	mm_params := RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id}

	// Record call args
	mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.mutex.Lock()
	mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.callArgs = append(mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.callArgs, &mm_params)
	mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.nsUID != nil && !minimock.Equal(*mm_want_ptrs.nsUID, mm_got.nsUID) {
				mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameter nsUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originNsUID, *mm_want_ptrs.nsUID, mm_got.nsUID, minimock.Diff(*mm_want_ptrs.nsUID, mm_got.nsUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceConnectionByID.t.Fatal("No results are set for the RepositoryMock.GetNamespaceConnectionByID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetNamespaceConnectionByID.funcGetNamespaceConnectionByID != nil {
		return mmGetNamespaceConnectionByID.funcGetNamespaceConnectionByID(ctx, nsUID, id)
	}
	mmGetNamespaceConnectionByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespaceConnectionByID. %v %v %v", ctx, nsUID, id)
	return
}

// GetNamespaceConnectionByIDAfterCounter returns a count of finished RepositoryMock.GetNamespaceConnectionByID invocations
func (mmGetNamespaceConnectionByID *RepositoryMock) GetNamespaceConnectionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.afterGetNamespaceConnectionByIDCounter)
}

// GetNamespaceConnectionByIDBeforeCounter returns a count of RepositoryMock.GetNamespaceConnectionByID invocations
func (mmGetNamespaceConnectionByID *RepositoryMock) GetNamespaceConnectionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.beforeGetNamespaceConnectionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespaceConnectionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Calls() []*RepositoryMockGetNamespaceConnectionByIDParams {
	mmGetNamespaceConnectionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespaceConnectionByIDParams, len(mmGetNamespaceConnectionByID.callArgs))
	copy(argCopy, mmGetNamespaceConnectionByID.callArgs)

	mmGetNamespaceConnectionByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceConnectionByIDDone returns true if the count of the GetNamespaceConnectionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespaceConnectionByIDDone() bool {
	if m.GetNamespaceConnectionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceConnectionByIDMock.invocationsDone()
}

// MinimockGetNamespaceConnectionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespaceConnectionByIDInspect() {
	for _, e := range m.GetNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceConnectionByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceConnectionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceConnectionByIDMock.defaultExpectation != nil && afterGetNamespaceConnectionByIDCounter < 1 {
		if m.GetNamespaceConnectionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s", m.GetNamespaceConnectionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s with params: %#v", m.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceConnectionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceConnectionByID != nil && afterGetNamespaceConnectionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s", m.funcGetNamespaceConnectionByIDOrigin)
	}

	if !m.GetNamespaceConnectionByIDMock.invocationsDone() && afterGetNamespaceConnectionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespaceConnectionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceConnectionByIDMock.expectedInvocations), m.GetNamespaceConnectionByIDMock.expectedInvocationsOrigin, afterGetNamespaceConnectionByIDCounter)
	}
}

type mRepositoryMockGetNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockGetNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockGetNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNamespaceSecretByIDExpectation specifies expectation struct of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNamespaceSecretByIDParams
	paramPtrs          *RepositoryMockGetNamespaceSecretByIDParamPtrs
	expectationOrigins RepositoryMockGetNamespaceSecretByIDExpectationOrigins
	results            *RepositoryMockGetNamespaceSecretByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNamespaceSecretByIDParams contains parameters of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockGetNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockGetNamespaceSecretByIDResults contains results of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDResults struct {
	sp1 *datamodel.Secret
	err error
}

// RepositoryMockGetNamespaceSecretByIDOrigins contains origins of expectations of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Optional() *mRepositoryMockGetNamespaceSecretByID {
	mmGetNamespaceSecretByID.optional = true
	return mmGetNamespaceSecretByID
}

// Expect sets up expected params for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceSecretByID.defaultExpectation.params = &RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceSecretByID.defaultExpectation.params) {
			mmGetNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.inspectFuncGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespaceSecretByID")
	}

	mmGetNamespaceSecretByID.mock.inspectFuncGetNamespaceSecretByID = f

	return mmGetNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Return(sp1 *datamodel.Secret, err error) *RepositoryMock {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{mock: mmGetNamespaceSecretByID.mock}
	}
	mmGetNamespaceSecretByID.defaultExpectation.results = &RepositoryMockGetNamespaceSecretByIDResults{sp1, err}
	mmGetNamespaceSecretByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.GetNamespaceSecretByID method
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error)) *RepositoryMock {
	if mmGetNamespaceSecretByID.defaultExpectation != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespaceSecretByID method")
	}

	if len(mmGetNamespaceSecretByID.expectations) > 0 {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespaceSecretByID method")
	}

	mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID = f
	mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceSecretByID.mock
}

// When sets expectation for the Repository.GetNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockGetNamespaceSecretByIDExpectation {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespaceSecretByIDExpectation{
		mock:               mmGetNamespaceSecretByID.mock,
		params:             &RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id},
		expectationOrigins: RepositoryMockGetNamespaceSecretByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceSecretByID.expectations = append(mmGetNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespaceSecretByIDExpectation) Then(sp1 *datamodel.Secret, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespaceSecretByIDResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespaceSecretByID should be invoked
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Times(n uint64) *mRepositoryMockGetNamespaceSecretByID {
	if n == 0 {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceSecretByID.expectedInvocations, n)
	mmGetNamespaceSecretByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceSecretByID
}

func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) invocationsDone() bool {
	if len(mmGetNamespaceSecretByID.expectations) == 0 && mmGetNamespaceSecretByID.defaultExpectation == nil && mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.mock.afterGetNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceSecretByID implements mm_repository.Repository
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceSecretByID.beforeGetNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceSecretByID.afterGetNamespaceSecretByIDCounter, 1)

	mmGetNamespaceSecretByID.t.Helper()

	if mmGetNamespaceSecretByID.inspectFuncGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.inspectFuncGetNamespaceSecretByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.mutex.Lock()
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.callArgs = append(mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.callArgs, &mm_params)
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.GetNamespaceSecretByID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetNamespaceSecretByID.funcGetNamespaceSecretByID != nil {
		return mmGetNamespaceSecretByID.funcGetNamespaceSecretByID(ctx, ownerPermalink, id)
	}
	mmGetNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespaceSecretByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// GetNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.GetNamespaceSecretByID invocations
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.afterGetNamespaceSecretByIDCounter)
}

// GetNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.GetNamespaceSecretByID invocations
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.beforeGetNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Calls() []*RepositoryMockGetNamespaceSecretByIDParams {
	mmGetNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespaceSecretByIDParams, len(mmGetNamespaceSecretByID.callArgs))
	copy(argCopy, mmGetNamespaceSecretByID.callArgs)

	mmGetNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceSecretByIDDone returns true if the count of the GetNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespaceSecretByIDDone() bool {
	if m.GetNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceSecretByIDMock.invocationsDone()
}

// MinimockGetNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespaceSecretByIDInspect() {
	for _, e := range m.GetNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceSecretByIDMock.defaultExpectation != nil && afterGetNamespaceSecretByIDCounter < 1 {
		if m.GetNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s", m.GetNamespaceSecretByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s with params: %#v", m.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceSecretByID != nil && afterGetNamespaceSecretByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s", m.funcGetNamespaceSecretByIDOrigin)
	}

	if !m.GetNamespaceSecretByIDMock.invocationsDone() && afterGetNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespaceSecretByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceSecretByIDMock.expectedInvocations), m.GetNamespaceSecretByIDMock.expectedInvocationsOrigin, afterGetNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation
	expectations       []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation

	callArgs []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation specifies expectation struct of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams
	paramPtrs          *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs
	expectationOrigins RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectationOrigins
	results            *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams contains parameters of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams struct {
	ctx           context.Context
	pipelineRunID string
	page          int
	pageSize      int
	filter        filtering.Filter
	order         ordering.OrderBy
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs contains pointers to parameters of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs struct {
	ctx           *context.Context
	pipelineRunID *string
	page          *int
	pageSize      *int
	filter        *filtering.Filter
	order         *ordering.OrderBy
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults contains results of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults struct {
	ca1 []datamodel.ComponentRun
	i1  int64
	err error
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigins contains origins of expectations of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectationOrigins struct {
	origin              string
	originCtx           string
	originPipelineRunID string
	originPage          string
	originPageSize      string
	originFilter        string
	originOrder         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Optional() *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.optional = true
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// Expect sets up expected params for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Expect(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by ExpectParams functions")
	}

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations {
		if minimock.Equal(e.params, mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params) {
			mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params)
		}
	}

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectPipelineRunIDParam2 sets up expected param pipelineRunID for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectPipelineRunIDParam2(pipelineRunID string) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.pipelineRunID = &pipelineRunID
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originPipelineRunID = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectPageParam3 sets up expected param page for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectPageParam3(page int) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.page = &page
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectPageSizeParam4 sets up expected param pageSize for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectPageSizeParam4(pageSize int) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectFilterParam5 sets up expected param filter for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.filter = &filter
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectOrderParam6 sets up expected param order for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectOrderParam6(order ordering.OrderBy) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.order = &order
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Inspect(f func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy)) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions")
	}

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions = f

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// Return sets up results that will be returned by Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Return(ca1 []datamodel.ComponentRun, i1 int64, err error) *RepositoryMock {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{mock: mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.results = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults{ca1, i1, err}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock
}

// Set uses given function f to mock the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions method
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Set(f func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) (ca1 []datamodel.ComponentRun, i1 int64, err error)) *RepositoryMock {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Default expectation is already set for the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions method")
	}

	if len(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations) > 0 {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Some expectations are already set for the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions method")
	}

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions = f
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock
}

// When sets expectation for the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions which will trigger the result defined by the following
// Then helper
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) When(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	expectation := &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{
		mock:               mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock,
		params:             &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order},
		expectationOrigins: RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations = append(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation) Then(ca1 []datamodel.ComponentRun, i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults{ca1, i1, err}
	return e.mock
}

// Times sets number of times Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions should be invoked
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Times(n uint64) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if n == 0 {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Times of RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectedInvocations, n)
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) invocationsDone() bool {
	if len(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations) == 0 && mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil && mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPaginatedComponentRunsByPipelineRunIDWithPermissions implements mm_repository.Repository
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *RepositoryMock) GetPaginatedComponentRunsByPipelineRunIDWithPermissions(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) (ca1 []datamodel.ComponentRun, i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.beforeGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter, 1)

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Helper()

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions(ctx, pipelineRunID, page, pageSize, filter, order)
	}

	mm_params := RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order}

	// Record call args
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.mutex.Lock()
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.callArgs = append(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.callArgs, &mm_params)
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.mutex.Unlock()

	for _, e := range mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.i1, e.results.err
		}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineRunID != nil && !minimock.Equal(*mm_want_ptrs.pipelineRunID, mm_got.pipelineRunID) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter pipelineRunID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originPipelineRunID, *mm_want_ptrs.pipelineRunID, mm_got.pipelineRunID, minimock.Diff(*mm_want_ptrs.pipelineRunID, mm_got.pipelineRunID))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Fatal("No results are set for the RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions")
		}
		return (*mm_results).ca1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions(ctx, pipelineRunID, page, pageSize, filter, order)
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Fatalf("Unexpected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions. %v %v %v %v %v %v", ctx, pipelineRunID, page, pageSize, filter, order)
	return
}

// GetPaginatedComponentRunsByPipelineRunIDWithPermissionsAfterCounter returns a count of finished RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions invocations
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *RepositoryMock) GetPaginatedComponentRunsByPipelineRunIDWithPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
}

// GetPaginatedComponentRunsByPipelineRunIDWithPermissionsBeforeCounter returns a count of RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions invocations
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *RepositoryMock) GetPaginatedComponentRunsByPipelineRunIDWithPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.beforeGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Calls() []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams {
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams, len(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.callArgs))
	copy(argCopy, mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.callArgs)

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsDone returns true if the count of the GetPaginatedComponentRunsByPipelineRunIDWithPermissions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsDone() bool {
	if m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.invocationsDone()
}

// MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsInspect() {
	for _, e := range m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter := mm_atomic.LoadUint64(&m.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation != nil && afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter < 1 {
		if m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s", m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s with params: %#v", m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil && afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s", m.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigin)
	}

	if !m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.invocationsDone() && afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectedInvocations), m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectedInvocationsOrigin, afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
	}
}

type mRepositoryMockGetPaginatedPipelineRunsByRequester struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation
	expectations       []*RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation

	callArgs []*RepositoryMockGetPaginatedPipelineRunsByRequesterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation specifies expectation struct of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPaginatedPipelineRunsByRequesterParams
	paramPtrs          *RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs
	expectationOrigins RepositoryMockGetPaginatedPipelineRunsByRequesterExpectationOrigins
	results            *RepositoryMockGetPaginatedPipelineRunsByRequesterResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterParams contains parameters of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterParams struct {
	ctx    context.Context
	params mm_repository.GetPipelineRunsByRequesterParams
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs contains pointers to parameters of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs struct {
	ctx    *context.Context
	params *mm_repository.GetPipelineRunsByRequesterParams
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterResults contains results of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterResults struct {
	pa1 []datamodel.PipelineRun
	i1  int64
	err error
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterOrigins contains origins of expectations of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Optional() *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	mmGetPaginatedPipelineRunsByRequester.optional = true
	return mmGetPaginatedPipelineRunsByRequester
}

// Expect sets up expected params for Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Expect(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{}
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by ExpectParams functions")
	}

	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params = &RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPaginatedPipelineRunsByRequester.expectations {
		if minimock.Equal(e.params, mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params) {
			mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params)
		}
	}

	return mmGetPaginatedPipelineRunsByRequester
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{}
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs{}
	}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsByRequester
}

// ExpectParamsParam2 sets up expected param params for Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) ExpectParamsParam2(params mm_repository.GetPipelineRunsByRequesterParams) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{}
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs{}
	}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs.params = &params
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsByRequester
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Inspect(f func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams)) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.inspectFuncGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPaginatedPipelineRunsByRequester")
	}

	mmGetPaginatedPipelineRunsByRequester.mock.inspectFuncGetPaginatedPipelineRunsByRequester = f

	return mmGetPaginatedPipelineRunsByRequester
}

// Return sets up results that will be returned by Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Return(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{mock: mmGetPaginatedPipelineRunsByRequester.mock}
	}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.results = &RepositoryMockGetPaginatedPipelineRunsByRequesterResults{pa1, i1, err}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsByRequester.mock
}

// Set uses given function f to mock the Repository.GetPaginatedPipelineRunsByRequester method
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Set(f func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) (pa1 []datamodel.PipelineRun, i1 int64, err error)) *RepositoryMock {
	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Default expectation is already set for the Repository.GetPaginatedPipelineRunsByRequester method")
	}

	if len(mmGetPaginatedPipelineRunsByRequester.expectations) > 0 {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Some expectations are already set for the Repository.GetPaginatedPipelineRunsByRequester method")
	}

	mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester = f
	mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequesterOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsByRequester.mock
}

// When sets expectation for the Repository.GetPaginatedPipelineRunsByRequester which will trigger the result defined by the following
// Then helper
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) When(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) *RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	expectation := &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{
		mock:               mmGetPaginatedPipelineRunsByRequester.mock,
		params:             &RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params},
		expectationOrigins: RepositoryMockGetPaginatedPipelineRunsByRequesterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPaginatedPipelineRunsByRequester.expectations = append(mmGetPaginatedPipelineRunsByRequester.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPaginatedPipelineRunsByRequester return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation) Then(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPaginatedPipelineRunsByRequesterResults{pa1, i1, err}
	return e.mock
}

// Times sets number of times Repository.GetPaginatedPipelineRunsByRequester should be invoked
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Times(n uint64) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if n == 0 {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Times of RepositoryMock.GetPaginatedPipelineRunsByRequester mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPaginatedPipelineRunsByRequester.expectedInvocations, n)
	mmGetPaginatedPipelineRunsByRequester.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsByRequester
}

func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) invocationsDone() bool {
	if len(mmGetPaginatedPipelineRunsByRequester.expectations) == 0 && mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil && mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.mock.afterGetPaginatedPipelineRunsByRequesterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPaginatedPipelineRunsByRequester implements mm_repository.Repository
func (mmGetPaginatedPipelineRunsByRequester *RepositoryMock) GetPaginatedPipelineRunsByRequester(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) (pa1 []datamodel.PipelineRun, i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsByRequester.beforeGetPaginatedPipelineRunsByRequesterCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsByRequester.afterGetPaginatedPipelineRunsByRequesterCounter, 1)

	mmGetPaginatedPipelineRunsByRequester.t.Helper()

	if mmGetPaginatedPipelineRunsByRequester.inspectFuncGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.inspectFuncGetPaginatedPipelineRunsByRequester(ctx, params)
	}

	mm_params := RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params}

	// Record call args
	mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.mutex.Lock()
	mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.callArgs = append(mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.callArgs, &mm_params)
	mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.mutex.Unlock()

	for _, e := range mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.i1, e.results.err
		}
	}

	if mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.params
		mm_want_ptrs := mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPaginatedPipelineRunsByRequester.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsByRequester got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetPaginatedPipelineRunsByRequester.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsByRequester got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPaginatedPipelineRunsByRequester.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsByRequester got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPaginatedPipelineRunsByRequester.t.Fatal("No results are set for the RepositoryMock.GetPaginatedPipelineRunsByRequester")
		}
		return (*mm_results).pa1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetPaginatedPipelineRunsByRequester.funcGetPaginatedPipelineRunsByRequester != nil {
		return mmGetPaginatedPipelineRunsByRequester.funcGetPaginatedPipelineRunsByRequester(ctx, params)
	}
	mmGetPaginatedPipelineRunsByRequester.t.Fatalf("Unexpected call to RepositoryMock.GetPaginatedPipelineRunsByRequester. %v %v", ctx, params)
	return
}

// GetPaginatedPipelineRunsByRequesterAfterCounter returns a count of finished RepositoryMock.GetPaginatedPipelineRunsByRequester invocations
func (mmGetPaginatedPipelineRunsByRequester *RepositoryMock) GetPaginatedPipelineRunsByRequesterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.afterGetPaginatedPipelineRunsByRequesterCounter)
}

// GetPaginatedPipelineRunsByRequesterBeforeCounter returns a count of RepositoryMock.GetPaginatedPipelineRunsByRequester invocations
func (mmGetPaginatedPipelineRunsByRequester *RepositoryMock) GetPaginatedPipelineRunsByRequesterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.beforeGetPaginatedPipelineRunsByRequesterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPaginatedPipelineRunsByRequester.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Calls() []*RepositoryMockGetPaginatedPipelineRunsByRequesterParams {
	mmGetPaginatedPipelineRunsByRequester.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPaginatedPipelineRunsByRequesterParams, len(mmGetPaginatedPipelineRunsByRequester.callArgs))
	copy(argCopy, mmGetPaginatedPipelineRunsByRequester.callArgs)

	mmGetPaginatedPipelineRunsByRequester.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaginatedPipelineRunsByRequesterDone returns true if the count of the GetPaginatedPipelineRunsByRequester invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsByRequesterDone() bool {
	if m.GetPaginatedPipelineRunsByRequesterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaginatedPipelineRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaginatedPipelineRunsByRequesterMock.invocationsDone()
}

// MinimockGetPaginatedPipelineRunsByRequesterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsByRequesterInspect() {
	for _, e := range m.GetPaginatedPipelineRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaginatedPipelineRunsByRequesterCounter := mm_atomic.LoadUint64(&m.afterGetPaginatedPipelineRunsByRequesterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation != nil && afterGetPaginatedPipelineRunsByRequesterCounter < 1 {
		if m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s", m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s with params: %#v", m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPaginatedPipelineRunsByRequester != nil && afterGetPaginatedPipelineRunsByRequesterCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s", m.funcGetPaginatedPipelineRunsByRequesterOrigin)
	}

	if !m.GetPaginatedPipelineRunsByRequesterMock.invocationsDone() && afterGetPaginatedPipelineRunsByRequesterCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaginatedPipelineRunsByRequesterMock.expectedInvocations), m.GetPaginatedPipelineRunsByRequesterMock.expectedInvocationsOrigin, afterGetPaginatedPipelineRunsByRequesterCounter)
	}
}

type mRepositoryMockGetPaginatedPipelineRunsWithPermissions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation
	expectations       []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation

	callArgs []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation specifies expectation struct of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams
	paramPtrs          *RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs
	expectationOrigins RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectationOrigins
	results            *RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams contains parameters of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams struct {
	ctx          context.Context
	requesterUID string
	pipelineUID  string
	page         int
	pageSize     int
	filter       filtering.Filter
	order        ordering.OrderBy
	isOwner      bool
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs contains pointers to parameters of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs struct {
	ctx          *context.Context
	requesterUID *string
	pipelineUID  *string
	page         *int
	pageSize     *int
	filter       *filtering.Filter
	order        *ordering.OrderBy
	isOwner      *bool
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults contains results of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults struct {
	pa1 []datamodel.PipelineRun
	i1  int64
	err error
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsOrigins contains origins of expectations of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectationOrigins struct {
	origin             string
	originCtx          string
	originRequesterUID string
	originPipelineUID  string
	originPage         string
	originPageSize     string
	originFilter       string
	originOrder        string
	originIsOwner      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Optional() *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	mmGetPaginatedPipelineRunsWithPermissions.optional = true
	return mmGetPaginatedPipelineRunsWithPermissions
}

// Expect sets up expected params for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Expect(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by ExpectParams functions")
	}

	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPaginatedPipelineRunsWithPermissions.expectations {
		if minimock.Equal(e.params, mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params) {
			mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params)
		}
	}

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectRequesterUIDParam2 sets up expected param requesterUID for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectRequesterUIDParam2(requesterUID string) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.requesterUID = &requesterUID
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originRequesterUID = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectPipelineUIDParam3(pipelineUID string) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectPageParam4 sets up expected param page for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectPageParam4(page int) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.page = &page
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectPageSizeParam5 sets up expected param pageSize for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectPageSizeParam5(pageSize int) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectFilterParam6 sets up expected param filter for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectFilterParam6(filter filtering.Filter) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.filter = &filter
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectOrderParam7 sets up expected param order for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectOrderParam7(order ordering.OrderBy) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.order = &order
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectIsOwnerParam8 sets up expected param isOwner for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectIsOwnerParam8(isOwner bool) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.isOwner = &isOwner
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originIsOwner = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Inspect(f func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool)) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.inspectFuncGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPaginatedPipelineRunsWithPermissions")
	}

	mmGetPaginatedPipelineRunsWithPermissions.mock.inspectFuncGetPaginatedPipelineRunsWithPermissions = f

	return mmGetPaginatedPipelineRunsWithPermissions
}

// Return sets up results that will be returned by Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Return(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{mock: mmGetPaginatedPipelineRunsWithPermissions.mock}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.results = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults{pa1, i1, err}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsWithPermissions.mock
}

// Set uses given function f to mock the Repository.GetPaginatedPipelineRunsWithPermissions method
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Set(f func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) (pa1 []datamodel.PipelineRun, i1 int64, err error)) *RepositoryMock {
	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Default expectation is already set for the Repository.GetPaginatedPipelineRunsWithPermissions method")
	}

	if len(mmGetPaginatedPipelineRunsWithPermissions.expectations) > 0 {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Some expectations are already set for the Repository.GetPaginatedPipelineRunsWithPermissions method")
	}

	mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions = f
	mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissionsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsWithPermissions.mock
}

// When sets expectation for the Repository.GetPaginatedPipelineRunsWithPermissions which will trigger the result defined by the following
// Then helper
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) When(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) *RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	expectation := &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{
		mock:               mmGetPaginatedPipelineRunsWithPermissions.mock,
		params:             &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner},
		expectationOrigins: RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPaginatedPipelineRunsWithPermissions.expectations = append(mmGetPaginatedPipelineRunsWithPermissions.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPaginatedPipelineRunsWithPermissions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation) Then(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults{pa1, i1, err}
	return e.mock
}

// Times sets number of times Repository.GetPaginatedPipelineRunsWithPermissions should be invoked
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Times(n uint64) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if n == 0 {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Times of RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPaginatedPipelineRunsWithPermissions.expectedInvocations, n)
	mmGetPaginatedPipelineRunsWithPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsWithPermissions
}

func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) invocationsDone() bool {
	if len(mmGetPaginatedPipelineRunsWithPermissions.expectations) == 0 && mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil && mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.mock.afterGetPaginatedPipelineRunsWithPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPaginatedPipelineRunsWithPermissions implements mm_repository.Repository
func (mmGetPaginatedPipelineRunsWithPermissions *RepositoryMock) GetPaginatedPipelineRunsWithPermissions(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) (pa1 []datamodel.PipelineRun, i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsWithPermissions.beforeGetPaginatedPipelineRunsWithPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsWithPermissions.afterGetPaginatedPipelineRunsWithPermissionsCounter, 1)

	mmGetPaginatedPipelineRunsWithPermissions.t.Helper()

	if mmGetPaginatedPipelineRunsWithPermissions.inspectFuncGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.inspectFuncGetPaginatedPipelineRunsWithPermissions(ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner)
	}

	mm_params := RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner}

	// Record call args
	mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.mutex.Lock()
	mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.callArgs = append(mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.callArgs, &mm_params)
	mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.mutex.Unlock()

	for _, e := range mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.i1, e.results.err
		}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.requesterUID != nil && !minimock.Equal(*mm_want_ptrs.requesterUID, mm_got.requesterUID) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter requesterUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originRequesterUID, *mm_want_ptrs.requesterUID, mm_got.requesterUID, minimock.Diff(*mm_want_ptrs.requesterUID, mm_got.requesterUID))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.isOwner != nil && !minimock.Equal(*mm_want_ptrs.isOwner, mm_got.isOwner) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter isOwner, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originIsOwner, *mm_want_ptrs.isOwner, mm_got.isOwner, minimock.Diff(*mm_want_ptrs.isOwner, mm_got.isOwner))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPaginatedPipelineRunsWithPermissions.t.Fatal("No results are set for the RepositoryMock.GetPaginatedPipelineRunsWithPermissions")
		}
		return (*mm_results).pa1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetPaginatedPipelineRunsWithPermissions.funcGetPaginatedPipelineRunsWithPermissions != nil {
		return mmGetPaginatedPipelineRunsWithPermissions.funcGetPaginatedPipelineRunsWithPermissions(ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner)
	}
	mmGetPaginatedPipelineRunsWithPermissions.t.Fatalf("Unexpected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions. %v %v %v %v %v %v %v %v", ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner)
	return
}

// GetPaginatedPipelineRunsWithPermissionsAfterCounter returns a count of finished RepositoryMock.GetPaginatedPipelineRunsWithPermissions invocations
func (mmGetPaginatedPipelineRunsWithPermissions *RepositoryMock) GetPaginatedPipelineRunsWithPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.afterGetPaginatedPipelineRunsWithPermissionsCounter)
}

// GetPaginatedPipelineRunsWithPermissionsBeforeCounter returns a count of RepositoryMock.GetPaginatedPipelineRunsWithPermissions invocations
func (mmGetPaginatedPipelineRunsWithPermissions *RepositoryMock) GetPaginatedPipelineRunsWithPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.beforeGetPaginatedPipelineRunsWithPermissionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Calls() []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams {
	mmGetPaginatedPipelineRunsWithPermissions.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams, len(mmGetPaginatedPipelineRunsWithPermissions.callArgs))
	copy(argCopy, mmGetPaginatedPipelineRunsWithPermissions.callArgs)

	mmGetPaginatedPipelineRunsWithPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaginatedPipelineRunsWithPermissionsDone returns true if the count of the GetPaginatedPipelineRunsWithPermissions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsWithPermissionsDone() bool {
	if m.GetPaginatedPipelineRunsWithPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaginatedPipelineRunsWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaginatedPipelineRunsWithPermissionsMock.invocationsDone()
}

// MinimockGetPaginatedPipelineRunsWithPermissionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsWithPermissionsInspect() {
	for _, e := range m.GetPaginatedPipelineRunsWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaginatedPipelineRunsWithPermissionsCounter := mm_atomic.LoadUint64(&m.afterGetPaginatedPipelineRunsWithPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation != nil && afterGetPaginatedPipelineRunsWithPermissionsCounter < 1 {
		if m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s", m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s with params: %#v", m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPaginatedPipelineRunsWithPermissions != nil && afterGetPaginatedPipelineRunsWithPermissionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s", m.funcGetPaginatedPipelineRunsWithPermissionsOrigin)
	}

	if !m.GetPaginatedPipelineRunsWithPermissionsMock.invocationsDone() && afterGetPaginatedPipelineRunsWithPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaginatedPipelineRunsWithPermissionsMock.expectedInvocations), m.GetPaginatedPipelineRunsWithPermissionsMock.expectedInvocationsOrigin, afterGetPaginatedPipelineRunsWithPermissionsCounter)
	}
}

type mRepositoryMockGetPipelineByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByIDExpectation
	expectations       []*RepositoryMockGetPipelineByIDExpectation

	callArgs []*RepositoryMockGetPipelineByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineByIDExpectation specifies expectation struct of the Repository.GetPipelineByID
type RepositoryMockGetPipelineByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineByIDParams
	paramPtrs          *RepositoryMockGetPipelineByIDParamPtrs
	expectationOrigins RepositoryMockGetPipelineByIDExpectationOrigins
	results            *RepositoryMockGetPipelineByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineByIDParams contains parameters of the Repository.GetPipelineByID
type RepositoryMockGetPipelineByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	isBasicView    bool
	embedReleases  bool
}

// RepositoryMockGetPipelineByIDParamPtrs contains pointers to parameters of the Repository.GetPipelineByID
type RepositoryMockGetPipelineByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	isBasicView    *bool
	embedReleases  *bool
}

// RepositoryMockGetPipelineByIDResults contains results of the Repository.GetPipelineByID
type RepositoryMockGetPipelineByIDResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// RepositoryMockGetPipelineByIDOrigins contains origins of expectations of the Repository.GetPipelineByID
type RepositoryMockGetPipelineByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originIsBasicView    string
	originEmbedReleases  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) Optional() *mRepositoryMockGetPipelineByID {
	mmGetPipelineByID.optional = true
	return mmGetPipelineByID
}

// Expect sets up expected params for Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) Expect(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByID {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	if mmGetPipelineByID.defaultExpectation == nil {
		mmGetPipelineByID.defaultExpectation = &RepositoryMockGetPipelineByIDExpectation{}
	}

	if mmGetPipelineByID.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by ExpectParams functions")
	}

	mmGetPipelineByID.defaultExpectation.params = &RepositoryMockGetPipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}
	mmGetPipelineByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineByID.expectations {
		if minimock.Equal(e.params, mmGetPipelineByID.defaultExpectation.params) {
			mmGetPipelineByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByID.defaultExpectation.params)
		}
	}

	return mmGetPipelineByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByID {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	if mmGetPipelineByID.defaultExpectation == nil {
		mmGetPipelineByID.defaultExpectation = &RepositoryMockGetPipelineByIDExpectation{}
	}

	if mmGetPipelineByID.defaultExpectation.params != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Expect")
	}

	if mmGetPipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDParamPtrs{}
	}
	mmGetPipelineByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetPipelineByID {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	if mmGetPipelineByID.defaultExpectation == nil {
		mmGetPipelineByID.defaultExpectation = &RepositoryMockGetPipelineByIDExpectation{}
	}

	if mmGetPipelineByID.defaultExpectation.params != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Expect")
	}

	if mmGetPipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDParamPtrs{}
	}
	mmGetPipelineByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetPipelineByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetPipelineByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) ExpectIdParam3(id string) *mRepositoryMockGetPipelineByID {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	if mmGetPipelineByID.defaultExpectation == nil {
		mmGetPipelineByID.defaultExpectation = &RepositoryMockGetPipelineByIDExpectation{}
	}

	if mmGetPipelineByID.defaultExpectation.params != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Expect")
	}

	if mmGetPipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDParamPtrs{}
	}
	mmGetPipelineByID.defaultExpectation.paramPtrs.id = &id
	mmGetPipelineByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPipelineByID
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetPipelineByID {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	if mmGetPipelineByID.defaultExpectation == nil {
		mmGetPipelineByID.defaultExpectation = &RepositoryMockGetPipelineByIDExpectation{}
	}

	if mmGetPipelineByID.defaultExpectation.params != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Expect")
	}

	if mmGetPipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDParamPtrs{}
	}
	mmGetPipelineByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineByID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineByID
}

// ExpectEmbedReleasesParam5 sets up expected param embedReleases for Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) ExpectEmbedReleasesParam5(embedReleases bool) *mRepositoryMockGetPipelineByID {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	if mmGetPipelineByID.defaultExpectation == nil {
		mmGetPipelineByID.defaultExpectation = &RepositoryMockGetPipelineByIDExpectation{}
	}

	if mmGetPipelineByID.defaultExpectation.params != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Expect")
	}

	if mmGetPipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDParamPtrs{}
	}
	mmGetPipelineByID.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmGetPipelineByID.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmGetPipelineByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByID {
	if mmGetPipelineByID.mock.inspectFuncGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByID")
	}

	mmGetPipelineByID.mock.inspectFuncGetPipelineByID = f

	return mmGetPipelineByID
}

// Return sets up results that will be returned by Repository.GetPipelineByID
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	if mmGetPipelineByID.defaultExpectation == nil {
		mmGetPipelineByID.defaultExpectation = &RepositoryMockGetPipelineByIDExpectation{mock: mmGetPipelineByID.mock}
	}
	mmGetPipelineByID.defaultExpectation.results = &RepositoryMockGetPipelineByIDResults{pp1, err}
	mmGetPipelineByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByID.mock
}

// Set uses given function f to mock the Repository.GetPipelineByID method
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) Set(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByID.defaultExpectation != nil {
		mmGetPipelineByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByID method")
	}

	if len(mmGetPipelineByID.expectations) > 0 {
		mmGetPipelineByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByID method")
	}

	mmGetPipelineByID.mock.funcGetPipelineByID = f
	mmGetPipelineByID.mock.funcGetPipelineByIDOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByID.mock
}

// When sets expectation for the Repository.GetPipelineByID which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) When(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByIDExpectation {
	if mmGetPipelineByID.mock.funcGetPipelineByID != nil {
		mmGetPipelineByID.mock.t.Fatalf("RepositoryMock.GetPipelineByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByIDExpectation{
		mock:               mmGetPipelineByID.mock,
		params:             &RepositoryMockGetPipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases},
		expectationOrigins: RepositoryMockGetPipelineByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineByID.expectations = append(mmGetPipelineByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByIDExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByID should be invoked
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) Times(n uint64) *mRepositoryMockGetPipelineByID {
	if n == 0 {
		mmGetPipelineByID.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByID.expectedInvocations, n)
	mmGetPipelineByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByID
}

func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) invocationsDone() bool {
	if len(mmGetPipelineByID.expectations) == 0 && mmGetPipelineByID.defaultExpectation == nil && mmGetPipelineByID.mock.funcGetPipelineByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByID.mock.afterGetPipelineByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByID implements mm_repository.Repository
func (mmGetPipelineByID *RepositoryMock) GetPipelineByID(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByID.beforeGetPipelineByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByID.afterGetPipelineByIDCounter, 1)

	mmGetPipelineByID.t.Helper()

	if mmGetPipelineByID.inspectFuncGetPipelineByID != nil {
		mmGetPipelineByID.inspectFuncGetPipelineByID(ctx, ownerPermalink, id, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByID.GetPipelineByIDMock.mutex.Lock()
	mmGetPipelineByID.GetPipelineByIDMock.callArgs = append(mmGetPipelineByID.GetPipelineByIDMock.callArgs, &mm_params)
	mmGetPipelineByID.GetPipelineByIDMock.mutex.Unlock()

	for _, e := range mmGetPipelineByID.GetPipelineByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByID.t.Errorf("RepositoryMock.GetPipelineByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetPipelineByID.t.Errorf("RepositoryMock.GetPipelineByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPipelineByID.t.Errorf("RepositoryMock.GetPipelineByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByID.t.Errorf("RepositoryMock.GetPipelineByID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByID.t.Errorf("RepositoryMock.GetPipelineByID got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByID.t.Errorf("RepositoryMock.GetPipelineByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByID.GetPipelineByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByID.t.Fatal("No results are set for the RepositoryMock.GetPipelineByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByID.funcGetPipelineByID != nil {
		return mmGetPipelineByID.funcGetPipelineByID(ctx, ownerPermalink, id, isBasicView, embedReleases)
	}
	mmGetPipelineByID.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByID. %v %v %v %v %v", ctx, ownerPermalink, id, isBasicView, embedReleases)
	return
}

// GetPipelineByIDAfterCounter returns a count of finished RepositoryMock.GetPipelineByID invocations
func (mmGetPipelineByID *RepositoryMock) GetPipelineByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByID.afterGetPipelineByIDCounter)
}

// GetPipelineByIDBeforeCounter returns a count of RepositoryMock.GetPipelineByID invocations
func (mmGetPipelineByID *RepositoryMock) GetPipelineByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByID.beforeGetPipelineByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByID *mRepositoryMockGetPipelineByID) Calls() []*RepositoryMockGetPipelineByIDParams {
	mmGetPipelineByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByIDParams, len(mmGetPipelineByID.callArgs))
	copy(argCopy, mmGetPipelineByID.callArgs)

	mmGetPipelineByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByIDDone returns true if the count of the GetPipelineByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByIDDone() bool {
	if m.GetPipelineByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByIDMock.invocationsDone()
}

// MinimockGetPipelineByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByIDInspect() {
	for _, e := range m.GetPipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineByIDCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByIDMock.defaultExpectation != nil && afterGetPipelineByIDCounter < 1 {
		if m.GetPipelineByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByID at\n%s", m.GetPipelineByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByID at\n%s with params: %#v", m.GetPipelineByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByID != nil && afterGetPipelineByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineByID at\n%s", m.funcGetPipelineByIDOrigin)
	}

	if !m.GetPipelineByIDMock.invocationsDone() && afterGetPipelineByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByIDMock.expectedInvocations), m.GetPipelineByIDMock.expectedInvocationsOrigin, afterGetPipelineByIDCounter)
	}
}

type mRepositoryMockGetPipelineByIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByIDAdminExpectation
	expectations       []*RepositoryMockGetPipelineByIDAdminExpectation

	callArgs []*RepositoryMockGetPipelineByIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineByIDAdminExpectation specifies expectation struct of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineByIDAdminParams
	paramPtrs          *RepositoryMockGetPipelineByIDAdminParamPtrs
	expectationOrigins RepositoryMockGetPipelineByIDAdminExpectationOrigins
	results            *RepositoryMockGetPipelineByIDAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineByIDAdminParams contains parameters of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminParams struct {
	ctx           context.Context
	id            string
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByIDAdminParamPtrs contains pointers to parameters of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminParamPtrs struct {
	ctx           *context.Context
	id            *string
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByIDAdminResults contains results of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// RepositoryMockGetPipelineByIDAdminOrigins contains origins of expectations of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminExpectationOrigins struct {
	origin              string
	originCtx           string
	originId            string
	originIsBasicView   string
	originEmbedReleases string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Optional() *mRepositoryMockGetPipelineByIDAdmin {
	mmGetPipelineByIDAdmin.optional = true
	return mmGetPipelineByIDAdmin
}

// Expect sets up expected params for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Expect(ctx context.Context, id string, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetPipelineByIDAdmin.defaultExpectation.params = &RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineByIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetPipelineByIDAdmin.defaultExpectation.params) {
			mmGetPipelineByIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetPipelineByIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// ExpectIdParam2 sets up expected param id for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectIdParam2(id string) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.id = &id
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Inspect(f func(ctx context.Context, id string, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.inspectFuncGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByIDAdmin")
	}

	mmGetPipelineByIDAdmin.mock.inspectFuncGetPipelineByIDAdmin = f

	return mmGetPipelineByIDAdmin
}

// Return sets up results that will be returned by Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{mock: mmGetPipelineByIDAdmin.mock}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.results = &RepositoryMockGetPipelineByIDAdminResults{pp1, err}
	mmGetPipelineByIDAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetPipelineByIDAdmin method
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Set(f func(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByIDAdmin.defaultExpectation != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByIDAdmin method")
	}

	if len(mmGetPipelineByIDAdmin.expectations) > 0 {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByIDAdmin method")
	}

	mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin = f
	mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdminOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByIDAdmin.mock
}

// When sets expectation for the Repository.GetPipelineByIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) When(ctx context.Context, id string, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByIDAdminExpectation {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByIDAdminExpectation{
		mock:               mmGetPipelineByIDAdmin.mock,
		params:             &RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases},
		expectationOrigins: RepositoryMockGetPipelineByIDAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineByIDAdmin.expectations = append(mmGetPipelineByIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByIDAdminExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByIDAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByIDAdmin should be invoked
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Times(n uint64) *mRepositoryMockGetPipelineByIDAdmin {
	if n == 0 {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByIDAdmin.expectedInvocations, n)
	mmGetPipelineByIDAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByIDAdmin
}

func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) invocationsDone() bool {
	if len(mmGetPipelineByIDAdmin.expectations) == 0 && mmGetPipelineByIDAdmin.defaultExpectation == nil && mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.mock.afterGetPipelineByIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByIDAdmin implements mm_repository.Repository
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdmin(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.beforeGetPipelineByIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.afterGetPipelineByIDAdminCounter, 1)

	mmGetPipelineByIDAdmin.t.Helper()

	if mmGetPipelineByIDAdmin.inspectFuncGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.inspectFuncGetPipelineByIDAdmin(ctx, id, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.mutex.Lock()
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.callArgs = append(mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.callArgs, &mm_params)
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.mutex.Unlock()

	for _, e := range mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetPipelineByIDAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByIDAdmin.funcGetPipelineByIDAdmin != nil {
		return mmGetPipelineByIDAdmin.funcGetPipelineByIDAdmin(ctx, id, isBasicView, embedReleases)
	}
	mmGetPipelineByIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByIDAdmin. %v %v %v %v", ctx, id, isBasicView, embedReleases)
	return
}

// GetPipelineByIDAdminAfterCounter returns a count of finished RepositoryMock.GetPipelineByIDAdmin invocations
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.afterGetPipelineByIDAdminCounter)
}

// GetPipelineByIDAdminBeforeCounter returns a count of RepositoryMock.GetPipelineByIDAdmin invocations
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.beforeGetPipelineByIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Calls() []*RepositoryMockGetPipelineByIDAdminParams {
	mmGetPipelineByIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByIDAdminParams, len(mmGetPipelineByIDAdmin.callArgs))
	copy(argCopy, mmGetPipelineByIDAdmin.callArgs)

	mmGetPipelineByIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByIDAdminDone returns true if the count of the GetPipelineByIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByIDAdminDone() bool {
	if m.GetPipelineByIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByIDAdminMock.invocationsDone()
}

// MinimockGetPipelineByIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByIDAdminInspect() {
	for _, e := range m.GetPipelineByIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineByIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByIDAdminMock.defaultExpectation != nil && afterGetPipelineByIDAdminCounter < 1 {
		if m.GetPipelineByIDAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s", m.GetPipelineByIDAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s with params: %#v", m.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineByIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByIDAdmin != nil && afterGetPipelineByIDAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s", m.funcGetPipelineByIDAdminOrigin)
	}

	if !m.GetPipelineByIDAdminMock.invocationsDone() && afterGetPipelineByIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByIDAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByIDAdminMock.expectedInvocations), m.GetPipelineByIDAdminMock.expectedInvocationsOrigin, afterGetPipelineByIDAdminCounter)
	}
}

type mRepositoryMockGetPipelineByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByUIDExpectation
	expectations       []*RepositoryMockGetPipelineByUIDExpectation

	callArgs []*RepositoryMockGetPipelineByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineByUIDExpectation specifies expectation struct of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineByUIDParams
	paramPtrs          *RepositoryMockGetPipelineByUIDParamPtrs
	expectationOrigins RepositoryMockGetPipelineByUIDExpectationOrigins
	results            *RepositoryMockGetPipelineByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineByUIDParams contains parameters of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByUIDParamPtrs contains pointers to parameters of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByUIDResults contains results of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// RepositoryMockGetPipelineByUIDOrigins contains origins of expectations of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDExpectationOrigins struct {
	origin              string
	originCtx           string
	originUid           string
	originIsBasicView   string
	originEmbedReleases string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Optional() *mRepositoryMockGetPipelineByUID {
	mmGetPipelineByUID.optional = true
	return mmGetPipelineByUID
}

// Expect sets up expected params for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by ExpectParams functions")
	}

	mmGetPipelineByUID.defaultExpectation.params = &RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineByUID.expectations {
		if minimock.Equal(e.params, mmGetPipelineByUID.defaultExpectation.params) {
			mmGetPipelineByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByUID.defaultExpectation.params)
		}
	}

	return mmGetPipelineByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.inspectFuncGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByUID")
	}

	mmGetPipelineByUID.mock.inspectFuncGetPipelineByUID = f

	return mmGetPipelineByUID
}

// Return sets up results that will be returned by Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{mock: mmGetPipelineByUID.mock}
	}
	mmGetPipelineByUID.defaultExpectation.results = &RepositoryMockGetPipelineByUIDResults{pp1, err}
	mmGetPipelineByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUID.mock
}

// Set uses given function f to mock the Repository.GetPipelineByUID method
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByUID.defaultExpectation != nil {
		mmGetPipelineByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByUID method")
	}

	if len(mmGetPipelineByUID.expectations) > 0 {
		mmGetPipelineByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByUID method")
	}

	mmGetPipelineByUID.mock.funcGetPipelineByUID = f
	mmGetPipelineByUID.mock.funcGetPipelineByUIDOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUID.mock
}

// When sets expectation for the Repository.GetPipelineByUID which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) When(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByUIDExpectation {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByUIDExpectation{
		mock:               mmGetPipelineByUID.mock,
		params:             &RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases},
		expectationOrigins: RepositoryMockGetPipelineByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineByUID.expectations = append(mmGetPipelineByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByUIDExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByUIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByUID should be invoked
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Times(n uint64) *mRepositoryMockGetPipelineByUID {
	if n == 0 {
		mmGetPipelineByUID.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByUID.expectedInvocations, n)
	mmGetPipelineByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUID
}

func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) invocationsDone() bool {
	if len(mmGetPipelineByUID.expectations) == 0 && mmGetPipelineByUID.defaultExpectation == nil && mmGetPipelineByUID.mock.funcGetPipelineByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUID.mock.afterGetPipelineByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByUID implements mm_repository.Repository
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUID(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByUID.beforeGetPipelineByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByUID.afterGetPipelineByUIDCounter, 1)

	mmGetPipelineByUID.t.Helper()

	if mmGetPipelineByUID.inspectFuncGetPipelineByUID != nil {
		mmGetPipelineByUID.inspectFuncGetPipelineByUID(ctx, uid, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByUID.GetPipelineByUIDMock.mutex.Lock()
	mmGetPipelineByUID.GetPipelineByUIDMock.callArgs = append(mmGetPipelineByUID.GetPipelineByUIDMock.callArgs, &mm_params)
	mmGetPipelineByUID.GetPipelineByUIDMock.mutex.Unlock()

	for _, e := range mmGetPipelineByUID.GetPipelineByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByUID.t.Fatal("No results are set for the RepositoryMock.GetPipelineByUID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByUID.funcGetPipelineByUID != nil {
		return mmGetPipelineByUID.funcGetPipelineByUID(ctx, uid, isBasicView, embedReleases)
	}
	mmGetPipelineByUID.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByUID. %v %v %v %v", ctx, uid, isBasicView, embedReleases)
	return
}

// GetPipelineByUIDAfterCounter returns a count of finished RepositoryMock.GetPipelineByUID invocations
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUID.afterGetPipelineByUIDCounter)
}

// GetPipelineByUIDBeforeCounter returns a count of RepositoryMock.GetPipelineByUID invocations
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUID.beforeGetPipelineByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Calls() []*RepositoryMockGetPipelineByUIDParams {
	mmGetPipelineByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByUIDParams, len(mmGetPipelineByUID.callArgs))
	copy(argCopy, mmGetPipelineByUID.callArgs)

	mmGetPipelineByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByUIDDone returns true if the count of the GetPipelineByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByUIDDone() bool {
	if m.GetPipelineByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByUIDMock.invocationsDone()
}

// MinimockGetPipelineByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByUIDInspect() {
	for _, e := range m.GetPipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineByUIDCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByUIDMock.defaultExpectation != nil && afterGetPipelineByUIDCounter < 1 {
		if m.GetPipelineByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s", m.GetPipelineByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s with params: %#v", m.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByUID != nil && afterGetPipelineByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s", m.funcGetPipelineByUIDOrigin)
	}

	if !m.GetPipelineByUIDMock.invocationsDone() && afterGetPipelineByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByUIDMock.expectedInvocations), m.GetPipelineByUIDMock.expectedInvocationsOrigin, afterGetPipelineByUIDCounter)
	}
}

type mRepositoryMockGetPipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineReleaseByIDExpectation
	expectations       []*RepositoryMockGetPipelineReleaseByIDExpectation

	callArgs []*RepositoryMockGetPipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineReleaseByIDExpectation specifies expectation struct of the Repository.GetPipelineReleaseByID
type RepositoryMockGetPipelineReleaseByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineReleaseByIDParams
	paramPtrs          *RepositoryMockGetPipelineReleaseByIDParamPtrs
	expectationOrigins RepositoryMockGetPipelineReleaseByIDExpectationOrigins
	results            *RepositoryMockGetPipelineReleaseByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineReleaseByIDParams contains parameters of the Repository.GetPipelineReleaseByID
type RepositoryMockGetPipelineReleaseByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
	isBasicView    bool
}

// RepositoryMockGetPipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.GetPipelineReleaseByID
type RepositoryMockGetPipelineReleaseByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
	isBasicView    *bool
}

// RepositoryMockGetPipelineReleaseByIDResults contains results of the Repository.GetPipelineReleaseByID
type RepositoryMockGetPipelineReleaseByIDResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// RepositoryMockGetPipelineReleaseByIDOrigins contains origins of expectations of the Repository.GetPipelineReleaseByID
type RepositoryMockGetPipelineReleaseByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originId             string
	originIsBasicView    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) Optional() *mRepositoryMockGetPipelineReleaseByID {
	mmGetPipelineReleaseByID.optional = true
	return mmGetPipelineReleaseByID
}

// Expect sets up expected params for Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) *mRepositoryMockGetPipelineReleaseByID {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	if mmGetPipelineReleaseByID.defaultExpectation == nil {
		mmGetPipelineReleaseByID.defaultExpectation = &RepositoryMockGetPipelineReleaseByIDExpectation{}
	}

	if mmGetPipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmGetPipelineReleaseByID.defaultExpectation.params = &RepositoryMockGetPipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}
	mmGetPipelineReleaseByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmGetPipelineReleaseByID.defaultExpectation.params) {
			mmGetPipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmGetPipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineReleaseByID {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	if mmGetPipelineReleaseByID.defaultExpectation == nil {
		mmGetPipelineReleaseByID.defaultExpectation = &RepositoryMockGetPipelineReleaseByIDExpectation{}
	}

	if mmGetPipelineReleaseByID.defaultExpectation.params != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Expect")
	}

	if mmGetPipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByIDParamPtrs{}
	}
	mmGetPipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineReleaseByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetPipelineReleaseByID {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	if mmGetPipelineReleaseByID.defaultExpectation == nil {
		mmGetPipelineReleaseByID.defaultExpectation = &RepositoryMockGetPipelineReleaseByIDExpectation{}
	}

	if mmGetPipelineReleaseByID.defaultExpectation.params != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Expect")
	}

	if mmGetPipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByIDParamPtrs{}
	}
	mmGetPipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetPipelineReleaseByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockGetPipelineReleaseByID {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	if mmGetPipelineReleaseByID.defaultExpectation == nil {
		mmGetPipelineReleaseByID.defaultExpectation = &RepositoryMockGetPipelineReleaseByIDExpectation{}
	}

	if mmGetPipelineReleaseByID.defaultExpectation.params != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Expect")
	}

	if mmGetPipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByIDParamPtrs{}
	}
	mmGetPipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmGetPipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockGetPipelineReleaseByID {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	if mmGetPipelineReleaseByID.defaultExpectation == nil {
		mmGetPipelineReleaseByID.defaultExpectation = &RepositoryMockGetPipelineReleaseByIDExpectation{}
	}

	if mmGetPipelineReleaseByID.defaultExpectation.params != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Expect")
	}

	if mmGetPipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByIDParamPtrs{}
	}
	mmGetPipelineReleaseByID.defaultExpectation.paramPtrs.id = &id
	mmGetPipelineReleaseByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByID
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockGetPipelineReleaseByID {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	if mmGetPipelineReleaseByID.defaultExpectation == nil {
		mmGetPipelineReleaseByID.defaultExpectation = &RepositoryMockGetPipelineReleaseByIDExpectation{}
	}

	if mmGetPipelineReleaseByID.defaultExpectation.params != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Expect")
	}

	if mmGetPipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByIDParamPtrs{}
	}
	mmGetPipelineReleaseByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineReleaseByID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool)) *mRepositoryMockGetPipelineReleaseByID {
	if mmGetPipelineReleaseByID.mock.inspectFuncGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineReleaseByID")
	}

	mmGetPipelineReleaseByID.mock.inspectFuncGetPipelineReleaseByID = f

	return mmGetPipelineReleaseByID
}

// Return sets up results that will be returned by Repository.GetPipelineReleaseByID
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	if mmGetPipelineReleaseByID.defaultExpectation == nil {
		mmGetPipelineReleaseByID.defaultExpectation = &RepositoryMockGetPipelineReleaseByIDExpectation{mock: mmGetPipelineReleaseByID.mock}
	}
	mmGetPipelineReleaseByID.defaultExpectation.results = &RepositoryMockGetPipelineReleaseByIDResults{pp1, err}
	mmGetPipelineReleaseByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.GetPipelineReleaseByID method
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetPipelineReleaseByID.defaultExpectation != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineReleaseByID method")
	}

	if len(mmGetPipelineReleaseByID.expectations) > 0 {
		mmGetPipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineReleaseByID method")
	}

	mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID = f
	mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByIDOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByID.mock
}

// When sets expectation for the Repository.GetPipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) *RepositoryMockGetPipelineReleaseByIDExpectation {
	if mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineReleaseByIDExpectation{
		mock:               mmGetPipelineReleaseByID.mock,
		params:             &RepositoryMockGetPipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView},
		expectationOrigins: RepositoryMockGetPipelineReleaseByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineReleaseByID.expectations = append(mmGetPipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineReleaseByIDExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineReleaseByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineReleaseByID should be invoked
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) Times(n uint64) *mRepositoryMockGetPipelineReleaseByID {
	if n == 0 {
		mmGetPipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.GetPipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineReleaseByID.expectedInvocations, n)
	mmGetPipelineReleaseByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByID
}

func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) invocationsDone() bool {
	if len(mmGetPipelineReleaseByID.expectations) == 0 && mmGetPipelineReleaseByID.defaultExpectation == nil && mmGetPipelineReleaseByID.mock.funcGetPipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineReleaseByID.mock.afterGetPipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineReleaseByID implements mm_repository.Repository
func (mmGetPipelineReleaseByID *RepositoryMock) GetPipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetPipelineReleaseByID.beforeGetPipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineReleaseByID.afterGetPipelineReleaseByIDCounter, 1)

	mmGetPipelineReleaseByID.t.Helper()

	if mmGetPipelineReleaseByID.inspectFuncGetPipelineReleaseByID != nil {
		mmGetPipelineReleaseByID.inspectFuncGetPipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, isBasicView)
	}

	mm_params := RepositoryMockGetPipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}

	// Record call args
	mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.mutex.Lock()
	mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.callArgs = append(mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.callArgs, &mm_params)
	mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineReleaseByID.t.Errorf("RepositoryMock.GetPipelineReleaseByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetPipelineReleaseByID.t.Errorf("RepositoryMock.GetPipelineReleaseByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetPipelineReleaseByID.t.Errorf("RepositoryMock.GetPipelineReleaseByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPipelineReleaseByID.t.Errorf("RepositoryMock.GetPipelineReleaseByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineReleaseByID.t.Errorf("RepositoryMock.GetPipelineReleaseByID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineReleaseByID.t.Errorf("RepositoryMock.GetPipelineReleaseByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineReleaseByID.GetPipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.GetPipelineReleaseByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineReleaseByID.funcGetPipelineReleaseByID != nil {
		return mmGetPipelineReleaseByID.funcGetPipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, isBasicView)
	}
	mmGetPipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineReleaseByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, isBasicView)
	return
}

// GetPipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.GetPipelineReleaseByID invocations
func (mmGetPipelineReleaseByID *RepositoryMock) GetPipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineReleaseByID.afterGetPipelineReleaseByIDCounter)
}

// GetPipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.GetPipelineReleaseByID invocations
func (mmGetPipelineReleaseByID *RepositoryMock) GetPipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineReleaseByID.beforeGetPipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineReleaseByID *mRepositoryMockGetPipelineReleaseByID) Calls() []*RepositoryMockGetPipelineReleaseByIDParams {
	mmGetPipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineReleaseByIDParams, len(mmGetPipelineReleaseByID.callArgs))
	copy(argCopy, mmGetPipelineReleaseByID.callArgs)

	mmGetPipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineReleaseByIDDone returns true if the count of the GetPipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineReleaseByIDDone() bool {
	if m.GetPipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineReleaseByIDMock.invocationsDone()
}

// MinimockGetPipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineReleaseByIDInspect() {
	for _, e := range m.GetPipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterGetPipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineReleaseByIDMock.defaultExpectation != nil && afterGetPipelineReleaseByIDCounter < 1 {
		if m.GetPipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByID at\n%s", m.GetPipelineReleaseByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByID at\n%s with params: %#v", m.GetPipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineReleaseByID != nil && afterGetPipelineReleaseByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByID at\n%s", m.funcGetPipelineReleaseByIDOrigin)
	}

	if !m.GetPipelineReleaseByIDMock.invocationsDone() && afterGetPipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineReleaseByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineReleaseByIDMock.expectedInvocations), m.GetPipelineReleaseByIDMock.expectedInvocationsOrigin, afterGetPipelineReleaseByIDCounter)
	}
}

type mRepositoryMockGetPipelineReleaseByUIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineReleaseByUIDAdminExpectation
	expectations       []*RepositoryMockGetPipelineReleaseByUIDAdminExpectation

	callArgs []*RepositoryMockGetPipelineReleaseByUIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineReleaseByUIDAdminExpectation specifies expectation struct of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineReleaseByUIDAdminParams
	paramPtrs          *RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs
	expectationOrigins RepositoryMockGetPipelineReleaseByUIDAdminExpectationOrigins
	results            *RepositoryMockGetPipelineReleaseByUIDAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineReleaseByUIDAdminParams contains parameters of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminParams struct {
	ctx         context.Context
	uid         uuid.UUID
	isBasicView bool
}

// RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs contains pointers to parameters of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs struct {
	ctx         *context.Context
	uid         *uuid.UUID
	isBasicView *bool
}

// RepositoryMockGetPipelineReleaseByUIDAdminResults contains results of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// RepositoryMockGetPipelineReleaseByUIDAdminOrigins contains origins of expectations of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminExpectationOrigins struct {
	origin            string
	originCtx         string
	originUid         string
	originIsBasicView string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Optional() *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	mmGetPipelineReleaseByUIDAdmin.optional = true
	return mmGetPipelineReleaseByUIDAdmin
}

// Expect sets up expected params for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params = &RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineReleaseByUIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params) {
			mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetPipelineReleaseByUIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs{}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByUIDAdmin
}

// ExpectUidParam2 sets up expected param uid for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs{}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs.uid = &uid
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByUIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs{}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByUIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool)) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.inspectFuncGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineReleaseByUIDAdmin")
	}

	mmGetPipelineReleaseByUIDAdmin.mock.inspectFuncGetPipelineReleaseByUIDAdmin = f

	return mmGetPipelineReleaseByUIDAdmin
}

// Return sets up results that will be returned by Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{mock: mmGetPipelineReleaseByUIDAdmin.mock}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.results = &RepositoryMockGetPipelineReleaseByUIDAdminResults{pp1, err}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByUIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetPipelineReleaseByUIDAdmin method
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineReleaseByUIDAdmin method")
	}

	if len(mmGetPipelineReleaseByUIDAdmin.expectations) > 0 {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineReleaseByUIDAdmin method")
	}

	mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin = f
	mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdminOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByUIDAdmin.mock
}

// When sets expectation for the Repository.GetPipelineReleaseByUIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) When(ctx context.Context, uid uuid.UUID, isBasicView bool) *RepositoryMockGetPipelineReleaseByUIDAdminExpectation {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{
		mock:               mmGetPipelineReleaseByUIDAdmin.mock,
		params:             &RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView},
		expectationOrigins: RepositoryMockGetPipelineReleaseByUIDAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineReleaseByUIDAdmin.expectations = append(mmGetPipelineReleaseByUIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineReleaseByUIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineReleaseByUIDAdminExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineReleaseByUIDAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineReleaseByUIDAdmin should be invoked
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Times(n uint64) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if n == 0 {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetPipelineReleaseByUIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineReleaseByUIDAdmin.expectedInvocations, n)
	mmGetPipelineReleaseByUIDAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByUIDAdmin
}

func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) invocationsDone() bool {
	if len(mmGetPipelineReleaseByUIDAdmin.expectations) == 0 && mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil && mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.mock.afterGetPipelineReleaseByUIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineReleaseByUIDAdmin implements mm_repository.Repository
func (mmGetPipelineReleaseByUIDAdmin *RepositoryMock) GetPipelineReleaseByUIDAdmin(ctx context.Context, uid uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetPipelineReleaseByUIDAdmin.beforeGetPipelineReleaseByUIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineReleaseByUIDAdmin.afterGetPipelineReleaseByUIDAdminCounter, 1)

	mmGetPipelineReleaseByUIDAdmin.t.Helper()

	if mmGetPipelineReleaseByUIDAdmin.inspectFuncGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.inspectFuncGetPipelineReleaseByUIDAdmin(ctx, uid, isBasicView)
	}

	mm_params := RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView}

	// Record call args
	mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.mutex.Lock()
	mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.callArgs = append(mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.callArgs, &mm_params)
	mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.mutex.Unlock()

	for _, e := range mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineReleaseByUIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetPipelineReleaseByUIDAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineReleaseByUIDAdmin.funcGetPipelineReleaseByUIDAdmin != nil {
		return mmGetPipelineReleaseByUIDAdmin.funcGetPipelineReleaseByUIDAdmin(ctx, uid, isBasicView)
	}
	mmGetPipelineReleaseByUIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineReleaseByUIDAdmin. %v %v %v", ctx, uid, isBasicView)
	return
}

// GetPipelineReleaseByUIDAdminAfterCounter returns a count of finished RepositoryMock.GetPipelineReleaseByUIDAdmin invocations
func (mmGetPipelineReleaseByUIDAdmin *RepositoryMock) GetPipelineReleaseByUIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.afterGetPipelineReleaseByUIDAdminCounter)
}

// GetPipelineReleaseByUIDAdminBeforeCounter returns a count of RepositoryMock.GetPipelineReleaseByUIDAdmin invocations
func (mmGetPipelineReleaseByUIDAdmin *RepositoryMock) GetPipelineReleaseByUIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.beforeGetPipelineReleaseByUIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineReleaseByUIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Calls() []*RepositoryMockGetPipelineReleaseByUIDAdminParams {
	mmGetPipelineReleaseByUIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineReleaseByUIDAdminParams, len(mmGetPipelineReleaseByUIDAdmin.callArgs))
	copy(argCopy, mmGetPipelineReleaseByUIDAdmin.callArgs)

	mmGetPipelineReleaseByUIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineReleaseByUIDAdminDone returns true if the count of the GetPipelineReleaseByUIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineReleaseByUIDAdminDone() bool {
	if m.GetPipelineReleaseByUIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineReleaseByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineReleaseByUIDAdminMock.invocationsDone()
}

// MinimockGetPipelineReleaseByUIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineReleaseByUIDAdminInspect() {
	for _, e := range m.GetPipelineReleaseByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineReleaseByUIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetPipelineReleaseByUIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineReleaseByUIDAdminMock.defaultExpectation != nil && afterGetPipelineReleaseByUIDAdminCounter < 1 {
		if m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s", m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s with params: %#v", m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineReleaseByUIDAdmin != nil && afterGetPipelineReleaseByUIDAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s", m.funcGetPipelineReleaseByUIDAdminOrigin)
	}

	if !m.GetPipelineReleaseByUIDAdminMock.invocationsDone() && afterGetPipelineReleaseByUIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineReleaseByUIDAdminMock.expectedInvocations), m.GetPipelineReleaseByUIDAdminMock.expectedInvocationsOrigin, afterGetPipelineReleaseByUIDAdminCounter)
	}
}

type mRepositoryMockGetPipelineRunByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineRunByUIDExpectation
	expectations       []*RepositoryMockGetPipelineRunByUIDExpectation

	callArgs []*RepositoryMockGetPipelineRunByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineRunByUIDExpectation specifies expectation struct of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineRunByUIDParams
	paramPtrs          *RepositoryMockGetPipelineRunByUIDParamPtrs
	expectationOrigins RepositoryMockGetPipelineRunByUIDExpectationOrigins
	results            *RepositoryMockGetPipelineRunByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineRunByUIDParams contains parameters of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// RepositoryMockGetPipelineRunByUIDParamPtrs contains pointers to parameters of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
}

// RepositoryMockGetPipelineRunByUIDResults contains results of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDResults struct {
	pp1 *datamodel.PipelineRun
	err error
}

// RepositoryMockGetPipelineRunByUIDOrigins contains origins of expectations of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Optional() *mRepositoryMockGetPipelineRunByUID {
	mmGetPipelineRunByUID.optional = true
	return mmGetPipelineRunByUID
}

// Expect sets up expected params for Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Expect(ctx context.Context, u1 uuid.UUID) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{}
	}

	if mmGetPipelineRunByUID.defaultExpectation.paramPtrs != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by ExpectParams functions")
	}

	mmGetPipelineRunByUID.defaultExpectation.params = &RepositoryMockGetPipelineRunByUIDParams{ctx, u1}
	mmGetPipelineRunByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineRunByUID.expectations {
		if minimock.Equal(e.params, mmGetPipelineRunByUID.defaultExpectation.params) {
			mmGetPipelineRunByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineRunByUID.defaultExpectation.params)
		}
	}

	return mmGetPipelineRunByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{}
	}

	if mmGetPipelineRunByUID.defaultExpectation.params != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Expect")
	}

	if mmGetPipelineRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineRunByUIDParamPtrs{}
	}
	mmGetPipelineRunByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineRunByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineRunByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{}
	}

	if mmGetPipelineRunByUID.defaultExpectation.params != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Expect")
	}

	if mmGetPipelineRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineRunByUIDParamPtrs{}
	}
	mmGetPipelineRunByUID.defaultExpectation.paramPtrs.u1 = &u1
	mmGetPipelineRunByUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetPipelineRunByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.inspectFuncGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineRunByUID")
	}

	mmGetPipelineRunByUID.mock.inspectFuncGetPipelineRunByUID = f

	return mmGetPipelineRunByUID
}

// Return sets up results that will be returned by Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Return(pp1 *datamodel.PipelineRun, err error) *RepositoryMock {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{mock: mmGetPipelineRunByUID.mock}
	}
	mmGetPipelineRunByUID.defaultExpectation.results = &RepositoryMockGetPipelineRunByUIDResults{pp1, err}
	mmGetPipelineRunByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineRunByUID.mock
}

// Set uses given function f to mock the Repository.GetPipelineRunByUID method
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Set(f func(ctx context.Context, u1 uuid.UUID) (pp1 *datamodel.PipelineRun, err error)) *RepositoryMock {
	if mmGetPipelineRunByUID.defaultExpectation != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineRunByUID method")
	}

	if len(mmGetPipelineRunByUID.expectations) > 0 {
		mmGetPipelineRunByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineRunByUID method")
	}

	mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID = f
	mmGetPipelineRunByUID.mock.funcGetPipelineRunByUIDOrigin = minimock.CallerInfo(1)
	return mmGetPipelineRunByUID.mock
}

// When sets expectation for the Repository.GetPipelineRunByUID which will trigger the result defined by the following
// Then helper
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) When(ctx context.Context, u1 uuid.UUID) *RepositoryMockGetPipelineRunByUIDExpectation {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineRunByUIDExpectation{
		mock:               mmGetPipelineRunByUID.mock,
		params:             &RepositoryMockGetPipelineRunByUIDParams{ctx, u1},
		expectationOrigins: RepositoryMockGetPipelineRunByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineRunByUID.expectations = append(mmGetPipelineRunByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineRunByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineRunByUIDExpectation) Then(pp1 *datamodel.PipelineRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineRunByUIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineRunByUID should be invoked
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Times(n uint64) *mRepositoryMockGetPipelineRunByUID {
	if n == 0 {
		mmGetPipelineRunByUID.mock.t.Fatalf("Times of RepositoryMock.GetPipelineRunByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineRunByUID.expectedInvocations, n)
	mmGetPipelineRunByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineRunByUID
}

func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) invocationsDone() bool {
	if len(mmGetPipelineRunByUID.expectations) == 0 && mmGetPipelineRunByUID.defaultExpectation == nil && mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineRunByUID.mock.afterGetPipelineRunByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineRunByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineRunByUID implements mm_repository.Repository
func (mmGetPipelineRunByUID *RepositoryMock) GetPipelineRunByUID(ctx context.Context, u1 uuid.UUID) (pp1 *datamodel.PipelineRun, err error) {
	mm_atomic.AddUint64(&mmGetPipelineRunByUID.beforeGetPipelineRunByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineRunByUID.afterGetPipelineRunByUIDCounter, 1)

	mmGetPipelineRunByUID.t.Helper()

	if mmGetPipelineRunByUID.inspectFuncGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.inspectFuncGetPipelineRunByUID(ctx, u1)
	}

	mm_params := RepositoryMockGetPipelineRunByUIDParams{ctx, u1}

	// Record call args
	mmGetPipelineRunByUID.GetPipelineRunByUIDMock.mutex.Lock()
	mmGetPipelineRunByUID.GetPipelineRunByUIDMock.callArgs = append(mmGetPipelineRunByUID.GetPipelineRunByUIDMock.callArgs, &mm_params)
	mmGetPipelineRunByUID.GetPipelineRunByUIDMock.mutex.Unlock()

	for _, e := range mmGetPipelineRunByUID.GetPipelineRunByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineRunByUIDParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineRunByUID.t.Errorf("RepositoryMock.GetPipelineRunByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetPipelineRunByUID.t.Errorf("RepositoryMock.GetPipelineRunByUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineRunByUID.t.Errorf("RepositoryMock.GetPipelineRunByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineRunByUID.t.Fatal("No results are set for the RepositoryMock.GetPipelineRunByUID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineRunByUID.funcGetPipelineRunByUID != nil {
		return mmGetPipelineRunByUID.funcGetPipelineRunByUID(ctx, u1)
	}
	mmGetPipelineRunByUID.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineRunByUID. %v %v", ctx, u1)
	return
}

// GetPipelineRunByUIDAfterCounter returns a count of finished RepositoryMock.GetPipelineRunByUID invocations
func (mmGetPipelineRunByUID *RepositoryMock) GetPipelineRunByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineRunByUID.afterGetPipelineRunByUIDCounter)
}

// GetPipelineRunByUIDBeforeCounter returns a count of RepositoryMock.GetPipelineRunByUID invocations
func (mmGetPipelineRunByUID *RepositoryMock) GetPipelineRunByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineRunByUID.beforeGetPipelineRunByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineRunByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Calls() []*RepositoryMockGetPipelineRunByUIDParams {
	mmGetPipelineRunByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineRunByUIDParams, len(mmGetPipelineRunByUID.callArgs))
	copy(argCopy, mmGetPipelineRunByUID.callArgs)

	mmGetPipelineRunByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineRunByUIDDone returns true if the count of the GetPipelineRunByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineRunByUIDDone() bool {
	if m.GetPipelineRunByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineRunByUIDMock.invocationsDone()
}

// MinimockGetPipelineRunByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineRunByUIDInspect() {
	for _, e := range m.GetPipelineRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineRunByUIDCounter := mm_atomic.LoadUint64(&m.afterGetPipelineRunByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineRunByUIDMock.defaultExpectation != nil && afterGetPipelineRunByUIDCounter < 1 {
		if m.GetPipelineRunByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s", m.GetPipelineRunByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s with params: %#v", m.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineRunByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineRunByUID != nil && afterGetPipelineRunByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s", m.funcGetPipelineRunByUIDOrigin)
	}

	if !m.GetPipelineRunByUIDMock.invocationsDone() && afterGetPipelineRunByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineRunByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineRunByUIDMock.expectedInvocations), m.GetPipelineRunByUIDMock.expectedInvocationsOrigin, afterGetPipelineRunByUIDCounter)
	}
}

type mRepositoryMockListAllComponentDefinitions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListAllComponentDefinitionsExpectation
	expectations       []*RepositoryMockListAllComponentDefinitionsExpectation

	callArgs []*RepositoryMockListAllComponentDefinitionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListAllComponentDefinitionsExpectation specifies expectation struct of the Repository.ListAllComponentDefinitions
type RepositoryMockListAllComponentDefinitionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListAllComponentDefinitionsParams
	paramPtrs          *RepositoryMockListAllComponentDefinitionsParamPtrs
	expectationOrigins RepositoryMockListAllComponentDefinitionsExpectationOrigins
	results            *RepositoryMockListAllComponentDefinitionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListAllComponentDefinitionsParams contains parameters of the Repository.ListAllComponentDefinitions
type RepositoryMockListAllComponentDefinitionsParams struct {
	ctx context.Context
}

// RepositoryMockListAllComponentDefinitionsParamPtrs contains pointers to parameters of the Repository.ListAllComponentDefinitions
type RepositoryMockListAllComponentDefinitionsParamPtrs struct {
	ctx *context.Context
}

// RepositoryMockListAllComponentDefinitionsResults contains results of the Repository.ListAllComponentDefinitions
type RepositoryMockListAllComponentDefinitionsResults struct {
	cpa1 []*datamodel.ComponentDefinition
	err  error
}

// RepositoryMockListAllComponentDefinitionsOrigins contains origins of expectations of the Repository.ListAllComponentDefinitions
type RepositoryMockListAllComponentDefinitionsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) Optional() *mRepositoryMockListAllComponentDefinitions {
	mmListAllComponentDefinitions.optional = true
	return mmListAllComponentDefinitions
}

// Expect sets up expected params for Repository.ListAllComponentDefinitions
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) Expect(ctx context.Context) *mRepositoryMockListAllComponentDefinitions {
	if mmListAllComponentDefinitions.mock.funcListAllComponentDefinitions != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("RepositoryMock.ListAllComponentDefinitions mock is already set by Set")
	}

	if mmListAllComponentDefinitions.defaultExpectation == nil {
		mmListAllComponentDefinitions.defaultExpectation = &RepositoryMockListAllComponentDefinitionsExpectation{}
	}

	if mmListAllComponentDefinitions.defaultExpectation.paramPtrs != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("RepositoryMock.ListAllComponentDefinitions mock is already set by ExpectParams functions")
	}

	mmListAllComponentDefinitions.defaultExpectation.params = &RepositoryMockListAllComponentDefinitionsParams{ctx}
	mmListAllComponentDefinitions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAllComponentDefinitions.expectations {
		if minimock.Equal(e.params, mmListAllComponentDefinitions.defaultExpectation.params) {
			mmListAllComponentDefinitions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAllComponentDefinitions.defaultExpectation.params)
		}
	}

	return mmListAllComponentDefinitions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListAllComponentDefinitions
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListAllComponentDefinitions {
	if mmListAllComponentDefinitions.mock.funcListAllComponentDefinitions != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("RepositoryMock.ListAllComponentDefinitions mock is already set by Set")
	}

	if mmListAllComponentDefinitions.defaultExpectation == nil {
		mmListAllComponentDefinitions.defaultExpectation = &RepositoryMockListAllComponentDefinitionsExpectation{}
	}

	if mmListAllComponentDefinitions.defaultExpectation.params != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("RepositoryMock.ListAllComponentDefinitions mock is already set by Expect")
	}

	if mmListAllComponentDefinitions.defaultExpectation.paramPtrs == nil {
		mmListAllComponentDefinitions.defaultExpectation.paramPtrs = &RepositoryMockListAllComponentDefinitionsParamPtrs{}
	}
	mmListAllComponentDefinitions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAllComponentDefinitions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAllComponentDefinitions
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListAllComponentDefinitions
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) Inspect(f func(ctx context.Context)) *mRepositoryMockListAllComponentDefinitions {
	if mmListAllComponentDefinitions.mock.inspectFuncListAllComponentDefinitions != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListAllComponentDefinitions")
	}

	mmListAllComponentDefinitions.mock.inspectFuncListAllComponentDefinitions = f

	return mmListAllComponentDefinitions
}

// Return sets up results that will be returned by Repository.ListAllComponentDefinitions
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) Return(cpa1 []*datamodel.ComponentDefinition, err error) *RepositoryMock {
	if mmListAllComponentDefinitions.mock.funcListAllComponentDefinitions != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("RepositoryMock.ListAllComponentDefinitions mock is already set by Set")
	}

	if mmListAllComponentDefinitions.defaultExpectation == nil {
		mmListAllComponentDefinitions.defaultExpectation = &RepositoryMockListAllComponentDefinitionsExpectation{mock: mmListAllComponentDefinitions.mock}
	}
	mmListAllComponentDefinitions.defaultExpectation.results = &RepositoryMockListAllComponentDefinitionsResults{cpa1, err}
	mmListAllComponentDefinitions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAllComponentDefinitions.mock
}

// Set uses given function f to mock the Repository.ListAllComponentDefinitions method
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) Set(f func(ctx context.Context) (cpa1 []*datamodel.ComponentDefinition, err error)) *RepositoryMock {
	if mmListAllComponentDefinitions.defaultExpectation != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("Default expectation is already set for the Repository.ListAllComponentDefinitions method")
	}

	if len(mmListAllComponentDefinitions.expectations) > 0 {
		mmListAllComponentDefinitions.mock.t.Fatalf("Some expectations are already set for the Repository.ListAllComponentDefinitions method")
	}

	mmListAllComponentDefinitions.mock.funcListAllComponentDefinitions = f
	mmListAllComponentDefinitions.mock.funcListAllComponentDefinitionsOrigin = minimock.CallerInfo(1)
	return mmListAllComponentDefinitions.mock
}

// When sets expectation for the Repository.ListAllComponentDefinitions which will trigger the result defined by the following
// Then helper
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) When(ctx context.Context) *RepositoryMockListAllComponentDefinitionsExpectation {
	if mmListAllComponentDefinitions.mock.funcListAllComponentDefinitions != nil {
		mmListAllComponentDefinitions.mock.t.Fatalf("RepositoryMock.ListAllComponentDefinitions mock is already set by Set")
	}

	expectation := &RepositoryMockListAllComponentDefinitionsExpectation{
		mock:               mmListAllComponentDefinitions.mock,
		params:             &RepositoryMockListAllComponentDefinitionsParams{ctx},
		expectationOrigins: RepositoryMockListAllComponentDefinitionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAllComponentDefinitions.expectations = append(mmListAllComponentDefinitions.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListAllComponentDefinitions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListAllComponentDefinitionsExpectation) Then(cpa1 []*datamodel.ComponentDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockListAllComponentDefinitionsResults{cpa1, err}
	return e.mock
}

// Times sets number of times Repository.ListAllComponentDefinitions should be invoked
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) Times(n uint64) *mRepositoryMockListAllComponentDefinitions {
	if n == 0 {
		mmListAllComponentDefinitions.mock.t.Fatalf("Times of RepositoryMock.ListAllComponentDefinitions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAllComponentDefinitions.expectedInvocations, n)
	mmListAllComponentDefinitions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAllComponentDefinitions
}

func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) invocationsDone() bool {
	if len(mmListAllComponentDefinitions.expectations) == 0 && mmListAllComponentDefinitions.defaultExpectation == nil && mmListAllComponentDefinitions.mock.funcListAllComponentDefinitions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAllComponentDefinitions.mock.afterListAllComponentDefinitionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAllComponentDefinitions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAllComponentDefinitions implements mm_repository.Repository
func (mmListAllComponentDefinitions *RepositoryMock) ListAllComponentDefinitions(ctx context.Context) (cpa1 []*datamodel.ComponentDefinition, err error) {
	mm_atomic.AddUint64(&mmListAllComponentDefinitions.beforeListAllComponentDefinitionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAllComponentDefinitions.afterListAllComponentDefinitionsCounter, 1)

	mmListAllComponentDefinitions.t.Helper()

	if mmListAllComponentDefinitions.inspectFuncListAllComponentDefinitions != nil {
		mmListAllComponentDefinitions.inspectFuncListAllComponentDefinitions(ctx)
	}

	mm_params := RepositoryMockListAllComponentDefinitionsParams{ctx}

	// Record call args
	mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.mutex.Lock()
	mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.callArgs = append(mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.callArgs, &mm_params)
	mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.mutex.Unlock()

	for _, e := range mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.defaultExpectation.params
		mm_want_ptrs := mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListAllComponentDefinitionsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAllComponentDefinitions.t.Errorf("RepositoryMock.ListAllComponentDefinitions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAllComponentDefinitions.t.Errorf("RepositoryMock.ListAllComponentDefinitions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAllComponentDefinitions.ListAllComponentDefinitionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAllComponentDefinitions.t.Fatal("No results are set for the RepositoryMock.ListAllComponentDefinitions")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmListAllComponentDefinitions.funcListAllComponentDefinitions != nil {
		return mmListAllComponentDefinitions.funcListAllComponentDefinitions(ctx)
	}
	mmListAllComponentDefinitions.t.Fatalf("Unexpected call to RepositoryMock.ListAllComponentDefinitions. %v", ctx)
	return
}

// ListAllComponentDefinitionsAfterCounter returns a count of finished RepositoryMock.ListAllComponentDefinitions invocations
func (mmListAllComponentDefinitions *RepositoryMock) ListAllComponentDefinitionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllComponentDefinitions.afterListAllComponentDefinitionsCounter)
}

// ListAllComponentDefinitionsBeforeCounter returns a count of RepositoryMock.ListAllComponentDefinitions invocations
func (mmListAllComponentDefinitions *RepositoryMock) ListAllComponentDefinitionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAllComponentDefinitions.beforeListAllComponentDefinitionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListAllComponentDefinitions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAllComponentDefinitions *mRepositoryMockListAllComponentDefinitions) Calls() []*RepositoryMockListAllComponentDefinitionsParams {
	mmListAllComponentDefinitions.mutex.RLock()

	argCopy := make([]*RepositoryMockListAllComponentDefinitionsParams, len(mmListAllComponentDefinitions.callArgs))
	copy(argCopy, mmListAllComponentDefinitions.callArgs)

	mmListAllComponentDefinitions.mutex.RUnlock()

	return argCopy
}

// MinimockListAllComponentDefinitionsDone returns true if the count of the ListAllComponentDefinitions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListAllComponentDefinitionsDone() bool {
	if m.ListAllComponentDefinitionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAllComponentDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAllComponentDefinitionsMock.invocationsDone()
}

// MinimockListAllComponentDefinitionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListAllComponentDefinitionsInspect() {
	for _, e := range m.ListAllComponentDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListAllComponentDefinitions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAllComponentDefinitionsCounter := mm_atomic.LoadUint64(&m.afterListAllComponentDefinitionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAllComponentDefinitionsMock.defaultExpectation != nil && afterListAllComponentDefinitionsCounter < 1 {
		if m.ListAllComponentDefinitionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListAllComponentDefinitions at\n%s", m.ListAllComponentDefinitionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListAllComponentDefinitions at\n%s with params: %#v", m.ListAllComponentDefinitionsMock.defaultExpectation.expectationOrigins.origin, *m.ListAllComponentDefinitionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAllComponentDefinitions != nil && afterListAllComponentDefinitionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListAllComponentDefinitions at\n%s", m.funcListAllComponentDefinitionsOrigin)
	}

	if !m.ListAllComponentDefinitionsMock.invocationsDone() && afterListAllComponentDefinitionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListAllComponentDefinitions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAllComponentDefinitionsMock.expectedInvocations), m.ListAllComponentDefinitionsMock.expectedInvocationsOrigin, afterListAllComponentDefinitionsCounter)
	}
}

type mRepositoryMockListComponentDefinitionUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListComponentDefinitionUIDsExpectation
	expectations       []*RepositoryMockListComponentDefinitionUIDsExpectation

	callArgs []*RepositoryMockListComponentDefinitionUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListComponentDefinitionUIDsExpectation specifies expectation struct of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListComponentDefinitionUIDsParams
	paramPtrs          *RepositoryMockListComponentDefinitionUIDsParamPtrs
	expectationOrigins RepositoryMockListComponentDefinitionUIDsExpectationOrigins
	results            *RepositoryMockListComponentDefinitionUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListComponentDefinitionUIDsParams contains parameters of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsParams struct {
	ctx context.Context
	l1  mm_repository.ListComponentDefinitionsParams
}

// RepositoryMockListComponentDefinitionUIDsParamPtrs contains pointers to parameters of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListComponentDefinitionsParams
}

// RepositoryMockListComponentDefinitionUIDsResults contains results of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsResults struct {
	uids      []*datamodel.ComponentDefinition
	totalSize int64
	err       error
}

// RepositoryMockListComponentDefinitionUIDsOrigins contains origins of expectations of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Optional() *mRepositoryMockListComponentDefinitionUIDs {
	mmListComponentDefinitionUIDs.optional = true
	return mmListComponentDefinitionUIDs
}

// Expect sets up expected params for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Expect(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by ExpectParams functions")
	}

	mmListComponentDefinitionUIDs.defaultExpectation.params = &RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}
	mmListComponentDefinitionUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListComponentDefinitionUIDs.expectations {
		if minimock.Equal(e.params, mmListComponentDefinitionUIDs.defaultExpectation.params) {
			mmListComponentDefinitionUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListComponentDefinitionUIDs.defaultExpectation.params)
		}
	}

	return mmListComponentDefinitionUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.params != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Expect")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs == nil {
		mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs = &RepositoryMockListComponentDefinitionUIDsParamPtrs{}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmListComponentDefinitionUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListComponentDefinitionUIDs
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) ExpectL1Param2(l1 mm_repository.ListComponentDefinitionsParams) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.params != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Expect")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs == nil {
		mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs = &RepositoryMockListComponentDefinitionUIDsParamPtrs{}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs.l1 = &l1
	mmListComponentDefinitionUIDs.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListComponentDefinitionUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Inspect(f func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams)) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.inspectFuncListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListComponentDefinitionUIDs")
	}

	mmListComponentDefinitionUIDs.mock.inspectFuncListComponentDefinitionUIDs = f

	return mmListComponentDefinitionUIDs
}

// Return sets up results that will be returned by Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Return(uids []*datamodel.ComponentDefinition, totalSize int64, err error) *RepositoryMock {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{mock: mmListComponentDefinitionUIDs.mock}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.results = &RepositoryMockListComponentDefinitionUIDsResults{uids, totalSize, err}
	mmListComponentDefinitionUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListComponentDefinitionUIDs.mock
}

// Set uses given function f to mock the Repository.ListComponentDefinitionUIDs method
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Set(f func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error)) *RepositoryMock {
	if mmListComponentDefinitionUIDs.defaultExpectation != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.ListComponentDefinitionUIDs method")
	}

	if len(mmListComponentDefinitionUIDs.expectations) > 0 {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.ListComponentDefinitionUIDs method")
	}

	mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs = f
	mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDsOrigin = minimock.CallerInfo(1)
	return mmListComponentDefinitionUIDs.mock
}

// When sets expectation for the Repository.ListComponentDefinitionUIDs which will trigger the result defined by the following
// Then helper
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) When(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) *RepositoryMockListComponentDefinitionUIDsExpectation {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockListComponentDefinitionUIDsExpectation{
		mock:               mmListComponentDefinitionUIDs.mock,
		params:             &RepositoryMockListComponentDefinitionUIDsParams{ctx, l1},
		expectationOrigins: RepositoryMockListComponentDefinitionUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListComponentDefinitionUIDs.expectations = append(mmListComponentDefinitionUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListComponentDefinitionUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListComponentDefinitionUIDsExpectation) Then(uids []*datamodel.ComponentDefinition, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListComponentDefinitionUIDsResults{uids, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListComponentDefinitionUIDs should be invoked
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Times(n uint64) *mRepositoryMockListComponentDefinitionUIDs {
	if n == 0 {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Times of RepositoryMock.ListComponentDefinitionUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListComponentDefinitionUIDs.expectedInvocations, n)
	mmListComponentDefinitionUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListComponentDefinitionUIDs
}

func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) invocationsDone() bool {
	if len(mmListComponentDefinitionUIDs.expectations) == 0 && mmListComponentDefinitionUIDs.defaultExpectation == nil && mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.mock.afterListComponentDefinitionUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListComponentDefinitionUIDs implements mm_repository.Repository
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDs(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.beforeListComponentDefinitionUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.afterListComponentDefinitionUIDsCounter, 1)

	mmListComponentDefinitionUIDs.t.Helper()

	if mmListComponentDefinitionUIDs.inspectFuncListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.inspectFuncListComponentDefinitionUIDs(ctx, l1)
	}

	mm_params := RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}

	// Record call args
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.mutex.Lock()
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.callArgs = append(mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.callArgs, &mm_params)
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.mutex.Unlock()

	for _, e := range mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uids, e.results.totalSize, e.results.err
		}
	}

	if mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmListComponentDefinitionUIDs.t.Fatal("No results are set for the RepositoryMock.ListComponentDefinitionUIDs")
		}
		return (*mm_results).uids, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListComponentDefinitionUIDs.funcListComponentDefinitionUIDs != nil {
		return mmListComponentDefinitionUIDs.funcListComponentDefinitionUIDs(ctx, l1)
	}
	mmListComponentDefinitionUIDs.t.Fatalf("Unexpected call to RepositoryMock.ListComponentDefinitionUIDs. %v %v", ctx, l1)
	return
}

// ListComponentDefinitionUIDsAfterCounter returns a count of finished RepositoryMock.ListComponentDefinitionUIDs invocations
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.afterListComponentDefinitionUIDsCounter)
}

// ListComponentDefinitionUIDsBeforeCounter returns a count of RepositoryMock.ListComponentDefinitionUIDs invocations
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.beforeListComponentDefinitionUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListComponentDefinitionUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Calls() []*RepositoryMockListComponentDefinitionUIDsParams {
	mmListComponentDefinitionUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockListComponentDefinitionUIDsParams, len(mmListComponentDefinitionUIDs.callArgs))
	copy(argCopy, mmListComponentDefinitionUIDs.callArgs)

	mmListComponentDefinitionUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockListComponentDefinitionUIDsDone returns true if the count of the ListComponentDefinitionUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListComponentDefinitionUIDsDone() bool {
	if m.ListComponentDefinitionUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListComponentDefinitionUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListComponentDefinitionUIDsMock.invocationsDone()
}

// MinimockListComponentDefinitionUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListComponentDefinitionUIDsInspect() {
	for _, e := range m.ListComponentDefinitionUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListComponentDefinitionUIDsCounter := mm_atomic.LoadUint64(&m.afterListComponentDefinitionUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListComponentDefinitionUIDsMock.defaultExpectation != nil && afterListComponentDefinitionUIDsCounter < 1 {
		if m.ListComponentDefinitionUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s", m.ListComponentDefinitionUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s with params: %#v", m.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.origin, *m.ListComponentDefinitionUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListComponentDefinitionUIDs != nil && afterListComponentDefinitionUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s", m.funcListComponentDefinitionUIDsOrigin)
	}

	if !m.ListComponentDefinitionUIDsMock.invocationsDone() && afterListComponentDefinitionUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListComponentDefinitionUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListComponentDefinitionUIDsMock.expectedInvocations), m.ListComponentDefinitionUIDsMock.expectedInvocationsOrigin, afterListComponentDefinitionUIDsCounter)
	}
}

type mRepositoryMockListIntegrations struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListIntegrationsExpectation
	expectations       []*RepositoryMockListIntegrationsExpectation

	callArgs []*RepositoryMockListIntegrationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListIntegrationsExpectation specifies expectation struct of the Repository.ListIntegrations
type RepositoryMockListIntegrationsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListIntegrationsParams
	paramPtrs          *RepositoryMockListIntegrationsParamPtrs
	expectationOrigins RepositoryMockListIntegrationsExpectationOrigins
	results            *RepositoryMockListIntegrationsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListIntegrationsParams contains parameters of the Repository.ListIntegrations
type RepositoryMockListIntegrationsParams struct {
	ctx context.Context
	l1  mm_repository.ListIntegrationsParams
}

// RepositoryMockListIntegrationsParamPtrs contains pointers to parameters of the Repository.ListIntegrations
type RepositoryMockListIntegrationsParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListIntegrationsParams
}

// RepositoryMockListIntegrationsResults contains results of the Repository.ListIntegrations
type RepositoryMockListIntegrationsResults struct {
	i1  mm_repository.IntegrationList
	err error
}

// RepositoryMockListIntegrationsOrigins contains origins of expectations of the Repository.ListIntegrations
type RepositoryMockListIntegrationsExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListIntegrations *mRepositoryMockListIntegrations) Optional() *mRepositoryMockListIntegrations {
	mmListIntegrations.optional = true
	return mmListIntegrations
}

// Expect sets up expected params for Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) Expect(ctx context.Context, l1 mm_repository.ListIntegrationsParams) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{}
	}

	if mmListIntegrations.defaultExpectation.paramPtrs != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by ExpectParams functions")
	}

	mmListIntegrations.defaultExpectation.params = &RepositoryMockListIntegrationsParams{ctx, l1}
	mmListIntegrations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListIntegrations.expectations {
		if minimock.Equal(e.params, mmListIntegrations.defaultExpectation.params) {
			mmListIntegrations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListIntegrations.defaultExpectation.params)
		}
	}

	return mmListIntegrations
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{}
	}

	if mmListIntegrations.defaultExpectation.params != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Expect")
	}

	if mmListIntegrations.defaultExpectation.paramPtrs == nil {
		mmListIntegrations.defaultExpectation.paramPtrs = &RepositoryMockListIntegrationsParamPtrs{}
	}
	mmListIntegrations.defaultExpectation.paramPtrs.ctx = &ctx
	mmListIntegrations.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListIntegrations
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) ExpectL1Param2(l1 mm_repository.ListIntegrationsParams) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{}
	}

	if mmListIntegrations.defaultExpectation.params != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Expect")
	}

	if mmListIntegrations.defaultExpectation.paramPtrs == nil {
		mmListIntegrations.defaultExpectation.paramPtrs = &RepositoryMockListIntegrationsParamPtrs{}
	}
	mmListIntegrations.defaultExpectation.paramPtrs.l1 = &l1
	mmListIntegrations.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListIntegrations
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) Inspect(f func(ctx context.Context, l1 mm_repository.ListIntegrationsParams)) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.inspectFuncListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListIntegrations")
	}

	mmListIntegrations.mock.inspectFuncListIntegrations = f

	return mmListIntegrations
}

// Return sets up results that will be returned by Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) Return(i1 mm_repository.IntegrationList, err error) *RepositoryMock {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{mock: mmListIntegrations.mock}
	}
	mmListIntegrations.defaultExpectation.results = &RepositoryMockListIntegrationsResults{i1, err}
	mmListIntegrations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListIntegrations.mock
}

// Set uses given function f to mock the Repository.ListIntegrations method
func (mmListIntegrations *mRepositoryMockListIntegrations) Set(f func(ctx context.Context, l1 mm_repository.ListIntegrationsParams) (i1 mm_repository.IntegrationList, err error)) *RepositoryMock {
	if mmListIntegrations.defaultExpectation != nil {
		mmListIntegrations.mock.t.Fatalf("Default expectation is already set for the Repository.ListIntegrations method")
	}

	if len(mmListIntegrations.expectations) > 0 {
		mmListIntegrations.mock.t.Fatalf("Some expectations are already set for the Repository.ListIntegrations method")
	}

	mmListIntegrations.mock.funcListIntegrations = f
	mmListIntegrations.mock.funcListIntegrationsOrigin = minimock.CallerInfo(1)
	return mmListIntegrations.mock
}

// When sets expectation for the Repository.ListIntegrations which will trigger the result defined by the following
// Then helper
func (mmListIntegrations *mRepositoryMockListIntegrations) When(ctx context.Context, l1 mm_repository.ListIntegrationsParams) *RepositoryMockListIntegrationsExpectation {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	expectation := &RepositoryMockListIntegrationsExpectation{
		mock:               mmListIntegrations.mock,
		params:             &RepositoryMockListIntegrationsParams{ctx, l1},
		expectationOrigins: RepositoryMockListIntegrationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListIntegrations.expectations = append(mmListIntegrations.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListIntegrations return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListIntegrationsExpectation) Then(i1 mm_repository.IntegrationList, err error) *RepositoryMock {
	e.results = &RepositoryMockListIntegrationsResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.ListIntegrations should be invoked
func (mmListIntegrations *mRepositoryMockListIntegrations) Times(n uint64) *mRepositoryMockListIntegrations {
	if n == 0 {
		mmListIntegrations.mock.t.Fatalf("Times of RepositoryMock.ListIntegrations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListIntegrations.expectedInvocations, n)
	mmListIntegrations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListIntegrations
}

func (mmListIntegrations *mRepositoryMockListIntegrations) invocationsDone() bool {
	if len(mmListIntegrations.expectations) == 0 && mmListIntegrations.defaultExpectation == nil && mmListIntegrations.mock.funcListIntegrations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListIntegrations.mock.afterListIntegrationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListIntegrations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListIntegrations implements mm_repository.Repository
func (mmListIntegrations *RepositoryMock) ListIntegrations(ctx context.Context, l1 mm_repository.ListIntegrationsParams) (i1 mm_repository.IntegrationList, err error) {
	mm_atomic.AddUint64(&mmListIntegrations.beforeListIntegrationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListIntegrations.afterListIntegrationsCounter, 1)

	mmListIntegrations.t.Helper()

	if mmListIntegrations.inspectFuncListIntegrations != nil {
		mmListIntegrations.inspectFuncListIntegrations(ctx, l1)
	}

	mm_params := RepositoryMockListIntegrationsParams{ctx, l1}

	// Record call args
	mmListIntegrations.ListIntegrationsMock.mutex.Lock()
	mmListIntegrations.ListIntegrationsMock.callArgs = append(mmListIntegrations.ListIntegrationsMock.callArgs, &mm_params)
	mmListIntegrations.ListIntegrationsMock.mutex.Unlock()

	for _, e := range mmListIntegrations.ListIntegrationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmListIntegrations.ListIntegrationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListIntegrations.ListIntegrationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListIntegrations.ListIntegrationsMock.defaultExpectation.params
		mm_want_ptrs := mmListIntegrations.ListIntegrationsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListIntegrationsParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListIntegrations.t.Errorf("RepositoryMock.ListIntegrations got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListIntegrations.ListIntegrationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListIntegrations.t.Errorf("RepositoryMock.ListIntegrations got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListIntegrations.ListIntegrationsMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListIntegrations.t.Errorf("RepositoryMock.ListIntegrations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListIntegrations.ListIntegrationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListIntegrations.ListIntegrationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListIntegrations.t.Fatal("No results are set for the RepositoryMock.ListIntegrations")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmListIntegrations.funcListIntegrations != nil {
		return mmListIntegrations.funcListIntegrations(ctx, l1)
	}
	mmListIntegrations.t.Fatalf("Unexpected call to RepositoryMock.ListIntegrations. %v %v", ctx, l1)
	return
}

// ListIntegrationsAfterCounter returns a count of finished RepositoryMock.ListIntegrations invocations
func (mmListIntegrations *RepositoryMock) ListIntegrationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListIntegrations.afterListIntegrationsCounter)
}

// ListIntegrationsBeforeCounter returns a count of RepositoryMock.ListIntegrations invocations
func (mmListIntegrations *RepositoryMock) ListIntegrationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListIntegrations.beforeListIntegrationsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListIntegrations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListIntegrations *mRepositoryMockListIntegrations) Calls() []*RepositoryMockListIntegrationsParams {
	mmListIntegrations.mutex.RLock()

	argCopy := make([]*RepositoryMockListIntegrationsParams, len(mmListIntegrations.callArgs))
	copy(argCopy, mmListIntegrations.callArgs)

	mmListIntegrations.mutex.RUnlock()

	return argCopy
}

// MinimockListIntegrationsDone returns true if the count of the ListIntegrations invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListIntegrationsDone() bool {
	if m.ListIntegrationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListIntegrationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListIntegrationsMock.invocationsDone()
}

// MinimockListIntegrationsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListIntegrationsInspect() {
	for _, e := range m.ListIntegrationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListIntegrationsCounter := mm_atomic.LoadUint64(&m.afterListIntegrationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListIntegrationsMock.defaultExpectation != nil && afterListIntegrationsCounter < 1 {
		if m.ListIntegrationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s", m.ListIntegrationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s with params: %#v", m.ListIntegrationsMock.defaultExpectation.expectationOrigins.origin, *m.ListIntegrationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListIntegrations != nil && afterListIntegrationsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s", m.funcListIntegrationsOrigin)
	}

	if !m.ListIntegrationsMock.invocationsDone() && afterListIntegrationsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListIntegrations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListIntegrationsMock.expectedInvocations), m.ListIntegrationsMock.expectedInvocationsOrigin, afterListIntegrationsCounter)
	}
}

type mRepositoryMockListNamespaceConnections struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespaceConnectionsExpectation
	expectations       []*RepositoryMockListNamespaceConnectionsExpectation

	callArgs []*RepositoryMockListNamespaceConnectionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListNamespaceConnectionsExpectation specifies expectation struct of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListNamespaceConnectionsParams
	paramPtrs          *RepositoryMockListNamespaceConnectionsParamPtrs
	expectationOrigins RepositoryMockListNamespaceConnectionsExpectationOrigins
	results            *RepositoryMockListNamespaceConnectionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListNamespaceConnectionsParams contains parameters of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsParams struct {
	ctx context.Context
	l1  mm_repository.ListNamespaceConnectionsParams
}

// RepositoryMockListNamespaceConnectionsParamPtrs contains pointers to parameters of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListNamespaceConnectionsParams
}

// RepositoryMockListNamespaceConnectionsResults contains results of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsResults struct {
	c2  mm_repository.ConnectionList
	err error
}

// RepositoryMockListNamespaceConnectionsOrigins contains origins of expectations of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Optional() *mRepositoryMockListNamespaceConnections {
	mmListNamespaceConnections.optional = true
	return mmListNamespaceConnections
}

// Expect sets up expected params for Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Expect(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{}
	}

	if mmListNamespaceConnections.defaultExpectation.paramPtrs != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by ExpectParams functions")
	}

	mmListNamespaceConnections.defaultExpectation.params = &RepositoryMockListNamespaceConnectionsParams{ctx, l1}
	mmListNamespaceConnections.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespaceConnections.expectations {
		if minimock.Equal(e.params, mmListNamespaceConnections.defaultExpectation.params) {
			mmListNamespaceConnections.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceConnections.defaultExpectation.params)
		}
	}

	return mmListNamespaceConnections
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{}
	}

	if mmListNamespaceConnections.defaultExpectation.params != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Expect")
	}

	if mmListNamespaceConnections.defaultExpectation.paramPtrs == nil {
		mmListNamespaceConnections.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceConnectionsParamPtrs{}
	}
	mmListNamespaceConnections.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespaceConnections.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespaceConnections
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) ExpectL1Param2(l1 mm_repository.ListNamespaceConnectionsParams) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{}
	}

	if mmListNamespaceConnections.defaultExpectation.params != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Expect")
	}

	if mmListNamespaceConnections.defaultExpectation.paramPtrs == nil {
		mmListNamespaceConnections.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceConnectionsParamPtrs{}
	}
	mmListNamespaceConnections.defaultExpectation.paramPtrs.l1 = &l1
	mmListNamespaceConnections.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListNamespaceConnections
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Inspect(f func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams)) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.inspectFuncListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespaceConnections")
	}

	mmListNamespaceConnections.mock.inspectFuncListNamespaceConnections = f

	return mmListNamespaceConnections
}

// Return sets up results that will be returned by Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Return(c2 mm_repository.ConnectionList, err error) *RepositoryMock {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{mock: mmListNamespaceConnections.mock}
	}
	mmListNamespaceConnections.defaultExpectation.results = &RepositoryMockListNamespaceConnectionsResults{c2, err}
	mmListNamespaceConnections.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespaceConnections.mock
}

// Set uses given function f to mock the Repository.ListNamespaceConnections method
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Set(f func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) (c2 mm_repository.ConnectionList, err error)) *RepositoryMock {
	if mmListNamespaceConnections.defaultExpectation != nil {
		mmListNamespaceConnections.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespaceConnections method")
	}

	if len(mmListNamespaceConnections.expectations) > 0 {
		mmListNamespaceConnections.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespaceConnections method")
	}

	mmListNamespaceConnections.mock.funcListNamespaceConnections = f
	mmListNamespaceConnections.mock.funcListNamespaceConnectionsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceConnections.mock
}

// When sets expectation for the Repository.ListNamespaceConnections which will trigger the result defined by the following
// Then helper
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) When(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) *RepositoryMockListNamespaceConnectionsExpectation {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespaceConnectionsExpectation{
		mock:               mmListNamespaceConnections.mock,
		params:             &RepositoryMockListNamespaceConnectionsParams{ctx, l1},
		expectationOrigins: RepositoryMockListNamespaceConnectionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespaceConnections.expectations = append(mmListNamespaceConnections.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespaceConnections return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespaceConnectionsExpectation) Then(c2 mm_repository.ConnectionList, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespaceConnectionsResults{c2, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespaceConnections should be invoked
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Times(n uint64) *mRepositoryMockListNamespaceConnections {
	if n == 0 {
		mmListNamespaceConnections.mock.t.Fatalf("Times of RepositoryMock.ListNamespaceConnections mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceConnections.expectedInvocations, n)
	mmListNamespaceConnections.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceConnections
}

func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) invocationsDone() bool {
	if len(mmListNamespaceConnections.expectations) == 0 && mmListNamespaceConnections.defaultExpectation == nil && mmListNamespaceConnections.mock.funcListNamespaceConnections == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceConnections.mock.afterListNamespaceConnectionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceConnections.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceConnections implements mm_repository.Repository
func (mmListNamespaceConnections *RepositoryMock) ListNamespaceConnections(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) (c2 mm_repository.ConnectionList, err error) {
	mm_atomic.AddUint64(&mmListNamespaceConnections.beforeListNamespaceConnectionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceConnections.afterListNamespaceConnectionsCounter, 1)

	mmListNamespaceConnections.t.Helper()

	if mmListNamespaceConnections.inspectFuncListNamespaceConnections != nil {
		mmListNamespaceConnections.inspectFuncListNamespaceConnections(ctx, l1)
	}

	mm_params := RepositoryMockListNamespaceConnectionsParams{ctx, l1}

	// Record call args
	mmListNamespaceConnections.ListNamespaceConnectionsMock.mutex.Lock()
	mmListNamespaceConnections.ListNamespaceConnectionsMock.callArgs = append(mmListNamespaceConnections.ListNamespaceConnectionsMock.callArgs, &mm_params)
	mmListNamespaceConnections.ListNamespaceConnectionsMock.mutex.Unlock()

	for _, e := range mmListNamespaceConnections.ListNamespaceConnectionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespaceConnectionsParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceConnections.t.Errorf("RepositoryMock.ListNamespaceConnections got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListNamespaceConnections.t.Errorf("RepositoryMock.ListNamespaceConnections got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceConnections.t.Errorf("RepositoryMock.ListNamespaceConnections got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceConnections.t.Fatal("No results are set for the RepositoryMock.ListNamespaceConnections")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmListNamespaceConnections.funcListNamespaceConnections != nil {
		return mmListNamespaceConnections.funcListNamespaceConnections(ctx, l1)
	}
	mmListNamespaceConnections.t.Fatalf("Unexpected call to RepositoryMock.ListNamespaceConnections. %v %v", ctx, l1)
	return
}

// ListNamespaceConnectionsAfterCounter returns a count of finished RepositoryMock.ListNamespaceConnections invocations
func (mmListNamespaceConnections *RepositoryMock) ListNamespaceConnectionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceConnections.afterListNamespaceConnectionsCounter)
}

// ListNamespaceConnectionsBeforeCounter returns a count of RepositoryMock.ListNamespaceConnections invocations
func (mmListNamespaceConnections *RepositoryMock) ListNamespaceConnectionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceConnections.beforeListNamespaceConnectionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespaceConnections.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Calls() []*RepositoryMockListNamespaceConnectionsParams {
	mmListNamespaceConnections.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespaceConnectionsParams, len(mmListNamespaceConnections.callArgs))
	copy(argCopy, mmListNamespaceConnections.callArgs)

	mmListNamespaceConnections.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceConnectionsDone returns true if the count of the ListNamespaceConnections invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespaceConnectionsDone() bool {
	if m.ListNamespaceConnectionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceConnectionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceConnectionsMock.invocationsDone()
}

// MinimockListNamespaceConnectionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespaceConnectionsInspect() {
	for _, e := range m.ListNamespaceConnectionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespaceConnectionsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceConnectionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceConnectionsMock.defaultExpectation != nil && afterListNamespaceConnectionsCounter < 1 {
		if m.ListNamespaceConnectionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s", m.ListNamespaceConnectionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s with params: %#v", m.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespaceConnectionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceConnections != nil && afterListNamespaceConnectionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s", m.funcListNamespaceConnectionsOrigin)
	}

	if !m.ListNamespaceConnectionsMock.invocationsDone() && afterListNamespaceConnectionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespaceConnections at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceConnectionsMock.expectedInvocations), m.ListNamespaceConnectionsMock.expectedInvocationsOrigin, afterListNamespaceConnectionsCounter)
	}
}

type mRepositoryMockListNamespaceSecrets struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespaceSecretsExpectation
	expectations       []*RepositoryMockListNamespaceSecretsExpectation

	callArgs []*RepositoryMockListNamespaceSecretsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListNamespaceSecretsExpectation specifies expectation struct of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListNamespaceSecretsParams
	paramPtrs          *RepositoryMockListNamespaceSecretsParamPtrs
	expectationOrigins RepositoryMockListNamespaceSecretsExpectationOrigins
	results            *RepositoryMockListNamespaceSecretsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListNamespaceSecretsParams contains parameters of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	filter         filtering.Filter
}

// RepositoryMockListNamespaceSecretsParamPtrs contains pointers to parameters of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	filter         *filtering.Filter
}

// RepositoryMockListNamespaceSecretsResults contains results of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsResults struct {
	spa1 []*datamodel.Secret
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListNamespaceSecretsOrigins contains origins of expectations of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPageSize       string
	originPageToken      string
	originFilter         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Optional() *mRepositoryMockListNamespaceSecrets {
	mmListNamespaceSecrets.optional = true
	return mmListNamespaceSecrets
}

// Expect sets up expected params for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by ExpectParams functions")
	}

	mmListNamespaceSecrets.defaultExpectation.params = &RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespaceSecrets.expectations {
		if minimock.Equal(e.params, mmListNamespaceSecrets.defaultExpectation.params) {
			mmListNamespaceSecrets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceSecrets.defaultExpectation.params)
		}
	}

	return mmListNamespaceSecrets
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.filter = &filter
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter)) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.inspectFuncListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespaceSecrets")
	}

	mmListNamespaceSecrets.mock.inspectFuncListNamespaceSecrets = f

	return mmListNamespaceSecrets
}

// Return sets up results that will be returned by Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Return(spa1 []*datamodel.Secret, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{mock: mmListNamespaceSecrets.mock}
	}
	mmListNamespaceSecrets.defaultExpectation.results = &RepositoryMockListNamespaceSecretsResults{spa1, i1, s1, err}
	mmListNamespaceSecrets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespaceSecrets.mock
}

// Set uses given function f to mock the Repository.ListNamespaceSecrets method
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListNamespaceSecrets.defaultExpectation != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespaceSecrets method")
	}

	if len(mmListNamespaceSecrets.expectations) > 0 {
		mmListNamespaceSecrets.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespaceSecrets method")
	}

	mmListNamespaceSecrets.mock.funcListNamespaceSecrets = f
	mmListNamespaceSecrets.mock.funcListNamespaceSecretsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceSecrets.mock
}

// When sets expectation for the Repository.ListNamespaceSecrets which will trigger the result defined by the following
// Then helper
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) *RepositoryMockListNamespaceSecretsExpectation {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespaceSecretsExpectation{
		mock:               mmListNamespaceSecrets.mock,
		params:             &RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter},
		expectationOrigins: RepositoryMockListNamespaceSecretsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespaceSecrets.expectations = append(mmListNamespaceSecrets.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespaceSecrets return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespaceSecretsExpectation) Then(spa1 []*datamodel.Secret, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespaceSecretsResults{spa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespaceSecrets should be invoked
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Times(n uint64) *mRepositoryMockListNamespaceSecrets {
	if n == 0 {
		mmListNamespaceSecrets.mock.t.Fatalf("Times of RepositoryMock.ListNamespaceSecrets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceSecrets.expectedInvocations, n)
	mmListNamespaceSecrets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceSecrets
}

func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) invocationsDone() bool {
	if len(mmListNamespaceSecrets.expectations) == 0 && mmListNamespaceSecrets.defaultExpectation == nil && mmListNamespaceSecrets.mock.funcListNamespaceSecrets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceSecrets.mock.afterListNamespaceSecretsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceSecrets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceSecrets implements mm_repository.Repository
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecrets(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListNamespaceSecrets.beforeListNamespaceSecretsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceSecrets.afterListNamespaceSecretsCounter, 1)

	mmListNamespaceSecrets.t.Helper()

	if mmListNamespaceSecrets.inspectFuncListNamespaceSecrets != nil {
		mmListNamespaceSecrets.inspectFuncListNamespaceSecrets(ctx, ownerPermalink, pageSize, pageToken, filter)
	}

	mm_params := RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}

	// Record call args
	mmListNamespaceSecrets.ListNamespaceSecretsMock.mutex.Lock()
	mmListNamespaceSecrets.ListNamespaceSecretsMock.callArgs = append(mmListNamespaceSecrets.ListNamespaceSecretsMock.callArgs, &mm_params)
	mmListNamespaceSecrets.ListNamespaceSecretsMock.mutex.Unlock()

	for _, e := range mmListNamespaceSecrets.ListNamespaceSecretsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceSecrets.t.Fatal("No results are set for the RepositoryMock.ListNamespaceSecrets")
		}
		return (*mm_results).spa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListNamespaceSecrets.funcListNamespaceSecrets != nil {
		return mmListNamespaceSecrets.funcListNamespaceSecrets(ctx, ownerPermalink, pageSize, pageToken, filter)
	}
	mmListNamespaceSecrets.t.Fatalf("Unexpected call to RepositoryMock.ListNamespaceSecrets. %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, filter)
	return
}

// ListNamespaceSecretsAfterCounter returns a count of finished RepositoryMock.ListNamespaceSecrets invocations
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecretsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceSecrets.afterListNamespaceSecretsCounter)
}

// ListNamespaceSecretsBeforeCounter returns a count of RepositoryMock.ListNamespaceSecrets invocations
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecretsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceSecrets.beforeListNamespaceSecretsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespaceSecrets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Calls() []*RepositoryMockListNamespaceSecretsParams {
	mmListNamespaceSecrets.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespaceSecretsParams, len(mmListNamespaceSecrets.callArgs))
	copy(argCopy, mmListNamespaceSecrets.callArgs)

	mmListNamespaceSecrets.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceSecretsDone returns true if the count of the ListNamespaceSecrets invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespaceSecretsDone() bool {
	if m.ListNamespaceSecretsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceSecretsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceSecretsMock.invocationsDone()
}

// MinimockListNamespaceSecretsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespaceSecretsInspect() {
	for _, e := range m.ListNamespaceSecretsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespaceSecretsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceSecretsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceSecretsMock.defaultExpectation != nil && afterListNamespaceSecretsCounter < 1 {
		if m.ListNamespaceSecretsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s", m.ListNamespaceSecretsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s with params: %#v", m.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespaceSecretsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceSecrets != nil && afterListNamespaceSecretsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s", m.funcListNamespaceSecretsOrigin)
	}

	if !m.ListNamespaceSecretsMock.invocationsDone() && afterListNamespaceSecretsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespaceSecrets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceSecretsMock.expectedInvocations), m.ListNamespaceSecretsMock.expectedInvocationsOrigin, afterListNamespaceSecretsCounter)
	}
}

type mRepositoryMockListPipelineIDsByConnectionID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineIDsByConnectionIDExpectation
	expectations       []*RepositoryMockListPipelineIDsByConnectionIDExpectation

	callArgs []*RepositoryMockListPipelineIDsByConnectionIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelineIDsByConnectionIDExpectation specifies expectation struct of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelineIDsByConnectionIDParams
	paramPtrs          *RepositoryMockListPipelineIDsByConnectionIDParamPtrs
	expectationOrigins RepositoryMockListPipelineIDsByConnectionIDExpectationOrigins
	results            *RepositoryMockListPipelineIDsByConnectionIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelineIDsByConnectionIDParams contains parameters of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDParams struct {
	ctx context.Context
	l1  mm_repository.ListPipelineIDsByConnectionIDParams
}

// RepositoryMockListPipelineIDsByConnectionIDParamPtrs contains pointers to parameters of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListPipelineIDsByConnectionIDParams
}

// RepositoryMockListPipelineIDsByConnectionIDResults contains results of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDResults struct {
	p1  mm_repository.PipelinesByConnectionList
	err error
}

// RepositoryMockListPipelineIDsByConnectionIDOrigins contains origins of expectations of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Optional() *mRepositoryMockListPipelineIDsByConnectionID {
	mmListPipelineIDsByConnectionID.optional = true
	return mmListPipelineIDsByConnectionID
}

// Expect sets up expected params for Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Expect(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{}
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by ExpectParams functions")
	}

	mmListPipelineIDsByConnectionID.defaultExpectation.params = &RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1}
	mmListPipelineIDsByConnectionID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelineIDsByConnectionID.expectations {
		if minimock.Equal(e.params, mmListPipelineIDsByConnectionID.defaultExpectation.params) {
			mmListPipelineIDsByConnectionID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineIDsByConnectionID.defaultExpectation.params)
		}
	}

	return mmListPipelineIDsByConnectionID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{}
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.params != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Expect")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs = &RepositoryMockListPipelineIDsByConnectionIDParamPtrs{}
	}
	mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelineIDsByConnectionID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelineIDsByConnectionID
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) ExpectL1Param2(l1 mm_repository.ListPipelineIDsByConnectionIDParams) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{}
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.params != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Expect")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs = &RepositoryMockListPipelineIDsByConnectionIDParamPtrs{}
	}
	mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs.l1 = &l1
	mmListPipelineIDsByConnectionID.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListPipelineIDsByConnectionID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Inspect(f func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams)) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.inspectFuncListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineIDsByConnectionID")
	}

	mmListPipelineIDsByConnectionID.mock.inspectFuncListPipelineIDsByConnectionID = f

	return mmListPipelineIDsByConnectionID
}

// Return sets up results that will be returned by Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Return(p1 mm_repository.PipelinesByConnectionList, err error) *RepositoryMock {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{mock: mmListPipelineIDsByConnectionID.mock}
	}
	mmListPipelineIDsByConnectionID.defaultExpectation.results = &RepositoryMockListPipelineIDsByConnectionIDResults{p1, err}
	mmListPipelineIDsByConnectionID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelineIDsByConnectionID.mock
}

// Set uses given function f to mock the Repository.ListPipelineIDsByConnectionID method
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Set(f func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) (p1 mm_repository.PipelinesByConnectionList, err error)) *RepositoryMock {
	if mmListPipelineIDsByConnectionID.defaultExpectation != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineIDsByConnectionID method")
	}

	if len(mmListPipelineIDsByConnectionID.expectations) > 0 {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineIDsByConnectionID method")
	}

	mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID = f
	mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionIDOrigin = minimock.CallerInfo(1)
	return mmListPipelineIDsByConnectionID.mock
}

// When sets expectation for the Repository.ListPipelineIDsByConnectionID which will trigger the result defined by the following
// Then helper
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) When(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) *RepositoryMockListPipelineIDsByConnectionIDExpectation {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineIDsByConnectionIDExpectation{
		mock:               mmListPipelineIDsByConnectionID.mock,
		params:             &RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1},
		expectationOrigins: RepositoryMockListPipelineIDsByConnectionIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelineIDsByConnectionID.expectations = append(mmListPipelineIDsByConnectionID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineIDsByConnectionID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineIDsByConnectionIDExpectation) Then(p1 mm_repository.PipelinesByConnectionList, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineIDsByConnectionIDResults{p1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineIDsByConnectionID should be invoked
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Times(n uint64) *mRepositoryMockListPipelineIDsByConnectionID {
	if n == 0 {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Times of RepositoryMock.ListPipelineIDsByConnectionID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineIDsByConnectionID.expectedInvocations, n)
	mmListPipelineIDsByConnectionID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelineIDsByConnectionID
}

func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) invocationsDone() bool {
	if len(mmListPipelineIDsByConnectionID.expectations) == 0 && mmListPipelineIDsByConnectionID.defaultExpectation == nil && mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.mock.afterListPipelineIDsByConnectionIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineIDsByConnectionID implements mm_repository.Repository
func (mmListPipelineIDsByConnectionID *RepositoryMock) ListPipelineIDsByConnectionID(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) (p1 mm_repository.PipelinesByConnectionList, err error) {
	mm_atomic.AddUint64(&mmListPipelineIDsByConnectionID.beforeListPipelineIDsByConnectionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineIDsByConnectionID.afterListPipelineIDsByConnectionIDCounter, 1)

	mmListPipelineIDsByConnectionID.t.Helper()

	if mmListPipelineIDsByConnectionID.inspectFuncListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.inspectFuncListPipelineIDsByConnectionID(ctx, l1)
	}

	mm_params := RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1}

	// Record call args
	mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.mutex.Lock()
	mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.callArgs = append(mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.callArgs, &mm_params)
	mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.mutex.Unlock()

	for _, e := range mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineIDsByConnectionID.t.Errorf("RepositoryMock.ListPipelineIDsByConnectionID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListPipelineIDsByConnectionID.t.Errorf("RepositoryMock.ListPipelineIDsByConnectionID got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineIDsByConnectionID.t.Errorf("RepositoryMock.ListPipelineIDsByConnectionID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineIDsByConnectionID.t.Fatal("No results are set for the RepositoryMock.ListPipelineIDsByConnectionID")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmListPipelineIDsByConnectionID.funcListPipelineIDsByConnectionID != nil {
		return mmListPipelineIDsByConnectionID.funcListPipelineIDsByConnectionID(ctx, l1)
	}
	mmListPipelineIDsByConnectionID.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineIDsByConnectionID. %v %v", ctx, l1)
	return
}

// ListPipelineIDsByConnectionIDAfterCounter returns a count of finished RepositoryMock.ListPipelineIDsByConnectionID invocations
func (mmListPipelineIDsByConnectionID *RepositoryMock) ListPipelineIDsByConnectionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.afterListPipelineIDsByConnectionIDCounter)
}

// ListPipelineIDsByConnectionIDBeforeCounter returns a count of RepositoryMock.ListPipelineIDsByConnectionID invocations
func (mmListPipelineIDsByConnectionID *RepositoryMock) ListPipelineIDsByConnectionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.beforeListPipelineIDsByConnectionIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineIDsByConnectionID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Calls() []*RepositoryMockListPipelineIDsByConnectionIDParams {
	mmListPipelineIDsByConnectionID.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineIDsByConnectionIDParams, len(mmListPipelineIDsByConnectionID.callArgs))
	copy(argCopy, mmListPipelineIDsByConnectionID.callArgs)

	mmListPipelineIDsByConnectionID.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineIDsByConnectionIDDone returns true if the count of the ListPipelineIDsByConnectionID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineIDsByConnectionIDDone() bool {
	if m.ListPipelineIDsByConnectionIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineIDsByConnectionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineIDsByConnectionIDMock.invocationsDone()
}

// MinimockListPipelineIDsByConnectionIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineIDsByConnectionIDInspect() {
	for _, e := range m.ListPipelineIDsByConnectionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelineIDsByConnectionIDCounter := mm_atomic.LoadUint64(&m.afterListPipelineIDsByConnectionIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineIDsByConnectionIDMock.defaultExpectation != nil && afterListPipelineIDsByConnectionIDCounter < 1 {
		if m.ListPipelineIDsByConnectionIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s", m.ListPipelineIDsByConnectionIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s with params: %#v", m.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelineIDsByConnectionIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineIDsByConnectionID != nil && afterListPipelineIDsByConnectionIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s", m.funcListPipelineIDsByConnectionIDOrigin)
	}

	if !m.ListPipelineIDsByConnectionIDMock.invocationsDone() && afterListPipelineIDsByConnectionIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineIDsByConnectionID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineIDsByConnectionIDMock.expectedInvocations), m.ListPipelineIDsByConnectionIDMock.expectedInvocationsOrigin, afterListPipelineIDsByConnectionIDCounter)
	}
}

type mRepositoryMockListPipelineReleases struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineReleasesExpectation
	expectations       []*RepositoryMockListPipelineReleasesExpectation

	callArgs []*RepositoryMockListPipelineReleasesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelineReleasesExpectation specifies expectation struct of the Repository.ListPipelineReleases
type RepositoryMockListPipelineReleasesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelineReleasesParams
	paramPtrs          *RepositoryMockListPipelineReleasesParamPtrs
	expectationOrigins RepositoryMockListPipelineReleasesExpectationOrigins
	results            *RepositoryMockListPipelineReleasesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelineReleasesParams contains parameters of the Repository.ListPipelineReleases
type RepositoryMockListPipelineReleasesParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	showDeleted    bool
	returnCount    bool
}

// RepositoryMockListPipelineReleasesParamPtrs contains pointers to parameters of the Repository.ListPipelineReleases
type RepositoryMockListPipelineReleasesParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	showDeleted    *bool
	returnCount    *bool
}

// RepositoryMockListPipelineReleasesResults contains results of the Repository.ListPipelineReleases
type RepositoryMockListPipelineReleasesResults struct {
	ppa1 []*datamodel.PipelineRelease
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListPipelineReleasesOrigins contains origins of expectations of the Repository.ListPipelineReleases
type RepositoryMockListPipelineReleasesExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originPageSize       string
	originPageToken      string
	originIsBasicView    string
	originFilter         string
	originShowDeleted    string
	originReturnCount    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) Optional() *mRepositoryMockListPipelineReleases {
	mmListPipelineReleases.optional = true
	return mmListPipelineReleases
}

// Expect sets up expected params for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by ExpectParams functions")
	}

	mmListPipelineReleases.defaultExpectation.params = &RepositoryMockListPipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}
	mmListPipelineReleases.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelineReleases.expectations {
		if minimock.Equal(e.params, mmListPipelineReleases.defaultExpectation.params) {
			mmListPipelineReleases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineReleases.defaultExpectation.params)
		}
	}

	return mmListPipelineReleases
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectPageSizeParam4 sets up expected param pageSize for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectPageSizeParam4(pageSize int64) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectPageTokenParam5 sets up expected param pageToken for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectPageTokenParam5(pageToken string) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectIsBasicViewParam6 sets up expected param isBasicView for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectIsBasicViewParam6(isBasicView bool) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectFilterParam7 sets up expected param filter for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectFilterParam7(filter filtering.Filter) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.filter = &filter
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// ExpectReturnCountParam9 sets up expected param returnCount for Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) ExpectReturnCountParam9(returnCount bool) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{}
	}

	if mmListPipelineReleases.defaultExpectation.params != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Expect")
	}

	if mmListPipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListPipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListPipelineReleasesParamPtrs{}
	}
	mmListPipelineReleases.defaultExpectation.paramPtrs.returnCount = &returnCount
	mmListPipelineReleases.defaultExpectation.expectationOrigins.originReturnCount = minimock.CallerInfo(1)

	return mmListPipelineReleases
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool)) *mRepositoryMockListPipelineReleases {
	if mmListPipelineReleases.mock.inspectFuncListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineReleases")
	}

	mmListPipelineReleases.mock.inspectFuncListPipelineReleases = f

	return mmListPipelineReleases
}

// Return sets up results that will be returned by Repository.ListPipelineReleases
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) Return(ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	if mmListPipelineReleases.defaultExpectation == nil {
		mmListPipelineReleases.defaultExpectation = &RepositoryMockListPipelineReleasesExpectation{mock: mmListPipelineReleases.mock}
	}
	mmListPipelineReleases.defaultExpectation.results = &RepositoryMockListPipelineReleasesResults{ppa1, i1, s1, err}
	mmListPipelineReleases.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelineReleases.mock
}

// Set uses given function f to mock the Repository.ListPipelineReleases method
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPipelineReleases.defaultExpectation != nil {
		mmListPipelineReleases.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineReleases method")
	}

	if len(mmListPipelineReleases.expectations) > 0 {
		mmListPipelineReleases.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineReleases method")
	}

	mmListPipelineReleases.mock.funcListPipelineReleases = f
	mmListPipelineReleases.mock.funcListPipelineReleasesOrigin = minimock.CallerInfo(1)
	return mmListPipelineReleases.mock
}

// When sets expectation for the Repository.ListPipelineReleases which will trigger the result defined by the following
// Then helper
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) *RepositoryMockListPipelineReleasesExpectation {
	if mmListPipelineReleases.mock.funcListPipelineReleases != nil {
		mmListPipelineReleases.mock.t.Fatalf("RepositoryMock.ListPipelineReleases mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineReleasesExpectation{
		mock:               mmListPipelineReleases.mock,
		params:             &RepositoryMockListPipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount},
		expectationOrigins: RepositoryMockListPipelineReleasesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelineReleases.expectations = append(mmListPipelineReleases.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineReleases return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineReleasesExpectation) Then(ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineReleasesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineReleases should be invoked
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) Times(n uint64) *mRepositoryMockListPipelineReleases {
	if n == 0 {
		mmListPipelineReleases.mock.t.Fatalf("Times of RepositoryMock.ListPipelineReleases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineReleases.expectedInvocations, n)
	mmListPipelineReleases.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelineReleases
}

func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) invocationsDone() bool {
	if len(mmListPipelineReleases.expectations) == 0 && mmListPipelineReleases.defaultExpectation == nil && mmListPipelineReleases.mock.funcListPipelineReleases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineReleases.mock.afterListPipelineReleasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineReleases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineReleases implements mm_repository.Repository
func (mmListPipelineReleases *RepositoryMock) ListPipelineReleases(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPipelineReleases.beforeListPipelineReleasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineReleases.afterListPipelineReleasesCounter, 1)

	mmListPipelineReleases.t.Helper()

	if mmListPipelineReleases.inspectFuncListPipelineReleases != nil {
		mmListPipelineReleases.inspectFuncListPipelineReleases(ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	}

	mm_params := RepositoryMockListPipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}

	// Record call args
	mmListPipelineReleases.ListPipelineReleasesMock.mutex.Lock()
	mmListPipelineReleases.ListPipelineReleasesMock.callArgs = append(mmListPipelineReleases.ListPipelineReleasesMock.callArgs, &mm_params)
	mmListPipelineReleases.ListPipelineReleasesMock.mutex.Unlock()

	for _, e := range mmListPipelineReleases.ListPipelineReleasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.returnCount != nil && !minimock.Equal(*mm_want_ptrs.returnCount, mm_got.returnCount) {
				mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameter returnCount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.originReturnCount, *mm_want_ptrs.returnCount, mm_got.returnCount, minimock.Diff(*mm_want_ptrs.returnCount, mm_got.returnCount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineReleases.t.Errorf("RepositoryMock.ListPipelineReleases got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineReleases.ListPipelineReleasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineReleases.t.Fatal("No results are set for the RepositoryMock.ListPipelineReleases")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPipelineReleases.funcListPipelineReleases != nil {
		return mmListPipelineReleases.funcListPipelineReleases(ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	}
	mmListPipelineReleases.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineReleases. %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	return
}

// ListPipelineReleasesAfterCounter returns a count of finished RepositoryMock.ListPipelineReleases invocations
func (mmListPipelineReleases *RepositoryMock) ListPipelineReleasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineReleases.afterListPipelineReleasesCounter)
}

// ListPipelineReleasesBeforeCounter returns a count of RepositoryMock.ListPipelineReleases invocations
func (mmListPipelineReleases *RepositoryMock) ListPipelineReleasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineReleases.beforeListPipelineReleasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineReleases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineReleases *mRepositoryMockListPipelineReleases) Calls() []*RepositoryMockListPipelineReleasesParams {
	mmListPipelineReleases.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineReleasesParams, len(mmListPipelineReleases.callArgs))
	copy(argCopy, mmListPipelineReleases.callArgs)

	mmListPipelineReleases.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineReleasesDone returns true if the count of the ListPipelineReleases invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineReleasesDone() bool {
	if m.ListPipelineReleasesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineReleasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineReleasesMock.invocationsDone()
}

// MinimockListPipelineReleasesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineReleasesInspect() {
	for _, e := range m.ListPipelineReleasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineReleases at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelineReleasesCounter := mm_atomic.LoadUint64(&m.afterListPipelineReleasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineReleasesMock.defaultExpectation != nil && afterListPipelineReleasesCounter < 1 {
		if m.ListPipelineReleasesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineReleases at\n%s", m.ListPipelineReleasesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineReleases at\n%s with params: %#v", m.ListPipelineReleasesMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelineReleasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineReleases != nil && afterListPipelineReleasesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelineReleases at\n%s", m.funcListPipelineReleasesOrigin)
	}

	if !m.ListPipelineReleasesMock.invocationsDone() && afterListPipelineReleasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineReleases at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineReleasesMock.expectedInvocations), m.ListPipelineReleasesMock.expectedInvocationsOrigin, afterListPipelineReleasesCounter)
	}
}

type mRepositoryMockListPipelineRunOns struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineRunOnsExpectation
	expectations       []*RepositoryMockListPipelineRunOnsExpectation

	callArgs []*RepositoryMockListPipelineRunOnsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelineRunOnsExpectation specifies expectation struct of the Repository.ListPipelineRunOns
type RepositoryMockListPipelineRunOnsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelineRunOnsParams
	paramPtrs          *RepositoryMockListPipelineRunOnsParamPtrs
	expectationOrigins RepositoryMockListPipelineRunOnsExpectationOrigins
	results            *RepositoryMockListPipelineRunOnsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelineRunOnsParams contains parameters of the Repository.ListPipelineRunOns
type RepositoryMockListPipelineRunOnsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
}

// RepositoryMockListPipelineRunOnsParamPtrs contains pointers to parameters of the Repository.ListPipelineRunOns
type RepositoryMockListPipelineRunOnsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
}

// RepositoryMockListPipelineRunOnsResults contains results of the Repository.ListPipelineRunOns
type RepositoryMockListPipelineRunOnsResults struct {
	p1  mm_repository.PipelineRunOnList
	err error
}

// RepositoryMockListPipelineRunOnsOrigins contains origins of expectations of the Repository.ListPipelineRunOns
type RepositoryMockListPipelineRunOnsExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) Optional() *mRepositoryMockListPipelineRunOns {
	mmListPipelineRunOns.optional = true
	return mmListPipelineRunOns
}

// Expect sets up expected params for Repository.ListPipelineRunOns
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) Expect(ctx context.Context, pipelineUID uuid.UUID) *mRepositoryMockListPipelineRunOns {
	if mmListPipelineRunOns.mock.funcListPipelineRunOns != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by Set")
	}

	if mmListPipelineRunOns.defaultExpectation == nil {
		mmListPipelineRunOns.defaultExpectation = &RepositoryMockListPipelineRunOnsExpectation{}
	}

	if mmListPipelineRunOns.defaultExpectation.paramPtrs != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by ExpectParams functions")
	}

	mmListPipelineRunOns.defaultExpectation.params = &RepositoryMockListPipelineRunOnsParams{ctx, pipelineUID}
	mmListPipelineRunOns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelineRunOns.expectations {
		if minimock.Equal(e.params, mmListPipelineRunOns.defaultExpectation.params) {
			mmListPipelineRunOns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineRunOns.defaultExpectation.params)
		}
	}

	return mmListPipelineRunOns
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineRunOns
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineRunOns {
	if mmListPipelineRunOns.mock.funcListPipelineRunOns != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by Set")
	}

	if mmListPipelineRunOns.defaultExpectation == nil {
		mmListPipelineRunOns.defaultExpectation = &RepositoryMockListPipelineRunOnsExpectation{}
	}

	if mmListPipelineRunOns.defaultExpectation.params != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by Expect")
	}

	if mmListPipelineRunOns.defaultExpectation.paramPtrs == nil {
		mmListPipelineRunOns.defaultExpectation.paramPtrs = &RepositoryMockListPipelineRunOnsParamPtrs{}
	}
	mmListPipelineRunOns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelineRunOns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelineRunOns
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.ListPipelineRunOns
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockListPipelineRunOns {
	if mmListPipelineRunOns.mock.funcListPipelineRunOns != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by Set")
	}

	if mmListPipelineRunOns.defaultExpectation == nil {
		mmListPipelineRunOns.defaultExpectation = &RepositoryMockListPipelineRunOnsExpectation{}
	}

	if mmListPipelineRunOns.defaultExpectation.params != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by Expect")
	}

	if mmListPipelineRunOns.defaultExpectation.paramPtrs == nil {
		mmListPipelineRunOns.defaultExpectation.paramPtrs = &RepositoryMockListPipelineRunOnsParamPtrs{}
	}
	mmListPipelineRunOns.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmListPipelineRunOns.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmListPipelineRunOns
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineRunOns
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID)) *mRepositoryMockListPipelineRunOns {
	if mmListPipelineRunOns.mock.inspectFuncListPipelineRunOns != nil {
		mmListPipelineRunOns.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineRunOns")
	}

	mmListPipelineRunOns.mock.inspectFuncListPipelineRunOns = f

	return mmListPipelineRunOns
}

// Return sets up results that will be returned by Repository.ListPipelineRunOns
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) Return(p1 mm_repository.PipelineRunOnList, err error) *RepositoryMock {
	if mmListPipelineRunOns.mock.funcListPipelineRunOns != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by Set")
	}

	if mmListPipelineRunOns.defaultExpectation == nil {
		mmListPipelineRunOns.defaultExpectation = &RepositoryMockListPipelineRunOnsExpectation{mock: mmListPipelineRunOns.mock}
	}
	mmListPipelineRunOns.defaultExpectation.results = &RepositoryMockListPipelineRunOnsResults{p1, err}
	mmListPipelineRunOns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelineRunOns.mock
}

// Set uses given function f to mock the Repository.ListPipelineRunOns method
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) Set(f func(ctx context.Context, pipelineUID uuid.UUID) (p1 mm_repository.PipelineRunOnList, err error)) *RepositoryMock {
	if mmListPipelineRunOns.defaultExpectation != nil {
		mmListPipelineRunOns.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineRunOns method")
	}

	if len(mmListPipelineRunOns.expectations) > 0 {
		mmListPipelineRunOns.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineRunOns method")
	}

	mmListPipelineRunOns.mock.funcListPipelineRunOns = f
	mmListPipelineRunOns.mock.funcListPipelineRunOnsOrigin = minimock.CallerInfo(1)
	return mmListPipelineRunOns.mock
}

// When sets expectation for the Repository.ListPipelineRunOns which will trigger the result defined by the following
// Then helper
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) When(ctx context.Context, pipelineUID uuid.UUID) *RepositoryMockListPipelineRunOnsExpectation {
	if mmListPipelineRunOns.mock.funcListPipelineRunOns != nil {
		mmListPipelineRunOns.mock.t.Fatalf("RepositoryMock.ListPipelineRunOns mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineRunOnsExpectation{
		mock:               mmListPipelineRunOns.mock,
		params:             &RepositoryMockListPipelineRunOnsParams{ctx, pipelineUID},
		expectationOrigins: RepositoryMockListPipelineRunOnsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelineRunOns.expectations = append(mmListPipelineRunOns.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineRunOns return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineRunOnsExpectation) Then(p1 mm_repository.PipelineRunOnList, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineRunOnsResults{p1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineRunOns should be invoked
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) Times(n uint64) *mRepositoryMockListPipelineRunOns {
	if n == 0 {
		mmListPipelineRunOns.mock.t.Fatalf("Times of RepositoryMock.ListPipelineRunOns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineRunOns.expectedInvocations, n)
	mmListPipelineRunOns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelineRunOns
}

func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) invocationsDone() bool {
	if len(mmListPipelineRunOns.expectations) == 0 && mmListPipelineRunOns.defaultExpectation == nil && mmListPipelineRunOns.mock.funcListPipelineRunOns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineRunOns.mock.afterListPipelineRunOnsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineRunOns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineRunOns implements mm_repository.Repository
func (mmListPipelineRunOns *RepositoryMock) ListPipelineRunOns(ctx context.Context, pipelineUID uuid.UUID) (p1 mm_repository.PipelineRunOnList, err error) {
	mm_atomic.AddUint64(&mmListPipelineRunOns.beforeListPipelineRunOnsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineRunOns.afterListPipelineRunOnsCounter, 1)

	mmListPipelineRunOns.t.Helper()

	if mmListPipelineRunOns.inspectFuncListPipelineRunOns != nil {
		mmListPipelineRunOns.inspectFuncListPipelineRunOns(ctx, pipelineUID)
	}

	mm_params := RepositoryMockListPipelineRunOnsParams{ctx, pipelineUID}

	// Record call args
	mmListPipelineRunOns.ListPipelineRunOnsMock.mutex.Lock()
	mmListPipelineRunOns.ListPipelineRunOnsMock.callArgs = append(mmListPipelineRunOns.ListPipelineRunOnsMock.callArgs, &mm_params)
	mmListPipelineRunOns.ListPipelineRunOnsMock.mutex.Unlock()

	for _, e := range mmListPipelineRunOns.ListPipelineRunOnsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineRunOnsParams{ctx, pipelineUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineRunOns.t.Errorf("RepositoryMock.ListPipelineRunOns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmListPipelineRunOns.t.Errorf("RepositoryMock.ListPipelineRunOns got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineRunOns.t.Errorf("RepositoryMock.ListPipelineRunOns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineRunOns.ListPipelineRunOnsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineRunOns.t.Fatal("No results are set for the RepositoryMock.ListPipelineRunOns")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmListPipelineRunOns.funcListPipelineRunOns != nil {
		return mmListPipelineRunOns.funcListPipelineRunOns(ctx, pipelineUID)
	}
	mmListPipelineRunOns.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineRunOns. %v %v", ctx, pipelineUID)
	return
}

// ListPipelineRunOnsAfterCounter returns a count of finished RepositoryMock.ListPipelineRunOns invocations
func (mmListPipelineRunOns *RepositoryMock) ListPipelineRunOnsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineRunOns.afterListPipelineRunOnsCounter)
}

// ListPipelineRunOnsBeforeCounter returns a count of RepositoryMock.ListPipelineRunOns invocations
func (mmListPipelineRunOns *RepositoryMock) ListPipelineRunOnsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineRunOns.beforeListPipelineRunOnsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineRunOns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineRunOns *mRepositoryMockListPipelineRunOns) Calls() []*RepositoryMockListPipelineRunOnsParams {
	mmListPipelineRunOns.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineRunOnsParams, len(mmListPipelineRunOns.callArgs))
	copy(argCopy, mmListPipelineRunOns.callArgs)

	mmListPipelineRunOns.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineRunOnsDone returns true if the count of the ListPipelineRunOns invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineRunOnsDone() bool {
	if m.ListPipelineRunOnsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineRunOnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineRunOnsMock.invocationsDone()
}

// MinimockListPipelineRunOnsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineRunOnsInspect() {
	for _, e := range m.ListPipelineRunOnsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelineRunOnsCounter := mm_atomic.LoadUint64(&m.afterListPipelineRunOnsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineRunOnsMock.defaultExpectation != nil && afterListPipelineRunOnsCounter < 1 {
		if m.ListPipelineRunOnsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOns at\n%s", m.ListPipelineRunOnsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOns at\n%s with params: %#v", m.ListPipelineRunOnsMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelineRunOnsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineRunOns != nil && afterListPipelineRunOnsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOns at\n%s", m.funcListPipelineRunOnsOrigin)
	}

	if !m.ListPipelineRunOnsMock.invocationsDone() && afterListPipelineRunOnsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineRunOns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineRunOnsMock.expectedInvocations), m.ListPipelineRunOnsMock.expectedInvocationsOrigin, afterListPipelineRunOnsCounter)
	}
}

type mRepositoryMockListPipelineRunOnsByIdentifier struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineRunOnsByIdentifierExpectation
	expectations       []*RepositoryMockListPipelineRunOnsByIdentifierExpectation

	callArgs []*RepositoryMockListPipelineRunOnsByIdentifierParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelineRunOnsByIdentifierExpectation specifies expectation struct of the Repository.ListPipelineRunOnsByIdentifier
type RepositoryMockListPipelineRunOnsByIdentifierExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelineRunOnsByIdentifierParams
	paramPtrs          *RepositoryMockListPipelineRunOnsByIdentifierParamPtrs
	expectationOrigins RepositoryMockListPipelineRunOnsByIdentifierExpectationOrigins
	results            *RepositoryMockListPipelineRunOnsByIdentifierResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelineRunOnsByIdentifierParams contains parameters of the Repository.ListPipelineRunOnsByIdentifier
type RepositoryMockListPipelineRunOnsByIdentifierParams struct {
	ctx           context.Context
	ComponentType string
	Identifier    base.Identifier
}

// RepositoryMockListPipelineRunOnsByIdentifierParamPtrs contains pointers to parameters of the Repository.ListPipelineRunOnsByIdentifier
type RepositoryMockListPipelineRunOnsByIdentifierParamPtrs struct {
	ctx           *context.Context
	ComponentType *string
	Identifier    *base.Identifier
}

// RepositoryMockListPipelineRunOnsByIdentifierResults contains results of the Repository.ListPipelineRunOnsByIdentifier
type RepositoryMockListPipelineRunOnsByIdentifierResults struct {
	p1  mm_repository.PipelineRunOnList
	err error
}

// RepositoryMockListPipelineRunOnsByIdentifierOrigins contains origins of expectations of the Repository.ListPipelineRunOnsByIdentifier
type RepositoryMockListPipelineRunOnsByIdentifierExpectationOrigins struct {
	origin              string
	originCtx           string
	originComponentType string
	originIdentifier    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) Optional() *mRepositoryMockListPipelineRunOnsByIdentifier {
	mmListPipelineRunOnsByIdentifier.optional = true
	return mmListPipelineRunOnsByIdentifier
}

// Expect sets up expected params for Repository.ListPipelineRunOnsByIdentifier
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) Expect(ctx context.Context, ComponentType string, Identifier base.Identifier) *mRepositoryMockListPipelineRunOnsByIdentifier {
	if mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Set")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation = &RepositoryMockListPipelineRunOnsByIdentifierExpectation{}
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by ExpectParams functions")
	}

	mmListPipelineRunOnsByIdentifier.defaultExpectation.params = &RepositoryMockListPipelineRunOnsByIdentifierParams{ctx, ComponentType, Identifier}
	mmListPipelineRunOnsByIdentifier.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelineRunOnsByIdentifier.expectations {
		if minimock.Equal(e.params, mmListPipelineRunOnsByIdentifier.defaultExpectation.params) {
			mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineRunOnsByIdentifier.defaultExpectation.params)
		}
	}

	return mmListPipelineRunOnsByIdentifier
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineRunOnsByIdentifier
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineRunOnsByIdentifier {
	if mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Set")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation = &RepositoryMockListPipelineRunOnsByIdentifierExpectation{}
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation.params != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Expect")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs = &RepositoryMockListPipelineRunOnsByIdentifierParamPtrs{}
	}
	mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelineRunOnsByIdentifier.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelineRunOnsByIdentifier
}

// ExpectComponentTypeParam2 sets up expected param ComponentType for Repository.ListPipelineRunOnsByIdentifier
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) ExpectComponentTypeParam2(ComponentType string) *mRepositoryMockListPipelineRunOnsByIdentifier {
	if mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Set")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation = &RepositoryMockListPipelineRunOnsByIdentifierExpectation{}
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation.params != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Expect")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs = &RepositoryMockListPipelineRunOnsByIdentifierParamPtrs{}
	}
	mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs.ComponentType = &ComponentType
	mmListPipelineRunOnsByIdentifier.defaultExpectation.expectationOrigins.originComponentType = minimock.CallerInfo(1)

	return mmListPipelineRunOnsByIdentifier
}

// ExpectIdentifierParam3 sets up expected param Identifier for Repository.ListPipelineRunOnsByIdentifier
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) ExpectIdentifierParam3(Identifier base.Identifier) *mRepositoryMockListPipelineRunOnsByIdentifier {
	if mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Set")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation = &RepositoryMockListPipelineRunOnsByIdentifierExpectation{}
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation.params != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Expect")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs = &RepositoryMockListPipelineRunOnsByIdentifierParamPtrs{}
	}
	mmListPipelineRunOnsByIdentifier.defaultExpectation.paramPtrs.Identifier = &Identifier
	mmListPipelineRunOnsByIdentifier.defaultExpectation.expectationOrigins.originIdentifier = minimock.CallerInfo(1)

	return mmListPipelineRunOnsByIdentifier
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineRunOnsByIdentifier
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) Inspect(f func(ctx context.Context, ComponentType string, Identifier base.Identifier)) *mRepositoryMockListPipelineRunOnsByIdentifier {
	if mmListPipelineRunOnsByIdentifier.mock.inspectFuncListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineRunOnsByIdentifier")
	}

	mmListPipelineRunOnsByIdentifier.mock.inspectFuncListPipelineRunOnsByIdentifier = f

	return mmListPipelineRunOnsByIdentifier
}

// Return sets up results that will be returned by Repository.ListPipelineRunOnsByIdentifier
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) Return(p1 mm_repository.PipelineRunOnList, err error) *RepositoryMock {
	if mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Set")
	}

	if mmListPipelineRunOnsByIdentifier.defaultExpectation == nil {
		mmListPipelineRunOnsByIdentifier.defaultExpectation = &RepositoryMockListPipelineRunOnsByIdentifierExpectation{mock: mmListPipelineRunOnsByIdentifier.mock}
	}
	mmListPipelineRunOnsByIdentifier.defaultExpectation.results = &RepositoryMockListPipelineRunOnsByIdentifierResults{p1, err}
	mmListPipelineRunOnsByIdentifier.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelineRunOnsByIdentifier.mock
}

// Set uses given function f to mock the Repository.ListPipelineRunOnsByIdentifier method
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) Set(f func(ctx context.Context, ComponentType string, Identifier base.Identifier) (p1 mm_repository.PipelineRunOnList, err error)) *RepositoryMock {
	if mmListPipelineRunOnsByIdentifier.defaultExpectation != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineRunOnsByIdentifier method")
	}

	if len(mmListPipelineRunOnsByIdentifier.expectations) > 0 {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineRunOnsByIdentifier method")
	}

	mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier = f
	mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifierOrigin = minimock.CallerInfo(1)
	return mmListPipelineRunOnsByIdentifier.mock
}

// When sets expectation for the Repository.ListPipelineRunOnsByIdentifier which will trigger the result defined by the following
// Then helper
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) When(ctx context.Context, ComponentType string, Identifier base.Identifier) *RepositoryMockListPipelineRunOnsByIdentifierExpectation {
	if mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("RepositoryMock.ListPipelineRunOnsByIdentifier mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineRunOnsByIdentifierExpectation{
		mock:               mmListPipelineRunOnsByIdentifier.mock,
		params:             &RepositoryMockListPipelineRunOnsByIdentifierParams{ctx, ComponentType, Identifier},
		expectationOrigins: RepositoryMockListPipelineRunOnsByIdentifierExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelineRunOnsByIdentifier.expectations = append(mmListPipelineRunOnsByIdentifier.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineRunOnsByIdentifier return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineRunOnsByIdentifierExpectation) Then(p1 mm_repository.PipelineRunOnList, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineRunOnsByIdentifierResults{p1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineRunOnsByIdentifier should be invoked
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) Times(n uint64) *mRepositoryMockListPipelineRunOnsByIdentifier {
	if n == 0 {
		mmListPipelineRunOnsByIdentifier.mock.t.Fatalf("Times of RepositoryMock.ListPipelineRunOnsByIdentifier mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineRunOnsByIdentifier.expectedInvocations, n)
	mmListPipelineRunOnsByIdentifier.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelineRunOnsByIdentifier
}

func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) invocationsDone() bool {
	if len(mmListPipelineRunOnsByIdentifier.expectations) == 0 && mmListPipelineRunOnsByIdentifier.defaultExpectation == nil && mmListPipelineRunOnsByIdentifier.mock.funcListPipelineRunOnsByIdentifier == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineRunOnsByIdentifier.mock.afterListPipelineRunOnsByIdentifierCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineRunOnsByIdentifier.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineRunOnsByIdentifier implements mm_repository.Repository
func (mmListPipelineRunOnsByIdentifier *RepositoryMock) ListPipelineRunOnsByIdentifier(ctx context.Context, ComponentType string, Identifier base.Identifier) (p1 mm_repository.PipelineRunOnList, err error) {
	mm_atomic.AddUint64(&mmListPipelineRunOnsByIdentifier.beforeListPipelineRunOnsByIdentifierCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineRunOnsByIdentifier.afterListPipelineRunOnsByIdentifierCounter, 1)

	mmListPipelineRunOnsByIdentifier.t.Helper()

	if mmListPipelineRunOnsByIdentifier.inspectFuncListPipelineRunOnsByIdentifier != nil {
		mmListPipelineRunOnsByIdentifier.inspectFuncListPipelineRunOnsByIdentifier(ctx, ComponentType, Identifier)
	}

	mm_params := RepositoryMockListPipelineRunOnsByIdentifierParams{ctx, ComponentType, Identifier}

	// Record call args
	mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.mutex.Lock()
	mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.callArgs = append(mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.callArgs, &mm_params)
	mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.mutex.Unlock()

	for _, e := range mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineRunOnsByIdentifierParams{ctx, ComponentType, Identifier}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineRunOnsByIdentifier.t.Errorf("RepositoryMock.ListPipelineRunOnsByIdentifier got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ComponentType != nil && !minimock.Equal(*mm_want_ptrs.ComponentType, mm_got.ComponentType) {
				mmListPipelineRunOnsByIdentifier.t.Errorf("RepositoryMock.ListPipelineRunOnsByIdentifier got unexpected parameter ComponentType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.expectationOrigins.originComponentType, *mm_want_ptrs.ComponentType, mm_got.ComponentType, minimock.Diff(*mm_want_ptrs.ComponentType, mm_got.ComponentType))
			}

			if mm_want_ptrs.Identifier != nil && !minimock.Equal(*mm_want_ptrs.Identifier, mm_got.Identifier) {
				mmListPipelineRunOnsByIdentifier.t.Errorf("RepositoryMock.ListPipelineRunOnsByIdentifier got unexpected parameter Identifier, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.expectationOrigins.originIdentifier, *mm_want_ptrs.Identifier, mm_got.Identifier, minimock.Diff(*mm_want_ptrs.Identifier, mm_got.Identifier))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineRunOnsByIdentifier.t.Errorf("RepositoryMock.ListPipelineRunOnsByIdentifier got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineRunOnsByIdentifier.ListPipelineRunOnsByIdentifierMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineRunOnsByIdentifier.t.Fatal("No results are set for the RepositoryMock.ListPipelineRunOnsByIdentifier")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmListPipelineRunOnsByIdentifier.funcListPipelineRunOnsByIdentifier != nil {
		return mmListPipelineRunOnsByIdentifier.funcListPipelineRunOnsByIdentifier(ctx, ComponentType, Identifier)
	}
	mmListPipelineRunOnsByIdentifier.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineRunOnsByIdentifier. %v %v %v", ctx, ComponentType, Identifier)
	return
}

// ListPipelineRunOnsByIdentifierAfterCounter returns a count of finished RepositoryMock.ListPipelineRunOnsByIdentifier invocations
func (mmListPipelineRunOnsByIdentifier *RepositoryMock) ListPipelineRunOnsByIdentifierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineRunOnsByIdentifier.afterListPipelineRunOnsByIdentifierCounter)
}

// ListPipelineRunOnsByIdentifierBeforeCounter returns a count of RepositoryMock.ListPipelineRunOnsByIdentifier invocations
func (mmListPipelineRunOnsByIdentifier *RepositoryMock) ListPipelineRunOnsByIdentifierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineRunOnsByIdentifier.beforeListPipelineRunOnsByIdentifierCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineRunOnsByIdentifier.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineRunOnsByIdentifier *mRepositoryMockListPipelineRunOnsByIdentifier) Calls() []*RepositoryMockListPipelineRunOnsByIdentifierParams {
	mmListPipelineRunOnsByIdentifier.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineRunOnsByIdentifierParams, len(mmListPipelineRunOnsByIdentifier.callArgs))
	copy(argCopy, mmListPipelineRunOnsByIdentifier.callArgs)

	mmListPipelineRunOnsByIdentifier.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineRunOnsByIdentifierDone returns true if the count of the ListPipelineRunOnsByIdentifier invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineRunOnsByIdentifierDone() bool {
	if m.ListPipelineRunOnsByIdentifierMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineRunOnsByIdentifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineRunOnsByIdentifierMock.invocationsDone()
}

// MinimockListPipelineRunOnsByIdentifierInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineRunOnsByIdentifierInspect() {
	for _, e := range m.ListPipelineRunOnsByIdentifierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOnsByIdentifier at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelineRunOnsByIdentifierCounter := mm_atomic.LoadUint64(&m.afterListPipelineRunOnsByIdentifierCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineRunOnsByIdentifierMock.defaultExpectation != nil && afterListPipelineRunOnsByIdentifierCounter < 1 {
		if m.ListPipelineRunOnsByIdentifierMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOnsByIdentifier at\n%s", m.ListPipelineRunOnsByIdentifierMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOnsByIdentifier at\n%s with params: %#v", m.ListPipelineRunOnsByIdentifierMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelineRunOnsByIdentifierMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineRunOnsByIdentifier != nil && afterListPipelineRunOnsByIdentifierCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelineRunOnsByIdentifier at\n%s", m.funcListPipelineRunOnsByIdentifierOrigin)
	}

	if !m.ListPipelineRunOnsByIdentifierMock.invocationsDone() && afterListPipelineRunOnsByIdentifierCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineRunOnsByIdentifier at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineRunOnsByIdentifierMock.expectedInvocations), m.ListPipelineRunOnsByIdentifierMock.expectedInvocationsOrigin, afterListPipelineRunOnsByIdentifierCounter)
	}
}

type mRepositoryMockListPipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineTagsExpectation
	expectations       []*RepositoryMockListPipelineTagsExpectation

	callArgs []*RepositoryMockListPipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelineTagsExpectation specifies expectation struct of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelineTagsParams
	paramPtrs          *RepositoryMockListPipelineTagsParamPtrs
	expectationOrigins RepositoryMockListPipelineTagsExpectationOrigins
	results            *RepositoryMockListPipelineTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelineTagsParams contains parameters of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
}

// RepositoryMockListPipelineTagsParamPtrs contains pointers to parameters of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
}

// RepositoryMockListPipelineTagsResults contains results of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsResults struct {
	ta1 []datamodel.Tag
	err error
}

// RepositoryMockListPipelineTagsOrigins contains origins of expectations of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Optional() *mRepositoryMockListPipelineTags {
	mmListPipelineTags.optional = true
	return mmListPipelineTags
}

// Expect sets up expected params for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by ExpectParams functions")
	}

	mmListPipelineTags.defaultExpectation.params = &RepositoryMockListPipelineTagsParams{ctx, pipelineUID}
	mmListPipelineTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelineTags.expectations {
		if minimock.Equal(e.params, mmListPipelineTags.defaultExpectation.params) {
			mmListPipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineTags.defaultExpectation.params)
		}
	}

	return mmListPipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.params != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Expect")
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs == nil {
		mmListPipelineTags.defaultExpectation.paramPtrs = &RepositoryMockListPipelineTagsParamPtrs{}
	}
	mmListPipelineTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelineTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.params != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Expect")
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs == nil {
		mmListPipelineTags.defaultExpectation.paramPtrs = &RepositoryMockListPipelineTagsParamPtrs{}
	}
	mmListPipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmListPipelineTags.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmListPipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID)) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.inspectFuncListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineTags")
	}

	mmListPipelineTags.mock.inspectFuncListPipelineTags = f

	return mmListPipelineTags
}

// Return sets up results that will be returned by Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Return(ta1 []datamodel.Tag, err error) *RepositoryMock {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{mock: mmListPipelineTags.mock}
	}
	mmListPipelineTags.defaultExpectation.results = &RepositoryMockListPipelineTagsResults{ta1, err}
	mmListPipelineTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelineTags.mock
}

// Set uses given function f to mock the Repository.ListPipelineTags method
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error)) *RepositoryMock {
	if mmListPipelineTags.defaultExpectation != nil {
		mmListPipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineTags method")
	}

	if len(mmListPipelineTags.expectations) > 0 {
		mmListPipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineTags method")
	}

	mmListPipelineTags.mock.funcListPipelineTags = f
	mmListPipelineTags.mock.funcListPipelineTagsOrigin = minimock.CallerInfo(1)
	return mmListPipelineTags.mock
}

// When sets expectation for the Repository.ListPipelineTags which will trigger the result defined by the following
// Then helper
func (mmListPipelineTags *mRepositoryMockListPipelineTags) When(ctx context.Context, pipelineUID uuid.UUID) *RepositoryMockListPipelineTagsExpectation {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineTagsExpectation{
		mock:               mmListPipelineTags.mock,
		params:             &RepositoryMockListPipelineTagsParams{ctx, pipelineUID},
		expectationOrigins: RepositoryMockListPipelineTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelineTags.expectations = append(mmListPipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineTagsExpectation) Then(ta1 []datamodel.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineTagsResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineTags should be invoked
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Times(n uint64) *mRepositoryMockListPipelineTags {
	if n == 0 {
		mmListPipelineTags.mock.t.Fatalf("Times of RepositoryMock.ListPipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineTags.expectedInvocations, n)
	mmListPipelineTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelineTags
}

func (mmListPipelineTags *mRepositoryMockListPipelineTags) invocationsDone() bool {
	if len(mmListPipelineTags.expectations) == 0 && mmListPipelineTags.defaultExpectation == nil && mmListPipelineTags.mock.funcListPipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineTags.mock.afterListPipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineTags implements mm_repository.Repository
func (mmListPipelineTags *RepositoryMock) ListPipelineTags(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error) {
	mm_atomic.AddUint64(&mmListPipelineTags.beforeListPipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineTags.afterListPipelineTagsCounter, 1)

	mmListPipelineTags.t.Helper()

	if mmListPipelineTags.inspectFuncListPipelineTags != nil {
		mmListPipelineTags.inspectFuncListPipelineTags(ctx, pipelineUID)
	}

	mm_params := RepositoryMockListPipelineTagsParams{ctx, pipelineUID}

	// Record call args
	mmListPipelineTags.ListPipelineTagsMock.mutex.Lock()
	mmListPipelineTags.ListPipelineTagsMock.callArgs = append(mmListPipelineTags.ListPipelineTagsMock.callArgs, &mm_params)
	mmListPipelineTags.ListPipelineTagsMock.mutex.Unlock()

	for _, e := range mmListPipelineTags.ListPipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListPipelineTags.ListPipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineTagsParams{ctx, pipelineUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineTags.t.Fatal("No results are set for the RepositoryMock.ListPipelineTags")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListPipelineTags.funcListPipelineTags != nil {
		return mmListPipelineTags.funcListPipelineTags(ctx, pipelineUID)
	}
	mmListPipelineTags.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineTags. %v %v", ctx, pipelineUID)
	return
}

// ListPipelineTagsAfterCounter returns a count of finished RepositoryMock.ListPipelineTags invocations
func (mmListPipelineTags *RepositoryMock) ListPipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineTags.afterListPipelineTagsCounter)
}

// ListPipelineTagsBeforeCounter returns a count of RepositoryMock.ListPipelineTags invocations
func (mmListPipelineTags *RepositoryMock) ListPipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineTags.beforeListPipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Calls() []*RepositoryMockListPipelineTagsParams {
	mmListPipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineTagsParams, len(mmListPipelineTags.callArgs))
	copy(argCopy, mmListPipelineTags.callArgs)

	mmListPipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineTagsDone returns true if the count of the ListPipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineTagsDone() bool {
	if m.ListPipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineTagsMock.invocationsDone()
}

// MinimockListPipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineTagsInspect() {
	for _, e := range m.ListPipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelineTagsCounter := mm_atomic.LoadUint64(&m.afterListPipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineTagsMock.defaultExpectation != nil && afterListPipelineTagsCounter < 1 {
		if m.ListPipelineTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s", m.ListPipelineTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s with params: %#v", m.ListPipelineTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineTags != nil && afterListPipelineTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s", m.funcListPipelineTagsOrigin)
	}

	if !m.ListPipelineTagsMock.invocationsDone() && afterListPipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineTagsMock.expectedInvocations), m.ListPipelineTagsMock.expectedInvocationsOrigin, afterListPipelineTagsCounter)
	}
}

type mRepositoryMockListPipelines struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelinesExpectation
	expectations       []*RepositoryMockListPipelinesExpectation

	callArgs []*RepositoryMockListPipelinesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelinesExpectation specifies expectation struct of the Repository.ListPipelines
type RepositoryMockListPipelinesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelinesParams
	paramPtrs          *RepositoryMockListPipelinesParamPtrs
	expectationOrigins RepositoryMockListPipelinesExpectationOrigins
	results            *RepositoryMockListPipelinesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelinesParams contains parameters of the Repository.ListPipelines
type RepositoryMockListPipelinesParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	uidAllowList   []uuid.UUID
	showDeleted    bool
	embedReleases  bool
	order          ordering.OrderBy
}

// RepositoryMockListPipelinesParamPtrs contains pointers to parameters of the Repository.ListPipelines
type RepositoryMockListPipelinesParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	uidAllowList   *[]uuid.UUID
	showDeleted    *bool
	embedReleases  *bool
	order          *ordering.OrderBy
}

// RepositoryMockListPipelinesResults contains results of the Repository.ListPipelines
type RepositoryMockListPipelinesResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListPipelinesOrigins contains origins of expectations of the Repository.ListPipelines
type RepositoryMockListPipelinesExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPageSize       string
	originPageToken      string
	originIsBasicView    string
	originFilter         string
	originUidAllowList   string
	originShowDeleted    string
	originEmbedReleases  string
	originOrder          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelines *mRepositoryMockListPipelines) Optional() *mRepositoryMockListPipelines {
	mmListPipelines.optional = true
	return mmListPipelines
}

// Expect sets up expected params for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.paramPtrs != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by ExpectParams functions")
	}

	mmListPipelines.defaultExpectation.params = &RepositoryMockListPipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}
	mmListPipelines.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelines.expectations {
		if minimock.Equal(e.params, mmListPipelines.defaultExpectation.params) {
			mmListPipelines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelines.defaultExpectation.params)
		}
	}

	return mmListPipelines
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelines.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmListPipelines.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListPipelines.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListPipelines.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListPipelines.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectFilterParam6 sets up expected param filter for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectFilterParam6(filter filtering.Filter) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.filter = &filter
	mmListPipelines.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectUidAllowListParam7 sets up expected param uidAllowList for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectUidAllowListParam7(uidAllowList []uuid.UUID) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmListPipelines.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListPipelines.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectEmbedReleasesParam9 sets up expected param embedReleases for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectEmbedReleasesParam9(embedReleases bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmListPipelines.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectOrderParam10 sets up expected param order for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectOrderParam10(order ordering.OrderBy) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.order = &order
	mmListPipelines.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmListPipelines
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.inspectFuncListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelines")
	}

	mmListPipelines.mock.inspectFuncListPipelines = f

	return mmListPipelines
}

// Return sets up results that will be returned by Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{mock: mmListPipelines.mock}
	}
	mmListPipelines.defaultExpectation.results = &RepositoryMockListPipelinesResults{ppa1, i1, s1, err}
	mmListPipelines.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelines.mock
}

// Set uses given function f to mock the Repository.ListPipelines method
func (mmListPipelines *mRepositoryMockListPipelines) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPipelines.defaultExpectation != nil {
		mmListPipelines.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelines method")
	}

	if len(mmListPipelines.expectations) > 0 {
		mmListPipelines.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelines method")
	}

	mmListPipelines.mock.funcListPipelines = f
	mmListPipelines.mock.funcListPipelinesOrigin = minimock.CallerInfo(1)
	return mmListPipelines.mock
}

// When sets expectation for the Repository.ListPipelines which will trigger the result defined by the following
// Then helper
func (mmListPipelines *mRepositoryMockListPipelines) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *RepositoryMockListPipelinesExpectation {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelinesExpectation{
		mock:               mmListPipelines.mock,
		params:             &RepositoryMockListPipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order},
		expectationOrigins: RepositoryMockListPipelinesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelines.expectations = append(mmListPipelines.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelines return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelinesExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelinesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelines should be invoked
func (mmListPipelines *mRepositoryMockListPipelines) Times(n uint64) *mRepositoryMockListPipelines {
	if n == 0 {
		mmListPipelines.mock.t.Fatalf("Times of RepositoryMock.ListPipelines mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelines.expectedInvocations, n)
	mmListPipelines.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelines
}

func (mmListPipelines *mRepositoryMockListPipelines) invocationsDone() bool {
	if len(mmListPipelines.expectations) == 0 && mmListPipelines.defaultExpectation == nil && mmListPipelines.mock.funcListPipelines == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelines.mock.afterListPipelinesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelines.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelines implements mm_repository.Repository
func (mmListPipelines *RepositoryMock) ListPipelines(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPipelines.beforeListPipelinesCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelines.afterListPipelinesCounter, 1)

	mmListPipelines.t.Helper()

	if mmListPipelines.inspectFuncListPipelines != nil {
		mmListPipelines.inspectFuncListPipelines(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}

	mm_params := RepositoryMockListPipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

	// Record call args
	mmListPipelines.ListPipelinesMock.mutex.Lock()
	mmListPipelines.ListPipelinesMock.callArgs = append(mmListPipelines.ListPipelinesMock.callArgs, &mm_params)
	mmListPipelines.ListPipelinesMock.mutex.Unlock()

	for _, e := range mmListPipelines.ListPipelinesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPipelines.ListPipelinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelines.ListPipelinesMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelines.ListPipelinesMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelines.ListPipelinesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelines.ListPipelinesMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelines.t.Fatal("No results are set for the RepositoryMock.ListPipelines")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPipelines.funcListPipelines != nil {
		return mmListPipelines.funcListPipelines(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}
	mmListPipelines.t.Fatalf("Unexpected call to RepositoryMock.ListPipelines. %v %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	return
}

// ListPipelinesAfterCounter returns a count of finished RepositoryMock.ListPipelines invocations
func (mmListPipelines *RepositoryMock) ListPipelinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelines.afterListPipelinesCounter)
}

// ListPipelinesBeforeCounter returns a count of RepositoryMock.ListPipelines invocations
func (mmListPipelines *RepositoryMock) ListPipelinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelines.beforeListPipelinesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelines *mRepositoryMockListPipelines) Calls() []*RepositoryMockListPipelinesParams {
	mmListPipelines.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelinesParams, len(mmListPipelines.callArgs))
	copy(argCopy, mmListPipelines.callArgs)

	mmListPipelines.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelinesDone returns true if the count of the ListPipelines invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelinesDone() bool {
	if m.ListPipelinesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelinesMock.invocationsDone()
}

// MinimockListPipelinesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelinesInspect() {
	for _, e := range m.ListPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelinesCounter := mm_atomic.LoadUint64(&m.afterListPipelinesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelinesMock.defaultExpectation != nil && afterListPipelinesCounter < 1 {
		if m.ListPipelinesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s", m.ListPipelinesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s with params: %#v", m.ListPipelinesMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelines != nil && afterListPipelinesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s", m.funcListPipelinesOrigin)
	}

	if !m.ListPipelinesMock.invocationsDone() && afterListPipelinesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelines at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelinesMock.expectedInvocations), m.ListPipelinesMock.expectedInvocationsOrigin, afterListPipelinesCounter)
	}
}

type mRepositoryMockListPipelinesAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelinesAdminExpectation
	expectations       []*RepositoryMockListPipelinesAdminExpectation

	callArgs []*RepositoryMockListPipelinesAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelinesAdminExpectation specifies expectation struct of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelinesAdminParams
	paramPtrs          *RepositoryMockListPipelinesAdminParamPtrs
	expectationOrigins RepositoryMockListPipelinesAdminExpectationOrigins
	results            *RepositoryMockListPipelinesAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelinesAdminParams contains parameters of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminParams struct {
	ctx           context.Context
	pageSize      int64
	pageToken     string
	isBasicView   bool
	filter        filtering.Filter
	showDeleted   bool
	embedReleases bool
}

// RepositoryMockListPipelinesAdminParamPtrs contains pointers to parameters of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminParamPtrs struct {
	ctx           *context.Context
	pageSize      *int64
	pageToken     *string
	isBasicView   *bool
	filter        *filtering.Filter
	showDeleted   *bool
	embedReleases *bool
}

// RepositoryMockListPipelinesAdminResults contains results of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListPipelinesAdminOrigins contains origins of expectations of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminExpectationOrigins struct {
	origin              string
	originCtx           string
	originPageSize      string
	originPageToken     string
	originIsBasicView   string
	originFilter        string
	originShowDeleted   string
	originEmbedReleases string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Optional() *mRepositoryMockListPipelinesAdmin {
	mmListPipelinesAdmin.optional = true
	return mmListPipelinesAdmin
}

// Expect sets up expected params for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by ExpectParams functions")
	}

	mmListPipelinesAdmin.defaultExpectation.params = &RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelinesAdmin.expectations {
		if minimock.Equal(e.params, mmListPipelinesAdmin.defaultExpectation.params) {
			mmListPipelinesAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelinesAdmin.defaultExpectation.params)
		}
	}

	return mmListPipelinesAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.filter = &filter
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectShowDeletedParam6 sets up expected param showDeleted for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectShowDeletedParam6(showDeleted bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectEmbedReleasesParam7 sets up expected param embedReleases for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectEmbedReleasesParam7(embedReleases bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool)) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.inspectFuncListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelinesAdmin")
	}

	mmListPipelinesAdmin.mock.inspectFuncListPipelinesAdmin = f

	return mmListPipelinesAdmin
}

// Return sets up results that will be returned by Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{mock: mmListPipelinesAdmin.mock}
	}
	mmListPipelinesAdmin.defaultExpectation.results = &RepositoryMockListPipelinesAdminResults{ppa1, i1, s1, err}
	mmListPipelinesAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelinesAdmin.mock
}

// Set uses given function f to mock the Repository.ListPipelinesAdmin method
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPipelinesAdmin.defaultExpectation != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelinesAdmin method")
	}

	if len(mmListPipelinesAdmin.expectations) > 0 {
		mmListPipelinesAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelinesAdmin method")
	}

	mmListPipelinesAdmin.mock.funcListPipelinesAdmin = f
	mmListPipelinesAdmin.mock.funcListPipelinesAdminOrigin = minimock.CallerInfo(1)
	return mmListPipelinesAdmin.mock
}

// When sets expectation for the Repository.ListPipelinesAdmin which will trigger the result defined by the following
// Then helper
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) *RepositoryMockListPipelinesAdminExpectation {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelinesAdminExpectation{
		mock:               mmListPipelinesAdmin.mock,
		params:             &RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases},
		expectationOrigins: RepositoryMockListPipelinesAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelinesAdmin.expectations = append(mmListPipelinesAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelinesAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelinesAdminExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelinesAdminResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelinesAdmin should be invoked
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Times(n uint64) *mRepositoryMockListPipelinesAdmin {
	if n == 0 {
		mmListPipelinesAdmin.mock.t.Fatalf("Times of RepositoryMock.ListPipelinesAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelinesAdmin.expectedInvocations, n)
	mmListPipelinesAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelinesAdmin
}

func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) invocationsDone() bool {
	if len(mmListPipelinesAdmin.expectations) == 0 && mmListPipelinesAdmin.defaultExpectation == nil && mmListPipelinesAdmin.mock.funcListPipelinesAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelinesAdmin.mock.afterListPipelinesAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelinesAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelinesAdmin implements mm_repository.Repository
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdmin(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPipelinesAdmin.beforeListPipelinesAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelinesAdmin.afterListPipelinesAdminCounter, 1)

	mmListPipelinesAdmin.t.Helper()

	if mmListPipelinesAdmin.inspectFuncListPipelinesAdmin != nil {
		mmListPipelinesAdmin.inspectFuncListPipelinesAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	}

	mm_params := RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}

	// Record call args
	mmListPipelinesAdmin.ListPipelinesAdminMock.mutex.Lock()
	mmListPipelinesAdmin.ListPipelinesAdminMock.callArgs = append(mmListPipelinesAdmin.ListPipelinesAdminMock.callArgs, &mm_params)
	mmListPipelinesAdmin.ListPipelinesAdminMock.mutex.Unlock()

	for _, e := range mmListPipelinesAdmin.ListPipelinesAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelinesAdmin.t.Fatal("No results are set for the RepositoryMock.ListPipelinesAdmin")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPipelinesAdmin.funcListPipelinesAdmin != nil {
		return mmListPipelinesAdmin.funcListPipelinesAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	}
	mmListPipelinesAdmin.t.Fatalf("Unexpected call to RepositoryMock.ListPipelinesAdmin. %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	return
}

// ListPipelinesAdminAfterCounter returns a count of finished RepositoryMock.ListPipelinesAdmin invocations
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelinesAdmin.afterListPipelinesAdminCounter)
}

// ListPipelinesAdminBeforeCounter returns a count of RepositoryMock.ListPipelinesAdmin invocations
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelinesAdmin.beforeListPipelinesAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelinesAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Calls() []*RepositoryMockListPipelinesAdminParams {
	mmListPipelinesAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelinesAdminParams, len(mmListPipelinesAdmin.callArgs))
	copy(argCopy, mmListPipelinesAdmin.callArgs)

	mmListPipelinesAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelinesAdminDone returns true if the count of the ListPipelinesAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelinesAdminDone() bool {
	if m.ListPipelinesAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelinesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelinesAdminMock.invocationsDone()
}

// MinimockListPipelinesAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelinesAdminInspect() {
	for _, e := range m.ListPipelinesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelinesAdminCounter := mm_atomic.LoadUint64(&m.afterListPipelinesAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelinesAdminMock.defaultExpectation != nil && afterListPipelinesAdminCounter < 1 {
		if m.ListPipelinesAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s", m.ListPipelinesAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s with params: %#v", m.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelinesAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelinesAdmin != nil && afterListPipelinesAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s", m.funcListPipelinesAdminOrigin)
	}

	if !m.ListPipelinesAdminMock.invocationsDone() && afterListPipelinesAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelinesAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelinesAdminMock.expectedInvocations), m.ListPipelinesAdminMock.expectedInvocationsOrigin, afterListPipelinesAdminCounter)
	}
}

type mRepositoryMockListPublicPipelines struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPublicPipelinesExpectation
	expectations       []*RepositoryMockListPublicPipelinesExpectation

	callArgs []*RepositoryMockListPublicPipelinesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPublicPipelinesExpectation specifies expectation struct of the Repository.ListPublicPipelines
type RepositoryMockListPublicPipelinesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPublicPipelinesParams
	paramPtrs          *RepositoryMockListPublicPipelinesParamPtrs
	expectationOrigins RepositoryMockListPublicPipelinesExpectationOrigins
	results            *RepositoryMockListPublicPipelinesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPublicPipelinesParams contains parameters of the Repository.ListPublicPipelines
type RepositoryMockListPublicPipelinesParams struct {
	ctx                context.Context
	pageSize           int64
	pageToken          string
	isBasicView        bool
	filter             filtering.Filter
	uidAllowList       []uuid.UUID
	showDeleted        bool
	embedReleases      bool
	order              ordering.OrderBy
	presetNamespaceUID uuid.UUID
}

// RepositoryMockListPublicPipelinesParamPtrs contains pointers to parameters of the Repository.ListPublicPipelines
type RepositoryMockListPublicPipelinesParamPtrs struct {
	ctx                *context.Context
	pageSize           *int64
	pageToken          *string
	isBasicView        *bool
	filter             *filtering.Filter
	uidAllowList       *[]uuid.UUID
	showDeleted        *bool
	embedReleases      *bool
	order              *ordering.OrderBy
	presetNamespaceUID *uuid.UUID
}

// RepositoryMockListPublicPipelinesResults contains results of the Repository.ListPublicPipelines
type RepositoryMockListPublicPipelinesResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListPublicPipelinesOrigins contains origins of expectations of the Repository.ListPublicPipelines
type RepositoryMockListPublicPipelinesExpectationOrigins struct {
	origin                   string
	originCtx                string
	originPageSize           string
	originPageToken          string
	originIsBasicView        string
	originFilter             string
	originUidAllowList       string
	originShowDeleted        string
	originEmbedReleases      string
	originOrder              string
	originPresetNamespaceUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) Optional() *mRepositoryMockListPublicPipelines {
	mmListPublicPipelines.optional = true
	return mmListPublicPipelines
}

// Expect sets up expected params for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by ExpectParams functions")
	}

	mmListPublicPipelines.defaultExpectation.params = &RepositoryMockListPublicPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID}
	mmListPublicPipelines.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPublicPipelines.expectations {
		if minimock.Equal(e.params, mmListPublicPipelines.defaultExpectation.params) {
			mmListPublicPipelines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPublicPipelines.defaultExpectation.params)
		}
	}

	return mmListPublicPipelines
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.filter = &filter
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectUidAllowListParam6 sets up expected param uidAllowList for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectUidAllowListParam6(uidAllowList []uuid.UUID) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectShowDeletedParam7 sets up expected param showDeleted for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectShowDeletedParam7(showDeleted bool) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectEmbedReleasesParam8 sets up expected param embedReleases for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectEmbedReleasesParam8(embedReleases bool) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectOrderParam9 sets up expected param order for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectOrderParam9(order ordering.OrderBy) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.order = &order
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// ExpectPresetNamespaceUIDParam10 sets up expected param presetNamespaceUID for Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) ExpectPresetNamespaceUIDParam10(presetNamespaceUID uuid.UUID) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{}
	}

	if mmListPublicPipelines.defaultExpectation.params != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Expect")
	}

	if mmListPublicPipelines.defaultExpectation.paramPtrs == nil {
		mmListPublicPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPublicPipelinesParamPtrs{}
	}
	mmListPublicPipelines.defaultExpectation.paramPtrs.presetNamespaceUID = &presetNamespaceUID
	mmListPublicPipelines.defaultExpectation.expectationOrigins.originPresetNamespaceUID = minimock.CallerInfo(1)

	return mmListPublicPipelines
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID)) *mRepositoryMockListPublicPipelines {
	if mmListPublicPipelines.mock.inspectFuncListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPublicPipelines")
	}

	mmListPublicPipelines.mock.inspectFuncListPublicPipelines = f

	return mmListPublicPipelines
}

// Return sets up results that will be returned by Repository.ListPublicPipelines
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	if mmListPublicPipelines.defaultExpectation == nil {
		mmListPublicPipelines.defaultExpectation = &RepositoryMockListPublicPipelinesExpectation{mock: mmListPublicPipelines.mock}
	}
	mmListPublicPipelines.defaultExpectation.results = &RepositoryMockListPublicPipelinesResults{ppa1, i1, s1, err}
	mmListPublicPipelines.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPublicPipelines.mock
}

// Set uses given function f to mock the Repository.ListPublicPipelines method
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPublicPipelines.defaultExpectation != nil {
		mmListPublicPipelines.mock.t.Fatalf("Default expectation is already set for the Repository.ListPublicPipelines method")
	}

	if len(mmListPublicPipelines.expectations) > 0 {
		mmListPublicPipelines.mock.t.Fatalf("Some expectations are already set for the Repository.ListPublicPipelines method")
	}

	mmListPublicPipelines.mock.funcListPublicPipelines = f
	mmListPublicPipelines.mock.funcListPublicPipelinesOrigin = minimock.CallerInfo(1)
	return mmListPublicPipelines.mock
}

// When sets expectation for the Repository.ListPublicPipelines which will trigger the result defined by the following
// Then helper
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) *RepositoryMockListPublicPipelinesExpectation {
	if mmListPublicPipelines.mock.funcListPublicPipelines != nil {
		mmListPublicPipelines.mock.t.Fatalf("RepositoryMock.ListPublicPipelines mock is already set by Set")
	}

	expectation := &RepositoryMockListPublicPipelinesExpectation{
		mock:               mmListPublicPipelines.mock,
		params:             &RepositoryMockListPublicPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID},
		expectationOrigins: RepositoryMockListPublicPipelinesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPublicPipelines.expectations = append(mmListPublicPipelines.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPublicPipelines return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPublicPipelinesExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPublicPipelinesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPublicPipelines should be invoked
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) Times(n uint64) *mRepositoryMockListPublicPipelines {
	if n == 0 {
		mmListPublicPipelines.mock.t.Fatalf("Times of RepositoryMock.ListPublicPipelines mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPublicPipelines.expectedInvocations, n)
	mmListPublicPipelines.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPublicPipelines
}

func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) invocationsDone() bool {
	if len(mmListPublicPipelines.expectations) == 0 && mmListPublicPipelines.defaultExpectation == nil && mmListPublicPipelines.mock.funcListPublicPipelines == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPublicPipelines.mock.afterListPublicPipelinesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPublicPipelines.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPublicPipelines implements mm_repository.Repository
func (mmListPublicPipelines *RepositoryMock) ListPublicPipelines(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPublicPipelines.beforeListPublicPipelinesCounter, 1)
	defer mm_atomic.AddUint64(&mmListPublicPipelines.afterListPublicPipelinesCounter, 1)

	mmListPublicPipelines.t.Helper()

	if mmListPublicPipelines.inspectFuncListPublicPipelines != nil {
		mmListPublicPipelines.inspectFuncListPublicPipelines(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID)
	}

	mm_params := RepositoryMockListPublicPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID}

	// Record call args
	mmListPublicPipelines.ListPublicPipelinesMock.mutex.Lock()
	mmListPublicPipelines.ListPublicPipelinesMock.callArgs = append(mmListPublicPipelines.ListPublicPipelinesMock.callArgs, &mm_params)
	mmListPublicPipelines.ListPublicPipelinesMock.mutex.Unlock()

	for _, e := range mmListPublicPipelines.ListPublicPipelinesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.Counter, 1)
		mm_want := mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.params
		mm_want_ptrs := mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPublicPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.presetNamespaceUID != nil && !minimock.Equal(*mm_want_ptrs.presetNamespaceUID, mm_got.presetNamespaceUID) {
				mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameter presetNamespaceUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.originPresetNamespaceUID, *mm_want_ptrs.presetNamespaceUID, mm_got.presetNamespaceUID, minimock.Diff(*mm_want_ptrs.presetNamespaceUID, mm_got.presetNamespaceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPublicPipelines.t.Errorf("RepositoryMock.ListPublicPipelines got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPublicPipelines.ListPublicPipelinesMock.defaultExpectation.results
		if mm_results == nil {
			mmListPublicPipelines.t.Fatal("No results are set for the RepositoryMock.ListPublicPipelines")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPublicPipelines.funcListPublicPipelines != nil {
		return mmListPublicPipelines.funcListPublicPipelines(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID)
	}
	mmListPublicPipelines.t.Fatalf("Unexpected call to RepositoryMock.ListPublicPipelines. %v %v %v %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID)
	return
}

// ListPublicPipelinesAfterCounter returns a count of finished RepositoryMock.ListPublicPipelines invocations
func (mmListPublicPipelines *RepositoryMock) ListPublicPipelinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPublicPipelines.afterListPublicPipelinesCounter)
}

// ListPublicPipelinesBeforeCounter returns a count of RepositoryMock.ListPublicPipelines invocations
func (mmListPublicPipelines *RepositoryMock) ListPublicPipelinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPublicPipelines.beforeListPublicPipelinesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPublicPipelines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPublicPipelines *mRepositoryMockListPublicPipelines) Calls() []*RepositoryMockListPublicPipelinesParams {
	mmListPublicPipelines.mutex.RLock()

	argCopy := make([]*RepositoryMockListPublicPipelinesParams, len(mmListPublicPipelines.callArgs))
	copy(argCopy, mmListPublicPipelines.callArgs)

	mmListPublicPipelines.mutex.RUnlock()

	return argCopy
}

// MinimockListPublicPipelinesDone returns true if the count of the ListPublicPipelines invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPublicPipelinesDone() bool {
	if m.ListPublicPipelinesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPublicPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPublicPipelinesMock.invocationsDone()
}

// MinimockListPublicPipelinesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPublicPipelinesInspect() {
	for _, e := range m.ListPublicPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPublicPipelines at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPublicPipelinesCounter := mm_atomic.LoadUint64(&m.afterListPublicPipelinesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPublicPipelinesMock.defaultExpectation != nil && afterListPublicPipelinesCounter < 1 {
		if m.ListPublicPipelinesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPublicPipelines at\n%s", m.ListPublicPipelinesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPublicPipelines at\n%s with params: %#v", m.ListPublicPipelinesMock.defaultExpectation.expectationOrigins.origin, *m.ListPublicPipelinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPublicPipelines != nil && afterListPublicPipelinesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPublicPipelines at\n%s", m.funcListPublicPipelinesOrigin)
	}

	if !m.ListPublicPipelinesMock.invocationsDone() && afterListPublicPipelinesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPublicPipelines at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPublicPipelinesMock.expectedInvocations), m.ListPublicPipelinesMock.expectedInvocationsOrigin, afterListPublicPipelinesCounter)
	}
}

type mRepositoryMockPinUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockPinUserExpectation
	expectations       []*RepositoryMockPinUserExpectation

	callArgs []*RepositoryMockPinUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockPinUserExpectation specifies expectation struct of the Repository.PinUser
type RepositoryMockPinUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockPinUserParams
	paramPtrs          *RepositoryMockPinUserParamPtrs
	expectationOrigins RepositoryMockPinUserExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// RepositoryMockPinUserParams contains parameters of the Repository.PinUser
type RepositoryMockPinUserParams struct {
	ctx   context.Context
	table string
}

// RepositoryMockPinUserParamPtrs contains pointers to parameters of the Repository.PinUser
type RepositoryMockPinUserParamPtrs struct {
	ctx   *context.Context
	table *string
}

// RepositoryMockPinUserOrigins contains origins of expectations of the Repository.PinUser
type RepositoryMockPinUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originTable string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPinUser *mRepositoryMockPinUser) Optional() *mRepositoryMockPinUser {
	mmPinUser.optional = true
	return mmPinUser
}

// Expect sets up expected params for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Expect(ctx context.Context, table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.paramPtrs != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by ExpectParams functions")
	}

	mmPinUser.defaultExpectation.params = &RepositoryMockPinUserParams{ctx, table}
	mmPinUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPinUser.expectations {
		if minimock.Equal(e.params, mmPinUser.defaultExpectation.params) {
			mmPinUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPinUser.defaultExpectation.params)
		}
	}

	return mmPinUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmPinUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPinUser
}

// ExpectTableParam2 sets up expected param table for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectTableParam2(table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.table = &table
	mmPinUser.defaultExpectation.expectationOrigins.originTable = minimock.CallerInfo(1)

	return mmPinUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Inspect(f func(ctx context.Context, table string)) *mRepositoryMockPinUser {
	if mmPinUser.mock.inspectFuncPinUser != nil {
		mmPinUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.PinUser")
	}

	mmPinUser.mock.inspectFuncPinUser = f

	return mmPinUser
}

// Return sets up results that will be returned by Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Return() *RepositoryMock {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{mock: mmPinUser.mock}
	}

	mmPinUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPinUser.mock
}

// Set uses given function f to mock the Repository.PinUser method
func (mmPinUser *mRepositoryMockPinUser) Set(f func(ctx context.Context, table string)) *RepositoryMock {
	if mmPinUser.defaultExpectation != nil {
		mmPinUser.mock.t.Fatalf("Default expectation is already set for the Repository.PinUser method")
	}

	if len(mmPinUser.expectations) > 0 {
		mmPinUser.mock.t.Fatalf("Some expectations are already set for the Repository.PinUser method")
	}

	mmPinUser.mock.funcPinUser = f
	mmPinUser.mock.funcPinUserOrigin = minimock.CallerInfo(1)
	return mmPinUser.mock
}

// When sets expectation for the Repository.PinUser which will trigger the result defined by the following
// Then helper
func (mmPinUser *mRepositoryMockPinUser) When(ctx context.Context, table string) *RepositoryMockPinUserExpectation {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	expectation := &RepositoryMockPinUserExpectation{
		mock:               mmPinUser.mock,
		params:             &RepositoryMockPinUserParams{ctx, table},
		expectationOrigins: RepositoryMockPinUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPinUser.expectations = append(mmPinUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.PinUser return parameters for the expectation previously defined by the When method

func (e *RepositoryMockPinUserExpectation) Then() *RepositoryMock {
	return e.mock
}

// Times sets number of times Repository.PinUser should be invoked
func (mmPinUser *mRepositoryMockPinUser) Times(n uint64) *mRepositoryMockPinUser {
	if n == 0 {
		mmPinUser.mock.t.Fatalf("Times of RepositoryMock.PinUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPinUser.expectedInvocations, n)
	mmPinUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPinUser
}

func (mmPinUser *mRepositoryMockPinUser) invocationsDone() bool {
	if len(mmPinUser.expectations) == 0 && mmPinUser.defaultExpectation == nil && mmPinUser.mock.funcPinUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPinUser.mock.afterPinUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPinUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PinUser implements mm_repository.Repository
func (mmPinUser *RepositoryMock) PinUser(ctx context.Context, table string) {
	mm_atomic.AddUint64(&mmPinUser.beforePinUserCounter, 1)
	defer mm_atomic.AddUint64(&mmPinUser.afterPinUserCounter, 1)

	mmPinUser.t.Helper()

	if mmPinUser.inspectFuncPinUser != nil {
		mmPinUser.inspectFuncPinUser(ctx, table)
	}

	mm_params := RepositoryMockPinUserParams{ctx, table}

	// Record call args
	mmPinUser.PinUserMock.mutex.Lock()
	mmPinUser.PinUserMock.callArgs = append(mmPinUser.PinUserMock.callArgs, &mm_params)
	mmPinUser.PinUserMock.mutex.Unlock()

	for _, e := range mmPinUser.PinUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPinUser.PinUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPinUser.PinUserMock.defaultExpectation.Counter, 1)
		mm_want := mmPinUser.PinUserMock.defaultExpectation.params
		mm_want_ptrs := mmPinUser.PinUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockPinUserParams{ctx, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter table, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.originTable, *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPinUser.funcPinUser != nil {
		mmPinUser.funcPinUser(ctx, table)
		return
	}
	mmPinUser.t.Fatalf("Unexpected call to RepositoryMock.PinUser. %v %v", ctx, table)

}

// PinUserAfterCounter returns a count of finished RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.afterPinUserCounter)
}

// PinUserBeforeCounter returns a count of RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.beforePinUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.PinUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPinUser *mRepositoryMockPinUser) Calls() []*RepositoryMockPinUserParams {
	mmPinUser.mutex.RLock()

	argCopy := make([]*RepositoryMockPinUserParams, len(mmPinUser.callArgs))
	copy(argCopy, mmPinUser.callArgs)

	mmPinUser.mutex.RUnlock()

	return argCopy
}

// MinimockPinUserDone returns true if the count of the PinUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockPinUserDone() bool {
	if m.PinUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PinUserMock.invocationsDone()
}

// MinimockPinUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockPinUserInspect() {
	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPinUserCounter := mm_atomic.LoadUint64(&m.afterPinUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PinUserMock.defaultExpectation != nil && afterPinUserCounter < 1 {
		if m.PinUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s", m.PinUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s with params: %#v", m.PinUserMock.defaultExpectation.expectationOrigins.origin, *m.PinUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPinUser != nil && afterPinUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s", m.funcPinUserOrigin)
	}

	if !m.PinUserMock.invocationsDone() && afterPinUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.PinUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PinUserMock.expectedInvocations), m.PinUserMock.expectedInvocationsOrigin, afterPinUserCounter)
	}
}

type mRepositoryMockTranspileFilter struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTranspileFilterExpectation
	expectations       []*RepositoryMockTranspileFilterExpectation

	callArgs []*RepositoryMockTranspileFilterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockTranspileFilterExpectation specifies expectation struct of the Repository.TranspileFilter
type RepositoryMockTranspileFilterExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockTranspileFilterParams
	paramPtrs          *RepositoryMockTranspileFilterParamPtrs
	expectationOrigins RepositoryMockTranspileFilterExpectationOrigins
	results            *RepositoryMockTranspileFilterResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockTranspileFilterParams contains parameters of the Repository.TranspileFilter
type RepositoryMockTranspileFilterParams struct {
	f1 filtering.Filter
}

// RepositoryMockTranspileFilterParamPtrs contains pointers to parameters of the Repository.TranspileFilter
type RepositoryMockTranspileFilterParamPtrs struct {
	f1 *filtering.Filter
}

// RepositoryMockTranspileFilterResults contains results of the Repository.TranspileFilter
type RepositoryMockTranspileFilterResults struct {
	ep1 *clause.Expr
	err error
}

// RepositoryMockTranspileFilterOrigins contains origins of expectations of the Repository.TranspileFilter
type RepositoryMockTranspileFilterExpectationOrigins struct {
	origin   string
	originF1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Optional() *mRepositoryMockTranspileFilter {
	mmTranspileFilter.optional = true
	return mmTranspileFilter
}

// Expect sets up expected params for Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Expect(f1 filtering.Filter) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{}
	}

	if mmTranspileFilter.defaultExpectation.paramPtrs != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by ExpectParams functions")
	}

	mmTranspileFilter.defaultExpectation.params = &RepositoryMockTranspileFilterParams{f1}
	mmTranspileFilter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTranspileFilter.expectations {
		if minimock.Equal(e.params, mmTranspileFilter.defaultExpectation.params) {
			mmTranspileFilter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTranspileFilter.defaultExpectation.params)
		}
	}

	return mmTranspileFilter
}

// ExpectF1Param1 sets up expected param f1 for Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) ExpectF1Param1(f1 filtering.Filter) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{}
	}

	if mmTranspileFilter.defaultExpectation.params != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Expect")
	}

	if mmTranspileFilter.defaultExpectation.paramPtrs == nil {
		mmTranspileFilter.defaultExpectation.paramPtrs = &RepositoryMockTranspileFilterParamPtrs{}
	}
	mmTranspileFilter.defaultExpectation.paramPtrs.f1 = &f1
	mmTranspileFilter.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmTranspileFilter
}

// Inspect accepts an inspector function that has same arguments as the Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Inspect(f func(f1 filtering.Filter)) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.inspectFuncTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("Inspect function is already set for RepositoryMock.TranspileFilter")
	}

	mmTranspileFilter.mock.inspectFuncTranspileFilter = f

	return mmTranspileFilter
}

// Return sets up results that will be returned by Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Return(ep1 *clause.Expr, err error) *RepositoryMock {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{mock: mmTranspileFilter.mock}
	}
	mmTranspileFilter.defaultExpectation.results = &RepositoryMockTranspileFilterResults{ep1, err}
	mmTranspileFilter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTranspileFilter.mock
}

// Set uses given function f to mock the Repository.TranspileFilter method
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Set(f func(f1 filtering.Filter) (ep1 *clause.Expr, err error)) *RepositoryMock {
	if mmTranspileFilter.defaultExpectation != nil {
		mmTranspileFilter.mock.t.Fatalf("Default expectation is already set for the Repository.TranspileFilter method")
	}

	if len(mmTranspileFilter.expectations) > 0 {
		mmTranspileFilter.mock.t.Fatalf("Some expectations are already set for the Repository.TranspileFilter method")
	}

	mmTranspileFilter.mock.funcTranspileFilter = f
	mmTranspileFilter.mock.funcTranspileFilterOrigin = minimock.CallerInfo(1)
	return mmTranspileFilter.mock
}

// When sets expectation for the Repository.TranspileFilter which will trigger the result defined by the following
// Then helper
func (mmTranspileFilter *mRepositoryMockTranspileFilter) When(f1 filtering.Filter) *RepositoryMockTranspileFilterExpectation {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	expectation := &RepositoryMockTranspileFilterExpectation{
		mock:               mmTranspileFilter.mock,
		params:             &RepositoryMockTranspileFilterParams{f1},
		expectationOrigins: RepositoryMockTranspileFilterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTranspileFilter.expectations = append(mmTranspileFilter.expectations, expectation)
	return expectation
}

// Then sets up Repository.TranspileFilter return parameters for the expectation previously defined by the When method
func (e *RepositoryMockTranspileFilterExpectation) Then(ep1 *clause.Expr, err error) *RepositoryMock {
	e.results = &RepositoryMockTranspileFilterResults{ep1, err}
	return e.mock
}

// Times sets number of times Repository.TranspileFilter should be invoked
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Times(n uint64) *mRepositoryMockTranspileFilter {
	if n == 0 {
		mmTranspileFilter.mock.t.Fatalf("Times of RepositoryMock.TranspileFilter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTranspileFilter.expectedInvocations, n)
	mmTranspileFilter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTranspileFilter
}

func (mmTranspileFilter *mRepositoryMockTranspileFilter) invocationsDone() bool {
	if len(mmTranspileFilter.expectations) == 0 && mmTranspileFilter.defaultExpectation == nil && mmTranspileFilter.mock.funcTranspileFilter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTranspileFilter.mock.afterTranspileFilterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTranspileFilter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TranspileFilter implements mm_repository.Repository
func (mmTranspileFilter *RepositoryMock) TranspileFilter(f1 filtering.Filter) (ep1 *clause.Expr, err error) {
	mm_atomic.AddUint64(&mmTranspileFilter.beforeTranspileFilterCounter, 1)
	defer mm_atomic.AddUint64(&mmTranspileFilter.afterTranspileFilterCounter, 1)

	mmTranspileFilter.t.Helper()

	if mmTranspileFilter.inspectFuncTranspileFilter != nil {
		mmTranspileFilter.inspectFuncTranspileFilter(f1)
	}

	mm_params := RepositoryMockTranspileFilterParams{f1}

	// Record call args
	mmTranspileFilter.TranspileFilterMock.mutex.Lock()
	mmTranspileFilter.TranspileFilterMock.callArgs = append(mmTranspileFilter.TranspileFilterMock.callArgs, &mm_params)
	mmTranspileFilter.TranspileFilterMock.mutex.Unlock()

	for _, e := range mmTranspileFilter.TranspileFilterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmTranspileFilter.TranspileFilterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTranspileFilter.TranspileFilterMock.defaultExpectation.Counter, 1)
		mm_want := mmTranspileFilter.TranspileFilterMock.defaultExpectation.params
		mm_want_ptrs := mmTranspileFilter.TranspileFilterMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockTranspileFilterParams{f1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmTranspileFilter.t.Errorf("RepositoryMock.TranspileFilter got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTranspileFilter.TranspileFilterMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTranspileFilter.t.Errorf("RepositoryMock.TranspileFilter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTranspileFilter.TranspileFilterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTranspileFilter.TranspileFilterMock.defaultExpectation.results
		if mm_results == nil {
			mmTranspileFilter.t.Fatal("No results are set for the RepositoryMock.TranspileFilter")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmTranspileFilter.funcTranspileFilter != nil {
		return mmTranspileFilter.funcTranspileFilter(f1)
	}
	mmTranspileFilter.t.Fatalf("Unexpected call to RepositoryMock.TranspileFilter. %v", f1)
	return
}

// TranspileFilterAfterCounter returns a count of finished RepositoryMock.TranspileFilter invocations
func (mmTranspileFilter *RepositoryMock) TranspileFilterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTranspileFilter.afterTranspileFilterCounter)
}

// TranspileFilterBeforeCounter returns a count of RepositoryMock.TranspileFilter invocations
func (mmTranspileFilter *RepositoryMock) TranspileFilterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTranspileFilter.beforeTranspileFilterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.TranspileFilter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Calls() []*RepositoryMockTranspileFilterParams {
	mmTranspileFilter.mutex.RLock()

	argCopy := make([]*RepositoryMockTranspileFilterParams, len(mmTranspileFilter.callArgs))
	copy(argCopy, mmTranspileFilter.callArgs)

	mmTranspileFilter.mutex.RUnlock()

	return argCopy
}

// MinimockTranspileFilterDone returns true if the count of the TranspileFilter invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTranspileFilterDone() bool {
	if m.TranspileFilterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TranspileFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TranspileFilterMock.invocationsDone()
}

// MinimockTranspileFilterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTranspileFilterInspect() {
	for _, e := range m.TranspileFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTranspileFilterCounter := mm_atomic.LoadUint64(&m.afterTranspileFilterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TranspileFilterMock.defaultExpectation != nil && afterTranspileFilterCounter < 1 {
		if m.TranspileFilterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s", m.TranspileFilterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s with params: %#v", m.TranspileFilterMock.defaultExpectation.expectationOrigins.origin, *m.TranspileFilterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTranspileFilter != nil && afterTranspileFilterCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s", m.funcTranspileFilterOrigin)
	}

	if !m.TranspileFilterMock.invocationsDone() && afterTranspileFilterCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.TranspileFilter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TranspileFilterMock.expectedInvocations), m.TranspileFilterMock.expectedInvocationsOrigin, afterTranspileFilterCounter)
	}
}

type mRepositoryMockUpdateComponentRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateComponentRunExpectation
	expectations       []*RepositoryMockUpdateComponentRunExpectation

	callArgs []*RepositoryMockUpdateComponentRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateComponentRunExpectation specifies expectation struct of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateComponentRunParams
	paramPtrs          *RepositoryMockUpdateComponentRunParamPtrs
	expectationOrigins RepositoryMockUpdateComponentRunExpectationOrigins
	results            *RepositoryMockUpdateComponentRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateComponentRunParams contains parameters of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunParams struct {
	ctx                context.Context
	pipelineTriggerUID string
	componentID        string
	componentRun       *datamodel.ComponentRun
}

// RepositoryMockUpdateComponentRunParamPtrs contains pointers to parameters of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunParamPtrs struct {
	ctx                *context.Context
	pipelineTriggerUID *string
	componentID        *string
	componentRun       **datamodel.ComponentRun
}

// RepositoryMockUpdateComponentRunResults contains results of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunResults struct {
	err error
}

// RepositoryMockUpdateComponentRunOrigins contains origins of expectations of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunExpectationOrigins struct {
	origin                   string
	originCtx                string
	originPipelineTriggerUID string
	originComponentID        string
	originComponentRun       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Optional() *mRepositoryMockUpdateComponentRun {
	mmUpdateComponentRun.optional = true
	return mmUpdateComponentRun
}

// Expect sets up expected params for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Expect(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by ExpectParams functions")
	}

	mmUpdateComponentRun.defaultExpectation.params = &RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun}
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateComponentRun.expectations {
		if minimock.Equal(e.params, mmUpdateComponentRun.defaultExpectation.params) {
			mmUpdateComponentRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateComponentRun.defaultExpectation.params)
		}
	}

	return mmUpdateComponentRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// ExpectPipelineTriggerUIDParam2 sets up expected param pipelineTriggerUID for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectPipelineTriggerUIDParam2(pipelineTriggerUID string) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.pipelineTriggerUID = &pipelineTriggerUID
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originPipelineTriggerUID = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// ExpectComponentIDParam3 sets up expected param componentID for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectComponentIDParam3(componentID string) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.componentID = &componentID
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originComponentID = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// ExpectComponentRunParam4 sets up expected param componentRun for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectComponentRunParam4(componentRun *datamodel.ComponentRun) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.componentRun = &componentRun
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originComponentRun = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Inspect(f func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun)) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.inspectFuncUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateComponentRun")
	}

	mmUpdateComponentRun.mock.inspectFuncUpdateComponentRun = f

	return mmUpdateComponentRun
}

// Return sets up results that will be returned by Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Return(err error) *RepositoryMock {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{mock: mmUpdateComponentRun.mock}
	}
	mmUpdateComponentRun.defaultExpectation.results = &RepositoryMockUpdateComponentRunResults{err}
	mmUpdateComponentRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateComponentRun.mock
}

// Set uses given function f to mock the Repository.UpdateComponentRun method
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Set(f func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) (err error)) *RepositoryMock {
	if mmUpdateComponentRun.defaultExpectation != nil {
		mmUpdateComponentRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateComponentRun method")
	}

	if len(mmUpdateComponentRun.expectations) > 0 {
		mmUpdateComponentRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateComponentRun method")
	}

	mmUpdateComponentRun.mock.funcUpdateComponentRun = f
	mmUpdateComponentRun.mock.funcUpdateComponentRunOrigin = minimock.CallerInfo(1)
	return mmUpdateComponentRun.mock
}

// When sets expectation for the Repository.UpdateComponentRun which will trigger the result defined by the following
// Then helper
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) When(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) *RepositoryMockUpdateComponentRunExpectation {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateComponentRunExpectation{
		mock:               mmUpdateComponentRun.mock,
		params:             &RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun},
		expectationOrigins: RepositoryMockUpdateComponentRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateComponentRun.expectations = append(mmUpdateComponentRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateComponentRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateComponentRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateComponentRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateComponentRun should be invoked
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Times(n uint64) *mRepositoryMockUpdateComponentRun {
	if n == 0 {
		mmUpdateComponentRun.mock.t.Fatalf("Times of RepositoryMock.UpdateComponentRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateComponentRun.expectedInvocations, n)
	mmUpdateComponentRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateComponentRun
}

func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) invocationsDone() bool {
	if len(mmUpdateComponentRun.expectations) == 0 && mmUpdateComponentRun.defaultExpectation == nil && mmUpdateComponentRun.mock.funcUpdateComponentRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateComponentRun.mock.afterUpdateComponentRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateComponentRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateComponentRun implements mm_repository.Repository
func (mmUpdateComponentRun *RepositoryMock) UpdateComponentRun(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) (err error) {
	mm_atomic.AddUint64(&mmUpdateComponentRun.beforeUpdateComponentRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateComponentRun.afterUpdateComponentRunCounter, 1)

	mmUpdateComponentRun.t.Helper()

	if mmUpdateComponentRun.inspectFuncUpdateComponentRun != nil {
		mmUpdateComponentRun.inspectFuncUpdateComponentRun(ctx, pipelineTriggerUID, componentID, componentRun)
	}

	mm_params := RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun}

	// Record call args
	mmUpdateComponentRun.UpdateComponentRunMock.mutex.Lock()
	mmUpdateComponentRun.UpdateComponentRunMock.callArgs = append(mmUpdateComponentRun.UpdateComponentRunMock.callArgs, &mm_params)
	mmUpdateComponentRun.UpdateComponentRunMock.mutex.Unlock()

	for _, e := range mmUpdateComponentRun.UpdateComponentRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineTriggerUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter pipelineTriggerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originPipelineTriggerUID, *mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID, minimock.Diff(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID))
			}

			if mm_want_ptrs.componentID != nil && !minimock.Equal(*mm_want_ptrs.componentID, mm_got.componentID) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter componentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originComponentID, *mm_want_ptrs.componentID, mm_got.componentID, minimock.Diff(*mm_want_ptrs.componentID, mm_got.componentID))
			}

			if mm_want_ptrs.componentRun != nil && !minimock.Equal(*mm_want_ptrs.componentRun, mm_got.componentRun) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter componentRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originComponentRun, *mm_want_ptrs.componentRun, mm_got.componentRun, minimock.Diff(*mm_want_ptrs.componentRun, mm_got.componentRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateComponentRun.t.Fatal("No results are set for the RepositoryMock.UpdateComponentRun")
		}
		return (*mm_results).err
	}
	if mmUpdateComponentRun.funcUpdateComponentRun != nil {
		return mmUpdateComponentRun.funcUpdateComponentRun(ctx, pipelineTriggerUID, componentID, componentRun)
	}
	mmUpdateComponentRun.t.Fatalf("Unexpected call to RepositoryMock.UpdateComponentRun. %v %v %v %v", ctx, pipelineTriggerUID, componentID, componentRun)
	return
}

// UpdateComponentRunAfterCounter returns a count of finished RepositoryMock.UpdateComponentRun invocations
func (mmUpdateComponentRun *RepositoryMock) UpdateComponentRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateComponentRun.afterUpdateComponentRunCounter)
}

// UpdateComponentRunBeforeCounter returns a count of RepositoryMock.UpdateComponentRun invocations
func (mmUpdateComponentRun *RepositoryMock) UpdateComponentRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateComponentRun.beforeUpdateComponentRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateComponentRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Calls() []*RepositoryMockUpdateComponentRunParams {
	mmUpdateComponentRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateComponentRunParams, len(mmUpdateComponentRun.callArgs))
	copy(argCopy, mmUpdateComponentRun.callArgs)

	mmUpdateComponentRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateComponentRunDone returns true if the count of the UpdateComponentRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateComponentRunDone() bool {
	if m.UpdateComponentRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateComponentRunMock.invocationsDone()
}

// MinimockUpdateComponentRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateComponentRunInspect() {
	for _, e := range m.UpdateComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateComponentRunCounter := mm_atomic.LoadUint64(&m.afterUpdateComponentRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateComponentRunMock.defaultExpectation != nil && afterUpdateComponentRunCounter < 1 {
		if m.UpdateComponentRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s", m.UpdateComponentRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s with params: %#v", m.UpdateComponentRunMock.defaultExpectation.expectationOrigins.origin, *m.UpdateComponentRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateComponentRun != nil && afterUpdateComponentRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s", m.funcUpdateComponentRunOrigin)
	}

	if !m.UpdateComponentRunMock.invocationsDone() && afterUpdateComponentRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateComponentRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateComponentRunMock.expectedInvocations), m.UpdateComponentRunMock.expectedInvocationsOrigin, afterUpdateComponentRunCounter)
	}
}

type mRepositoryMockUpdateNamespaceConnectionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceConnectionByUIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceConnectionByUIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceConnectionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespaceConnectionByUIDExpectation specifies expectation struct of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespaceConnectionByUIDParams
	paramPtrs          *RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespaceConnectionByUIDExpectationOrigins
	results            *RepositoryMockUpdateNamespaceConnectionByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespaceConnectionByUIDParams contains parameters of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
	cp1 *datamodel.Connection
}

// RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
	cp1 **datamodel.Connection
}

// RepositoryMockUpdateNamespaceConnectionByUIDResults contains results of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDResults struct {
	cp2 *datamodel.Connection
	err error
}

// RepositoryMockUpdateNamespaceConnectionByUIDOrigins contains origins of expectations of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Optional() *mRepositoryMockUpdateNamespaceConnectionByUID {
	mmUpdateNamespaceConnectionByUID.optional = true
	return mmUpdateNamespaceConnectionByUID
}

// Expect sets up expected params for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Expect(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceConnectionByUID.defaultExpectation.params = &RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespaceConnectionByUID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceConnectionByUID.defaultExpectation.params) {
			mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceConnectionByUID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceConnectionByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.params != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Expect")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs{}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespaceConnectionByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.params != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Expect")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs{}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs.u1 = &u1
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmUpdateNamespaceConnectionByUID
}

// ExpectCp1Param3 sets up expected param cp1 for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) ExpectCp1Param3(cp1 *datamodel.Connection) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.params != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Expect")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs{}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs.cp1 = &cp1
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmUpdateNamespaceConnectionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection)) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.inspectFuncUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceConnectionByUID")
	}

	mmUpdateNamespaceConnectionByUID.mock.inspectFuncUpdateNamespaceConnectionByUID = f

	return mmUpdateNamespaceConnectionByUID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Return(cp2 *datamodel.Connection, err error) *RepositoryMock {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{mock: mmUpdateNamespaceConnectionByUID.mock}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.results = &RepositoryMockUpdateNamespaceConnectionByUIDResults{cp2, err}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceConnectionByUID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceConnectionByUID method
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Set(f func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)) *RepositoryMock {
	if mmUpdateNamespaceConnectionByUID.defaultExpectation != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceConnectionByUID method")
	}

	if len(mmUpdateNamespaceConnectionByUID.expectations) > 0 {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceConnectionByUID method")
	}

	mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID = f
	mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceConnectionByUID.mock
}

// When sets expectation for the Repository.UpdateNamespaceConnectionByUID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) When(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) *RepositoryMockUpdateNamespaceConnectionByUIDExpectation {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{
		mock:               mmUpdateNamespaceConnectionByUID.mock,
		params:             &RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1},
		expectationOrigins: RepositoryMockUpdateNamespaceConnectionByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespaceConnectionByUID.expectations = append(mmUpdateNamespaceConnectionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceConnectionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceConnectionByUIDExpectation) Then(cp2 *datamodel.Connection, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceConnectionByUIDResults{cp2, err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceConnectionByUID should be invoked
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Times(n uint64) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if n == 0 {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceConnectionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceConnectionByUID.expectedInvocations, n)
	mmUpdateNamespaceConnectionByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceConnectionByUID
}

func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) invocationsDone() bool {
	if len(mmUpdateNamespaceConnectionByUID.expectations) == 0 && mmUpdateNamespaceConnectionByUID.defaultExpectation == nil && mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.mock.afterUpdateNamespaceConnectionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceConnectionByUID implements mm_repository.Repository
func (mmUpdateNamespaceConnectionByUID *RepositoryMock) UpdateNamespaceConnectionByUID(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceConnectionByUID.beforeUpdateNamespaceConnectionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceConnectionByUID.afterUpdateNamespaceConnectionByUIDCounter, 1)

	mmUpdateNamespaceConnectionByUID.t.Helper()

	if mmUpdateNamespaceConnectionByUID.inspectFuncUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.inspectFuncUpdateNamespaceConnectionByUID(ctx, u1, cp1)
	}

	mm_params := RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1}

	// Record call args
	mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.mutex.Lock()
	mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.callArgs = append(mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.callArgs, &mm_params)
	mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceConnectionByUID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceConnectionByUID")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmUpdateNamespaceConnectionByUID.funcUpdateNamespaceConnectionByUID != nil {
		return mmUpdateNamespaceConnectionByUID.funcUpdateNamespaceConnectionByUID(ctx, u1, cp1)
	}
	mmUpdateNamespaceConnectionByUID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceConnectionByUID. %v %v %v", ctx, u1, cp1)
	return
}

// UpdateNamespaceConnectionByUIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceConnectionByUID invocations
func (mmUpdateNamespaceConnectionByUID *RepositoryMock) UpdateNamespaceConnectionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.afterUpdateNamespaceConnectionByUIDCounter)
}

// UpdateNamespaceConnectionByUIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceConnectionByUID invocations
func (mmUpdateNamespaceConnectionByUID *RepositoryMock) UpdateNamespaceConnectionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.beforeUpdateNamespaceConnectionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceConnectionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Calls() []*RepositoryMockUpdateNamespaceConnectionByUIDParams {
	mmUpdateNamespaceConnectionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceConnectionByUIDParams, len(mmUpdateNamespaceConnectionByUID.callArgs))
	copy(argCopy, mmUpdateNamespaceConnectionByUID.callArgs)

	mmUpdateNamespaceConnectionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceConnectionByUIDDone returns true if the count of the UpdateNamespaceConnectionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceConnectionByUIDDone() bool {
	if m.UpdateNamespaceConnectionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceConnectionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceConnectionByUIDMock.invocationsDone()
}

// MinimockUpdateNamespaceConnectionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceConnectionByUIDInspect() {
	for _, e := range m.UpdateNamespaceConnectionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespaceConnectionByUIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceConnectionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceConnectionByUIDMock.defaultExpectation != nil && afterUpdateNamespaceConnectionByUIDCounter < 1 {
		if m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s", m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s with params: %#v", m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceConnectionByUID != nil && afterUpdateNamespaceConnectionByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s", m.funcUpdateNamespaceConnectionByUIDOrigin)
	}

	if !m.UpdateNamespaceConnectionByUIDMock.invocationsDone() && afterUpdateNamespaceConnectionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceConnectionByUIDMock.expectedInvocations), m.UpdateNamespaceConnectionByUIDMock.expectedInvocationsOrigin, afterUpdateNamespaceConnectionByUIDCounter)
	}
}

type mRepositoryMockUpdateNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespaceSecretByIDExpectation specifies expectation struct of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespaceSecretByIDParams
	paramPtrs          *RepositoryMockUpdateNamespaceSecretByIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespaceSecretByIDExpectationOrigins
	results            *RepositoryMockUpdateNamespaceSecretByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespaceSecretByIDParams contains parameters of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	secret         *datamodel.Secret
}

// RepositoryMockUpdateNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	secret         **datamodel.Secret
}

// RepositoryMockUpdateNamespaceSecretByIDResults contains results of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDResults struct {
	err error
}

// RepositoryMockUpdateNamespaceSecretByIDOrigins contains origins of expectations of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originSecret         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Optional() *mRepositoryMockUpdateNamespaceSecretByID {
	mmUpdateNamespaceSecretByID.optional = true
	return mmUpdateNamespaceSecretByID
}

// Expect sets up expected params for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceSecretByID.defaultExpectation.params = &RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceSecretByID.defaultExpectation.params) {
			mmUpdateNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// ExpectSecretParam4 sets up expected param secret for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectSecretParam4(secret *datamodel.Secret) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.secret = &secret
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originSecret = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret)) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.inspectFuncUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceSecretByID")
	}

	mmUpdateNamespaceSecretByID.mock.inspectFuncUpdateNamespaceSecretByID = f

	return mmUpdateNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{mock: mmUpdateNamespaceSecretByID.mock}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.results = &RepositoryMockUpdateNamespaceSecretByIDResults{err}
	mmUpdateNamespaceSecretByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceSecretByID method
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error)) *RepositoryMock {
	if mmUpdateNamespaceSecretByID.defaultExpectation != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceSecretByID method")
	}

	if len(mmUpdateNamespaceSecretByID.expectations) > 0 {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceSecretByID method")
	}

	mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID = f
	mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceSecretByID.mock
}

// When sets expectation for the Repository.UpdateNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) *RepositoryMockUpdateNamespaceSecretByIDExpectation {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceSecretByIDExpectation{
		mock:               mmUpdateNamespaceSecretByID.mock,
		params:             &RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret},
		expectationOrigins: RepositoryMockUpdateNamespaceSecretByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespaceSecretByID.expectations = append(mmUpdateNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceSecretByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceSecretByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceSecretByID should be invoked
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Times(n uint64) *mRepositoryMockUpdateNamespaceSecretByID {
	if n == 0 {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceSecretByID.expectedInvocations, n)
	mmUpdateNamespaceSecretByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceSecretByID
}

func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) invocationsDone() bool {
	if len(mmUpdateNamespaceSecretByID.expectations) == 0 && mmUpdateNamespaceSecretByID.defaultExpectation == nil && mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.mock.afterUpdateNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceSecretByID implements mm_repository.Repository
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.beforeUpdateNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.afterUpdateNamespaceSecretByIDCounter, 1)

	mmUpdateNamespaceSecretByID.t.Helper()

	if mmUpdateNamespaceSecretByID.inspectFuncUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.inspectFuncUpdateNamespaceSecretByID(ctx, ownerPermalink, id, secret)
	}

	mm_params := RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}

	// Record call args
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.mutex.Lock()
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.callArgs = append(mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.callArgs, &mm_params)
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.secret != nil && !minimock.Equal(*mm_want_ptrs.secret, mm_got.secret) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter secret, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originSecret, *mm_want_ptrs.secret, mm_got.secret, minimock.Diff(*mm_want_ptrs.secret, mm_got.secret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceSecretByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespaceSecretByID.funcUpdateNamespaceSecretByID != nil {
		return mmUpdateNamespaceSecretByID.funcUpdateNamespaceSecretByID(ctx, ownerPermalink, id, secret)
	}
	mmUpdateNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceSecretByID. %v %v %v %v", ctx, ownerPermalink, id, secret)
	return
}

// UpdateNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceSecretByID invocations
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.afterUpdateNamespaceSecretByIDCounter)
}

// UpdateNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceSecretByID invocations
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.beforeUpdateNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Calls() []*RepositoryMockUpdateNamespaceSecretByIDParams {
	mmUpdateNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceSecretByIDParams, len(mmUpdateNamespaceSecretByID.callArgs))
	copy(argCopy, mmUpdateNamespaceSecretByID.callArgs)

	mmUpdateNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceSecretByIDDone returns true if the count of the UpdateNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceSecretByIDDone() bool {
	if m.UpdateNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceSecretByIDMock.invocationsDone()
}

// MinimockUpdateNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceSecretByIDInspect() {
	for _, e := range m.UpdateNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceSecretByIDMock.defaultExpectation != nil && afterUpdateNamespaceSecretByIDCounter < 1 {
		if m.UpdateNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s", m.UpdateNamespaceSecretByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s with params: %#v", m.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceSecretByID != nil && afterUpdateNamespaceSecretByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s", m.funcUpdateNamespaceSecretByIDOrigin)
	}

	if !m.UpdateNamespaceSecretByIDMock.invocationsDone() && afterUpdateNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceSecretByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceSecretByIDMock.expectedInvocations), m.UpdateNamespaceSecretByIDMock.expectedInvocationsOrigin, afterUpdateNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockUpdatePipelineByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdatePipelineByUIDExpectation
	expectations       []*RepositoryMockUpdatePipelineByUIDExpectation

	callArgs []*RepositoryMockUpdatePipelineByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdatePipelineByUIDExpectation specifies expectation struct of the Repository.UpdatePipelineByUID
type RepositoryMockUpdatePipelineByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdatePipelineByUIDParams
	paramPtrs          *RepositoryMockUpdatePipelineByUIDParamPtrs
	expectationOrigins RepositoryMockUpdatePipelineByUIDExpectationOrigins
	results            *RepositoryMockUpdatePipelineByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdatePipelineByUIDParams contains parameters of the Repository.UpdatePipelineByUID
type RepositoryMockUpdatePipelineByUIDParams struct {
	ctx      context.Context
	uid      uuid.UUID
	pipeline *datamodel.Pipeline
}

// RepositoryMockUpdatePipelineByUIDParamPtrs contains pointers to parameters of the Repository.UpdatePipelineByUID
type RepositoryMockUpdatePipelineByUIDParamPtrs struct {
	ctx      *context.Context
	uid      *uuid.UUID
	pipeline **datamodel.Pipeline
}

// RepositoryMockUpdatePipelineByUIDResults contains results of the Repository.UpdatePipelineByUID
type RepositoryMockUpdatePipelineByUIDResults struct {
	err error
}

// RepositoryMockUpdatePipelineByUIDOrigins contains origins of expectations of the Repository.UpdatePipelineByUID
type RepositoryMockUpdatePipelineByUIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originUid      string
	originPipeline string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) Optional() *mRepositoryMockUpdatePipelineByUID {
	mmUpdatePipelineByUID.optional = true
	return mmUpdatePipelineByUID
}

// Expect sets up expected params for Repository.UpdatePipelineByUID
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) Expect(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) *mRepositoryMockUpdatePipelineByUID {
	if mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Set")
	}

	if mmUpdatePipelineByUID.defaultExpectation == nil {
		mmUpdatePipelineByUID.defaultExpectation = &RepositoryMockUpdatePipelineByUIDExpectation{}
	}

	if mmUpdatePipelineByUID.defaultExpectation.paramPtrs != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by ExpectParams functions")
	}

	mmUpdatePipelineByUID.defaultExpectation.params = &RepositoryMockUpdatePipelineByUIDParams{ctx, uid, pipeline}
	mmUpdatePipelineByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePipelineByUID.expectations {
		if minimock.Equal(e.params, mmUpdatePipelineByUID.defaultExpectation.params) {
			mmUpdatePipelineByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePipelineByUID.defaultExpectation.params)
		}
	}

	return mmUpdatePipelineByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdatePipelineByUID
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdatePipelineByUID {
	if mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Set")
	}

	if mmUpdatePipelineByUID.defaultExpectation == nil {
		mmUpdatePipelineByUID.defaultExpectation = &RepositoryMockUpdatePipelineByUIDExpectation{}
	}

	if mmUpdatePipelineByUID.defaultExpectation.params != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Expect")
	}

	if mmUpdatePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineByUIDParamPtrs{}
	}
	mmUpdatePipelineByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePipelineByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePipelineByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.UpdatePipelineByUID
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockUpdatePipelineByUID {
	if mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Set")
	}

	if mmUpdatePipelineByUID.defaultExpectation == nil {
		mmUpdatePipelineByUID.defaultExpectation = &RepositoryMockUpdatePipelineByUIDExpectation{}
	}

	if mmUpdatePipelineByUID.defaultExpectation.params != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Expect")
	}

	if mmUpdatePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineByUIDParamPtrs{}
	}
	mmUpdatePipelineByUID.defaultExpectation.paramPtrs.uid = &uid
	mmUpdatePipelineByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmUpdatePipelineByUID
}

// ExpectPipelineParam3 sets up expected param pipeline for Repository.UpdatePipelineByUID
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) ExpectPipelineParam3(pipeline *datamodel.Pipeline) *mRepositoryMockUpdatePipelineByUID {
	if mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Set")
	}

	if mmUpdatePipelineByUID.defaultExpectation == nil {
		mmUpdatePipelineByUID.defaultExpectation = &RepositoryMockUpdatePipelineByUIDExpectation{}
	}

	if mmUpdatePipelineByUID.defaultExpectation.params != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Expect")
	}

	if mmUpdatePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineByUIDParamPtrs{}
	}
	mmUpdatePipelineByUID.defaultExpectation.paramPtrs.pipeline = &pipeline
	mmUpdatePipelineByUID.defaultExpectation.expectationOrigins.originPipeline = minimock.CallerInfo(1)

	return mmUpdatePipelineByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdatePipelineByUID
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline)) *mRepositoryMockUpdatePipelineByUID {
	if mmUpdatePipelineByUID.mock.inspectFuncUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdatePipelineByUID")
	}

	mmUpdatePipelineByUID.mock.inspectFuncUpdatePipelineByUID = f

	return mmUpdatePipelineByUID
}

// Return sets up results that will be returned by Repository.UpdatePipelineByUID
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) Return(err error) *RepositoryMock {
	if mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Set")
	}

	if mmUpdatePipelineByUID.defaultExpectation == nil {
		mmUpdatePipelineByUID.defaultExpectation = &RepositoryMockUpdatePipelineByUIDExpectation{mock: mmUpdatePipelineByUID.mock}
	}
	mmUpdatePipelineByUID.defaultExpectation.results = &RepositoryMockUpdatePipelineByUIDResults{err}
	mmUpdatePipelineByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineByUID.mock
}

// Set uses given function f to mock the Repository.UpdatePipelineByUID method
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) Set(f func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error)) *RepositoryMock {
	if mmUpdatePipelineByUID.defaultExpectation != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdatePipelineByUID method")
	}

	if len(mmUpdatePipelineByUID.expectations) > 0 {
		mmUpdatePipelineByUID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdatePipelineByUID method")
	}

	mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID = f
	mmUpdatePipelineByUID.mock.funcUpdatePipelineByUIDOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineByUID.mock
}

// When sets expectation for the Repository.UpdatePipelineByUID which will trigger the result defined by the following
// Then helper
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) When(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) *RepositoryMockUpdatePipelineByUIDExpectation {
	if mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdatePipelineByUID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdatePipelineByUIDExpectation{
		mock:               mmUpdatePipelineByUID.mock,
		params:             &RepositoryMockUpdatePipelineByUIDParams{ctx, uid, pipeline},
		expectationOrigins: RepositoryMockUpdatePipelineByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePipelineByUID.expectations = append(mmUpdatePipelineByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdatePipelineByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdatePipelineByUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdatePipelineByUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdatePipelineByUID should be invoked
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) Times(n uint64) *mRepositoryMockUpdatePipelineByUID {
	if n == 0 {
		mmUpdatePipelineByUID.mock.t.Fatalf("Times of RepositoryMock.UpdatePipelineByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePipelineByUID.expectedInvocations, n)
	mmUpdatePipelineByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineByUID
}

func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) invocationsDone() bool {
	if len(mmUpdatePipelineByUID.expectations) == 0 && mmUpdatePipelineByUID.defaultExpectation == nil && mmUpdatePipelineByUID.mock.funcUpdatePipelineByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineByUID.mock.afterUpdatePipelineByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePipelineByUID implements mm_repository.Repository
func (mmUpdatePipelineByUID *RepositoryMock) UpdatePipelineByUID(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmUpdatePipelineByUID.beforeUpdatePipelineByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePipelineByUID.afterUpdatePipelineByUIDCounter, 1)

	mmUpdatePipelineByUID.t.Helper()

	if mmUpdatePipelineByUID.inspectFuncUpdatePipelineByUID != nil {
		mmUpdatePipelineByUID.inspectFuncUpdatePipelineByUID(ctx, uid, pipeline)
	}

	mm_params := RepositoryMockUpdatePipelineByUIDParams{ctx, uid, pipeline}

	// Record call args
	mmUpdatePipelineByUID.UpdatePipelineByUIDMock.mutex.Lock()
	mmUpdatePipelineByUID.UpdatePipelineByUIDMock.callArgs = append(mmUpdatePipelineByUID.UpdatePipelineByUIDMock.callArgs, &mm_params)
	mmUpdatePipelineByUID.UpdatePipelineByUIDMock.mutex.Unlock()

	for _, e := range mmUpdatePipelineByUID.UpdatePipelineByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdatePipelineByUIDParams{ctx, uid, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePipelineByUID.t.Errorf("RepositoryMock.UpdatePipelineByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmUpdatePipelineByUID.t.Errorf("RepositoryMock.UpdatePipelineByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmUpdatePipelineByUID.t.Errorf("RepositoryMock.UpdatePipelineByUID got unexpected parameter pipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.expectationOrigins.originPipeline, *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePipelineByUID.t.Errorf("RepositoryMock.UpdatePipelineByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePipelineByUID.UpdatePipelineByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePipelineByUID.t.Fatal("No results are set for the RepositoryMock.UpdatePipelineByUID")
		}
		return (*mm_results).err
	}
	if mmUpdatePipelineByUID.funcUpdatePipelineByUID != nil {
		return mmUpdatePipelineByUID.funcUpdatePipelineByUID(ctx, uid, pipeline)
	}
	mmUpdatePipelineByUID.t.Fatalf("Unexpected call to RepositoryMock.UpdatePipelineByUID. %v %v %v", ctx, uid, pipeline)
	return
}

// UpdatePipelineByUIDAfterCounter returns a count of finished RepositoryMock.UpdatePipelineByUID invocations
func (mmUpdatePipelineByUID *RepositoryMock) UpdatePipelineByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineByUID.afterUpdatePipelineByUIDCounter)
}

// UpdatePipelineByUIDBeforeCounter returns a count of RepositoryMock.UpdatePipelineByUID invocations
func (mmUpdatePipelineByUID *RepositoryMock) UpdatePipelineByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineByUID.beforeUpdatePipelineByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdatePipelineByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePipelineByUID *mRepositoryMockUpdatePipelineByUID) Calls() []*RepositoryMockUpdatePipelineByUIDParams {
	mmUpdatePipelineByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdatePipelineByUIDParams, len(mmUpdatePipelineByUID.callArgs))
	copy(argCopy, mmUpdatePipelineByUID.callArgs)

	mmUpdatePipelineByUID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePipelineByUIDDone returns true if the count of the UpdatePipelineByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdatePipelineByUIDDone() bool {
	if m.UpdatePipelineByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePipelineByUIDMock.invocationsDone()
}

// MinimockUpdatePipelineByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdatePipelineByUIDInspect() {
	for _, e := range m.UpdatePipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePipelineByUIDCounter := mm_atomic.LoadUint64(&m.afterUpdatePipelineByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineByUIDMock.defaultExpectation != nil && afterUpdatePipelineByUIDCounter < 1 {
		if m.UpdatePipelineByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineByUID at\n%s", m.UpdatePipelineByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineByUID at\n%s with params: %#v", m.UpdatePipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePipelineByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineByUID != nil && afterUpdatePipelineByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineByUID at\n%s", m.funcUpdatePipelineByUIDOrigin)
	}

	if !m.UpdatePipelineByUIDMock.invocationsDone() && afterUpdatePipelineByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdatePipelineByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePipelineByUIDMock.expectedInvocations), m.UpdatePipelineByUIDMock.expectedInvocationsOrigin, afterUpdatePipelineByUIDCounter)
	}
}

type mRepositoryMockUpdatePipelineIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdatePipelineIDByIDExpectation
	expectations       []*RepositoryMockUpdatePipelineIDByIDExpectation

	callArgs []*RepositoryMockUpdatePipelineIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdatePipelineIDByIDExpectation specifies expectation struct of the Repository.UpdatePipelineIDByID
type RepositoryMockUpdatePipelineIDByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdatePipelineIDByIDParams
	paramPtrs          *RepositoryMockUpdatePipelineIDByIDParamPtrs
	expectationOrigins RepositoryMockUpdatePipelineIDByIDExpectationOrigins
	results            *RepositoryMockUpdatePipelineIDByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdatePipelineIDByIDParams contains parameters of the Repository.UpdatePipelineIDByID
type RepositoryMockUpdatePipelineIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	newID          string
}

// RepositoryMockUpdatePipelineIDByIDParamPtrs contains pointers to parameters of the Repository.UpdatePipelineIDByID
type RepositoryMockUpdatePipelineIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	newID          *string
}

// RepositoryMockUpdatePipelineIDByIDResults contains results of the Repository.UpdatePipelineIDByID
type RepositoryMockUpdatePipelineIDByIDResults struct {
	err error
}

// RepositoryMockUpdatePipelineIDByIDOrigins contains origins of expectations of the Repository.UpdatePipelineIDByID
type RepositoryMockUpdatePipelineIDByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originNewID          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) Optional() *mRepositoryMockUpdatePipelineIDByID {
	mmUpdatePipelineIDByID.optional = true
	return mmUpdatePipelineIDByID
}

// Expect sets up expected params for Repository.UpdatePipelineIDByID
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) Expect(ctx context.Context, ownerPermalink string, id string, newID string) *mRepositoryMockUpdatePipelineIDByID {
	if mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Set")
	}

	if mmUpdatePipelineIDByID.defaultExpectation == nil {
		mmUpdatePipelineIDByID.defaultExpectation = &RepositoryMockUpdatePipelineIDByIDExpectation{}
	}

	if mmUpdatePipelineIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by ExpectParams functions")
	}

	mmUpdatePipelineIDByID.defaultExpectation.params = &RepositoryMockUpdatePipelineIDByIDParams{ctx, ownerPermalink, id, newID}
	mmUpdatePipelineIDByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePipelineIDByID.expectations {
		if minimock.Equal(e.params, mmUpdatePipelineIDByID.defaultExpectation.params) {
			mmUpdatePipelineIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePipelineIDByID.defaultExpectation.params)
		}
	}

	return mmUpdatePipelineIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdatePipelineIDByID
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdatePipelineIDByID {
	if mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Set")
	}

	if mmUpdatePipelineIDByID.defaultExpectation == nil {
		mmUpdatePipelineIDByID.defaultExpectation = &RepositoryMockUpdatePipelineIDByIDExpectation{}
	}

	if mmUpdatePipelineIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineIDByIDParamPtrs{}
	}
	mmUpdatePipelineIDByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePipelineIDByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePipelineIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdatePipelineIDByID
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdatePipelineIDByID {
	if mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Set")
	}

	if mmUpdatePipelineIDByID.defaultExpectation == nil {
		mmUpdatePipelineIDByID.defaultExpectation = &RepositoryMockUpdatePipelineIDByIDExpectation{}
	}

	if mmUpdatePipelineIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineIDByIDParamPtrs{}
	}
	mmUpdatePipelineIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdatePipelineIDByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdatePipelineIDByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdatePipelineIDByID
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) ExpectIdParam3(id string) *mRepositoryMockUpdatePipelineIDByID {
	if mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Set")
	}

	if mmUpdatePipelineIDByID.defaultExpectation == nil {
		mmUpdatePipelineIDByID.defaultExpectation = &RepositoryMockUpdatePipelineIDByIDExpectation{}
	}

	if mmUpdatePipelineIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineIDByIDParamPtrs{}
	}
	mmUpdatePipelineIDByID.defaultExpectation.paramPtrs.id = &id
	mmUpdatePipelineIDByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdatePipelineIDByID
}

// ExpectNewIDParam4 sets up expected param newID for Repository.UpdatePipelineIDByID
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) ExpectNewIDParam4(newID string) *mRepositoryMockUpdatePipelineIDByID {
	if mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Set")
	}

	if mmUpdatePipelineIDByID.defaultExpectation == nil {
		mmUpdatePipelineIDByID.defaultExpectation = &RepositoryMockUpdatePipelineIDByIDExpectation{}
	}

	if mmUpdatePipelineIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineIDByIDParamPtrs{}
	}
	mmUpdatePipelineIDByID.defaultExpectation.paramPtrs.newID = &newID
	mmUpdatePipelineIDByID.defaultExpectation.expectationOrigins.originNewID = minimock.CallerInfo(1)

	return mmUpdatePipelineIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdatePipelineIDByID
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, newID string)) *mRepositoryMockUpdatePipelineIDByID {
	if mmUpdatePipelineIDByID.mock.inspectFuncUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdatePipelineIDByID")
	}

	mmUpdatePipelineIDByID.mock.inspectFuncUpdatePipelineIDByID = f

	return mmUpdatePipelineIDByID
}

// Return sets up results that will be returned by Repository.UpdatePipelineIDByID
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) Return(err error) *RepositoryMock {
	if mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Set")
	}

	if mmUpdatePipelineIDByID.defaultExpectation == nil {
		mmUpdatePipelineIDByID.defaultExpectation = &RepositoryMockUpdatePipelineIDByIDExpectation{mock: mmUpdatePipelineIDByID.mock}
	}
	mmUpdatePipelineIDByID.defaultExpectation.results = &RepositoryMockUpdatePipelineIDByIDResults{err}
	mmUpdatePipelineIDByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineIDByID.mock
}

// Set uses given function f to mock the Repository.UpdatePipelineIDByID method
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) Set(f func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdatePipelineIDByID.defaultExpectation != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdatePipelineIDByID method")
	}

	if len(mmUpdatePipelineIDByID.expectations) > 0 {
		mmUpdatePipelineIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdatePipelineIDByID method")
	}

	mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID = f
	mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByIDOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineIDByID.mock
}

// When sets expectation for the Repository.UpdatePipelineIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) When(ctx context.Context, ownerPermalink string, id string, newID string) *RepositoryMockUpdatePipelineIDByIDExpectation {
	if mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdatePipelineIDByIDExpectation{
		mock:               mmUpdatePipelineIDByID.mock,
		params:             &RepositoryMockUpdatePipelineIDByIDParams{ctx, ownerPermalink, id, newID},
		expectationOrigins: RepositoryMockUpdatePipelineIDByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePipelineIDByID.expectations = append(mmUpdatePipelineIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdatePipelineIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdatePipelineIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdatePipelineIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdatePipelineIDByID should be invoked
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) Times(n uint64) *mRepositoryMockUpdatePipelineIDByID {
	if n == 0 {
		mmUpdatePipelineIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdatePipelineIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePipelineIDByID.expectedInvocations, n)
	mmUpdatePipelineIDByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineIDByID
}

func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) invocationsDone() bool {
	if len(mmUpdatePipelineIDByID.expectations) == 0 && mmUpdatePipelineIDByID.defaultExpectation == nil && mmUpdatePipelineIDByID.mock.funcUpdatePipelineIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineIDByID.mock.afterUpdatePipelineIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePipelineIDByID implements mm_repository.Repository
func (mmUpdatePipelineIDByID *RepositoryMock) UpdatePipelineIDByID(ctx context.Context, ownerPermalink string, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdatePipelineIDByID.beforeUpdatePipelineIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePipelineIDByID.afterUpdatePipelineIDByIDCounter, 1)

	mmUpdatePipelineIDByID.t.Helper()

	if mmUpdatePipelineIDByID.inspectFuncUpdatePipelineIDByID != nil {
		mmUpdatePipelineIDByID.inspectFuncUpdatePipelineIDByID(ctx, ownerPermalink, id, newID)
	}

	mm_params := RepositoryMockUpdatePipelineIDByIDParams{ctx, ownerPermalink, id, newID}

	// Record call args
	mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.mutex.Lock()
	mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.callArgs = append(mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.callArgs, &mm_params)
	mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdatePipelineIDByIDParams{ctx, ownerPermalink, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePipelineIDByID.t.Errorf("RepositoryMock.UpdatePipelineIDByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdatePipelineIDByID.t.Errorf("RepositoryMock.UpdatePipelineIDByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdatePipelineIDByID.t.Errorf("RepositoryMock.UpdatePipelineIDByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdatePipelineIDByID.t.Errorf("RepositoryMock.UpdatePipelineIDByID got unexpected parameter newID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.expectationOrigins.originNewID, *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePipelineIDByID.t.Errorf("RepositoryMock.UpdatePipelineIDByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePipelineIDByID.UpdatePipelineIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePipelineIDByID.t.Fatal("No results are set for the RepositoryMock.UpdatePipelineIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdatePipelineIDByID.funcUpdatePipelineIDByID != nil {
		return mmUpdatePipelineIDByID.funcUpdatePipelineIDByID(ctx, ownerPermalink, id, newID)
	}
	mmUpdatePipelineIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdatePipelineIDByID. %v %v %v %v", ctx, ownerPermalink, id, newID)
	return
}

// UpdatePipelineIDByIDAfterCounter returns a count of finished RepositoryMock.UpdatePipelineIDByID invocations
func (mmUpdatePipelineIDByID *RepositoryMock) UpdatePipelineIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineIDByID.afterUpdatePipelineIDByIDCounter)
}

// UpdatePipelineIDByIDBeforeCounter returns a count of RepositoryMock.UpdatePipelineIDByID invocations
func (mmUpdatePipelineIDByID *RepositoryMock) UpdatePipelineIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineIDByID.beforeUpdatePipelineIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdatePipelineIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePipelineIDByID *mRepositoryMockUpdatePipelineIDByID) Calls() []*RepositoryMockUpdatePipelineIDByIDParams {
	mmUpdatePipelineIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdatePipelineIDByIDParams, len(mmUpdatePipelineIDByID.callArgs))
	copy(argCopy, mmUpdatePipelineIDByID.callArgs)

	mmUpdatePipelineIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePipelineIDByIDDone returns true if the count of the UpdatePipelineIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdatePipelineIDByIDDone() bool {
	if m.UpdatePipelineIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePipelineIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePipelineIDByIDMock.invocationsDone()
}

// MinimockUpdatePipelineIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdatePipelineIDByIDInspect() {
	for _, e := range m.UpdatePipelineIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineIDByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePipelineIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdatePipelineIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineIDByIDMock.defaultExpectation != nil && afterUpdatePipelineIDByIDCounter < 1 {
		if m.UpdatePipelineIDByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineIDByID at\n%s", m.UpdatePipelineIDByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineIDByID at\n%s with params: %#v", m.UpdatePipelineIDByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePipelineIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineIDByID != nil && afterUpdatePipelineIDByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineIDByID at\n%s", m.funcUpdatePipelineIDByIDOrigin)
	}

	if !m.UpdatePipelineIDByIDMock.invocationsDone() && afterUpdatePipelineIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdatePipelineIDByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePipelineIDByIDMock.expectedInvocations), m.UpdatePipelineIDByIDMock.expectedInvocationsOrigin, afterUpdatePipelineIDByIDCounter)
	}
}

type mRepositoryMockUpdatePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdatePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockUpdatePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockUpdatePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdatePipelineReleaseByIDExpectation specifies expectation struct of the Repository.UpdatePipelineReleaseByID
type RepositoryMockUpdatePipelineReleaseByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdatePipelineReleaseByIDParams
	paramPtrs          *RepositoryMockUpdatePipelineReleaseByIDParamPtrs
	expectationOrigins RepositoryMockUpdatePipelineReleaseByIDExpectationOrigins
	results            *RepositoryMockUpdatePipelineReleaseByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdatePipelineReleaseByIDParams contains parameters of the Repository.UpdatePipelineReleaseByID
type RepositoryMockUpdatePipelineReleaseByIDParams struct {
	ctx             context.Context
	ownerPermalink  string
	pipelineUID     uuid.UUID
	id              string
	pipelineRelease *datamodel.PipelineRelease
}

// RepositoryMockUpdatePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.UpdatePipelineReleaseByID
type RepositoryMockUpdatePipelineReleaseByIDParamPtrs struct {
	ctx             *context.Context
	ownerPermalink  *string
	pipelineUID     *uuid.UUID
	id              *string
	pipelineRelease **datamodel.PipelineRelease
}

// RepositoryMockUpdatePipelineReleaseByIDResults contains results of the Repository.UpdatePipelineReleaseByID
type RepositoryMockUpdatePipelineReleaseByIDResults struct {
	err error
}

// RepositoryMockUpdatePipelineReleaseByIDOrigins contains origins of expectations of the Repository.UpdatePipelineReleaseByID
type RepositoryMockUpdatePipelineReleaseByIDExpectationOrigins struct {
	origin                string
	originCtx             string
	originOwnerPermalink  string
	originPipelineUID     string
	originId              string
	originPipelineRelease string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) Optional() *mRepositoryMockUpdatePipelineReleaseByID {
	mmUpdatePipelineReleaseByID.optional = true
	return mmUpdatePipelineReleaseByID
}

// Expect sets up expected params for Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockUpdatePipelineReleaseByID {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseByIDExpectation{}
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmUpdatePipelineReleaseByID.defaultExpectation.params = &RepositoryMockUpdatePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}
	mmUpdatePipelineReleaseByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmUpdatePipelineReleaseByID.defaultExpectation.params) {
			mmUpdatePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmUpdatePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdatePipelineReleaseByID {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseByIDExpectation{}
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePipelineReleaseByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdatePipelineReleaseByID {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseByIDExpectation{}
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdatePipelineReleaseByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockUpdatePipelineReleaseByID {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseByIDExpectation{}
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmUpdatePipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockUpdatePipelineReleaseByID {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseByIDExpectation{}
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id
	mmUpdatePipelineReleaseByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseByID
}

// ExpectPipelineReleaseParam5 sets up expected param pipelineRelease for Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) ExpectPipelineReleaseParam5(pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockUpdatePipelineReleaseByID {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseByIDExpectation{}
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineRelease = &pipelineRelease
	mmUpdatePipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineRelease = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease)) *mRepositoryMockUpdatePipelineReleaseByID {
	if mmUpdatePipelineReleaseByID.mock.inspectFuncUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdatePipelineReleaseByID")
	}

	mmUpdatePipelineReleaseByID.mock.inspectFuncUpdatePipelineReleaseByID = f

	return mmUpdatePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.UpdatePipelineReleaseByID
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) Return(err error) *RepositoryMock {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseByIDExpectation{mock: mmUpdatePipelineReleaseByID.mock}
	}
	mmUpdatePipelineReleaseByID.defaultExpectation.results = &RepositoryMockUpdatePipelineReleaseByIDResults{err}
	mmUpdatePipelineReleaseByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.UpdatePipelineReleaseByID method
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error)) *RepositoryMock {
	if mmUpdatePipelineReleaseByID.defaultExpectation != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdatePipelineReleaseByID method")
	}

	if len(mmUpdatePipelineReleaseByID.expectations) > 0 {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdatePipelineReleaseByID method")
	}

	mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID = f
	mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByIDOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineReleaseByID.mock
}

// When sets expectation for the Repository.UpdatePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) *RepositoryMockUpdatePipelineReleaseByIDExpectation {
	if mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdatePipelineReleaseByIDExpectation{
		mock:               mmUpdatePipelineReleaseByID.mock,
		params:             &RepositoryMockUpdatePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease},
		expectationOrigins: RepositoryMockUpdatePipelineReleaseByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePipelineReleaseByID.expectations = append(mmUpdatePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdatePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdatePipelineReleaseByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdatePipelineReleaseByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdatePipelineReleaseByID should be invoked
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) Times(n uint64) *mRepositoryMockUpdatePipelineReleaseByID {
	if n == 0 {
		mmUpdatePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.UpdatePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePipelineReleaseByID.expectedInvocations, n)
	mmUpdatePipelineReleaseByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineReleaseByID
}

func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) invocationsDone() bool {
	if len(mmUpdatePipelineReleaseByID.expectations) == 0 && mmUpdatePipelineReleaseByID.defaultExpectation == nil && mmUpdatePipelineReleaseByID.mock.funcUpdatePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineReleaseByID.mock.afterUpdatePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePipelineReleaseByID implements mm_repository.Repository
func (mmUpdatePipelineReleaseByID *RepositoryMock) UpdatePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error) {
	mm_atomic.AddUint64(&mmUpdatePipelineReleaseByID.beforeUpdatePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePipelineReleaseByID.afterUpdatePipelineReleaseByIDCounter, 1)

	mmUpdatePipelineReleaseByID.t.Helper()

	if mmUpdatePipelineReleaseByID.inspectFuncUpdatePipelineReleaseByID != nil {
		mmUpdatePipelineReleaseByID.inspectFuncUpdatePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	}

	mm_params := RepositoryMockUpdatePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}

	// Record call args
	mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.mutex.Lock()
	mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.callArgs = append(mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.callArgs, &mm_params)
	mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdatePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePipelineReleaseByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdatePipelineReleaseByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmUpdatePipelineReleaseByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdatePipelineReleaseByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.pipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease) {
				mmUpdatePipelineReleaseByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseByID got unexpected parameter pipelineRelease, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineRelease, *mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease, minimock.Diff(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePipelineReleaseByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePipelineReleaseByID.UpdatePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.UpdatePipelineReleaseByID")
		}
		return (*mm_results).err
	}
	if mmUpdatePipelineReleaseByID.funcUpdatePipelineReleaseByID != nil {
		return mmUpdatePipelineReleaseByID.funcUpdatePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	}
	mmUpdatePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.UpdatePipelineReleaseByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	return
}

// UpdatePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.UpdatePipelineReleaseByID invocations
func (mmUpdatePipelineReleaseByID *RepositoryMock) UpdatePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineReleaseByID.afterUpdatePipelineReleaseByIDCounter)
}

// UpdatePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.UpdatePipelineReleaseByID invocations
func (mmUpdatePipelineReleaseByID *RepositoryMock) UpdatePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineReleaseByID.beforeUpdatePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdatePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePipelineReleaseByID *mRepositoryMockUpdatePipelineReleaseByID) Calls() []*RepositoryMockUpdatePipelineReleaseByIDParams {
	mmUpdatePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdatePipelineReleaseByIDParams, len(mmUpdatePipelineReleaseByID.callArgs))
	copy(argCopy, mmUpdatePipelineReleaseByID.callArgs)

	mmUpdatePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePipelineReleaseByIDDone returns true if the count of the UpdatePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdatePipelineReleaseByIDDone() bool {
	if m.UpdatePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePipelineReleaseByIDMock.invocationsDone()
}

// MinimockUpdatePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdatePipelineReleaseByIDInspect() {
	for _, e := range m.UpdatePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterUpdatePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineReleaseByIDMock.defaultExpectation != nil && afterUpdatePipelineReleaseByIDCounter < 1 {
		if m.UpdatePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseByID at\n%s", m.UpdatePipelineReleaseByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseByID at\n%s with params: %#v", m.UpdatePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineReleaseByID != nil && afterUpdatePipelineReleaseByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseByID at\n%s", m.funcUpdatePipelineReleaseByIDOrigin)
	}

	if !m.UpdatePipelineReleaseByIDMock.invocationsDone() && afterUpdatePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdatePipelineReleaseByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePipelineReleaseByIDMock.expectedInvocations), m.UpdatePipelineReleaseByIDMock.expectedInvocationsOrigin, afterUpdatePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockUpdatePipelineReleaseIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdatePipelineReleaseIDByIDExpectation
	expectations       []*RepositoryMockUpdatePipelineReleaseIDByIDExpectation

	callArgs []*RepositoryMockUpdatePipelineReleaseIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdatePipelineReleaseIDByIDExpectation specifies expectation struct of the Repository.UpdatePipelineReleaseIDByID
type RepositoryMockUpdatePipelineReleaseIDByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdatePipelineReleaseIDByIDParams
	paramPtrs          *RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs
	expectationOrigins RepositoryMockUpdatePipelineReleaseIDByIDExpectationOrigins
	results            *RepositoryMockUpdatePipelineReleaseIDByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdatePipelineReleaseIDByIDParams contains parameters of the Repository.UpdatePipelineReleaseIDByID
type RepositoryMockUpdatePipelineReleaseIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
	newID          string
}

// RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs contains pointers to parameters of the Repository.UpdatePipelineReleaseIDByID
type RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
	newID          *string
}

// RepositoryMockUpdatePipelineReleaseIDByIDResults contains results of the Repository.UpdatePipelineReleaseIDByID
type RepositoryMockUpdatePipelineReleaseIDByIDResults struct {
	err error
}

// RepositoryMockUpdatePipelineReleaseIDByIDOrigins contains origins of expectations of the Repository.UpdatePipelineReleaseIDByID
type RepositoryMockUpdatePipelineReleaseIDByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originId             string
	originNewID          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) Optional() *mRepositoryMockUpdatePipelineReleaseIDByID {
	mmUpdatePipelineReleaseIDByID.optional = true
	return mmUpdatePipelineReleaseIDByID
}

// Expect sets up expected params for Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by ExpectParams functions")
	}

	mmUpdatePipelineReleaseIDByID.defaultExpectation.params = &RepositoryMockUpdatePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePipelineReleaseIDByID.expectations {
		if minimock.Equal(e.params, mmUpdatePipelineReleaseIDByID.defaultExpectation.params) {
			mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePipelineReleaseIDByID.defaultExpectation.params)
		}
	}

	return mmUpdatePipelineReleaseIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdatePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseIDByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmUpdatePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseIDByID
}

// ExpectIdParam4 sets up expected param id for Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) ExpectIdParam4(id string) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs.id = &id
	mmUpdatePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseIDByID
}

// ExpectNewIDParam5 sets up expected param newID for Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) ExpectNewIDParam5(newID string) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.paramPtrs.newID = &newID
	mmUpdatePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originNewID = minimock.CallerInfo(1)

	return mmUpdatePipelineReleaseIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string)) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if mmUpdatePipelineReleaseIDByID.mock.inspectFuncUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdatePipelineReleaseIDByID")
	}

	mmUpdatePipelineReleaseIDByID.mock.inspectFuncUpdatePipelineReleaseIDByID = f

	return mmUpdatePipelineReleaseIDByID
}

// Return sets up results that will be returned by Repository.UpdatePipelineReleaseIDByID
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) Return(err error) *RepositoryMock {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdatePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdatePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{mock: mmUpdatePipelineReleaseIDByID.mock}
	}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.results = &RepositoryMockUpdatePipelineReleaseIDByIDResults{err}
	mmUpdatePipelineReleaseIDByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineReleaseIDByID.mock
}

// Set uses given function f to mock the Repository.UpdatePipelineReleaseIDByID method
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdatePipelineReleaseIDByID.defaultExpectation != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdatePipelineReleaseIDByID method")
	}

	if len(mmUpdatePipelineReleaseIDByID.expectations) > 0 {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdatePipelineReleaseIDByID method")
	}

	mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID = f
	mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByIDOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineReleaseIDByID.mock
}

// When sets expectation for the Repository.UpdatePipelineReleaseIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) *RepositoryMockUpdatePipelineReleaseIDByIDExpectation {
	if mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdatePipelineReleaseIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdatePipelineReleaseIDByIDExpectation{
		mock:               mmUpdatePipelineReleaseIDByID.mock,
		params:             &RepositoryMockUpdatePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID},
		expectationOrigins: RepositoryMockUpdatePipelineReleaseIDByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePipelineReleaseIDByID.expectations = append(mmUpdatePipelineReleaseIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdatePipelineReleaseIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdatePipelineReleaseIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdatePipelineReleaseIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdatePipelineReleaseIDByID should be invoked
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) Times(n uint64) *mRepositoryMockUpdatePipelineReleaseIDByID {
	if n == 0 {
		mmUpdatePipelineReleaseIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdatePipelineReleaseIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePipelineReleaseIDByID.expectedInvocations, n)
	mmUpdatePipelineReleaseIDByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineReleaseIDByID
}

func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) invocationsDone() bool {
	if len(mmUpdatePipelineReleaseIDByID.expectations) == 0 && mmUpdatePipelineReleaseIDByID.defaultExpectation == nil && mmUpdatePipelineReleaseIDByID.mock.funcUpdatePipelineReleaseIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineReleaseIDByID.mock.afterUpdatePipelineReleaseIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineReleaseIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePipelineReleaseIDByID implements mm_repository.Repository
func (mmUpdatePipelineReleaseIDByID *RepositoryMock) UpdatePipelineReleaseIDByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdatePipelineReleaseIDByID.beforeUpdatePipelineReleaseIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePipelineReleaseIDByID.afterUpdatePipelineReleaseIDByIDCounter, 1)

	mmUpdatePipelineReleaseIDByID.t.Helper()

	if mmUpdatePipelineReleaseIDByID.inspectFuncUpdatePipelineReleaseIDByID != nil {
		mmUpdatePipelineReleaseIDByID.inspectFuncUpdatePipelineReleaseIDByID(ctx, ownerPermalink, pipelineUID, id, newID)
	}

	mm_params := RepositoryMockUpdatePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}

	// Record call args
	mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.mutex.Lock()
	mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.callArgs = append(mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.callArgs, &mm_params)
	mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdatePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseIDByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdatePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseIDByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmUpdatePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseIDByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdatePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseIDByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdatePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseIDByID got unexpected parameter newID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originNewID, *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdatePipelineReleaseIDByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePipelineReleaseIDByID.UpdatePipelineReleaseIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePipelineReleaseIDByID.t.Fatal("No results are set for the RepositoryMock.UpdatePipelineReleaseIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdatePipelineReleaseIDByID.funcUpdatePipelineReleaseIDByID != nil {
		return mmUpdatePipelineReleaseIDByID.funcUpdatePipelineReleaseIDByID(ctx, ownerPermalink, pipelineUID, id, newID)
	}
	mmUpdatePipelineReleaseIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdatePipelineReleaseIDByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, newID)
	return
}

// UpdatePipelineReleaseIDByIDAfterCounter returns a count of finished RepositoryMock.UpdatePipelineReleaseIDByID invocations
func (mmUpdatePipelineReleaseIDByID *RepositoryMock) UpdatePipelineReleaseIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineReleaseIDByID.afterUpdatePipelineReleaseIDByIDCounter)
}

// UpdatePipelineReleaseIDByIDBeforeCounter returns a count of RepositoryMock.UpdatePipelineReleaseIDByID invocations
func (mmUpdatePipelineReleaseIDByID *RepositoryMock) UpdatePipelineReleaseIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineReleaseIDByID.beforeUpdatePipelineReleaseIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdatePipelineReleaseIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePipelineReleaseIDByID *mRepositoryMockUpdatePipelineReleaseIDByID) Calls() []*RepositoryMockUpdatePipelineReleaseIDByIDParams {
	mmUpdatePipelineReleaseIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdatePipelineReleaseIDByIDParams, len(mmUpdatePipelineReleaseIDByID.callArgs))
	copy(argCopy, mmUpdatePipelineReleaseIDByID.callArgs)

	mmUpdatePipelineReleaseIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePipelineReleaseIDByIDDone returns true if the count of the UpdatePipelineReleaseIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdatePipelineReleaseIDByIDDone() bool {
	if m.UpdatePipelineReleaseIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePipelineReleaseIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePipelineReleaseIDByIDMock.invocationsDone()
}

// MinimockUpdatePipelineReleaseIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdatePipelineReleaseIDByIDInspect() {
	for _, e := range m.UpdatePipelineReleaseIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseIDByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePipelineReleaseIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdatePipelineReleaseIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineReleaseIDByIDMock.defaultExpectation != nil && afterUpdatePipelineReleaseIDByIDCounter < 1 {
		if m.UpdatePipelineReleaseIDByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseIDByID at\n%s", m.UpdatePipelineReleaseIDByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseIDByID at\n%s with params: %#v", m.UpdatePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePipelineReleaseIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineReleaseIDByID != nil && afterUpdatePipelineReleaseIDByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineReleaseIDByID at\n%s", m.funcUpdatePipelineReleaseIDByIDOrigin)
	}

	if !m.UpdatePipelineReleaseIDByIDMock.invocationsDone() && afterUpdatePipelineReleaseIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdatePipelineReleaseIDByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePipelineReleaseIDByIDMock.expectedInvocations), m.UpdatePipelineReleaseIDByIDMock.expectedInvocationsOrigin, afterUpdatePipelineReleaseIDByIDCounter)
	}
}

type mRepositoryMockUpdatePipelineRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdatePipelineRunExpectation
	expectations       []*RepositoryMockUpdatePipelineRunExpectation

	callArgs []*RepositoryMockUpdatePipelineRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdatePipelineRunExpectation specifies expectation struct of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdatePipelineRunParams
	paramPtrs          *RepositoryMockUpdatePipelineRunParamPtrs
	expectationOrigins RepositoryMockUpdatePipelineRunExpectationOrigins
	results            *RepositoryMockUpdatePipelineRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdatePipelineRunParams contains parameters of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunParams struct {
	ctx                context.Context
	pipelineTriggerUID string
	pipelineRun        *datamodel.PipelineRun
}

// RepositoryMockUpdatePipelineRunParamPtrs contains pointers to parameters of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunParamPtrs struct {
	ctx                *context.Context
	pipelineTriggerUID *string
	pipelineRun        **datamodel.PipelineRun
}

// RepositoryMockUpdatePipelineRunResults contains results of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunResults struct {
	err error
}

// RepositoryMockUpdatePipelineRunOrigins contains origins of expectations of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunExpectationOrigins struct {
	origin                   string
	originCtx                string
	originPipelineTriggerUID string
	originPipelineRun        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Optional() *mRepositoryMockUpdatePipelineRun {
	mmUpdatePipelineRun.optional = true
	return mmUpdatePipelineRun
}

// Expect sets up expected params for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Expect(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by ExpectParams functions")
	}

	mmUpdatePipelineRun.defaultExpectation.params = &RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun}
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePipelineRun.expectations {
		if minimock.Equal(e.params, mmUpdatePipelineRun.defaultExpectation.params) {
			mmUpdatePipelineRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePipelineRun.defaultExpectation.params)
		}
	}

	return mmUpdatePipelineRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.params != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Expect")
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineRunParamPtrs{}
	}
	mmUpdatePipelineRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePipelineRun
}

// ExpectPipelineTriggerUIDParam2 sets up expected param pipelineTriggerUID for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) ExpectPipelineTriggerUIDParam2(pipelineTriggerUID string) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.params != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Expect")
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineRunParamPtrs{}
	}
	mmUpdatePipelineRun.defaultExpectation.paramPtrs.pipelineTriggerUID = &pipelineTriggerUID
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.originPipelineTriggerUID = minimock.CallerInfo(1)

	return mmUpdatePipelineRun
}

// ExpectPipelineRunParam3 sets up expected param pipelineRun for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) ExpectPipelineRunParam3(pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.params != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Expect")
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineRunParamPtrs{}
	}
	mmUpdatePipelineRun.defaultExpectation.paramPtrs.pipelineRun = &pipelineRun
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.originPipelineRun = minimock.CallerInfo(1)

	return mmUpdatePipelineRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Inspect(f func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun)) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.inspectFuncUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdatePipelineRun")
	}

	mmUpdatePipelineRun.mock.inspectFuncUpdatePipelineRun = f

	return mmUpdatePipelineRun
}

// Return sets up results that will be returned by Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Return(err error) *RepositoryMock {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{mock: mmUpdatePipelineRun.mock}
	}
	mmUpdatePipelineRun.defaultExpectation.results = &RepositoryMockUpdatePipelineRunResults{err}
	mmUpdatePipelineRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineRun.mock
}

// Set uses given function f to mock the Repository.UpdatePipelineRun method
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Set(f func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) (err error)) *RepositoryMock {
	if mmUpdatePipelineRun.defaultExpectation != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpdatePipelineRun method")
	}

	if len(mmUpdatePipelineRun.expectations) > 0 {
		mmUpdatePipelineRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpdatePipelineRun method")
	}

	mmUpdatePipelineRun.mock.funcUpdatePipelineRun = f
	mmUpdatePipelineRun.mock.funcUpdatePipelineRunOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineRun.mock
}

// When sets expectation for the Repository.UpdatePipelineRun which will trigger the result defined by the following
// Then helper
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) When(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) *RepositoryMockUpdatePipelineRunExpectation {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpdatePipelineRunExpectation{
		mock:               mmUpdatePipelineRun.mock,
		params:             &RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun},
		expectationOrigins: RepositoryMockUpdatePipelineRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePipelineRun.expectations = append(mmUpdatePipelineRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdatePipelineRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdatePipelineRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdatePipelineRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdatePipelineRun should be invoked
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Times(n uint64) *mRepositoryMockUpdatePipelineRun {
	if n == 0 {
		mmUpdatePipelineRun.mock.t.Fatalf("Times of RepositoryMock.UpdatePipelineRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePipelineRun.expectedInvocations, n)
	mmUpdatePipelineRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineRun
}

func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) invocationsDone() bool {
	if len(mmUpdatePipelineRun.expectations) == 0 && mmUpdatePipelineRun.defaultExpectation == nil && mmUpdatePipelineRun.mock.funcUpdatePipelineRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineRun.mock.afterUpdatePipelineRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePipelineRun implements mm_repository.Repository
func (mmUpdatePipelineRun *RepositoryMock) UpdatePipelineRun(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) (err error) {
	mm_atomic.AddUint64(&mmUpdatePipelineRun.beforeUpdatePipelineRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePipelineRun.afterUpdatePipelineRunCounter, 1)

	mmUpdatePipelineRun.t.Helper()

	if mmUpdatePipelineRun.inspectFuncUpdatePipelineRun != nil {
		mmUpdatePipelineRun.inspectFuncUpdatePipelineRun(ctx, pipelineTriggerUID, pipelineRun)
	}

	mm_params := RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun}

	// Record call args
	mmUpdatePipelineRun.UpdatePipelineRunMock.mutex.Lock()
	mmUpdatePipelineRun.UpdatePipelineRunMock.callArgs = append(mmUpdatePipelineRun.UpdatePipelineRunMock.callArgs, &mm_params)
	mmUpdatePipelineRun.UpdatePipelineRunMock.mutex.Unlock()

	for _, e := range mmUpdatePipelineRun.UpdatePipelineRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineTriggerUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID) {
				mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameter pipelineTriggerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.originPipelineTriggerUID, *mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID, minimock.Diff(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID))
			}

			if mm_want_ptrs.pipelineRun != nil && !minimock.Equal(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun) {
				mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameter pipelineRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.originPipelineRun, *mm_want_ptrs.pipelineRun, mm_got.pipelineRun, minimock.Diff(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePipelineRun.t.Fatal("No results are set for the RepositoryMock.UpdatePipelineRun")
		}
		return (*mm_results).err
	}
	if mmUpdatePipelineRun.funcUpdatePipelineRun != nil {
		return mmUpdatePipelineRun.funcUpdatePipelineRun(ctx, pipelineTriggerUID, pipelineRun)
	}
	mmUpdatePipelineRun.t.Fatalf("Unexpected call to RepositoryMock.UpdatePipelineRun. %v %v %v", ctx, pipelineTriggerUID, pipelineRun)
	return
}

// UpdatePipelineRunAfterCounter returns a count of finished RepositoryMock.UpdatePipelineRun invocations
func (mmUpdatePipelineRun *RepositoryMock) UpdatePipelineRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineRun.afterUpdatePipelineRunCounter)
}

// UpdatePipelineRunBeforeCounter returns a count of RepositoryMock.UpdatePipelineRun invocations
func (mmUpdatePipelineRun *RepositoryMock) UpdatePipelineRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineRun.beforeUpdatePipelineRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdatePipelineRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Calls() []*RepositoryMockUpdatePipelineRunParams {
	mmUpdatePipelineRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdatePipelineRunParams, len(mmUpdatePipelineRun.callArgs))
	copy(argCopy, mmUpdatePipelineRun.callArgs)

	mmUpdatePipelineRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePipelineRunDone returns true if the count of the UpdatePipelineRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdatePipelineRunDone() bool {
	if m.UpdatePipelineRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePipelineRunMock.invocationsDone()
}

// MinimockUpdatePipelineRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdatePipelineRunInspect() {
	for _, e := range m.UpdatePipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePipelineRunCounter := mm_atomic.LoadUint64(&m.afterUpdatePipelineRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineRunMock.defaultExpectation != nil && afterUpdatePipelineRunCounter < 1 {
		if m.UpdatePipelineRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s", m.UpdatePipelineRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s with params: %#v", m.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePipelineRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineRun != nil && afterUpdatePipelineRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s", m.funcUpdatePipelineRunOrigin)
	}

	if !m.UpdatePipelineRunMock.invocationsDone() && afterUpdatePipelineRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdatePipelineRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePipelineRunMock.expectedInvocations), m.UpdatePipelineRunMock.expectedInvocationsOrigin, afterUpdatePipelineRunCounter)
	}
}

type mRepositoryMockUpsertComponentDefinition struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertComponentDefinitionExpectation
	expectations       []*RepositoryMockUpsertComponentDefinitionExpectation

	callArgs []*RepositoryMockUpsertComponentDefinitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertComponentDefinitionExpectation specifies expectation struct of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertComponentDefinitionParams
	paramPtrs          *RepositoryMockUpsertComponentDefinitionParamPtrs
	expectationOrigins RepositoryMockUpsertComponentDefinitionExpectationOrigins
	results            *RepositoryMockUpsertComponentDefinitionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertComponentDefinitionParams contains parameters of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionParams struct {
	ctx context.Context
	cp1 *pipelinepb.ComponentDefinition
}

// RepositoryMockUpsertComponentDefinitionParamPtrs contains pointers to parameters of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionParamPtrs struct {
	ctx *context.Context
	cp1 **pipelinepb.ComponentDefinition
}

// RepositoryMockUpsertComponentDefinitionResults contains results of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionResults struct {
	err error
}

// RepositoryMockUpsertComponentDefinitionOrigins contains origins of expectations of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Optional() *mRepositoryMockUpsertComponentDefinition {
	mmUpsertComponentDefinition.optional = true
	return mmUpsertComponentDefinition
}

// Expect sets up expected params for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Expect(ctx context.Context, cp1 *pipelinepb.ComponentDefinition) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by ExpectParams functions")
	}

	mmUpsertComponentDefinition.defaultExpectation.params = &RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}
	mmUpsertComponentDefinition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertComponentDefinition.expectations {
		if minimock.Equal(e.params, mmUpsertComponentDefinition.defaultExpectation.params) {
			mmUpsertComponentDefinition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertComponentDefinition.defaultExpectation.params)
		}
	}

	return mmUpsertComponentDefinition
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.params != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Expect")
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentDefinitionParamPtrs{}
	}
	mmUpsertComponentDefinition.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertComponentDefinition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertComponentDefinition
}

// ExpectCp1Param2 sets up expected param cp1 for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) ExpectCp1Param2(cp1 *pipelinepb.ComponentDefinition) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.params != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Expect")
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentDefinitionParamPtrs{}
	}
	mmUpsertComponentDefinition.defaultExpectation.paramPtrs.cp1 = &cp1
	mmUpsertComponentDefinition.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmUpsertComponentDefinition
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Inspect(f func(ctx context.Context, cp1 *pipelinepb.ComponentDefinition)) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.inspectFuncUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertComponentDefinition")
	}

	mmUpsertComponentDefinition.mock.inspectFuncUpsertComponentDefinition = f

	return mmUpsertComponentDefinition
}

// Return sets up results that will be returned by Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Return(err error) *RepositoryMock {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{mock: mmUpsertComponentDefinition.mock}
	}
	mmUpsertComponentDefinition.defaultExpectation.results = &RepositoryMockUpsertComponentDefinitionResults{err}
	mmUpsertComponentDefinition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentDefinition.mock
}

// Set uses given function f to mock the Repository.UpsertComponentDefinition method
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Set(f func(ctx context.Context, cp1 *pipelinepb.ComponentDefinition) (err error)) *RepositoryMock {
	if mmUpsertComponentDefinition.defaultExpectation != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertComponentDefinition method")
	}

	if len(mmUpsertComponentDefinition.expectations) > 0 {
		mmUpsertComponentDefinition.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertComponentDefinition method")
	}

	mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition = f
	mmUpsertComponentDefinition.mock.funcUpsertComponentDefinitionOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentDefinition.mock
}

// When sets expectation for the Repository.UpsertComponentDefinition which will trigger the result defined by the following
// Then helper
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) When(ctx context.Context, cp1 *pipelinepb.ComponentDefinition) *RepositoryMockUpsertComponentDefinitionExpectation {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertComponentDefinitionExpectation{
		mock:               mmUpsertComponentDefinition.mock,
		params:             &RepositoryMockUpsertComponentDefinitionParams{ctx, cp1},
		expectationOrigins: RepositoryMockUpsertComponentDefinitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertComponentDefinition.expectations = append(mmUpsertComponentDefinition.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertComponentDefinition return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertComponentDefinitionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertComponentDefinitionResults{err}
	return e.mock
}

// Times sets number of times Repository.UpsertComponentDefinition should be invoked
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Times(n uint64) *mRepositoryMockUpsertComponentDefinition {
	if n == 0 {
		mmUpsertComponentDefinition.mock.t.Fatalf("Times of RepositoryMock.UpsertComponentDefinition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertComponentDefinition.expectedInvocations, n)
	mmUpsertComponentDefinition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentDefinition
}

func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) invocationsDone() bool {
	if len(mmUpsertComponentDefinition.expectations) == 0 && mmUpsertComponentDefinition.defaultExpectation == nil && mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertComponentDefinition.mock.afterUpsertComponentDefinitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertComponentDefinition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertComponentDefinition implements mm_repository.Repository
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinition(ctx context.Context, cp1 *pipelinepb.ComponentDefinition) (err error) {
	mm_atomic.AddUint64(&mmUpsertComponentDefinition.beforeUpsertComponentDefinitionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertComponentDefinition.afterUpsertComponentDefinitionCounter, 1)

	mmUpsertComponentDefinition.t.Helper()

	if mmUpsertComponentDefinition.inspectFuncUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.inspectFuncUpsertComponentDefinition(ctx, cp1)
	}

	mm_params := RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}

	// Record call args
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.mutex.Lock()
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.callArgs = append(mmUpsertComponentDefinition.UpsertComponentDefinitionMock.callArgs, &mm_params)
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.mutex.Unlock()

	for _, e := range mmUpsertComponentDefinition.UpsertComponentDefinitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertComponentDefinition.t.Fatal("No results are set for the RepositoryMock.UpsertComponentDefinition")
		}
		return (*mm_results).err
	}
	if mmUpsertComponentDefinition.funcUpsertComponentDefinition != nil {
		return mmUpsertComponentDefinition.funcUpsertComponentDefinition(ctx, cp1)
	}
	mmUpsertComponentDefinition.t.Fatalf("Unexpected call to RepositoryMock.UpsertComponentDefinition. %v %v", ctx, cp1)
	return
}

// UpsertComponentDefinitionAfterCounter returns a count of finished RepositoryMock.UpsertComponentDefinition invocations
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentDefinition.afterUpsertComponentDefinitionCounter)
}

// UpsertComponentDefinitionBeforeCounter returns a count of RepositoryMock.UpsertComponentDefinition invocations
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentDefinition.beforeUpsertComponentDefinitionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertComponentDefinition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Calls() []*RepositoryMockUpsertComponentDefinitionParams {
	mmUpsertComponentDefinition.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertComponentDefinitionParams, len(mmUpsertComponentDefinition.callArgs))
	copy(argCopy, mmUpsertComponentDefinition.callArgs)

	mmUpsertComponentDefinition.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertComponentDefinitionDone returns true if the count of the UpsertComponentDefinition invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertComponentDefinitionDone() bool {
	if m.UpsertComponentDefinitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertComponentDefinitionMock.invocationsDone()
}

// MinimockUpsertComponentDefinitionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertComponentDefinitionInspect() {
	for _, e := range m.UpsertComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertComponentDefinitionCounter := mm_atomic.LoadUint64(&m.afterUpsertComponentDefinitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertComponentDefinitionMock.defaultExpectation != nil && afterUpsertComponentDefinitionCounter < 1 {
		if m.UpsertComponentDefinitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s", m.UpsertComponentDefinitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s with params: %#v", m.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.origin, *m.UpsertComponentDefinitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertComponentDefinition != nil && afterUpsertComponentDefinitionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s", m.funcUpsertComponentDefinitionOrigin)
	}

	if !m.UpsertComponentDefinitionMock.invocationsDone() && afterUpsertComponentDefinitionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertComponentDefinition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertComponentDefinitionMock.expectedInvocations), m.UpsertComponentDefinitionMock.expectedInvocationsOrigin, afterUpsertComponentDefinitionCounter)
	}
}

type mRepositoryMockUpsertComponentRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertComponentRunExpectation
	expectations       []*RepositoryMockUpsertComponentRunExpectation

	callArgs []*RepositoryMockUpsertComponentRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertComponentRunExpectation specifies expectation struct of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertComponentRunParams
	paramPtrs          *RepositoryMockUpsertComponentRunParamPtrs
	expectationOrigins RepositoryMockUpsertComponentRunExpectationOrigins
	results            *RepositoryMockUpsertComponentRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertComponentRunParams contains parameters of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunParams struct {
	ctx          context.Context
	componentRun *datamodel.ComponentRun
}

// RepositoryMockUpsertComponentRunParamPtrs contains pointers to parameters of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunParamPtrs struct {
	ctx          *context.Context
	componentRun **datamodel.ComponentRun
}

// RepositoryMockUpsertComponentRunResults contains results of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunResults struct {
	err error
}

// RepositoryMockUpsertComponentRunOrigins contains origins of expectations of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunExpectationOrigins struct {
	origin             string
	originCtx          string
	originComponentRun string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Optional() *mRepositoryMockUpsertComponentRun {
	mmUpsertComponentRun.optional = true
	return mmUpsertComponentRun
}

// Expect sets up expected params for Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Expect(ctx context.Context, componentRun *datamodel.ComponentRun) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{}
	}

	if mmUpsertComponentRun.defaultExpectation.paramPtrs != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by ExpectParams functions")
	}

	mmUpsertComponentRun.defaultExpectation.params = &RepositoryMockUpsertComponentRunParams{ctx, componentRun}
	mmUpsertComponentRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertComponentRun.expectations {
		if minimock.Equal(e.params, mmUpsertComponentRun.defaultExpectation.params) {
			mmUpsertComponentRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertComponentRun.defaultExpectation.params)
		}
	}

	return mmUpsertComponentRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{}
	}

	if mmUpsertComponentRun.defaultExpectation.params != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Expect")
	}

	if mmUpsertComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentRunParamPtrs{}
	}
	mmUpsertComponentRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertComponentRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertComponentRun
}

// ExpectComponentRunParam2 sets up expected param componentRun for Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) ExpectComponentRunParam2(componentRun *datamodel.ComponentRun) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{}
	}

	if mmUpsertComponentRun.defaultExpectation.params != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Expect")
	}

	if mmUpsertComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentRunParamPtrs{}
	}
	mmUpsertComponentRun.defaultExpectation.paramPtrs.componentRun = &componentRun
	mmUpsertComponentRun.defaultExpectation.expectationOrigins.originComponentRun = minimock.CallerInfo(1)

	return mmUpsertComponentRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Inspect(f func(ctx context.Context, componentRun *datamodel.ComponentRun)) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.inspectFuncUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertComponentRun")
	}

	mmUpsertComponentRun.mock.inspectFuncUpsertComponentRun = f

	return mmUpsertComponentRun
}

// Return sets up results that will be returned by Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Return(err error) *RepositoryMock {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{mock: mmUpsertComponentRun.mock}
	}
	mmUpsertComponentRun.defaultExpectation.results = &RepositoryMockUpsertComponentRunResults{err}
	mmUpsertComponentRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentRun.mock
}

// Set uses given function f to mock the Repository.UpsertComponentRun method
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Set(f func(ctx context.Context, componentRun *datamodel.ComponentRun) (err error)) *RepositoryMock {
	if mmUpsertComponentRun.defaultExpectation != nil {
		mmUpsertComponentRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertComponentRun method")
	}

	if len(mmUpsertComponentRun.expectations) > 0 {
		mmUpsertComponentRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertComponentRun method")
	}

	mmUpsertComponentRun.mock.funcUpsertComponentRun = f
	mmUpsertComponentRun.mock.funcUpsertComponentRunOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentRun.mock
}

// When sets expectation for the Repository.UpsertComponentRun which will trigger the result defined by the following
// Then helper
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) When(ctx context.Context, componentRun *datamodel.ComponentRun) *RepositoryMockUpsertComponentRunExpectation {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertComponentRunExpectation{
		mock:               mmUpsertComponentRun.mock,
		params:             &RepositoryMockUpsertComponentRunParams{ctx, componentRun},
		expectationOrigins: RepositoryMockUpsertComponentRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertComponentRun.expectations = append(mmUpsertComponentRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertComponentRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertComponentRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertComponentRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpsertComponentRun should be invoked
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Times(n uint64) *mRepositoryMockUpsertComponentRun {
	if n == 0 {
		mmUpsertComponentRun.mock.t.Fatalf("Times of RepositoryMock.UpsertComponentRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertComponentRun.expectedInvocations, n)
	mmUpsertComponentRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentRun
}

func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) invocationsDone() bool {
	if len(mmUpsertComponentRun.expectations) == 0 && mmUpsertComponentRun.defaultExpectation == nil && mmUpsertComponentRun.mock.funcUpsertComponentRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertComponentRun.mock.afterUpsertComponentRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertComponentRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertComponentRun implements mm_repository.Repository
func (mmUpsertComponentRun *RepositoryMock) UpsertComponentRun(ctx context.Context, componentRun *datamodel.ComponentRun) (err error) {
	mm_atomic.AddUint64(&mmUpsertComponentRun.beforeUpsertComponentRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertComponentRun.afterUpsertComponentRunCounter, 1)

	mmUpsertComponentRun.t.Helper()

	if mmUpsertComponentRun.inspectFuncUpsertComponentRun != nil {
		mmUpsertComponentRun.inspectFuncUpsertComponentRun(ctx, componentRun)
	}

	mm_params := RepositoryMockUpsertComponentRunParams{ctx, componentRun}

	// Record call args
	mmUpsertComponentRun.UpsertComponentRunMock.mutex.Lock()
	mmUpsertComponentRun.UpsertComponentRunMock.callArgs = append(mmUpsertComponentRun.UpsertComponentRunMock.callArgs, &mm_params)
	mmUpsertComponentRun.UpsertComponentRunMock.mutex.Unlock()

	for _, e := range mmUpsertComponentRun.UpsertComponentRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertComponentRunParams{ctx, componentRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertComponentRun.t.Errorf("RepositoryMock.UpsertComponentRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.componentRun != nil && !minimock.Equal(*mm_want_ptrs.componentRun, mm_got.componentRun) {
				mmUpsertComponentRun.t.Errorf("RepositoryMock.UpsertComponentRun got unexpected parameter componentRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.expectationOrigins.originComponentRun, *mm_want_ptrs.componentRun, mm_got.componentRun, minimock.Diff(*mm_want_ptrs.componentRun, mm_got.componentRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertComponentRun.t.Errorf("RepositoryMock.UpsertComponentRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertComponentRun.t.Fatal("No results are set for the RepositoryMock.UpsertComponentRun")
		}
		return (*mm_results).err
	}
	if mmUpsertComponentRun.funcUpsertComponentRun != nil {
		return mmUpsertComponentRun.funcUpsertComponentRun(ctx, componentRun)
	}
	mmUpsertComponentRun.t.Fatalf("Unexpected call to RepositoryMock.UpsertComponentRun. %v %v", ctx, componentRun)
	return
}

// UpsertComponentRunAfterCounter returns a count of finished RepositoryMock.UpsertComponentRun invocations
func (mmUpsertComponentRun *RepositoryMock) UpsertComponentRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentRun.afterUpsertComponentRunCounter)
}

// UpsertComponentRunBeforeCounter returns a count of RepositoryMock.UpsertComponentRun invocations
func (mmUpsertComponentRun *RepositoryMock) UpsertComponentRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentRun.beforeUpsertComponentRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertComponentRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Calls() []*RepositoryMockUpsertComponentRunParams {
	mmUpsertComponentRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertComponentRunParams, len(mmUpsertComponentRun.callArgs))
	copy(argCopy, mmUpsertComponentRun.callArgs)

	mmUpsertComponentRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertComponentRunDone returns true if the count of the UpsertComponentRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertComponentRunDone() bool {
	if m.UpsertComponentRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertComponentRunMock.invocationsDone()
}

// MinimockUpsertComponentRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertComponentRunInspect() {
	for _, e := range m.UpsertComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertComponentRunCounter := mm_atomic.LoadUint64(&m.afterUpsertComponentRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertComponentRunMock.defaultExpectation != nil && afterUpsertComponentRunCounter < 1 {
		if m.UpsertComponentRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s", m.UpsertComponentRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s with params: %#v", m.UpsertComponentRunMock.defaultExpectation.expectationOrigins.origin, *m.UpsertComponentRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertComponentRun != nil && afterUpsertComponentRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s", m.funcUpsertComponentRunOrigin)
	}

	if !m.UpsertComponentRunMock.invocationsDone() && afterUpsertComponentRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertComponentRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertComponentRunMock.expectedInvocations), m.UpsertComponentRunMock.expectedInvocationsOrigin, afterUpsertComponentRunCounter)
	}
}

type mRepositoryMockUpsertPipelineRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertPipelineRunExpectation
	expectations       []*RepositoryMockUpsertPipelineRunExpectation

	callArgs []*RepositoryMockUpsertPipelineRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertPipelineRunExpectation specifies expectation struct of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertPipelineRunParams
	paramPtrs          *RepositoryMockUpsertPipelineRunParamPtrs
	expectationOrigins RepositoryMockUpsertPipelineRunExpectationOrigins
	results            *RepositoryMockUpsertPipelineRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertPipelineRunParams contains parameters of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunParams struct {
	ctx         context.Context
	pipelineRun *datamodel.PipelineRun
}

// RepositoryMockUpsertPipelineRunParamPtrs contains pointers to parameters of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunParamPtrs struct {
	ctx         *context.Context
	pipelineRun **datamodel.PipelineRun
}

// RepositoryMockUpsertPipelineRunResults contains results of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunResults struct {
	err error
}

// RepositoryMockUpsertPipelineRunOrigins contains origins of expectations of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineRun string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Optional() *mRepositoryMockUpsertPipelineRun {
	mmUpsertPipelineRun.optional = true
	return mmUpsertPipelineRun
}

// Expect sets up expected params for Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Expect(ctx context.Context, pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{}
	}

	if mmUpsertPipelineRun.defaultExpectation.paramPtrs != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by ExpectParams functions")
	}

	mmUpsertPipelineRun.defaultExpectation.params = &RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun}
	mmUpsertPipelineRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertPipelineRun.expectations {
		if minimock.Equal(e.params, mmUpsertPipelineRun.defaultExpectation.params) {
			mmUpsertPipelineRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertPipelineRun.defaultExpectation.params)
		}
	}

	return mmUpsertPipelineRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{}
	}

	if mmUpsertPipelineRun.defaultExpectation.params != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Expect")
	}

	if mmUpsertPipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpsertPipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertPipelineRunParamPtrs{}
	}
	mmUpsertPipelineRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertPipelineRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertPipelineRun
}

// ExpectPipelineRunParam2 sets up expected param pipelineRun for Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) ExpectPipelineRunParam2(pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{}
	}

	if mmUpsertPipelineRun.defaultExpectation.params != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Expect")
	}

	if mmUpsertPipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpsertPipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertPipelineRunParamPtrs{}
	}
	mmUpsertPipelineRun.defaultExpectation.paramPtrs.pipelineRun = &pipelineRun
	mmUpsertPipelineRun.defaultExpectation.expectationOrigins.originPipelineRun = minimock.CallerInfo(1)

	return mmUpsertPipelineRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Inspect(f func(ctx context.Context, pipelineRun *datamodel.PipelineRun)) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.inspectFuncUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertPipelineRun")
	}

	mmUpsertPipelineRun.mock.inspectFuncUpsertPipelineRun = f

	return mmUpsertPipelineRun
}

// Return sets up results that will be returned by Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Return(err error) *RepositoryMock {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{mock: mmUpsertPipelineRun.mock}
	}
	mmUpsertPipelineRun.defaultExpectation.results = &RepositoryMockUpsertPipelineRunResults{err}
	mmUpsertPipelineRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertPipelineRun.mock
}

// Set uses given function f to mock the Repository.UpsertPipelineRun method
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Set(f func(ctx context.Context, pipelineRun *datamodel.PipelineRun) (err error)) *RepositoryMock {
	if mmUpsertPipelineRun.defaultExpectation != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertPipelineRun method")
	}

	if len(mmUpsertPipelineRun.expectations) > 0 {
		mmUpsertPipelineRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertPipelineRun method")
	}

	mmUpsertPipelineRun.mock.funcUpsertPipelineRun = f
	mmUpsertPipelineRun.mock.funcUpsertPipelineRunOrigin = minimock.CallerInfo(1)
	return mmUpsertPipelineRun.mock
}

// When sets expectation for the Repository.UpsertPipelineRun which will trigger the result defined by the following
// Then helper
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) When(ctx context.Context, pipelineRun *datamodel.PipelineRun) *RepositoryMockUpsertPipelineRunExpectation {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertPipelineRunExpectation{
		mock:               mmUpsertPipelineRun.mock,
		params:             &RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun},
		expectationOrigins: RepositoryMockUpsertPipelineRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertPipelineRun.expectations = append(mmUpsertPipelineRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertPipelineRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertPipelineRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertPipelineRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpsertPipelineRun should be invoked
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Times(n uint64) *mRepositoryMockUpsertPipelineRun {
	if n == 0 {
		mmUpsertPipelineRun.mock.t.Fatalf("Times of RepositoryMock.UpsertPipelineRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertPipelineRun.expectedInvocations, n)
	mmUpsertPipelineRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertPipelineRun
}

func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) invocationsDone() bool {
	if len(mmUpsertPipelineRun.expectations) == 0 && mmUpsertPipelineRun.defaultExpectation == nil && mmUpsertPipelineRun.mock.funcUpsertPipelineRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertPipelineRun.mock.afterUpsertPipelineRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertPipelineRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertPipelineRun implements mm_repository.Repository
func (mmUpsertPipelineRun *RepositoryMock) UpsertPipelineRun(ctx context.Context, pipelineRun *datamodel.PipelineRun) (err error) {
	mm_atomic.AddUint64(&mmUpsertPipelineRun.beforeUpsertPipelineRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertPipelineRun.afterUpsertPipelineRunCounter, 1)

	mmUpsertPipelineRun.t.Helper()

	if mmUpsertPipelineRun.inspectFuncUpsertPipelineRun != nil {
		mmUpsertPipelineRun.inspectFuncUpsertPipelineRun(ctx, pipelineRun)
	}

	mm_params := RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun}

	// Record call args
	mmUpsertPipelineRun.UpsertPipelineRunMock.mutex.Lock()
	mmUpsertPipelineRun.UpsertPipelineRunMock.callArgs = append(mmUpsertPipelineRun.UpsertPipelineRunMock.callArgs, &mm_params)
	mmUpsertPipelineRun.UpsertPipelineRunMock.mutex.Unlock()

	for _, e := range mmUpsertPipelineRun.UpsertPipelineRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertPipelineRun.t.Errorf("RepositoryMock.UpsertPipelineRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineRun != nil && !minimock.Equal(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun) {
				mmUpsertPipelineRun.t.Errorf("RepositoryMock.UpsertPipelineRun got unexpected parameter pipelineRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.originPipelineRun, *mm_want_ptrs.pipelineRun, mm_got.pipelineRun, minimock.Diff(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertPipelineRun.t.Errorf("RepositoryMock.UpsertPipelineRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertPipelineRun.t.Fatal("No results are set for the RepositoryMock.UpsertPipelineRun")
		}
		return (*mm_results).err
	}
	if mmUpsertPipelineRun.funcUpsertPipelineRun != nil {
		return mmUpsertPipelineRun.funcUpsertPipelineRun(ctx, pipelineRun)
	}
	mmUpsertPipelineRun.t.Fatalf("Unexpected call to RepositoryMock.UpsertPipelineRun. %v %v", ctx, pipelineRun)
	return
}

// UpsertPipelineRunAfterCounter returns a count of finished RepositoryMock.UpsertPipelineRun invocations
func (mmUpsertPipelineRun *RepositoryMock) UpsertPipelineRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPipelineRun.afterUpsertPipelineRunCounter)
}

// UpsertPipelineRunBeforeCounter returns a count of RepositoryMock.UpsertPipelineRun invocations
func (mmUpsertPipelineRun *RepositoryMock) UpsertPipelineRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPipelineRun.beforeUpsertPipelineRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertPipelineRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Calls() []*RepositoryMockUpsertPipelineRunParams {
	mmUpsertPipelineRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertPipelineRunParams, len(mmUpsertPipelineRun.callArgs))
	copy(argCopy, mmUpsertPipelineRun.callArgs)

	mmUpsertPipelineRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertPipelineRunDone returns true if the count of the UpsertPipelineRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertPipelineRunDone() bool {
	if m.UpsertPipelineRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertPipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertPipelineRunMock.invocationsDone()
}

// MinimockUpsertPipelineRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertPipelineRunInspect() {
	for _, e := range m.UpsertPipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertPipelineRunCounter := mm_atomic.LoadUint64(&m.afterUpsertPipelineRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertPipelineRunMock.defaultExpectation != nil && afterUpsertPipelineRunCounter < 1 {
		if m.UpsertPipelineRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s", m.UpsertPipelineRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s with params: %#v", m.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.origin, *m.UpsertPipelineRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertPipelineRun != nil && afterUpsertPipelineRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s", m.funcUpsertPipelineRunOrigin)
	}

	if !m.UpsertPipelineRunMock.invocationsDone() && afterUpsertPipelineRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertPipelineRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertPipelineRunMock.expectedInvocations), m.UpsertPipelineRunMock.expectedInvocationsOrigin, afterUpsertPipelineRunCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddPipelineClonesInspect()

			m.MinimockAddPipelineRunsInspect()

			m.MinimockCheckPinnedUserInspect()

			m.MinimockCreateNamespaceConnectionInspect()

			m.MinimockCreateNamespaceSecretInspect()

			m.MinimockCreatePipelineInspect()

			m.MinimockCreatePipelineReleaseInspect()

			m.MinimockCreatePipelineRunOnInspect()

			m.MinimockCreatePipelineTagsInspect()

			m.MinimockDeleteComponentDefinitionInspect()

			m.MinimockDeleteNamespaceConnectionByIDInspect()

			m.MinimockDeleteNamespaceSecretByIDInspect()

			m.MinimockDeletePipelineByIDInspect()

			m.MinimockDeletePipelineReleaseByIDInspect()

			m.MinimockDeletePipelineRunOnInspect()

			m.MinimockDeletePipelineTagsInspect()

			m.MinimockGetConnectionByUIDInspect()

			m.MinimockGetDefinitionByUIDInspect()

			m.MinimockGetHubStatsInspect()

			m.MinimockGetLatestPipelineReleaseInspect()

			m.MinimockGetNamespaceConnectionByIDInspect()

			m.MinimockGetNamespaceSecretByIDInspect()

			m.MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsInspect()

			m.MinimockGetPaginatedPipelineRunsByRequesterInspect()

			m.MinimockGetPaginatedPipelineRunsWithPermissionsInspect()

			m.MinimockGetPipelineByIDInspect()

			m.MinimockGetPipelineByIDAdminInspect()

			m.MinimockGetPipelineByUIDInspect()

			m.MinimockGetPipelineReleaseByIDInspect()

			m.MinimockGetPipelineReleaseByUIDAdminInspect()

			m.MinimockGetPipelineRunByUIDInspect()

			m.MinimockListAllComponentDefinitionsInspect()

			m.MinimockListComponentDefinitionUIDsInspect()

			m.MinimockListIntegrationsInspect()

			m.MinimockListNamespaceConnectionsInspect()

			m.MinimockListNamespaceSecretsInspect()

			m.MinimockListPipelineIDsByConnectionIDInspect()

			m.MinimockListPipelineReleasesInspect()

			m.MinimockListPipelineRunOnsInspect()

			m.MinimockListPipelineRunOnsByIdentifierInspect()

			m.MinimockListPipelineTagsInspect()

			m.MinimockListPipelinesInspect()

			m.MinimockListPipelinesAdminInspect()

			m.MinimockListPublicPipelinesInspect()

			m.MinimockPinUserInspect()

			m.MinimockTranspileFilterInspect()

			m.MinimockUpdateComponentRunInspect()

			m.MinimockUpdateNamespaceConnectionByUIDInspect()

			m.MinimockUpdateNamespaceSecretByIDInspect()

			m.MinimockUpdatePipelineByUIDInspect()

			m.MinimockUpdatePipelineIDByIDInspect()

			m.MinimockUpdatePipelineReleaseByIDInspect()

			m.MinimockUpdatePipelineReleaseIDByIDInspect()

			m.MinimockUpdatePipelineRunInspect()

			m.MinimockUpsertComponentDefinitionInspect()

			m.MinimockUpsertComponentRunInspect()

			m.MinimockUpsertPipelineRunInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddPipelineClonesDone() &&
		m.MinimockAddPipelineRunsDone() &&
		m.MinimockCheckPinnedUserDone() &&
		m.MinimockCreateNamespaceConnectionDone() &&
		m.MinimockCreateNamespaceSecretDone() &&
		m.MinimockCreatePipelineDone() &&
		m.MinimockCreatePipelineReleaseDone() &&
		m.MinimockCreatePipelineRunOnDone() &&
		m.MinimockCreatePipelineTagsDone() &&
		m.MinimockDeleteComponentDefinitionDone() &&
		m.MinimockDeleteNamespaceConnectionByIDDone() &&
		m.MinimockDeleteNamespaceSecretByIDDone() &&
		m.MinimockDeletePipelineByIDDone() &&
		m.MinimockDeletePipelineReleaseByIDDone() &&
		m.MinimockDeletePipelineRunOnDone() &&
		m.MinimockDeletePipelineTagsDone() &&
		m.MinimockGetConnectionByUIDDone() &&
		m.MinimockGetDefinitionByUIDDone() &&
		m.MinimockGetHubStatsDone() &&
		m.MinimockGetLatestPipelineReleaseDone() &&
		m.MinimockGetNamespaceConnectionByIDDone() &&
		m.MinimockGetNamespaceSecretByIDDone() &&
		m.MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsDone() &&
		m.MinimockGetPaginatedPipelineRunsByRequesterDone() &&
		m.MinimockGetPaginatedPipelineRunsWithPermissionsDone() &&
		m.MinimockGetPipelineByIDDone() &&
		m.MinimockGetPipelineByIDAdminDone() &&
		m.MinimockGetPipelineByUIDDone() &&
		m.MinimockGetPipelineReleaseByIDDone() &&
		m.MinimockGetPipelineReleaseByUIDAdminDone() &&
		m.MinimockGetPipelineRunByUIDDone() &&
		m.MinimockListAllComponentDefinitionsDone() &&
		m.MinimockListComponentDefinitionUIDsDone() &&
		m.MinimockListIntegrationsDone() &&
		m.MinimockListNamespaceConnectionsDone() &&
		m.MinimockListNamespaceSecretsDone() &&
		m.MinimockListPipelineIDsByConnectionIDDone() &&
		m.MinimockListPipelineReleasesDone() &&
		m.MinimockListPipelineRunOnsDone() &&
		m.MinimockListPipelineRunOnsByIdentifierDone() &&
		m.MinimockListPipelineTagsDone() &&
		m.MinimockListPipelinesDone() &&
		m.MinimockListPipelinesAdminDone() &&
		m.MinimockListPublicPipelinesDone() &&
		m.MinimockPinUserDone() &&
		m.MinimockTranspileFilterDone() &&
		m.MinimockUpdateComponentRunDone() &&
		m.MinimockUpdateNamespaceConnectionByUIDDone() &&
		m.MinimockUpdateNamespaceSecretByIDDone() &&
		m.MinimockUpdatePipelineByUIDDone() &&
		m.MinimockUpdatePipelineIDByIDDone() &&
		m.MinimockUpdatePipelineReleaseByIDDone() &&
		m.MinimockUpdatePipelineReleaseIDByIDDone() &&
		m.MinimockUpdatePipelineRunDone() &&
		m.MinimockUpsertComponentDefinitionDone() &&
		m.MinimockUpsertComponentRunDone() &&
		m.MinimockUpsertPipelineRunDone()
}
