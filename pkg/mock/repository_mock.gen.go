// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"context"
	"sync"

	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"go.einride.tech/aip/filtering"
	"go.einride.tech/aip/ordering"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"github.com/instill-ai/pipeline-backend/pkg/datamodel"

	mm_repository "github.com/instill-ai/pipeline-backend/pkg/repository"
	pb "github.com/instill-ai/protogen-go/vdp/pipeline/v1beta"
)

// RepositoryMock implements mm_repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddPipelineClones          func(ctx context.Context, uid uuid.UUID) (err error)
	funcAddPipelineClonesOrigin    string
	inspectFuncAddPipelineClones   func(ctx context.Context, uid uuid.UUID)
	afterAddPipelineClonesCounter  uint64
	beforeAddPipelineClonesCounter uint64
	AddPipelineClonesMock          mRepositoryMockAddPipelineClones

	funcAddPipelineRuns          func(ctx context.Context, uid uuid.UUID) (err error)
	funcAddPipelineRunsOrigin    string
	inspectFuncAddPipelineRuns   func(ctx context.Context, uid uuid.UUID)
	afterAddPipelineRunsCounter  uint64
	beforeAddPipelineRunsCounter uint64
	AddPipelineRunsMock          mRepositoryMockAddPipelineRuns

	funcCheckPinnedUser          func(ctx context.Context, dp1 *gorm.DB, table string) (dp2 *gorm.DB)
	funcCheckPinnedUserOrigin    string
	inspectFuncCheckPinnedUser   func(ctx context.Context, dp1 *gorm.DB, table string)
	afterCheckPinnedUserCounter  uint64
	beforeCheckPinnedUserCounter uint64
	CheckPinnedUserMock          mRepositoryMockCheckPinnedUser

	funcCreateNamespaceConnection          func(ctx context.Context, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)
	funcCreateNamespaceConnectionOrigin    string
	inspectFuncCreateNamespaceConnection   func(ctx context.Context, cp1 *datamodel.Connection)
	afterCreateNamespaceConnectionCounter  uint64
	beforeCreateNamespaceConnectionCounter uint64
	CreateNamespaceConnectionMock          mRepositoryMockCreateNamespaceConnection

	funcCreateNamespacePipeline          func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)
	funcCreateNamespacePipelineOrigin    string
	inspectFuncCreateNamespacePipeline   func(ctx context.Context, pipeline *datamodel.Pipeline)
	afterCreateNamespacePipelineCounter  uint64
	beforeCreateNamespacePipelineCounter uint64
	CreateNamespacePipelineMock          mRepositoryMockCreateNamespacePipeline

	funcCreateNamespacePipelineRelease          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error)
	funcCreateNamespacePipelineReleaseOrigin    string
	inspectFuncCreateNamespacePipelineRelease   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease)
	afterCreateNamespacePipelineReleaseCounter  uint64
	beforeCreateNamespacePipelineReleaseCounter uint64
	CreateNamespacePipelineReleaseMock          mRepositoryMockCreateNamespacePipelineRelease

	funcCreateNamespaceSecret          func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error)
	funcCreateNamespaceSecretOrigin    string
	inspectFuncCreateNamespaceSecret   func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret)
	afterCreateNamespaceSecretCounter  uint64
	beforeCreateNamespaceSecretCounter uint64
	CreateNamespaceSecretMock          mRepositoryMockCreateNamespaceSecret

	funcCreatePipelineTags          func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)
	funcCreatePipelineTagsOrigin    string
	inspectFuncCreatePipelineTags   func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)
	afterCreatePipelineTagsCounter  uint64
	beforeCreatePipelineTagsCounter uint64
	CreatePipelineTagsMock          mRepositoryMockCreatePipelineTags

	funcDeleteNamespaceConnectionByID          func(ctx context.Context, nsUID uuid.UUID, id string) (err error)
	funcDeleteNamespaceConnectionByIDOrigin    string
	inspectFuncDeleteNamespaceConnectionByID   func(ctx context.Context, nsUID uuid.UUID, id string)
	afterDeleteNamespaceConnectionByIDCounter  uint64
	beforeDeleteNamespaceConnectionByIDCounter uint64
	DeleteNamespaceConnectionByIDMock          mRepositoryMockDeleteNamespaceConnectionByID

	funcDeleteNamespacePipelineByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	funcDeleteNamespacePipelineByIDOrigin    string
	inspectFuncDeleteNamespacePipelineByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeleteNamespacePipelineByIDCounter  uint64
	beforeDeleteNamespacePipelineByIDCounter uint64
	DeleteNamespacePipelineByIDMock          mRepositoryMockDeleteNamespacePipelineByID

	funcDeleteNamespacePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error)
	funcDeleteNamespacePipelineReleaseByIDOrigin    string
	inspectFuncDeleteNamespacePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string)
	afterDeleteNamespacePipelineReleaseByIDCounter  uint64
	beforeDeleteNamespacePipelineReleaseByIDCounter uint64
	DeleteNamespacePipelineReleaseByIDMock          mRepositoryMockDeleteNamespacePipelineReleaseByID

	funcDeleteNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	funcDeleteNamespaceSecretByIDOrigin    string
	inspectFuncDeleteNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeleteNamespaceSecretByIDCounter  uint64
	beforeDeleteNamespaceSecretByIDCounter uint64
	DeleteNamespaceSecretByIDMock          mRepositoryMockDeleteNamespaceSecretByID

	funcDeletePipelineTags          func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)
	funcDeletePipelineTagsOrigin    string
	inspectFuncDeletePipelineTags   func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)
	afterDeletePipelineTagsCounter  uint64
	beforeDeletePipelineTagsCounter uint64
	DeletePipelineTagsMock          mRepositoryMockDeletePipelineTags

	funcGetDefinitionByUID          func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error)
	funcGetDefinitionByUIDOrigin    string
	inspectFuncGetDefinitionByUID   func(ctx context.Context, u1 uuid.UUID)
	afterGetDefinitionByUIDCounter  uint64
	beforeGetDefinitionByUIDCounter uint64
	GetDefinitionByUIDMock          mRepositoryMockGetDefinitionByUID

	funcGetHubStats          func(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error)
	funcGetHubStatsOrigin    string
	inspectFuncGetHubStats   func(uidAllowList []uuid.UUID)
	afterGetHubStatsCounter  uint64
	beforeGetHubStatsCounter uint64
	GetHubStatsMock          mRepositoryMockGetHubStats

	funcGetLatestNamespacePipelineRelease          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	funcGetLatestNamespacePipelineReleaseOrigin    string
	inspectFuncGetLatestNamespacePipelineRelease   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool)
	afterGetLatestNamespacePipelineReleaseCounter  uint64
	beforeGetLatestNamespacePipelineReleaseCounter uint64
	GetLatestNamespacePipelineReleaseMock          mRepositoryMockGetLatestNamespacePipelineRelease

	funcGetNamespaceConnectionByID          func(ctx context.Context, nsUID uuid.UUID, id string) (cp1 *datamodel.Connection, err error)
	funcGetNamespaceConnectionByIDOrigin    string
	inspectFuncGetNamespaceConnectionByID   func(ctx context.Context, nsUID uuid.UUID, id string)
	afterGetNamespaceConnectionByIDCounter  uint64
	beforeGetNamespaceConnectionByIDCounter uint64
	GetNamespaceConnectionByIDMock          mRepositoryMockGetNamespaceConnectionByID

	funcGetNamespacePipelineByID          func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	funcGetNamespacePipelineByIDOrigin    string
	inspectFuncGetNamespacePipelineByID   func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool)
	afterGetNamespacePipelineByIDCounter  uint64
	beforeGetNamespacePipelineByIDCounter uint64
	GetNamespacePipelineByIDMock          mRepositoryMockGetNamespacePipelineByID

	funcGetNamespacePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	funcGetNamespacePipelineReleaseByIDOrigin    string
	inspectFuncGetNamespacePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool)
	afterGetNamespacePipelineReleaseByIDCounter  uint64
	beforeGetNamespacePipelineReleaseByIDCounter uint64
	GetNamespacePipelineReleaseByIDMock          mRepositoryMockGetNamespacePipelineReleaseByID

	funcGetNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error)
	funcGetNamespaceSecretByIDOrigin    string
	inspectFuncGetNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string)
	afterGetNamespaceSecretByIDCounter  uint64
	beforeGetNamespaceSecretByIDCounter uint64
	GetNamespaceSecretByIDMock          mRepositoryMockGetNamespaceSecretByID

	funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions          func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) (ca1 []datamodel.ComponentRun, i1 int64, err error)
	funcGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigin    string
	inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions   func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy)
	afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter  uint64
	beforeGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter uint64
	GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock          mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions

	funcGetPaginatedPipelineRunsByRequester          func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) (pa1 []datamodel.PipelineRun, i1 int64, err error)
	funcGetPaginatedPipelineRunsByRequesterOrigin    string
	inspectFuncGetPaginatedPipelineRunsByRequester   func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams)
	afterGetPaginatedPipelineRunsByRequesterCounter  uint64
	beforeGetPaginatedPipelineRunsByRequesterCounter uint64
	GetPaginatedPipelineRunsByRequesterMock          mRepositoryMockGetPaginatedPipelineRunsByRequester

	funcGetPaginatedPipelineRunsWithPermissions          func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) (pa1 []datamodel.PipelineRun, i1 int64, err error)
	funcGetPaginatedPipelineRunsWithPermissionsOrigin    string
	inspectFuncGetPaginatedPipelineRunsWithPermissions   func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool)
	afterGetPaginatedPipelineRunsWithPermissionsCounter  uint64
	beforeGetPaginatedPipelineRunsWithPermissionsCounter uint64
	GetPaginatedPipelineRunsWithPermissionsMock          mRepositoryMockGetPaginatedPipelineRunsWithPermissions

	funcGetPipelineByIDAdmin          func(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	funcGetPipelineByIDAdminOrigin    string
	inspectFuncGetPipelineByIDAdmin   func(ctx context.Context, id string, isBasicView bool, embedReleases bool)
	afterGetPipelineByIDAdminCounter  uint64
	beforeGetPipelineByIDAdminCounter uint64
	GetPipelineByIDAdminMock          mRepositoryMockGetPipelineByIDAdmin

	funcGetPipelineByUID          func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	funcGetPipelineByUIDOrigin    string
	inspectFuncGetPipelineByUID   func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)
	afterGetPipelineByUIDCounter  uint64
	beforeGetPipelineByUIDCounter uint64
	GetPipelineByUIDMock          mRepositoryMockGetPipelineByUID

	funcGetPipelineByUIDAdmin          func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	funcGetPipelineByUIDAdminOrigin    string
	inspectFuncGetPipelineByUIDAdmin   func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)
	afterGetPipelineByUIDAdminCounter  uint64
	beforeGetPipelineByUIDAdminCounter uint64
	GetPipelineByUIDAdminMock          mRepositoryMockGetPipelineByUIDAdmin

	funcGetPipelineReleaseByUIDAdmin          func(ctx context.Context, uid uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	funcGetPipelineReleaseByUIDAdminOrigin    string
	inspectFuncGetPipelineReleaseByUIDAdmin   func(ctx context.Context, uid uuid.UUID, isBasicView bool)
	afterGetPipelineReleaseByUIDAdminCounter  uint64
	beforeGetPipelineReleaseByUIDAdminCounter uint64
	GetPipelineReleaseByUIDAdminMock          mRepositoryMockGetPipelineReleaseByUIDAdmin

	funcGetPipelineRunByUID          func(ctx context.Context, u1 uuid.UUID) (pp1 *datamodel.PipelineRun, err error)
	funcGetPipelineRunByUIDOrigin    string
	inspectFuncGetPipelineRunByUID   func(ctx context.Context, u1 uuid.UUID)
	afterGetPipelineRunByUIDCounter  uint64
	beforeGetPipelineRunByUIDCounter uint64
	GetPipelineRunByUIDMock          mRepositoryMockGetPipelineRunByUID

	funcListComponentDefinitionUIDs          func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error)
	funcListComponentDefinitionUIDsOrigin    string
	inspectFuncListComponentDefinitionUIDs   func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams)
	afterListComponentDefinitionUIDsCounter  uint64
	beforeListComponentDefinitionUIDsCounter uint64
	ListComponentDefinitionUIDsMock          mRepositoryMockListComponentDefinitionUIDs

	funcListIntegrations          func(ctx context.Context, l1 mm_repository.ListIntegrationsParams) (i1 mm_repository.IntegrationList, err error)
	funcListIntegrationsOrigin    string
	inspectFuncListIntegrations   func(ctx context.Context, l1 mm_repository.ListIntegrationsParams)
	afterListIntegrationsCounter  uint64
	beforeListIntegrationsCounter uint64
	ListIntegrationsMock          mRepositoryMockListIntegrations

	funcListNamespaceConnections          func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) (c2 mm_repository.ConnectionList, err error)
	funcListNamespaceConnectionsOrigin    string
	inspectFuncListNamespaceConnections   func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams)
	afterListNamespaceConnectionsCounter  uint64
	beforeListNamespaceConnectionsCounter uint64
	ListNamespaceConnectionsMock          mRepositoryMockListNamespaceConnections

	funcListNamespacePipelineReleases          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error)
	funcListNamespacePipelineReleasesOrigin    string
	inspectFuncListNamespacePipelineReleases   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool)
	afterListNamespacePipelineReleasesCounter  uint64
	beforeListNamespacePipelineReleasesCounter uint64
	ListNamespacePipelineReleasesMock          mRepositoryMockListNamespacePipelineReleases

	funcListNamespacePipelines          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	funcListNamespacePipelinesOrigin    string
	inspectFuncListNamespacePipelines   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)
	afterListNamespacePipelinesCounter  uint64
	beforeListNamespacePipelinesCounter uint64
	ListNamespacePipelinesMock          mRepositoryMockListNamespacePipelines

	funcListNamespaceSecrets          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error)
	funcListNamespaceSecretsOrigin    string
	inspectFuncListNamespaceSecrets   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter)
	afterListNamespaceSecretsCounter  uint64
	beforeListNamespaceSecretsCounter uint64
	ListNamespaceSecretsMock          mRepositoryMockListNamespaceSecrets

	funcListPipelineIDsByConnectionID          func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) (p1 mm_repository.PipelinesByConnectionList, err error)
	funcListPipelineIDsByConnectionIDOrigin    string
	inspectFuncListPipelineIDsByConnectionID   func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams)
	afterListPipelineIDsByConnectionIDCounter  uint64
	beforeListPipelineIDsByConnectionIDCounter uint64
	ListPipelineIDsByConnectionIDMock          mRepositoryMockListPipelineIDsByConnectionID

	funcListPipelineTags          func(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error)
	funcListPipelineTagsOrigin    string
	inspectFuncListPipelineTags   func(ctx context.Context, pipelineUID uuid.UUID)
	afterListPipelineTagsCounter  uint64
	beforeListPipelineTagsCounter uint64
	ListPipelineTagsMock          mRepositoryMockListPipelineTags

	funcListPipelines          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	funcListPipelinesOrigin    string
	inspectFuncListPipelines   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID)
	afterListPipelinesCounter  uint64
	beforeListPipelinesCounter uint64
	ListPipelinesMock          mRepositoryMockListPipelines

	funcListPipelinesAdmin          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	funcListPipelinesAdminOrigin    string
	inspectFuncListPipelinesAdmin   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool)
	afterListPipelinesAdminCounter  uint64
	beforeListPipelinesAdminCounter uint64
	ListPipelinesAdminMock          mRepositoryMockListPipelinesAdmin

	funcPinUser          func(ctx context.Context, table string)
	funcPinUserOrigin    string
	inspectFuncPinUser   func(ctx context.Context, table string)
	afterPinUserCounter  uint64
	beforePinUserCounter uint64
	PinUserMock          mRepositoryMockPinUser

	funcTranspileFilter          func(f1 filtering.Filter) (ep1 *clause.Expr, err error)
	funcTranspileFilterOrigin    string
	inspectFuncTranspileFilter   func(f1 filtering.Filter)
	afterTranspileFilterCounter  uint64
	beforeTranspileFilterCounter uint64
	TranspileFilterMock          mRepositoryMockTranspileFilter

	funcUpdateComponentRun          func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) (err error)
	funcUpdateComponentRunOrigin    string
	inspectFuncUpdateComponentRun   func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun)
	afterUpdateComponentRunCounter  uint64
	beforeUpdateComponentRunCounter uint64
	UpdateComponentRunMock          mRepositoryMockUpdateComponentRun

	funcUpdateNamespaceConnectionByUID          func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)
	funcUpdateNamespaceConnectionByUIDOrigin    string
	inspectFuncUpdateNamespaceConnectionByUID   func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection)
	afterUpdateNamespaceConnectionByUIDCounter  uint64
	beforeUpdateNamespaceConnectionByUIDCounter uint64
	UpdateNamespaceConnectionByUIDMock          mRepositoryMockUpdateNamespaceConnectionByUID

	funcUpdateNamespacePipelineByUID          func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error)
	funcUpdateNamespacePipelineByUIDOrigin    string
	inspectFuncUpdateNamespacePipelineByUID   func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline)
	afterUpdateNamespacePipelineByUIDCounter  uint64
	beforeUpdateNamespacePipelineByUIDCounter uint64
	UpdateNamespacePipelineByUIDMock          mRepositoryMockUpdateNamespacePipelineByUID

	funcUpdateNamespacePipelineIDByID          func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)
	funcUpdateNamespacePipelineIDByIDOrigin    string
	inspectFuncUpdateNamespacePipelineIDByID   func(ctx context.Context, ownerPermalink string, id string, newID string)
	afterUpdateNamespacePipelineIDByIDCounter  uint64
	beforeUpdateNamespacePipelineIDByIDCounter uint64
	UpdateNamespacePipelineIDByIDMock          mRepositoryMockUpdateNamespacePipelineIDByID

	funcUpdateNamespacePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error)
	funcUpdateNamespacePipelineReleaseByIDOrigin    string
	inspectFuncUpdateNamespacePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease)
	afterUpdateNamespacePipelineReleaseByIDCounter  uint64
	beforeUpdateNamespacePipelineReleaseByIDCounter uint64
	UpdateNamespacePipelineReleaseByIDMock          mRepositoryMockUpdateNamespacePipelineReleaseByID

	funcUpdateNamespacePipelineReleaseIDByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error)
	funcUpdateNamespacePipelineReleaseIDByIDOrigin    string
	inspectFuncUpdateNamespacePipelineReleaseIDByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string)
	afterUpdateNamespacePipelineReleaseIDByIDCounter  uint64
	beforeUpdateNamespacePipelineReleaseIDByIDCounter uint64
	UpdateNamespacePipelineReleaseIDByIDMock          mRepositoryMockUpdateNamespacePipelineReleaseIDByID

	funcUpdateNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error)
	funcUpdateNamespaceSecretByIDOrigin    string
	inspectFuncUpdateNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret)
	afterUpdateNamespaceSecretByIDCounter  uint64
	beforeUpdateNamespaceSecretByIDCounter uint64
	UpdateNamespaceSecretByIDMock          mRepositoryMockUpdateNamespaceSecretByID

	funcUpdatePipelineRun          func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) (err error)
	funcUpdatePipelineRunOrigin    string
	inspectFuncUpdatePipelineRun   func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun)
	afterUpdatePipelineRunCounter  uint64
	beforeUpdatePipelineRunCounter uint64
	UpdatePipelineRunMock          mRepositoryMockUpdatePipelineRun

	funcUpsertComponentDefinition          func(ctx context.Context, cp1 *pb.ComponentDefinition) (err error)
	funcUpsertComponentDefinitionOrigin    string
	inspectFuncUpsertComponentDefinition   func(ctx context.Context, cp1 *pb.ComponentDefinition)
	afterUpsertComponentDefinitionCounter  uint64
	beforeUpsertComponentDefinitionCounter uint64
	UpsertComponentDefinitionMock          mRepositoryMockUpsertComponentDefinition

	funcUpsertComponentRun          func(ctx context.Context, componentRun *datamodel.ComponentRun) (err error)
	funcUpsertComponentRunOrigin    string
	inspectFuncUpsertComponentRun   func(ctx context.Context, componentRun *datamodel.ComponentRun)
	afterUpsertComponentRunCounter  uint64
	beforeUpsertComponentRunCounter uint64
	UpsertComponentRunMock          mRepositoryMockUpsertComponentRun

	funcUpsertPipelineRun          func(ctx context.Context, pipelineRun *datamodel.PipelineRun) (err error)
	funcUpsertPipelineRunOrigin    string
	inspectFuncUpsertPipelineRun   func(ctx context.Context, pipelineRun *datamodel.PipelineRun)
	afterUpsertPipelineRunCounter  uint64
	beforeUpsertPipelineRunCounter uint64
	UpsertPipelineRunMock          mRepositoryMockUpsertPipelineRun
}

// NewRepositoryMock returns a mock for mm_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddPipelineClonesMock = mRepositoryMockAddPipelineClones{mock: m}
	m.AddPipelineClonesMock.callArgs = []*RepositoryMockAddPipelineClonesParams{}

	m.AddPipelineRunsMock = mRepositoryMockAddPipelineRuns{mock: m}
	m.AddPipelineRunsMock.callArgs = []*RepositoryMockAddPipelineRunsParams{}

	m.CheckPinnedUserMock = mRepositoryMockCheckPinnedUser{mock: m}
	m.CheckPinnedUserMock.callArgs = []*RepositoryMockCheckPinnedUserParams{}

	m.CreateNamespaceConnectionMock = mRepositoryMockCreateNamespaceConnection{mock: m}
	m.CreateNamespaceConnectionMock.callArgs = []*RepositoryMockCreateNamespaceConnectionParams{}

	m.CreateNamespacePipelineMock = mRepositoryMockCreateNamespacePipeline{mock: m}
	m.CreateNamespacePipelineMock.callArgs = []*RepositoryMockCreateNamespacePipelineParams{}

	m.CreateNamespacePipelineReleaseMock = mRepositoryMockCreateNamespacePipelineRelease{mock: m}
	m.CreateNamespacePipelineReleaseMock.callArgs = []*RepositoryMockCreateNamespacePipelineReleaseParams{}

	m.CreateNamespaceSecretMock = mRepositoryMockCreateNamespaceSecret{mock: m}
	m.CreateNamespaceSecretMock.callArgs = []*RepositoryMockCreateNamespaceSecretParams{}

	m.CreatePipelineTagsMock = mRepositoryMockCreatePipelineTags{mock: m}
	m.CreatePipelineTagsMock.callArgs = []*RepositoryMockCreatePipelineTagsParams{}

	m.DeleteNamespaceConnectionByIDMock = mRepositoryMockDeleteNamespaceConnectionByID{mock: m}
	m.DeleteNamespaceConnectionByIDMock.callArgs = []*RepositoryMockDeleteNamespaceConnectionByIDParams{}

	m.DeleteNamespacePipelineByIDMock = mRepositoryMockDeleteNamespacePipelineByID{mock: m}
	m.DeleteNamespacePipelineByIDMock.callArgs = []*RepositoryMockDeleteNamespacePipelineByIDParams{}

	m.DeleteNamespacePipelineReleaseByIDMock = mRepositoryMockDeleteNamespacePipelineReleaseByID{mock: m}
	m.DeleteNamespacePipelineReleaseByIDMock.callArgs = []*RepositoryMockDeleteNamespacePipelineReleaseByIDParams{}

	m.DeleteNamespaceSecretByIDMock = mRepositoryMockDeleteNamespaceSecretByID{mock: m}
	m.DeleteNamespaceSecretByIDMock.callArgs = []*RepositoryMockDeleteNamespaceSecretByIDParams{}

	m.DeletePipelineTagsMock = mRepositoryMockDeletePipelineTags{mock: m}
	m.DeletePipelineTagsMock.callArgs = []*RepositoryMockDeletePipelineTagsParams{}

	m.GetDefinitionByUIDMock = mRepositoryMockGetDefinitionByUID{mock: m}
	m.GetDefinitionByUIDMock.callArgs = []*RepositoryMockGetDefinitionByUIDParams{}

	m.GetHubStatsMock = mRepositoryMockGetHubStats{mock: m}
	m.GetHubStatsMock.callArgs = []*RepositoryMockGetHubStatsParams{}

	m.GetLatestNamespacePipelineReleaseMock = mRepositoryMockGetLatestNamespacePipelineRelease{mock: m}
	m.GetLatestNamespacePipelineReleaseMock.callArgs = []*RepositoryMockGetLatestNamespacePipelineReleaseParams{}

	m.GetNamespaceConnectionByIDMock = mRepositoryMockGetNamespaceConnectionByID{mock: m}
	m.GetNamespaceConnectionByIDMock.callArgs = []*RepositoryMockGetNamespaceConnectionByIDParams{}

	m.GetNamespacePipelineByIDMock = mRepositoryMockGetNamespacePipelineByID{mock: m}
	m.GetNamespacePipelineByIDMock.callArgs = []*RepositoryMockGetNamespacePipelineByIDParams{}

	m.GetNamespacePipelineReleaseByIDMock = mRepositoryMockGetNamespacePipelineReleaseByID{mock: m}
	m.GetNamespacePipelineReleaseByIDMock.callArgs = []*RepositoryMockGetNamespacePipelineReleaseByIDParams{}

	m.GetNamespaceSecretByIDMock = mRepositoryMockGetNamespaceSecretByID{mock: m}
	m.GetNamespaceSecretByIDMock.callArgs = []*RepositoryMockGetNamespaceSecretByIDParams{}

	m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock = mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions{mock: m}
	m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.callArgs = []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{}

	m.GetPaginatedPipelineRunsByRequesterMock = mRepositoryMockGetPaginatedPipelineRunsByRequester{mock: m}
	m.GetPaginatedPipelineRunsByRequesterMock.callArgs = []*RepositoryMockGetPaginatedPipelineRunsByRequesterParams{}

	m.GetPaginatedPipelineRunsWithPermissionsMock = mRepositoryMockGetPaginatedPipelineRunsWithPermissions{mock: m}
	m.GetPaginatedPipelineRunsWithPermissionsMock.callArgs = []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{}

	m.GetPipelineByIDAdminMock = mRepositoryMockGetPipelineByIDAdmin{mock: m}
	m.GetPipelineByIDAdminMock.callArgs = []*RepositoryMockGetPipelineByIDAdminParams{}

	m.GetPipelineByUIDMock = mRepositoryMockGetPipelineByUID{mock: m}
	m.GetPipelineByUIDMock.callArgs = []*RepositoryMockGetPipelineByUIDParams{}

	m.GetPipelineByUIDAdminMock = mRepositoryMockGetPipelineByUIDAdmin{mock: m}
	m.GetPipelineByUIDAdminMock.callArgs = []*RepositoryMockGetPipelineByUIDAdminParams{}

	m.GetPipelineReleaseByUIDAdminMock = mRepositoryMockGetPipelineReleaseByUIDAdmin{mock: m}
	m.GetPipelineReleaseByUIDAdminMock.callArgs = []*RepositoryMockGetPipelineReleaseByUIDAdminParams{}

	m.GetPipelineRunByUIDMock = mRepositoryMockGetPipelineRunByUID{mock: m}
	m.GetPipelineRunByUIDMock.callArgs = []*RepositoryMockGetPipelineRunByUIDParams{}

	m.ListComponentDefinitionUIDsMock = mRepositoryMockListComponentDefinitionUIDs{mock: m}
	m.ListComponentDefinitionUIDsMock.callArgs = []*RepositoryMockListComponentDefinitionUIDsParams{}

	m.ListIntegrationsMock = mRepositoryMockListIntegrations{mock: m}
	m.ListIntegrationsMock.callArgs = []*RepositoryMockListIntegrationsParams{}

	m.ListNamespaceConnectionsMock = mRepositoryMockListNamespaceConnections{mock: m}
	m.ListNamespaceConnectionsMock.callArgs = []*RepositoryMockListNamespaceConnectionsParams{}

	m.ListNamespacePipelineReleasesMock = mRepositoryMockListNamespacePipelineReleases{mock: m}
	m.ListNamespacePipelineReleasesMock.callArgs = []*RepositoryMockListNamespacePipelineReleasesParams{}

	m.ListNamespacePipelinesMock = mRepositoryMockListNamespacePipelines{mock: m}
	m.ListNamespacePipelinesMock.callArgs = []*RepositoryMockListNamespacePipelinesParams{}

	m.ListNamespaceSecretsMock = mRepositoryMockListNamespaceSecrets{mock: m}
	m.ListNamespaceSecretsMock.callArgs = []*RepositoryMockListNamespaceSecretsParams{}

	m.ListPipelineIDsByConnectionIDMock = mRepositoryMockListPipelineIDsByConnectionID{mock: m}
	m.ListPipelineIDsByConnectionIDMock.callArgs = []*RepositoryMockListPipelineIDsByConnectionIDParams{}

	m.ListPipelineTagsMock = mRepositoryMockListPipelineTags{mock: m}
	m.ListPipelineTagsMock.callArgs = []*RepositoryMockListPipelineTagsParams{}

	m.ListPipelinesMock = mRepositoryMockListPipelines{mock: m}
	m.ListPipelinesMock.callArgs = []*RepositoryMockListPipelinesParams{}

	m.ListPipelinesAdminMock = mRepositoryMockListPipelinesAdmin{mock: m}
	m.ListPipelinesAdminMock.callArgs = []*RepositoryMockListPipelinesAdminParams{}

	m.PinUserMock = mRepositoryMockPinUser{mock: m}
	m.PinUserMock.callArgs = []*RepositoryMockPinUserParams{}

	m.TranspileFilterMock = mRepositoryMockTranspileFilter{mock: m}
	m.TranspileFilterMock.callArgs = []*RepositoryMockTranspileFilterParams{}

	m.UpdateComponentRunMock = mRepositoryMockUpdateComponentRun{mock: m}
	m.UpdateComponentRunMock.callArgs = []*RepositoryMockUpdateComponentRunParams{}

	m.UpdateNamespaceConnectionByUIDMock = mRepositoryMockUpdateNamespaceConnectionByUID{mock: m}
	m.UpdateNamespaceConnectionByUIDMock.callArgs = []*RepositoryMockUpdateNamespaceConnectionByUIDParams{}

	m.UpdateNamespacePipelineByUIDMock = mRepositoryMockUpdateNamespacePipelineByUID{mock: m}
	m.UpdateNamespacePipelineByUIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineByUIDParams{}

	m.UpdateNamespacePipelineIDByIDMock = mRepositoryMockUpdateNamespacePipelineIDByID{mock: m}
	m.UpdateNamespacePipelineIDByIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineIDByIDParams{}

	m.UpdateNamespacePipelineReleaseByIDMock = mRepositoryMockUpdateNamespacePipelineReleaseByID{mock: m}
	m.UpdateNamespacePipelineReleaseByIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineReleaseByIDParams{}

	m.UpdateNamespacePipelineReleaseIDByIDMock = mRepositoryMockUpdateNamespacePipelineReleaseIDByID{mock: m}
	m.UpdateNamespacePipelineReleaseIDByIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{}

	m.UpdateNamespaceSecretByIDMock = mRepositoryMockUpdateNamespaceSecretByID{mock: m}
	m.UpdateNamespaceSecretByIDMock.callArgs = []*RepositoryMockUpdateNamespaceSecretByIDParams{}

	m.UpdatePipelineRunMock = mRepositoryMockUpdatePipelineRun{mock: m}
	m.UpdatePipelineRunMock.callArgs = []*RepositoryMockUpdatePipelineRunParams{}

	m.UpsertComponentDefinitionMock = mRepositoryMockUpsertComponentDefinition{mock: m}
	m.UpsertComponentDefinitionMock.callArgs = []*RepositoryMockUpsertComponentDefinitionParams{}

	m.UpsertComponentRunMock = mRepositoryMockUpsertComponentRun{mock: m}
	m.UpsertComponentRunMock.callArgs = []*RepositoryMockUpsertComponentRunParams{}

	m.UpsertPipelineRunMock = mRepositoryMockUpsertPipelineRun{mock: m}
	m.UpsertPipelineRunMock.callArgs = []*RepositoryMockUpsertPipelineRunParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddPipelineClones struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddPipelineClonesExpectation
	expectations       []*RepositoryMockAddPipelineClonesExpectation

	callArgs []*RepositoryMockAddPipelineClonesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddPipelineClonesExpectation specifies expectation struct of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddPipelineClonesParams
	paramPtrs          *RepositoryMockAddPipelineClonesParamPtrs
	expectationOrigins RepositoryMockAddPipelineClonesExpectationOrigins
	results            *RepositoryMockAddPipelineClonesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddPipelineClonesParams contains parameters of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockAddPipelineClonesParamPtrs contains pointers to parameters of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryMockAddPipelineClonesResults contains results of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesResults struct {
	err error
}

// RepositoryMockAddPipelineClonesOrigins contains origins of expectations of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Optional() *mRepositoryMockAddPipelineClones {
	mmAddPipelineClones.optional = true
	return mmAddPipelineClones
}

// Expect sets up expected params for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by ExpectParams functions")
	}

	mmAddPipelineClones.defaultExpectation.params = &RepositoryMockAddPipelineClonesParams{ctx, uid}
	mmAddPipelineClones.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPipelineClones.expectations {
		if minimock.Equal(e.params, mmAddPipelineClones.defaultExpectation.params) {
			mmAddPipelineClones.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPipelineClones.defaultExpectation.params)
		}
	}

	return mmAddPipelineClones
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.params != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Expect")
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs == nil {
		mmAddPipelineClones.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineClonesParamPtrs{}
	}
	mmAddPipelineClones.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddPipelineClones.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddPipelineClones
}

// ExpectUidParam2 sets up expected param uid for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.params != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Expect")
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs == nil {
		mmAddPipelineClones.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineClonesParamPtrs{}
	}
	mmAddPipelineClones.defaultExpectation.paramPtrs.uid = &uid
	mmAddPipelineClones.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmAddPipelineClones
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.inspectFuncAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddPipelineClones")
	}

	mmAddPipelineClones.mock.inspectFuncAddPipelineClones = f

	return mmAddPipelineClones
}

// Return sets up results that will be returned by Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Return(err error) *RepositoryMock {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{mock: mmAddPipelineClones.mock}
	}
	mmAddPipelineClones.defaultExpectation.results = &RepositoryMockAddPipelineClonesResults{err}
	mmAddPipelineClones.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPipelineClones.mock
}

// Set uses given function f to mock the Repository.AddPipelineClones method
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmAddPipelineClones.defaultExpectation != nil {
		mmAddPipelineClones.mock.t.Fatalf("Default expectation is already set for the Repository.AddPipelineClones method")
	}

	if len(mmAddPipelineClones.expectations) > 0 {
		mmAddPipelineClones.mock.t.Fatalf("Some expectations are already set for the Repository.AddPipelineClones method")
	}

	mmAddPipelineClones.mock.funcAddPipelineClones = f
	mmAddPipelineClones.mock.funcAddPipelineClonesOrigin = minimock.CallerInfo(1)
	return mmAddPipelineClones.mock
}

// When sets expectation for the Repository.AddPipelineClones which will trigger the result defined by the following
// Then helper
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) When(ctx context.Context, uid uuid.UUID) *RepositoryMockAddPipelineClonesExpectation {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	expectation := &RepositoryMockAddPipelineClonesExpectation{
		mock:               mmAddPipelineClones.mock,
		params:             &RepositoryMockAddPipelineClonesParams{ctx, uid},
		expectationOrigins: RepositoryMockAddPipelineClonesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPipelineClones.expectations = append(mmAddPipelineClones.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddPipelineClones return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddPipelineClonesExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddPipelineClonesResults{err}
	return e.mock
}

// Times sets number of times Repository.AddPipelineClones should be invoked
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Times(n uint64) *mRepositoryMockAddPipelineClones {
	if n == 0 {
		mmAddPipelineClones.mock.t.Fatalf("Times of RepositoryMock.AddPipelineClones mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPipelineClones.expectedInvocations, n)
	mmAddPipelineClones.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPipelineClones
}

func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) invocationsDone() bool {
	if len(mmAddPipelineClones.expectations) == 0 && mmAddPipelineClones.defaultExpectation == nil && mmAddPipelineClones.mock.funcAddPipelineClones == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPipelineClones.mock.afterAddPipelineClonesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPipelineClones.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPipelineClones implements mm_repository.Repository
func (mmAddPipelineClones *RepositoryMock) AddPipelineClones(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmAddPipelineClones.beforeAddPipelineClonesCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPipelineClones.afterAddPipelineClonesCounter, 1)

	mmAddPipelineClones.t.Helper()

	if mmAddPipelineClones.inspectFuncAddPipelineClones != nil {
		mmAddPipelineClones.inspectFuncAddPipelineClones(ctx, uid)
	}

	mm_params := RepositoryMockAddPipelineClonesParams{ctx, uid}

	// Record call args
	mmAddPipelineClones.AddPipelineClonesMock.mutex.Lock()
	mmAddPipelineClones.AddPipelineClonesMock.callArgs = append(mmAddPipelineClones.AddPipelineClonesMock.callArgs, &mm_params)
	mmAddPipelineClones.AddPipelineClonesMock.mutex.Unlock()

	for _, e := range mmAddPipelineClones.AddPipelineClonesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.params
		mm_want_ptrs := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddPipelineClonesParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPipelineClones.t.Fatal("No results are set for the RepositoryMock.AddPipelineClones")
		}
		return (*mm_results).err
	}
	if mmAddPipelineClones.funcAddPipelineClones != nil {
		return mmAddPipelineClones.funcAddPipelineClones(ctx, uid)
	}
	mmAddPipelineClones.t.Fatalf("Unexpected call to RepositoryMock.AddPipelineClones. %v %v", ctx, uid)
	return
}

// AddPipelineClonesAfterCounter returns a count of finished RepositoryMock.AddPipelineClones invocations
func (mmAddPipelineClones *RepositoryMock) AddPipelineClonesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineClones.afterAddPipelineClonesCounter)
}

// AddPipelineClonesBeforeCounter returns a count of RepositoryMock.AddPipelineClones invocations
func (mmAddPipelineClones *RepositoryMock) AddPipelineClonesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineClones.beforeAddPipelineClonesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddPipelineClones.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Calls() []*RepositoryMockAddPipelineClonesParams {
	mmAddPipelineClones.mutex.RLock()

	argCopy := make([]*RepositoryMockAddPipelineClonesParams, len(mmAddPipelineClones.callArgs))
	copy(argCopy, mmAddPipelineClones.callArgs)

	mmAddPipelineClones.mutex.RUnlock()

	return argCopy
}

// MinimockAddPipelineClonesDone returns true if the count of the AddPipelineClones invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddPipelineClonesDone() bool {
	if m.AddPipelineClonesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPipelineClonesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPipelineClonesMock.invocationsDone()
}

// MinimockAddPipelineClonesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddPipelineClonesInspect() {
	for _, e := range m.AddPipelineClonesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPipelineClonesCounter := mm_atomic.LoadUint64(&m.afterAddPipelineClonesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPipelineClonesMock.defaultExpectation != nil && afterAddPipelineClonesCounter < 1 {
		if m.AddPipelineClonesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s", m.AddPipelineClonesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s with params: %#v", m.AddPipelineClonesMock.defaultExpectation.expectationOrigins.origin, *m.AddPipelineClonesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPipelineClones != nil && afterAddPipelineClonesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones at\n%s", m.funcAddPipelineClonesOrigin)
	}

	if !m.AddPipelineClonesMock.invocationsDone() && afterAddPipelineClonesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddPipelineClones at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPipelineClonesMock.expectedInvocations), m.AddPipelineClonesMock.expectedInvocationsOrigin, afterAddPipelineClonesCounter)
	}
}

type mRepositoryMockAddPipelineRuns struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddPipelineRunsExpectation
	expectations       []*RepositoryMockAddPipelineRunsExpectation

	callArgs []*RepositoryMockAddPipelineRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddPipelineRunsExpectation specifies expectation struct of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddPipelineRunsParams
	paramPtrs          *RepositoryMockAddPipelineRunsParamPtrs
	expectationOrigins RepositoryMockAddPipelineRunsExpectationOrigins
	results            *RepositoryMockAddPipelineRunsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddPipelineRunsParams contains parameters of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockAddPipelineRunsParamPtrs contains pointers to parameters of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryMockAddPipelineRunsResults contains results of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsResults struct {
	err error
}

// RepositoryMockAddPipelineRunsOrigins contains origins of expectations of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsExpectationOrigins struct {
	origin    string
	originCtx string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Optional() *mRepositoryMockAddPipelineRuns {
	mmAddPipelineRuns.optional = true
	return mmAddPipelineRuns
}

// Expect sets up expected params for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by ExpectParams functions")
	}

	mmAddPipelineRuns.defaultExpectation.params = &RepositoryMockAddPipelineRunsParams{ctx, uid}
	mmAddPipelineRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPipelineRuns.expectations {
		if minimock.Equal(e.params, mmAddPipelineRuns.defaultExpectation.params) {
			mmAddPipelineRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPipelineRuns.defaultExpectation.params)
		}
	}

	return mmAddPipelineRuns
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.params != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Expect")
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs == nil {
		mmAddPipelineRuns.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineRunsParamPtrs{}
	}
	mmAddPipelineRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddPipelineRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddPipelineRuns
}

// ExpectUidParam2 sets up expected param uid for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.params != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Expect")
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs == nil {
		mmAddPipelineRuns.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineRunsParamPtrs{}
	}
	mmAddPipelineRuns.defaultExpectation.paramPtrs.uid = &uid
	mmAddPipelineRuns.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmAddPipelineRuns
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.inspectFuncAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddPipelineRuns")
	}

	mmAddPipelineRuns.mock.inspectFuncAddPipelineRuns = f

	return mmAddPipelineRuns
}

// Return sets up results that will be returned by Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Return(err error) *RepositoryMock {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{mock: mmAddPipelineRuns.mock}
	}
	mmAddPipelineRuns.defaultExpectation.results = &RepositoryMockAddPipelineRunsResults{err}
	mmAddPipelineRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPipelineRuns.mock
}

// Set uses given function f to mock the Repository.AddPipelineRuns method
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmAddPipelineRuns.defaultExpectation != nil {
		mmAddPipelineRuns.mock.t.Fatalf("Default expectation is already set for the Repository.AddPipelineRuns method")
	}

	if len(mmAddPipelineRuns.expectations) > 0 {
		mmAddPipelineRuns.mock.t.Fatalf("Some expectations are already set for the Repository.AddPipelineRuns method")
	}

	mmAddPipelineRuns.mock.funcAddPipelineRuns = f
	mmAddPipelineRuns.mock.funcAddPipelineRunsOrigin = minimock.CallerInfo(1)
	return mmAddPipelineRuns.mock
}

// When sets expectation for the Repository.AddPipelineRuns which will trigger the result defined by the following
// Then helper
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) When(ctx context.Context, uid uuid.UUID) *RepositoryMockAddPipelineRunsExpectation {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	expectation := &RepositoryMockAddPipelineRunsExpectation{
		mock:               mmAddPipelineRuns.mock,
		params:             &RepositoryMockAddPipelineRunsParams{ctx, uid},
		expectationOrigins: RepositoryMockAddPipelineRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPipelineRuns.expectations = append(mmAddPipelineRuns.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddPipelineRuns return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddPipelineRunsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddPipelineRunsResults{err}
	return e.mock
}

// Times sets number of times Repository.AddPipelineRuns should be invoked
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Times(n uint64) *mRepositoryMockAddPipelineRuns {
	if n == 0 {
		mmAddPipelineRuns.mock.t.Fatalf("Times of RepositoryMock.AddPipelineRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPipelineRuns.expectedInvocations, n)
	mmAddPipelineRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPipelineRuns
}

func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) invocationsDone() bool {
	if len(mmAddPipelineRuns.expectations) == 0 && mmAddPipelineRuns.defaultExpectation == nil && mmAddPipelineRuns.mock.funcAddPipelineRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPipelineRuns.mock.afterAddPipelineRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPipelineRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPipelineRuns implements mm_repository.Repository
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRuns(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmAddPipelineRuns.beforeAddPipelineRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPipelineRuns.afterAddPipelineRunsCounter, 1)

	mmAddPipelineRuns.t.Helper()

	if mmAddPipelineRuns.inspectFuncAddPipelineRuns != nil {
		mmAddPipelineRuns.inspectFuncAddPipelineRuns(ctx, uid)
	}

	mm_params := RepositoryMockAddPipelineRunsParams{ctx, uid}

	// Record call args
	mmAddPipelineRuns.AddPipelineRunsMock.mutex.Lock()
	mmAddPipelineRuns.AddPipelineRunsMock.callArgs = append(mmAddPipelineRuns.AddPipelineRunsMock.callArgs, &mm_params)
	mmAddPipelineRuns.AddPipelineRunsMock.mutex.Unlock()

	for _, e := range mmAddPipelineRuns.AddPipelineRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.params
		mm_want_ptrs := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddPipelineRunsParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPipelineRuns.t.Fatal("No results are set for the RepositoryMock.AddPipelineRuns")
		}
		return (*mm_results).err
	}
	if mmAddPipelineRuns.funcAddPipelineRuns != nil {
		return mmAddPipelineRuns.funcAddPipelineRuns(ctx, uid)
	}
	mmAddPipelineRuns.t.Fatalf("Unexpected call to RepositoryMock.AddPipelineRuns. %v %v", ctx, uid)
	return
}

// AddPipelineRunsAfterCounter returns a count of finished RepositoryMock.AddPipelineRuns invocations
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineRuns.afterAddPipelineRunsCounter)
}

// AddPipelineRunsBeforeCounter returns a count of RepositoryMock.AddPipelineRuns invocations
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineRuns.beforeAddPipelineRunsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddPipelineRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Calls() []*RepositoryMockAddPipelineRunsParams {
	mmAddPipelineRuns.mutex.RLock()

	argCopy := make([]*RepositoryMockAddPipelineRunsParams, len(mmAddPipelineRuns.callArgs))
	copy(argCopy, mmAddPipelineRuns.callArgs)

	mmAddPipelineRuns.mutex.RUnlock()

	return argCopy
}

// MinimockAddPipelineRunsDone returns true if the count of the AddPipelineRuns invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddPipelineRunsDone() bool {
	if m.AddPipelineRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPipelineRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPipelineRunsMock.invocationsDone()
}

// MinimockAddPipelineRunsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddPipelineRunsInspect() {
	for _, e := range m.AddPipelineRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPipelineRunsCounter := mm_atomic.LoadUint64(&m.afterAddPipelineRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPipelineRunsMock.defaultExpectation != nil && afterAddPipelineRunsCounter < 1 {
		if m.AddPipelineRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s", m.AddPipelineRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s with params: %#v", m.AddPipelineRunsMock.defaultExpectation.expectationOrigins.origin, *m.AddPipelineRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPipelineRuns != nil && afterAddPipelineRunsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns at\n%s", m.funcAddPipelineRunsOrigin)
	}

	if !m.AddPipelineRunsMock.invocationsDone() && afterAddPipelineRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddPipelineRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPipelineRunsMock.expectedInvocations), m.AddPipelineRunsMock.expectedInvocationsOrigin, afterAddPipelineRunsCounter)
	}
}

type mRepositoryMockCheckPinnedUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckPinnedUserExpectation
	expectations       []*RepositoryMockCheckPinnedUserExpectation

	callArgs []*RepositoryMockCheckPinnedUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCheckPinnedUserExpectation specifies expectation struct of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCheckPinnedUserParams
	paramPtrs          *RepositoryMockCheckPinnedUserParamPtrs
	expectationOrigins RepositoryMockCheckPinnedUserExpectationOrigins
	results            *RepositoryMockCheckPinnedUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCheckPinnedUserParams contains parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParams struct {
	ctx   context.Context
	dp1   *gorm.DB
	table string
}

// RepositoryMockCheckPinnedUserParamPtrs contains pointers to parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParamPtrs struct {
	ctx   *context.Context
	dp1   **gorm.DB
	table *string
}

// RepositoryMockCheckPinnedUserResults contains results of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserResults struct {
	dp2 *gorm.DB
}

// RepositoryMockCheckPinnedUserOrigins contains origins of expectations of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originDp1   string
	originTable string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Optional() *mRepositoryMockCheckPinnedUser {
	mmCheckPinnedUser.optional = true
	return mmCheckPinnedUser
}

// Expect sets up expected params for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Expect(ctx context.Context, dp1 *gorm.DB, table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by ExpectParams functions")
	}

	mmCheckPinnedUser.defaultExpectation.params = &RepositoryMockCheckPinnedUserParams{ctx, dp1, table}
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPinnedUser.expectations {
		if minimock.Equal(e.params, mmCheckPinnedUser.defaultExpectation.params) {
			mmCheckPinnedUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPinnedUser.defaultExpectation.params)
		}
	}

	return mmCheckPinnedUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// ExpectDp1Param2 sets up expected param dp1 for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectDp1Param2(dp1 *gorm.DB) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.dp1 = &dp1
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originDp1 = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// ExpectTableParam3 sets up expected param table for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectTableParam3(table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.table = &table
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originTable = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Inspect(f func(ctx context.Context, dp1 *gorm.DB, table string)) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckPinnedUser")
	}

	mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser = f

	return mmCheckPinnedUser
}

// Return sets up results that will be returned by Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Return(dp2 *gorm.DB) *RepositoryMock {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{mock: mmCheckPinnedUser.mock}
	}
	mmCheckPinnedUser.defaultExpectation.results = &RepositoryMockCheckPinnedUserResults{dp2}
	mmCheckPinnedUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser.mock
}

// Set uses given function f to mock the Repository.CheckPinnedUser method
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Set(f func(ctx context.Context, dp1 *gorm.DB, table string) (dp2 *gorm.DB)) *RepositoryMock {
	if mmCheckPinnedUser.defaultExpectation != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Default expectation is already set for the Repository.CheckPinnedUser method")
	}

	if len(mmCheckPinnedUser.expectations) > 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Some expectations are already set for the Repository.CheckPinnedUser method")
	}

	mmCheckPinnedUser.mock.funcCheckPinnedUser = f
	mmCheckPinnedUser.mock.funcCheckPinnedUserOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser.mock
}

// When sets expectation for the Repository.CheckPinnedUser which will trigger the result defined by the following
// Then helper
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) When(ctx context.Context, dp1 *gorm.DB, table string) *RepositoryMockCheckPinnedUserExpectation {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	expectation := &RepositoryMockCheckPinnedUserExpectation{
		mock:               mmCheckPinnedUser.mock,
		params:             &RepositoryMockCheckPinnedUserParams{ctx, dp1, table},
		expectationOrigins: RepositoryMockCheckPinnedUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPinnedUser.expectations = append(mmCheckPinnedUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckPinnedUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckPinnedUserExpectation) Then(dp2 *gorm.DB) *RepositoryMock {
	e.results = &RepositoryMockCheckPinnedUserResults{dp2}
	return e.mock
}

// Times sets number of times Repository.CheckPinnedUser should be invoked
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Times(n uint64) *mRepositoryMockCheckPinnedUser {
	if n == 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Times of RepositoryMock.CheckPinnedUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPinnedUser.expectedInvocations, n)
	mmCheckPinnedUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser
}

func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) invocationsDone() bool {
	if len(mmCheckPinnedUser.expectations) == 0 && mmCheckPinnedUser.defaultExpectation == nil && mmCheckPinnedUser.mock.funcCheckPinnedUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.mock.afterCheckPinnedUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPinnedUser implements mm_repository.Repository
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUser(ctx context.Context, dp1 *gorm.DB, table string) (dp2 *gorm.DB) {
	mm_atomic.AddUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter, 1)

	mmCheckPinnedUser.t.Helper()

	if mmCheckPinnedUser.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.inspectFuncCheckPinnedUser(ctx, dp1, table)
	}

	mm_params := RepositoryMockCheckPinnedUserParams{ctx, dp1, table}

	// Record call args
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Lock()
	mmCheckPinnedUser.CheckPinnedUserMock.callArgs = append(mmCheckPinnedUser.CheckPinnedUserMock.callArgs, &mm_params)
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Unlock()

	for _, e := range mmCheckPinnedUser.CheckPinnedUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp2
		}
	}

	if mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCheckPinnedUserParams{ctx, dp1, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dp1 != nil && !minimock.Equal(*mm_want_ptrs.dp1, mm_got.dp1) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter dp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originDp1, *mm_want_ptrs.dp1, mm_got.dp1, minimock.Diff(*mm_want_ptrs.dp1, mm_got.dp1))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter table, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originTable, *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPinnedUser.t.Fatal("No results are set for the RepositoryMock.CheckPinnedUser")
		}
		return (*mm_results).dp2
	}
	if mmCheckPinnedUser.funcCheckPinnedUser != nil {
		return mmCheckPinnedUser.funcCheckPinnedUser(ctx, dp1, table)
	}
	mmCheckPinnedUser.t.Fatalf("Unexpected call to RepositoryMock.CheckPinnedUser. %v %v %v", ctx, dp1, table)
	return
}

// CheckPinnedUserAfterCounter returns a count of finished RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter)
}

// CheckPinnedUserBeforeCounter returns a count of RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckPinnedUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Calls() []*RepositoryMockCheckPinnedUserParams {
	mmCheckPinnedUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckPinnedUserParams, len(mmCheckPinnedUser.callArgs))
	copy(argCopy, mmCheckPinnedUser.callArgs)

	mmCheckPinnedUser.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPinnedUserDone returns true if the count of the CheckPinnedUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckPinnedUserDone() bool {
	if m.CheckPinnedUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPinnedUserMock.invocationsDone()
}

// MinimockCheckPinnedUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckPinnedUserInspect() {
	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPinnedUserCounter := mm_atomic.LoadUint64(&m.afterCheckPinnedUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPinnedUserMock.defaultExpectation != nil && afterCheckPinnedUserCounter < 1 {
		if m.CheckPinnedUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s", m.CheckPinnedUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s with params: %#v", m.CheckPinnedUserMock.defaultExpectation.expectationOrigins.origin, *m.CheckPinnedUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPinnedUser != nil && afterCheckPinnedUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s", m.funcCheckPinnedUserOrigin)
	}

	if !m.CheckPinnedUserMock.invocationsDone() && afterCheckPinnedUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CheckPinnedUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPinnedUserMock.expectedInvocations), m.CheckPinnedUserMock.expectedInvocationsOrigin, afterCheckPinnedUserCounter)
	}
}

type mRepositoryMockCreateNamespaceConnection struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespaceConnectionExpectation
	expectations       []*RepositoryMockCreateNamespaceConnectionExpectation

	callArgs []*RepositoryMockCreateNamespaceConnectionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateNamespaceConnectionExpectation specifies expectation struct of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateNamespaceConnectionParams
	paramPtrs          *RepositoryMockCreateNamespaceConnectionParamPtrs
	expectationOrigins RepositoryMockCreateNamespaceConnectionExpectationOrigins
	results            *RepositoryMockCreateNamespaceConnectionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateNamespaceConnectionParams contains parameters of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionParams struct {
	ctx context.Context
	cp1 *datamodel.Connection
}

// RepositoryMockCreateNamespaceConnectionParamPtrs contains pointers to parameters of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionParamPtrs struct {
	ctx *context.Context
	cp1 **datamodel.Connection
}

// RepositoryMockCreateNamespaceConnectionResults contains results of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionResults struct {
	cp2 *datamodel.Connection
	err error
}

// RepositoryMockCreateNamespaceConnectionOrigins contains origins of expectations of the Repository.CreateNamespaceConnection
type RepositoryMockCreateNamespaceConnectionExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Optional() *mRepositoryMockCreateNamespaceConnection {
	mmCreateNamespaceConnection.optional = true
	return mmCreateNamespaceConnection
}

// Expect sets up expected params for Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Expect(ctx context.Context, cp1 *datamodel.Connection) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{}
	}

	if mmCreateNamespaceConnection.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceConnection.defaultExpectation.params = &RepositoryMockCreateNamespaceConnectionParams{ctx, cp1}
	mmCreateNamespaceConnection.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespaceConnection.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceConnection.defaultExpectation.params) {
			mmCreateNamespaceConnection.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceConnection.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceConnection
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{}
	}

	if mmCreateNamespaceConnection.defaultExpectation.params != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Expect")
	}

	if mmCreateNamespaceConnection.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceConnection.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceConnectionParamPtrs{}
	}
	mmCreateNamespaceConnection.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespaceConnection.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespaceConnection
}

// ExpectCp1Param2 sets up expected param cp1 for Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) ExpectCp1Param2(cp1 *datamodel.Connection) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{}
	}

	if mmCreateNamespaceConnection.defaultExpectation.params != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Expect")
	}

	if mmCreateNamespaceConnection.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceConnection.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceConnectionParamPtrs{}
	}
	mmCreateNamespaceConnection.defaultExpectation.paramPtrs.cp1 = &cp1
	mmCreateNamespaceConnection.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmCreateNamespaceConnection
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Inspect(f func(ctx context.Context, cp1 *datamodel.Connection)) *mRepositoryMockCreateNamespaceConnection {
	if mmCreateNamespaceConnection.mock.inspectFuncCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespaceConnection")
	}

	mmCreateNamespaceConnection.mock.inspectFuncCreateNamespaceConnection = f

	return mmCreateNamespaceConnection
}

// Return sets up results that will be returned by Repository.CreateNamespaceConnection
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Return(cp2 *datamodel.Connection, err error) *RepositoryMock {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	if mmCreateNamespaceConnection.defaultExpectation == nil {
		mmCreateNamespaceConnection.defaultExpectation = &RepositoryMockCreateNamespaceConnectionExpectation{mock: mmCreateNamespaceConnection.mock}
	}
	mmCreateNamespaceConnection.defaultExpectation.results = &RepositoryMockCreateNamespaceConnectionResults{cp2, err}
	mmCreateNamespaceConnection.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceConnection.mock
}

// Set uses given function f to mock the Repository.CreateNamespaceConnection method
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Set(f func(ctx context.Context, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)) *RepositoryMock {
	if mmCreateNamespaceConnection.defaultExpectation != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespaceConnection method")
	}

	if len(mmCreateNamespaceConnection.expectations) > 0 {
		mmCreateNamespaceConnection.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespaceConnection method")
	}

	mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection = f
	mmCreateNamespaceConnection.mock.funcCreateNamespaceConnectionOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceConnection.mock
}

// When sets expectation for the Repository.CreateNamespaceConnection which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) When(ctx context.Context, cp1 *datamodel.Connection) *RepositoryMockCreateNamespaceConnectionExpectation {
	if mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.mock.t.Fatalf("RepositoryMock.CreateNamespaceConnection mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespaceConnectionExpectation{
		mock:               mmCreateNamespaceConnection.mock,
		params:             &RepositoryMockCreateNamespaceConnectionParams{ctx, cp1},
		expectationOrigins: RepositoryMockCreateNamespaceConnectionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespaceConnection.expectations = append(mmCreateNamespaceConnection.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespaceConnection return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespaceConnectionExpectation) Then(cp2 *datamodel.Connection, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespaceConnectionResults{cp2, err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespaceConnection should be invoked
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Times(n uint64) *mRepositoryMockCreateNamespaceConnection {
	if n == 0 {
		mmCreateNamespaceConnection.mock.t.Fatalf("Times of RepositoryMock.CreateNamespaceConnection mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceConnection.expectedInvocations, n)
	mmCreateNamespaceConnection.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceConnection
}

func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) invocationsDone() bool {
	if len(mmCreateNamespaceConnection.expectations) == 0 && mmCreateNamespaceConnection.defaultExpectation == nil && mmCreateNamespaceConnection.mock.funcCreateNamespaceConnection == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceConnection.mock.afterCreateNamespaceConnectionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceConnection.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceConnection implements mm_repository.Repository
func (mmCreateNamespaceConnection *RepositoryMock) CreateNamespaceConnection(ctx context.Context, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceConnection.beforeCreateNamespaceConnectionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceConnection.afterCreateNamespaceConnectionCounter, 1)

	mmCreateNamespaceConnection.t.Helper()

	if mmCreateNamespaceConnection.inspectFuncCreateNamespaceConnection != nil {
		mmCreateNamespaceConnection.inspectFuncCreateNamespaceConnection(ctx, cp1)
	}

	mm_params := RepositoryMockCreateNamespaceConnectionParams{ctx, cp1}

	// Record call args
	mmCreateNamespaceConnection.CreateNamespaceConnectionMock.mutex.Lock()
	mmCreateNamespaceConnection.CreateNamespaceConnectionMock.callArgs = append(mmCreateNamespaceConnection.CreateNamespaceConnectionMock.callArgs, &mm_params)
	mmCreateNamespaceConnection.CreateNamespaceConnectionMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceConnection.CreateNamespaceConnectionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespaceConnectionParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceConnection.t.Errorf("RepositoryMock.CreateNamespaceConnection got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmCreateNamespaceConnection.t.Errorf("RepositoryMock.CreateNamespaceConnection got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceConnection.t.Errorf("RepositoryMock.CreateNamespaceConnection got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceConnection.CreateNamespaceConnectionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceConnection.t.Fatal("No results are set for the RepositoryMock.CreateNamespaceConnection")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmCreateNamespaceConnection.funcCreateNamespaceConnection != nil {
		return mmCreateNamespaceConnection.funcCreateNamespaceConnection(ctx, cp1)
	}
	mmCreateNamespaceConnection.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespaceConnection. %v %v", ctx, cp1)
	return
}

// CreateNamespaceConnectionAfterCounter returns a count of finished RepositoryMock.CreateNamespaceConnection invocations
func (mmCreateNamespaceConnection *RepositoryMock) CreateNamespaceConnectionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceConnection.afterCreateNamespaceConnectionCounter)
}

// CreateNamespaceConnectionBeforeCounter returns a count of RepositoryMock.CreateNamespaceConnection invocations
func (mmCreateNamespaceConnection *RepositoryMock) CreateNamespaceConnectionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceConnection.beforeCreateNamespaceConnectionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespaceConnection.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceConnection *mRepositoryMockCreateNamespaceConnection) Calls() []*RepositoryMockCreateNamespaceConnectionParams {
	mmCreateNamespaceConnection.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespaceConnectionParams, len(mmCreateNamespaceConnection.callArgs))
	copy(argCopy, mmCreateNamespaceConnection.callArgs)

	mmCreateNamespaceConnection.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceConnectionDone returns true if the count of the CreateNamespaceConnection invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespaceConnectionDone() bool {
	if m.CreateNamespaceConnectionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceConnectionMock.invocationsDone()
}

// MinimockCreateNamespaceConnectionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespaceConnectionInspect() {
	for _, e := range m.CreateNamespaceConnectionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespaceConnectionCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceConnectionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceConnectionMock.defaultExpectation != nil && afterCreateNamespaceConnectionCounter < 1 {
		if m.CreateNamespaceConnectionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s", m.CreateNamespaceConnectionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s with params: %#v", m.CreateNamespaceConnectionMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespaceConnectionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceConnection != nil && afterCreateNamespaceConnectionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceConnection at\n%s", m.funcCreateNamespaceConnectionOrigin)
	}

	if !m.CreateNamespaceConnectionMock.invocationsDone() && afterCreateNamespaceConnectionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespaceConnection at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceConnectionMock.expectedInvocations), m.CreateNamespaceConnectionMock.expectedInvocationsOrigin, afterCreateNamespaceConnectionCounter)
	}
}

type mRepositoryMockCreateNamespacePipeline struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespacePipelineExpectation
	expectations       []*RepositoryMockCreateNamespacePipelineExpectation

	callArgs []*RepositoryMockCreateNamespacePipelineParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateNamespacePipelineExpectation specifies expectation struct of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateNamespacePipelineParams
	paramPtrs          *RepositoryMockCreateNamespacePipelineParamPtrs
	expectationOrigins RepositoryMockCreateNamespacePipelineExpectationOrigins
	results            *RepositoryMockCreateNamespacePipelineResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateNamespacePipelineParams contains parameters of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineParams struct {
	ctx      context.Context
	pipeline *datamodel.Pipeline
}

// RepositoryMockCreateNamespacePipelineParamPtrs contains pointers to parameters of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineParamPtrs struct {
	ctx      *context.Context
	pipeline **datamodel.Pipeline
}

// RepositoryMockCreateNamespacePipelineResults contains results of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineResults struct {
	err error
}

// RepositoryMockCreateNamespacePipelineOrigins contains origins of expectations of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineExpectationOrigins struct {
	origin         string
	originCtx      string
	originPipeline string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Optional() *mRepositoryMockCreateNamespacePipeline {
	mmCreateNamespacePipeline.optional = true
	return mmCreateNamespacePipeline
}

// Expect sets up expected params for Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Expect(ctx context.Context, pipeline *datamodel.Pipeline) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{}
	}

	if mmCreateNamespacePipeline.defaultExpectation.paramPtrs != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by ExpectParams functions")
	}

	mmCreateNamespacePipeline.defaultExpectation.params = &RepositoryMockCreateNamespacePipelineParams{ctx, pipeline}
	mmCreateNamespacePipeline.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespacePipeline.expectations {
		if minimock.Equal(e.params, mmCreateNamespacePipeline.defaultExpectation.params) {
			mmCreateNamespacePipeline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespacePipeline.defaultExpectation.params)
		}
	}

	return mmCreateNamespacePipeline
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{}
	}

	if mmCreateNamespacePipeline.defaultExpectation.params != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Expect")
	}

	if mmCreateNamespacePipeline.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipeline.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineParamPtrs{}
	}
	mmCreateNamespacePipeline.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespacePipeline.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespacePipeline
}

// ExpectPipelineParam2 sets up expected param pipeline for Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) ExpectPipelineParam2(pipeline *datamodel.Pipeline) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{}
	}

	if mmCreateNamespacePipeline.defaultExpectation.params != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Expect")
	}

	if mmCreateNamespacePipeline.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipeline.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineParamPtrs{}
	}
	mmCreateNamespacePipeline.defaultExpectation.paramPtrs.pipeline = &pipeline
	mmCreateNamespacePipeline.defaultExpectation.expectationOrigins.originPipeline = minimock.CallerInfo(1)

	return mmCreateNamespacePipeline
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Inspect(f func(ctx context.Context, pipeline *datamodel.Pipeline)) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.inspectFuncCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespacePipeline")
	}

	mmCreateNamespacePipeline.mock.inspectFuncCreateNamespacePipeline = f

	return mmCreateNamespacePipeline
}

// Return sets up results that will be returned by Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Return(err error) *RepositoryMock {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{mock: mmCreateNamespacePipeline.mock}
	}
	mmCreateNamespacePipeline.defaultExpectation.results = &RepositoryMockCreateNamespacePipelineResults{err}
	mmCreateNamespacePipeline.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespacePipeline.mock
}

// Set uses given function f to mock the Repository.CreateNamespacePipeline method
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Set(f func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)) *RepositoryMock {
	if mmCreateNamespacePipeline.defaultExpectation != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespacePipeline method")
	}

	if len(mmCreateNamespacePipeline.expectations) > 0 {
		mmCreateNamespacePipeline.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespacePipeline method")
	}

	mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline = f
	mmCreateNamespacePipeline.mock.funcCreateNamespacePipelineOrigin = minimock.CallerInfo(1)
	return mmCreateNamespacePipeline.mock
}

// When sets expectation for the Repository.CreateNamespacePipeline which will trigger the result defined by the following
// Then helper
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) When(ctx context.Context, pipeline *datamodel.Pipeline) *RepositoryMockCreateNamespacePipelineExpectation {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespacePipelineExpectation{
		mock:               mmCreateNamespacePipeline.mock,
		params:             &RepositoryMockCreateNamespacePipelineParams{ctx, pipeline},
		expectationOrigins: RepositoryMockCreateNamespacePipelineExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespacePipeline.expectations = append(mmCreateNamespacePipeline.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespacePipeline return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespacePipelineExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespacePipelineResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespacePipeline should be invoked
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Times(n uint64) *mRepositoryMockCreateNamespacePipeline {
	if n == 0 {
		mmCreateNamespacePipeline.mock.t.Fatalf("Times of RepositoryMock.CreateNamespacePipeline mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespacePipeline.expectedInvocations, n)
	mmCreateNamespacePipeline.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespacePipeline
}

func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) invocationsDone() bool {
	if len(mmCreateNamespacePipeline.expectations) == 0 && mmCreateNamespacePipeline.defaultExpectation == nil && mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipeline.mock.afterCreateNamespacePipelineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipeline.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespacePipeline implements mm_repository.Repository
func (mmCreateNamespacePipeline *RepositoryMock) CreateNamespacePipeline(ctx context.Context, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespacePipeline.beforeCreateNamespacePipelineCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespacePipeline.afterCreateNamespacePipelineCounter, 1)

	mmCreateNamespacePipeline.t.Helper()

	if mmCreateNamespacePipeline.inspectFuncCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.inspectFuncCreateNamespacePipeline(ctx, pipeline)
	}

	mm_params := RepositoryMockCreateNamespacePipelineParams{ctx, pipeline}

	// Record call args
	mmCreateNamespacePipeline.CreateNamespacePipelineMock.mutex.Lock()
	mmCreateNamespacePipeline.CreateNamespacePipelineMock.callArgs = append(mmCreateNamespacePipeline.CreateNamespacePipelineMock.callArgs, &mm_params)
	mmCreateNamespacePipeline.CreateNamespacePipelineMock.mutex.Unlock()

	for _, e := range mmCreateNamespacePipeline.CreateNamespacePipelineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespacePipelineParams{ctx, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespacePipeline.t.Errorf("RepositoryMock.CreateNamespacePipeline got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmCreateNamespacePipeline.t.Errorf("RepositoryMock.CreateNamespacePipeline got unexpected parameter pipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.expectationOrigins.originPipeline, *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespacePipeline.t.Errorf("RepositoryMock.CreateNamespacePipeline got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespacePipeline.t.Fatal("No results are set for the RepositoryMock.CreateNamespacePipeline")
		}
		return (*mm_results).err
	}
	if mmCreateNamespacePipeline.funcCreateNamespacePipeline != nil {
		return mmCreateNamespacePipeline.funcCreateNamespacePipeline(ctx, pipeline)
	}
	mmCreateNamespacePipeline.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespacePipeline. %v %v", ctx, pipeline)
	return
}

// CreateNamespacePipelineAfterCounter returns a count of finished RepositoryMock.CreateNamespacePipeline invocations
func (mmCreateNamespacePipeline *RepositoryMock) CreateNamespacePipelineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipeline.afterCreateNamespacePipelineCounter)
}

// CreateNamespacePipelineBeforeCounter returns a count of RepositoryMock.CreateNamespacePipeline invocations
func (mmCreateNamespacePipeline *RepositoryMock) CreateNamespacePipelineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipeline.beforeCreateNamespacePipelineCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespacePipeline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Calls() []*RepositoryMockCreateNamespacePipelineParams {
	mmCreateNamespacePipeline.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespacePipelineParams, len(mmCreateNamespacePipeline.callArgs))
	copy(argCopy, mmCreateNamespacePipeline.callArgs)

	mmCreateNamespacePipeline.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespacePipelineDone returns true if the count of the CreateNamespacePipeline invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespacePipelineDone() bool {
	if m.CreateNamespacePipelineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespacePipelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespacePipelineMock.invocationsDone()
}

// MinimockCreateNamespacePipelineInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespacePipelineInspect() {
	for _, e := range m.CreateNamespacePipelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipeline at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespacePipelineCounter := mm_atomic.LoadUint64(&m.afterCreateNamespacePipelineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespacePipelineMock.defaultExpectation != nil && afterCreateNamespacePipelineCounter < 1 {
		if m.CreateNamespacePipelineMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipeline at\n%s", m.CreateNamespacePipelineMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipeline at\n%s with params: %#v", m.CreateNamespacePipelineMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespacePipelineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespacePipeline != nil && afterCreateNamespacePipelineCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipeline at\n%s", m.funcCreateNamespacePipelineOrigin)
	}

	if !m.CreateNamespacePipelineMock.invocationsDone() && afterCreateNamespacePipelineCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespacePipeline at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespacePipelineMock.expectedInvocations), m.CreateNamespacePipelineMock.expectedInvocationsOrigin, afterCreateNamespacePipelineCounter)
	}
}

type mRepositoryMockCreateNamespacePipelineRelease struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespacePipelineReleaseExpectation
	expectations       []*RepositoryMockCreateNamespacePipelineReleaseExpectation

	callArgs []*RepositoryMockCreateNamespacePipelineReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateNamespacePipelineReleaseExpectation specifies expectation struct of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateNamespacePipelineReleaseParams
	paramPtrs          *RepositoryMockCreateNamespacePipelineReleaseParamPtrs
	expectationOrigins RepositoryMockCreateNamespacePipelineReleaseExpectationOrigins
	results            *RepositoryMockCreateNamespacePipelineReleaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateNamespacePipelineReleaseParams contains parameters of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseParams struct {
	ctx             context.Context
	ownerPermalink  string
	pipelineUID     uuid.UUID
	pipelineRelease *datamodel.PipelineRelease
}

// RepositoryMockCreateNamespacePipelineReleaseParamPtrs contains pointers to parameters of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseParamPtrs struct {
	ctx             *context.Context
	ownerPermalink  *string
	pipelineUID     *uuid.UUID
	pipelineRelease **datamodel.PipelineRelease
}

// RepositoryMockCreateNamespacePipelineReleaseResults contains results of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseResults struct {
	err error
}

// RepositoryMockCreateNamespacePipelineReleaseOrigins contains origins of expectations of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseExpectationOrigins struct {
	origin                string
	originCtx             string
	originOwnerPermalink  string
	originPipelineUID     string
	originPipelineRelease string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Optional() *mRepositoryMockCreateNamespacePipelineRelease {
	mmCreateNamespacePipelineRelease.optional = true
	return mmCreateNamespacePipelineRelease
}

// Expect sets up expected params for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by ExpectParams functions")
	}

	mmCreateNamespacePipelineRelease.defaultExpectation.params = &RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}
	mmCreateNamespacePipelineRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespacePipelineRelease.expectations {
		if minimock.Equal(e.params, mmCreateNamespacePipelineRelease.defaultExpectation.params) {
			mmCreateNamespacePipelineRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespacePipelineRelease.defaultExpectation.params)
		}
	}

	return mmCreateNamespacePipelineRelease
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespacePipelineRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespacePipelineRelease
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmCreateNamespacePipelineRelease.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmCreateNamespacePipelineRelease
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmCreateNamespacePipelineRelease.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmCreateNamespacePipelineRelease
}

// ExpectPipelineReleaseParam4 sets up expected param pipelineRelease for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectPipelineReleaseParam4(pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.pipelineRelease = &pipelineRelease
	mmCreateNamespacePipelineRelease.defaultExpectation.expectationOrigins.originPipelineRelease = minimock.CallerInfo(1)

	return mmCreateNamespacePipelineRelease
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease)) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.inspectFuncCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespacePipelineRelease")
	}

	mmCreateNamespacePipelineRelease.mock.inspectFuncCreateNamespacePipelineRelease = f

	return mmCreateNamespacePipelineRelease
}

// Return sets up results that will be returned by Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Return(err error) *RepositoryMock {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{mock: mmCreateNamespacePipelineRelease.mock}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.results = &RepositoryMockCreateNamespacePipelineReleaseResults{err}
	mmCreateNamespacePipelineRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespacePipelineRelease.mock
}

// Set uses given function f to mock the Repository.CreateNamespacePipelineRelease method
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error)) *RepositoryMock {
	if mmCreateNamespacePipelineRelease.defaultExpectation != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespacePipelineRelease method")
	}

	if len(mmCreateNamespacePipelineRelease.expectations) > 0 {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespacePipelineRelease method")
	}

	mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease = f
	mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineReleaseOrigin = minimock.CallerInfo(1)
	return mmCreateNamespacePipelineRelease.mock
}

// When sets expectation for the Repository.CreateNamespacePipelineRelease which will trigger the result defined by the following
// Then helper
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) *RepositoryMockCreateNamespacePipelineReleaseExpectation {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespacePipelineReleaseExpectation{
		mock:               mmCreateNamespacePipelineRelease.mock,
		params:             &RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease},
		expectationOrigins: RepositoryMockCreateNamespacePipelineReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespacePipelineRelease.expectations = append(mmCreateNamespacePipelineRelease.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespacePipelineRelease return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespacePipelineReleaseExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespacePipelineReleaseResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespacePipelineRelease should be invoked
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Times(n uint64) *mRepositoryMockCreateNamespacePipelineRelease {
	if n == 0 {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Times of RepositoryMock.CreateNamespacePipelineRelease mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespacePipelineRelease.expectedInvocations, n)
	mmCreateNamespacePipelineRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespacePipelineRelease
}

func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) invocationsDone() bool {
	if len(mmCreateNamespacePipelineRelease.expectations) == 0 && mmCreateNamespacePipelineRelease.defaultExpectation == nil && mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.mock.afterCreateNamespacePipelineReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespacePipelineRelease implements mm_repository.Repository
func (mmCreateNamespacePipelineRelease *RepositoryMock) CreateNamespacePipelineRelease(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespacePipelineRelease.beforeCreateNamespacePipelineReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespacePipelineRelease.afterCreateNamespacePipelineReleaseCounter, 1)

	mmCreateNamespacePipelineRelease.t.Helper()

	if mmCreateNamespacePipelineRelease.inspectFuncCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.inspectFuncCreateNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, pipelineRelease)
	}

	mm_params := RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}

	// Record call args
	mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.mutex.Lock()
	mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.callArgs = append(mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.callArgs, &mm_params)
	mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.mutex.Unlock()

	for _, e := range mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter pipelineRelease, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originPipelineRelease, *mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease, minimock.Diff(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespacePipelineRelease.t.Fatal("No results are set for the RepositoryMock.CreateNamespacePipelineRelease")
		}
		return (*mm_results).err
	}
	if mmCreateNamespacePipelineRelease.funcCreateNamespacePipelineRelease != nil {
		return mmCreateNamespacePipelineRelease.funcCreateNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, pipelineRelease)
	}
	mmCreateNamespacePipelineRelease.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespacePipelineRelease. %v %v %v %v", ctx, ownerPermalink, pipelineUID, pipelineRelease)
	return
}

// CreateNamespacePipelineReleaseAfterCounter returns a count of finished RepositoryMock.CreateNamespacePipelineRelease invocations
func (mmCreateNamespacePipelineRelease *RepositoryMock) CreateNamespacePipelineReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.afterCreateNamespacePipelineReleaseCounter)
}

// CreateNamespacePipelineReleaseBeforeCounter returns a count of RepositoryMock.CreateNamespacePipelineRelease invocations
func (mmCreateNamespacePipelineRelease *RepositoryMock) CreateNamespacePipelineReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.beforeCreateNamespacePipelineReleaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespacePipelineRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Calls() []*RepositoryMockCreateNamespacePipelineReleaseParams {
	mmCreateNamespacePipelineRelease.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespacePipelineReleaseParams, len(mmCreateNamespacePipelineRelease.callArgs))
	copy(argCopy, mmCreateNamespacePipelineRelease.callArgs)

	mmCreateNamespacePipelineRelease.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespacePipelineReleaseDone returns true if the count of the CreateNamespacePipelineRelease invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespacePipelineReleaseDone() bool {
	if m.CreateNamespacePipelineReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespacePipelineReleaseMock.invocationsDone()
}

// MinimockCreateNamespacePipelineReleaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespacePipelineReleaseInspect() {
	for _, e := range m.CreateNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipelineRelease at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespacePipelineReleaseCounter := mm_atomic.LoadUint64(&m.afterCreateNamespacePipelineReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespacePipelineReleaseMock.defaultExpectation != nil && afterCreateNamespacePipelineReleaseCounter < 1 {
		if m.CreateNamespacePipelineReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipelineRelease at\n%s", m.CreateNamespacePipelineReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipelineRelease at\n%s with params: %#v", m.CreateNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespacePipelineReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespacePipelineRelease != nil && afterCreateNamespacePipelineReleaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipelineRelease at\n%s", m.funcCreateNamespacePipelineReleaseOrigin)
	}

	if !m.CreateNamespacePipelineReleaseMock.invocationsDone() && afterCreateNamespacePipelineReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespacePipelineRelease at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespacePipelineReleaseMock.expectedInvocations), m.CreateNamespacePipelineReleaseMock.expectedInvocationsOrigin, afterCreateNamespacePipelineReleaseCounter)
	}
}

type mRepositoryMockCreateNamespaceSecret struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespaceSecretExpectation
	expectations       []*RepositoryMockCreateNamespaceSecretExpectation

	callArgs []*RepositoryMockCreateNamespaceSecretParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateNamespaceSecretExpectation specifies expectation struct of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateNamespaceSecretParams
	paramPtrs          *RepositoryMockCreateNamespaceSecretParamPtrs
	expectationOrigins RepositoryMockCreateNamespaceSecretExpectationOrigins
	results            *RepositoryMockCreateNamespaceSecretResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateNamespaceSecretParams contains parameters of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretParams struct {
	ctx            context.Context
	ownerPermalink string
	secret         *datamodel.Secret
}

// RepositoryMockCreateNamespaceSecretParamPtrs contains pointers to parameters of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	secret         **datamodel.Secret
}

// RepositoryMockCreateNamespaceSecretResults contains results of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretResults struct {
	err error
}

// RepositoryMockCreateNamespaceSecretOrigins contains origins of expectations of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originSecret         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Optional() *mRepositoryMockCreateNamespaceSecret {
	mmCreateNamespaceSecret.optional = true
	return mmCreateNamespaceSecret
}

// Expect sets up expected params for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Expect(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceSecret.defaultExpectation.params = &RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespaceSecret.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceSecret.defaultExpectation.params) {
			mmCreateNamespaceSecret.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceSecret.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceSecret
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespaceSecret
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmCreateNamespaceSecret
}

// ExpectSecretParam3 sets up expected param secret for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectSecretParam3(secret *datamodel.Secret) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.secret = &secret
	mmCreateNamespaceSecret.defaultExpectation.expectationOrigins.originSecret = minimock.CallerInfo(1)

	return mmCreateNamespaceSecret
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Inspect(f func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret)) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.inspectFuncCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespaceSecret")
	}

	mmCreateNamespaceSecret.mock.inspectFuncCreateNamespaceSecret = f

	return mmCreateNamespaceSecret
}

// Return sets up results that will be returned by Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Return(err error) *RepositoryMock {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{mock: mmCreateNamespaceSecret.mock}
	}
	mmCreateNamespaceSecret.defaultExpectation.results = &RepositoryMockCreateNamespaceSecretResults{err}
	mmCreateNamespaceSecret.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceSecret.mock
}

// Set uses given function f to mock the Repository.CreateNamespaceSecret method
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Set(f func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error)) *RepositoryMock {
	if mmCreateNamespaceSecret.defaultExpectation != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespaceSecret method")
	}

	if len(mmCreateNamespaceSecret.expectations) > 0 {
		mmCreateNamespaceSecret.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespaceSecret method")
	}

	mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret = f
	mmCreateNamespaceSecret.mock.funcCreateNamespaceSecretOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceSecret.mock
}

// When sets expectation for the Repository.CreateNamespaceSecret which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) When(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) *RepositoryMockCreateNamespaceSecretExpectation {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespaceSecretExpectation{
		mock:               mmCreateNamespaceSecret.mock,
		params:             &RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret},
		expectationOrigins: RepositoryMockCreateNamespaceSecretExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespaceSecret.expectations = append(mmCreateNamespaceSecret.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespaceSecret return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespaceSecretExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespaceSecretResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespaceSecret should be invoked
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Times(n uint64) *mRepositoryMockCreateNamespaceSecret {
	if n == 0 {
		mmCreateNamespaceSecret.mock.t.Fatalf("Times of RepositoryMock.CreateNamespaceSecret mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceSecret.expectedInvocations, n)
	mmCreateNamespaceSecret.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceSecret
}

func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) invocationsDone() bool {
	if len(mmCreateNamespaceSecret.expectations) == 0 && mmCreateNamespaceSecret.defaultExpectation == nil && mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceSecret.mock.afterCreateNamespaceSecretCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceSecret.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceSecret implements mm_repository.Repository
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecret(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceSecret.beforeCreateNamespaceSecretCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceSecret.afterCreateNamespaceSecretCounter, 1)

	mmCreateNamespaceSecret.t.Helper()

	if mmCreateNamespaceSecret.inspectFuncCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.inspectFuncCreateNamespaceSecret(ctx, ownerPermalink, secret)
	}

	mm_params := RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}

	// Record call args
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.mutex.Lock()
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.callArgs = append(mmCreateNamespaceSecret.CreateNamespaceSecretMock.callArgs, &mm_params)
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceSecret.CreateNamespaceSecretMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.secret != nil && !minimock.Equal(*mm_want_ptrs.secret, mm_got.secret) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter secret, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.originSecret, *mm_want_ptrs.secret, mm_got.secret, minimock.Diff(*mm_want_ptrs.secret, mm_got.secret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceSecret.t.Fatal("No results are set for the RepositoryMock.CreateNamespaceSecret")
		}
		return (*mm_results).err
	}
	if mmCreateNamespaceSecret.funcCreateNamespaceSecret != nil {
		return mmCreateNamespaceSecret.funcCreateNamespaceSecret(ctx, ownerPermalink, secret)
	}
	mmCreateNamespaceSecret.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespaceSecret. %v %v %v", ctx, ownerPermalink, secret)
	return
}

// CreateNamespaceSecretAfterCounter returns a count of finished RepositoryMock.CreateNamespaceSecret invocations
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecretAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceSecret.afterCreateNamespaceSecretCounter)
}

// CreateNamespaceSecretBeforeCounter returns a count of RepositoryMock.CreateNamespaceSecret invocations
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecretBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceSecret.beforeCreateNamespaceSecretCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespaceSecret.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Calls() []*RepositoryMockCreateNamespaceSecretParams {
	mmCreateNamespaceSecret.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespaceSecretParams, len(mmCreateNamespaceSecret.callArgs))
	copy(argCopy, mmCreateNamespaceSecret.callArgs)

	mmCreateNamespaceSecret.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceSecretDone returns true if the count of the CreateNamespaceSecret invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespaceSecretDone() bool {
	if m.CreateNamespaceSecretMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceSecretMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceSecretMock.invocationsDone()
}

// MinimockCreateNamespaceSecretInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespaceSecretInspect() {
	for _, e := range m.CreateNamespaceSecretMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespaceSecretCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceSecretCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceSecretMock.defaultExpectation != nil && afterCreateNamespaceSecretCounter < 1 {
		if m.CreateNamespaceSecretMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s", m.CreateNamespaceSecretMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s with params: %#v", m.CreateNamespaceSecretMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespaceSecretMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceSecret != nil && afterCreateNamespaceSecretCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret at\n%s", m.funcCreateNamespaceSecretOrigin)
	}

	if !m.CreateNamespaceSecretMock.invocationsDone() && afterCreateNamespaceSecretCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespaceSecret at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceSecretMock.expectedInvocations), m.CreateNamespaceSecretMock.expectedInvocationsOrigin, afterCreateNamespaceSecretCounter)
	}
}

type mRepositoryMockCreatePipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreatePipelineTagsExpectation
	expectations       []*RepositoryMockCreatePipelineTagsExpectation

	callArgs []*RepositoryMockCreatePipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreatePipelineTagsExpectation specifies expectation struct of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreatePipelineTagsParams
	paramPtrs          *RepositoryMockCreatePipelineTagsParamPtrs
	expectationOrigins RepositoryMockCreatePipelineTagsExpectationOrigins
	results            *RepositoryMockCreatePipelineTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreatePipelineTagsParams contains parameters of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	tagNames    []string
}

// RepositoryMockCreatePipelineTagsParamPtrs contains pointers to parameters of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	tagNames    *[]string
}

// RepositoryMockCreatePipelineTagsResults contains results of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsResults struct {
	err error
}

// RepositoryMockCreatePipelineTagsOrigins contains origins of expectations of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originTagNames    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Optional() *mRepositoryMockCreatePipelineTags {
	mmCreatePipelineTags.optional = true
	return mmCreatePipelineTags
}

// Expect sets up expected params for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by ExpectParams functions")
	}

	mmCreatePipelineTags.defaultExpectation.params = &RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePipelineTags.expectations {
		if minimock.Equal(e.params, mmCreatePipelineTags.defaultExpectation.params) {
			mmCreatePipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePipelineTags.defaultExpectation.params)
		}
	}

	return mmCreatePipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmCreatePipelineTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.tagNames = &tagNames
	mmCreatePipelineTags.defaultExpectation.expectationOrigins.originTagNames = minimock.CallerInfo(1)

	return mmCreatePipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.inspectFuncCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreatePipelineTags")
	}

	mmCreatePipelineTags.mock.inspectFuncCreatePipelineTags = f

	return mmCreatePipelineTags
}

// Return sets up results that will be returned by Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Return(err error) *RepositoryMock {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{mock: mmCreatePipelineTags.mock}
	}
	mmCreatePipelineTags.defaultExpectation.results = &RepositoryMockCreatePipelineTagsResults{err}
	mmCreatePipelineTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineTags.mock
}

// Set uses given function f to mock the Repository.CreatePipelineTags method
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmCreatePipelineTags.defaultExpectation != nil {
		mmCreatePipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.CreatePipelineTags method")
	}

	if len(mmCreatePipelineTags.expectations) > 0 {
		mmCreatePipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.CreatePipelineTags method")
	}

	mmCreatePipelineTags.mock.funcCreatePipelineTags = f
	mmCreatePipelineTags.mock.funcCreatePipelineTagsOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineTags.mock
}

// When sets expectation for the Repository.CreatePipelineTags which will trigger the result defined by the following
// Then helper
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) When(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *RepositoryMockCreatePipelineTagsExpectation {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockCreatePipelineTagsExpectation{
		mock:               mmCreatePipelineTags.mock,
		params:             &RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames},
		expectationOrigins: RepositoryMockCreatePipelineTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePipelineTags.expectations = append(mmCreatePipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreatePipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreatePipelineTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreatePipelineTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.CreatePipelineTags should be invoked
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Times(n uint64) *mRepositoryMockCreatePipelineTags {
	if n == 0 {
		mmCreatePipelineTags.mock.t.Fatalf("Times of RepositoryMock.CreatePipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePipelineTags.expectedInvocations, n)
	mmCreatePipelineTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePipelineTags
}

func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) invocationsDone() bool {
	if len(mmCreatePipelineTags.expectations) == 0 && mmCreatePipelineTags.defaultExpectation == nil && mmCreatePipelineTags.mock.funcCreatePipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePipelineTags.mock.afterCreatePipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePipelineTags implements mm_repository.Repository
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTags(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmCreatePipelineTags.beforeCreatePipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePipelineTags.afterCreatePipelineTagsCounter, 1)

	mmCreatePipelineTags.t.Helper()

	if mmCreatePipelineTags.inspectFuncCreatePipelineTags != nil {
		mmCreatePipelineTags.inspectFuncCreatePipelineTags(ctx, pipelineUID, tagNames)
	}

	mm_params := RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}

	// Record call args
	mmCreatePipelineTags.CreatePipelineTagsMock.mutex.Lock()
	mmCreatePipelineTags.CreatePipelineTagsMock.callArgs = append(mmCreatePipelineTags.CreatePipelineTagsMock.callArgs, &mm_params)
	mmCreatePipelineTags.CreatePipelineTagsMock.mutex.Unlock()

	for _, e := range mmCreatePipelineTags.CreatePipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter tagNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.originTagNames, *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePipelineTags.t.Fatal("No results are set for the RepositoryMock.CreatePipelineTags")
		}
		return (*mm_results).err
	}
	if mmCreatePipelineTags.funcCreatePipelineTags != nil {
		return mmCreatePipelineTags.funcCreatePipelineTags(ctx, pipelineUID, tagNames)
	}
	mmCreatePipelineTags.t.Fatalf("Unexpected call to RepositoryMock.CreatePipelineTags. %v %v %v", ctx, pipelineUID, tagNames)
	return
}

// CreatePipelineTagsAfterCounter returns a count of finished RepositoryMock.CreatePipelineTags invocations
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineTags.afterCreatePipelineTagsCounter)
}

// CreatePipelineTagsBeforeCounter returns a count of RepositoryMock.CreatePipelineTags invocations
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineTags.beforeCreatePipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreatePipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Calls() []*RepositoryMockCreatePipelineTagsParams {
	mmCreatePipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockCreatePipelineTagsParams, len(mmCreatePipelineTags.callArgs))
	copy(argCopy, mmCreatePipelineTags.callArgs)

	mmCreatePipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePipelineTagsDone returns true if the count of the CreatePipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreatePipelineTagsDone() bool {
	if m.CreatePipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePipelineTagsMock.invocationsDone()
}

// MinimockCreatePipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreatePipelineTagsInspect() {
	for _, e := range m.CreatePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePipelineTagsCounter := mm_atomic.LoadUint64(&m.afterCreatePipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePipelineTagsMock.defaultExpectation != nil && afterCreatePipelineTagsCounter < 1 {
		if m.CreatePipelineTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s", m.CreatePipelineTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s with params: %#v", m.CreatePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *m.CreatePipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePipelineTags != nil && afterCreatePipelineTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags at\n%s", m.funcCreatePipelineTagsOrigin)
	}

	if !m.CreatePipelineTagsMock.invocationsDone() && afterCreatePipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreatePipelineTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePipelineTagsMock.expectedInvocations), m.CreatePipelineTagsMock.expectedInvocationsOrigin, afterCreatePipelineTagsCounter)
	}
}

type mRepositoryMockDeleteNamespaceConnectionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespaceConnectionByIDExpectation
	expectations       []*RepositoryMockDeleteNamespaceConnectionByIDExpectation

	callArgs []*RepositoryMockDeleteNamespaceConnectionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteNamespaceConnectionByIDExpectation specifies expectation struct of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteNamespaceConnectionByIDParams
	paramPtrs          *RepositoryMockDeleteNamespaceConnectionByIDParamPtrs
	expectationOrigins RepositoryMockDeleteNamespaceConnectionByIDExpectationOrigins
	results            *RepositoryMockDeleteNamespaceConnectionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteNamespaceConnectionByIDParams contains parameters of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDParams struct {
	ctx   context.Context
	nsUID uuid.UUID
	id    string
}

// RepositoryMockDeleteNamespaceConnectionByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDParamPtrs struct {
	ctx   *context.Context
	nsUID *uuid.UUID
	id    *string
}

// RepositoryMockDeleteNamespaceConnectionByIDResults contains results of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDResults struct {
	err error
}

// RepositoryMockDeleteNamespaceConnectionByIDOrigins contains origins of expectations of the Repository.DeleteNamespaceConnectionByID
type RepositoryMockDeleteNamespaceConnectionByIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originNsUID string
	originId    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Optional() *mRepositoryMockDeleteNamespaceConnectionByID {
	mmDeleteNamespaceConnectionByID.optional = true
	return mmDeleteNamespaceConnectionByID
}

// Expect sets up expected params for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Expect(ctx context.Context, nsUID uuid.UUID, id string) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceConnectionByID.defaultExpectation.params = &RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id}
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespaceConnectionByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceConnectionByID.defaultExpectation.params) {
			mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceConnectionByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceConnectionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.params != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Expect")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceConnectionByIDParamPtrs{}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespaceConnectionByID
}

// ExpectNsUIDParam2 sets up expected param nsUID for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) ExpectNsUIDParam2(nsUID uuid.UUID) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.params != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Expect")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceConnectionByIDParamPtrs{}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs.nsUID = &nsUID
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.originNsUID = minimock.CallerInfo(1)

	return mmDeleteNamespaceConnectionByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{}
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.params != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Expect")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceConnectionByIDParamPtrs{}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteNamespaceConnectionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteNamespaceConnectionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Inspect(f func(ctx context.Context, nsUID uuid.UUID, id string)) *mRepositoryMockDeleteNamespaceConnectionByID {
	if mmDeleteNamespaceConnectionByID.mock.inspectFuncDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespaceConnectionByID")
	}

	mmDeleteNamespaceConnectionByID.mock.inspectFuncDeleteNamespaceConnectionByID = f

	return mmDeleteNamespaceConnectionByID
}

// Return sets up results that will be returned by Repository.DeleteNamespaceConnectionByID
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	if mmDeleteNamespaceConnectionByID.defaultExpectation == nil {
		mmDeleteNamespaceConnectionByID.defaultExpectation = &RepositoryMockDeleteNamespaceConnectionByIDExpectation{mock: mmDeleteNamespaceConnectionByID.mock}
	}
	mmDeleteNamespaceConnectionByID.defaultExpectation.results = &RepositoryMockDeleteNamespaceConnectionByIDResults{err}
	mmDeleteNamespaceConnectionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceConnectionByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespaceConnectionByID method
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Set(f func(ctx context.Context, nsUID uuid.UUID, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespaceConnectionByID.defaultExpectation != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespaceConnectionByID method")
	}

	if len(mmDeleteNamespaceConnectionByID.expectations) > 0 {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespaceConnectionByID method")
	}

	mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID = f
	mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceConnectionByID.mock
}

// When sets expectation for the Repository.DeleteNamespaceConnectionByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) When(ctx context.Context, nsUID uuid.UUID, id string) *RepositoryMockDeleteNamespaceConnectionByIDExpectation {
	if mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceConnectionByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespaceConnectionByIDExpectation{
		mock:               mmDeleteNamespaceConnectionByID.mock,
		params:             &RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id},
		expectationOrigins: RepositoryMockDeleteNamespaceConnectionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespaceConnectionByID.expectations = append(mmDeleteNamespaceConnectionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespaceConnectionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespaceConnectionByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespaceConnectionByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespaceConnectionByID should be invoked
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Times(n uint64) *mRepositoryMockDeleteNamespaceConnectionByID {
	if n == 0 {
		mmDeleteNamespaceConnectionByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespaceConnectionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceConnectionByID.expectedInvocations, n)
	mmDeleteNamespaceConnectionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceConnectionByID
}

func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) invocationsDone() bool {
	if len(mmDeleteNamespaceConnectionByID.expectations) == 0 && mmDeleteNamespaceConnectionByID.defaultExpectation == nil && mmDeleteNamespaceConnectionByID.mock.funcDeleteNamespaceConnectionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.mock.afterDeleteNamespaceConnectionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceConnectionByID implements mm_repository.Repository
func (mmDeleteNamespaceConnectionByID *RepositoryMock) DeleteNamespaceConnectionByID(ctx context.Context, nsUID uuid.UUID, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceConnectionByID.beforeDeleteNamespaceConnectionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceConnectionByID.afterDeleteNamespaceConnectionByIDCounter, 1)

	mmDeleteNamespaceConnectionByID.t.Helper()

	if mmDeleteNamespaceConnectionByID.inspectFuncDeleteNamespaceConnectionByID != nil {
		mmDeleteNamespaceConnectionByID.inspectFuncDeleteNamespaceConnectionByID(ctx, nsUID, id)
	}

	mm_params := RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id}

	// Record call args
	mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.mutex.Lock()
	mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.callArgs = append(mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.callArgs, &mm_params)
	mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespaceConnectionByIDParams{ctx, nsUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.nsUID != nil && !minimock.Equal(*mm_want_ptrs.nsUID, mm_got.nsUID) {
				mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameter nsUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originNsUID, *mm_want_ptrs.nsUID, mm_got.nsUID, minimock.Diff(*mm_want_ptrs.nsUID, mm_got.nsUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceConnectionByID.t.Errorf("RepositoryMock.DeleteNamespaceConnectionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceConnectionByID.DeleteNamespaceConnectionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceConnectionByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespaceConnectionByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespaceConnectionByID.funcDeleteNamespaceConnectionByID != nil {
		return mmDeleteNamespaceConnectionByID.funcDeleteNamespaceConnectionByID(ctx, nsUID, id)
	}
	mmDeleteNamespaceConnectionByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespaceConnectionByID. %v %v %v", ctx, nsUID, id)
	return
}

// DeleteNamespaceConnectionByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespaceConnectionByID invocations
func (mmDeleteNamespaceConnectionByID *RepositoryMock) DeleteNamespaceConnectionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.afterDeleteNamespaceConnectionByIDCounter)
}

// DeleteNamespaceConnectionByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespaceConnectionByID invocations
func (mmDeleteNamespaceConnectionByID *RepositoryMock) DeleteNamespaceConnectionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceConnectionByID.beforeDeleteNamespaceConnectionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespaceConnectionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceConnectionByID *mRepositoryMockDeleteNamespaceConnectionByID) Calls() []*RepositoryMockDeleteNamespaceConnectionByIDParams {
	mmDeleteNamespaceConnectionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespaceConnectionByIDParams, len(mmDeleteNamespaceConnectionByID.callArgs))
	copy(argCopy, mmDeleteNamespaceConnectionByID.callArgs)

	mmDeleteNamespaceConnectionByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceConnectionByIDDone returns true if the count of the DeleteNamespaceConnectionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespaceConnectionByIDDone() bool {
	if m.DeleteNamespaceConnectionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceConnectionByIDMock.invocationsDone()
}

// MinimockDeleteNamespaceConnectionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespaceConnectionByIDInspect() {
	for _, e := range m.DeleteNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespaceConnectionByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceConnectionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceConnectionByIDMock.defaultExpectation != nil && afterDeleteNamespaceConnectionByIDCounter < 1 {
		if m.DeleteNamespaceConnectionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s", m.DeleteNamespaceConnectionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s with params: %#v", m.DeleteNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespaceConnectionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceConnectionByID != nil && afterDeleteNamespaceConnectionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceConnectionByID at\n%s", m.funcDeleteNamespaceConnectionByIDOrigin)
	}

	if !m.DeleteNamespaceConnectionByIDMock.invocationsDone() && afterDeleteNamespaceConnectionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespaceConnectionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceConnectionByIDMock.expectedInvocations), m.DeleteNamespaceConnectionByIDMock.expectedInvocationsOrigin, afterDeleteNamespaceConnectionByIDCounter)
	}
}

type mRepositoryMockDeleteNamespacePipelineByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespacePipelineByIDExpectation
	expectations       []*RepositoryMockDeleteNamespacePipelineByIDExpectation

	callArgs []*RepositoryMockDeleteNamespacePipelineByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteNamespacePipelineByIDExpectation specifies expectation struct of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteNamespacePipelineByIDParams
	paramPtrs          *RepositoryMockDeleteNamespacePipelineByIDParamPtrs
	expectationOrigins RepositoryMockDeleteNamespacePipelineByIDExpectationOrigins
	results            *RepositoryMockDeleteNamespacePipelineByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteNamespacePipelineByIDParams contains parameters of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeleteNamespacePipelineByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeleteNamespacePipelineByIDResults contains results of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDResults struct {
	err error
}

// RepositoryMockDeleteNamespacePipelineByIDOrigins contains origins of expectations of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Optional() *mRepositoryMockDeleteNamespacePipelineByID {
	mmDeleteNamespacePipelineByID.optional = true
	return mmDeleteNamespacePipelineByID
}

// Expect sets up expected params for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespacePipelineByID.defaultExpectation.params = &RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id}
	mmDeleteNamespacePipelineByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespacePipelineByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespacePipelineByID.defaultExpectation.params) {
			mmDeleteNamespacePipelineByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespacePipelineByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespacePipelineByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespacePipelineByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespacePipelineByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmDeleteNamespacePipelineByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmDeleteNamespacePipelineByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteNamespacePipelineByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteNamespacePipelineByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.inspectFuncDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespacePipelineByID")
	}

	mmDeleteNamespacePipelineByID.mock.inspectFuncDeleteNamespacePipelineByID = f

	return mmDeleteNamespacePipelineByID
}

// Return sets up results that will be returned by Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{mock: mmDeleteNamespacePipelineByID.mock}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.results = &RepositoryMockDeleteNamespacePipelineByIDResults{err}
	mmDeleteNamespacePipelineByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespacePipelineByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespacePipelineByID method
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespacePipelineByID.defaultExpectation != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespacePipelineByID method")
	}

	if len(mmDeleteNamespacePipelineByID.expectations) > 0 {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespacePipelineByID method")
	}

	mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID = f
	mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespacePipelineByID.mock
}

// When sets expectation for the Repository.DeleteNamespacePipelineByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeleteNamespacePipelineByIDExpectation {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespacePipelineByIDExpectation{
		mock:               mmDeleteNamespacePipelineByID.mock,
		params:             &RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id},
		expectationOrigins: RepositoryMockDeleteNamespacePipelineByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespacePipelineByID.expectations = append(mmDeleteNamespacePipelineByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespacePipelineByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespacePipelineByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespacePipelineByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespacePipelineByID should be invoked
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Times(n uint64) *mRepositoryMockDeleteNamespacePipelineByID {
	if n == 0 {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespacePipelineByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespacePipelineByID.expectedInvocations, n)
	mmDeleteNamespacePipelineByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespacePipelineByID
}

func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) invocationsDone() bool {
	if len(mmDeleteNamespacePipelineByID.expectations) == 0 && mmDeleteNamespacePipelineByID.defaultExpectation == nil && mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.mock.afterDeleteNamespacePipelineByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespacePipelineByID implements mm_repository.Repository
func (mmDeleteNamespacePipelineByID *RepositoryMock) DeleteNamespacePipelineByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespacePipelineByID.beforeDeleteNamespacePipelineByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespacePipelineByID.afterDeleteNamespacePipelineByIDCounter, 1)

	mmDeleteNamespacePipelineByID.t.Helper()

	if mmDeleteNamespacePipelineByID.inspectFuncDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.inspectFuncDeleteNamespacePipelineByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.mutex.Lock()
	mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.callArgs = append(mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.callArgs, &mm_params)
	mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespacePipelineByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespacePipelineByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespacePipelineByID.funcDeleteNamespacePipelineByID != nil {
		return mmDeleteNamespacePipelineByID.funcDeleteNamespacePipelineByID(ctx, ownerPermalink, id)
	}
	mmDeleteNamespacePipelineByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespacePipelineByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeleteNamespacePipelineByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespacePipelineByID invocations
func (mmDeleteNamespacePipelineByID *RepositoryMock) DeleteNamespacePipelineByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.afterDeleteNamespacePipelineByIDCounter)
}

// DeleteNamespacePipelineByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespacePipelineByID invocations
func (mmDeleteNamespacePipelineByID *RepositoryMock) DeleteNamespacePipelineByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.beforeDeleteNamespacePipelineByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespacePipelineByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Calls() []*RepositoryMockDeleteNamespacePipelineByIDParams {
	mmDeleteNamespacePipelineByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespacePipelineByIDParams, len(mmDeleteNamespacePipelineByID.callArgs))
	copy(argCopy, mmDeleteNamespacePipelineByID.callArgs)

	mmDeleteNamespacePipelineByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespacePipelineByIDDone returns true if the count of the DeleteNamespacePipelineByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespacePipelineByIDDone() bool {
	if m.DeleteNamespacePipelineByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespacePipelineByIDMock.invocationsDone()
}

// MinimockDeleteNamespacePipelineByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespacePipelineByIDInspect() {
	for _, e := range m.DeleteNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespacePipelineByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespacePipelineByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespacePipelineByIDMock.defaultExpectation != nil && afterDeleteNamespacePipelineByIDCounter < 1 {
		if m.DeleteNamespacePipelineByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineByID at\n%s", m.DeleteNamespacePipelineByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineByID at\n%s with params: %#v", m.DeleteNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespacePipelineByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespacePipelineByID != nil && afterDeleteNamespacePipelineByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineByID at\n%s", m.funcDeleteNamespacePipelineByIDOrigin)
	}

	if !m.DeleteNamespacePipelineByIDMock.invocationsDone() && afterDeleteNamespacePipelineByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespacePipelineByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespacePipelineByIDMock.expectedInvocations), m.DeleteNamespacePipelineByIDMock.expectedInvocationsOrigin, afterDeleteNamespacePipelineByIDCounter)
	}
}

type mRepositoryMockDeleteNamespacePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockDeleteNamespacePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation specifies expectation struct of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteNamespacePipelineReleaseByIDParams
	paramPtrs          *RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs
	expectationOrigins RepositoryMockDeleteNamespacePipelineReleaseByIDExpectationOrigins
	results            *RepositoryMockDeleteNamespacePipelineReleaseByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDParams contains parameters of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDResults contains results of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDResults struct {
	err error
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDOrigins contains origins of expectations of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Optional() *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	mmDeleteNamespacePipelineReleaseByID.optional = true
	return mmDeleteNamespacePipelineReleaseByID
}

// Expect sets up expected params for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params = &RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespacePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params) {
			mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteNamespacePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string)) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.inspectFuncDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespacePipelineReleaseByID")
	}

	mmDeleteNamespacePipelineReleaseByID.mock.inspectFuncDeleteNamespacePipelineReleaseByID = f

	return mmDeleteNamespacePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{mock: mmDeleteNamespacePipelineReleaseByID.mock}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.results = &RepositoryMockDeleteNamespacePipelineReleaseByIDResults{err}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespacePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespacePipelineReleaseByID method
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespacePipelineReleaseByID method")
	}

	if len(mmDeleteNamespacePipelineReleaseByID.expectations) > 0 {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespacePipelineReleaseByID method")
	}

	mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID = f
	mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespacePipelineReleaseByID.mock
}

// When sets expectation for the Repository.DeleteNamespacePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) *RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{
		mock:               mmDeleteNamespacePipelineReleaseByID.mock,
		params:             &RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id},
		expectationOrigins: RepositoryMockDeleteNamespacePipelineReleaseByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespacePipelineReleaseByID.expectations = append(mmDeleteNamespacePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespacePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespacePipelineReleaseByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespacePipelineReleaseByID should be invoked
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Times(n uint64) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if n == 0 {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespacePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespacePipelineReleaseByID.expectedInvocations, n)
	mmDeleteNamespacePipelineReleaseByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespacePipelineReleaseByID
}

func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) invocationsDone() bool {
	if len(mmDeleteNamespacePipelineReleaseByID.expectations) == 0 && mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil && mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.mock.afterDeleteNamespacePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespacePipelineReleaseByID implements mm_repository.Repository
func (mmDeleteNamespacePipelineReleaseByID *RepositoryMock) DeleteNamespacePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespacePipelineReleaseByID.beforeDeleteNamespacePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespacePipelineReleaseByID.afterDeleteNamespacePipelineReleaseByIDCounter, 1)

	mmDeleteNamespacePipelineReleaseByID.t.Helper()

	if mmDeleteNamespacePipelineReleaseByID.inspectFuncDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.inspectFuncDeleteNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id)
	}

	mm_params := RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}

	// Record call args
	mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.mutex.Lock()
	mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.callArgs = append(mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.callArgs, &mm_params)
	mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespacePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespacePipelineReleaseByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespacePipelineReleaseByID.funcDeleteNamespacePipelineReleaseByID != nil {
		return mmDeleteNamespacePipelineReleaseByID.funcDeleteNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id)
	}
	mmDeleteNamespacePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespacePipelineReleaseByID. %v %v %v %v", ctx, ownerPermalink, pipelineUID, id)
	return
}

// DeleteNamespacePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespacePipelineReleaseByID invocations
func (mmDeleteNamespacePipelineReleaseByID *RepositoryMock) DeleteNamespacePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.afterDeleteNamespacePipelineReleaseByIDCounter)
}

// DeleteNamespacePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespacePipelineReleaseByID invocations
func (mmDeleteNamespacePipelineReleaseByID *RepositoryMock) DeleteNamespacePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.beforeDeleteNamespacePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespacePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Calls() []*RepositoryMockDeleteNamespacePipelineReleaseByIDParams {
	mmDeleteNamespacePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespacePipelineReleaseByIDParams, len(mmDeleteNamespacePipelineReleaseByID.callArgs))
	copy(argCopy, mmDeleteNamespacePipelineReleaseByID.callArgs)

	mmDeleteNamespacePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespacePipelineReleaseByIDDone returns true if the count of the DeleteNamespacePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespacePipelineReleaseByIDDone() bool {
	if m.DeleteNamespacePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespacePipelineReleaseByIDMock.invocationsDone()
}

// MinimockDeleteNamespacePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespacePipelineReleaseByIDInspect() {
	for _, e := range m.DeleteNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespacePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespacePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation != nil && afterDeleteNamespacePipelineReleaseByIDCounter < 1 {
		if m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID at\n%s", m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID at\n%s with params: %#v", m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespacePipelineReleaseByID != nil && afterDeleteNamespacePipelineReleaseByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID at\n%s", m.funcDeleteNamespacePipelineReleaseByIDOrigin)
	}

	if !m.DeleteNamespacePipelineReleaseByIDMock.invocationsDone() && afterDeleteNamespacePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespacePipelineReleaseByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespacePipelineReleaseByIDMock.expectedInvocations), m.DeleteNamespacePipelineReleaseByIDMock.expectedInvocationsOrigin, afterDeleteNamespacePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockDeleteNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockDeleteNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockDeleteNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteNamespaceSecretByIDExpectation specifies expectation struct of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteNamespaceSecretByIDParams
	paramPtrs          *RepositoryMockDeleteNamespaceSecretByIDParamPtrs
	expectationOrigins RepositoryMockDeleteNamespaceSecretByIDExpectationOrigins
	results            *RepositoryMockDeleteNamespaceSecretByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteNamespaceSecretByIDParams contains parameters of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeleteNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeleteNamespaceSecretByIDResults contains results of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDResults struct {
	err error
}

// RepositoryMockDeleteNamespaceSecretByIDOrigins contains origins of expectations of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Optional() *mRepositoryMockDeleteNamespaceSecretByID {
	mmDeleteNamespaceSecretByID.optional = true
	return mmDeleteNamespaceSecretByID
}

// Expect sets up expected params for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceSecretByID.defaultExpectation.params = &RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceSecretByID.defaultExpectation.params) {
			mmDeleteNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmDeleteNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteNamespaceSecretByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.inspectFuncDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespaceSecretByID")
	}

	mmDeleteNamespaceSecretByID.mock.inspectFuncDeleteNamespaceSecretByID = f

	return mmDeleteNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{mock: mmDeleteNamespaceSecretByID.mock}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.results = &RepositoryMockDeleteNamespaceSecretByIDResults{err}
	mmDeleteNamespaceSecretByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespaceSecretByID method
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespaceSecretByID.defaultExpectation != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespaceSecretByID method")
	}

	if len(mmDeleteNamespaceSecretByID.expectations) > 0 {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespaceSecretByID method")
	}

	mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID = f
	mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceSecretByID.mock
}

// When sets expectation for the Repository.DeleteNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeleteNamespaceSecretByIDExpectation {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespaceSecretByIDExpectation{
		mock:               mmDeleteNamespaceSecretByID.mock,
		params:             &RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id},
		expectationOrigins: RepositoryMockDeleteNamespaceSecretByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespaceSecretByID.expectations = append(mmDeleteNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespaceSecretByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespaceSecretByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespaceSecretByID should be invoked
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Times(n uint64) *mRepositoryMockDeleteNamespaceSecretByID {
	if n == 0 {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceSecretByID.expectedInvocations, n)
	mmDeleteNamespaceSecretByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceSecretByID
}

func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) invocationsDone() bool {
	if len(mmDeleteNamespaceSecretByID.expectations) == 0 && mmDeleteNamespaceSecretByID.defaultExpectation == nil && mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.mock.afterDeleteNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceSecretByID implements mm_repository.Repository
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.beforeDeleteNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.afterDeleteNamespaceSecretByIDCounter, 1)

	mmDeleteNamespaceSecretByID.t.Helper()

	if mmDeleteNamespaceSecretByID.inspectFuncDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.inspectFuncDeleteNamespaceSecretByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.mutex.Lock()
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.callArgs = append(mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.callArgs, &mm_params)
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespaceSecretByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespaceSecretByID.funcDeleteNamespaceSecretByID != nil {
		return mmDeleteNamespaceSecretByID.funcDeleteNamespaceSecretByID(ctx, ownerPermalink, id)
	}
	mmDeleteNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespaceSecretByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeleteNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespaceSecretByID invocations
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.afterDeleteNamespaceSecretByIDCounter)
}

// DeleteNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespaceSecretByID invocations
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.beforeDeleteNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Calls() []*RepositoryMockDeleteNamespaceSecretByIDParams {
	mmDeleteNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespaceSecretByIDParams, len(mmDeleteNamespaceSecretByID.callArgs))
	copy(argCopy, mmDeleteNamespaceSecretByID.callArgs)

	mmDeleteNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceSecretByIDDone returns true if the count of the DeleteNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespaceSecretByIDDone() bool {
	if m.DeleteNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceSecretByIDMock.invocationsDone()
}

// MinimockDeleteNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespaceSecretByIDInspect() {
	for _, e := range m.DeleteNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceSecretByIDMock.defaultExpectation != nil && afterDeleteNamespaceSecretByIDCounter < 1 {
		if m.DeleteNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s", m.DeleteNamespaceSecretByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s with params: %#v", m.DeleteNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceSecretByID != nil && afterDeleteNamespaceSecretByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID at\n%s", m.funcDeleteNamespaceSecretByIDOrigin)
	}

	if !m.DeleteNamespaceSecretByIDMock.invocationsDone() && afterDeleteNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespaceSecretByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceSecretByIDMock.expectedInvocations), m.DeleteNamespaceSecretByIDMock.expectedInvocationsOrigin, afterDeleteNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockDeletePipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeletePipelineTagsExpectation
	expectations       []*RepositoryMockDeletePipelineTagsExpectation

	callArgs []*RepositoryMockDeletePipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeletePipelineTagsExpectation specifies expectation struct of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeletePipelineTagsParams
	paramPtrs          *RepositoryMockDeletePipelineTagsParamPtrs
	expectationOrigins RepositoryMockDeletePipelineTagsExpectationOrigins
	results            *RepositoryMockDeletePipelineTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeletePipelineTagsParams contains parameters of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	tagNames    []string
}

// RepositoryMockDeletePipelineTagsParamPtrs contains pointers to parameters of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	tagNames    *[]string
}

// RepositoryMockDeletePipelineTagsResults contains results of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsResults struct {
	err error
}

// RepositoryMockDeletePipelineTagsOrigins contains origins of expectations of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
	originTagNames    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Optional() *mRepositoryMockDeletePipelineTags {
	mmDeletePipelineTags.optional = true
	return mmDeletePipelineTags
}

// Expect sets up expected params for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by ExpectParams functions")
	}

	mmDeletePipelineTags.defaultExpectation.params = &RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePipelineTags.expectations {
		if minimock.Equal(e.params, mmDeletePipelineTags.defaultExpectation.params) {
			mmDeletePipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelineTags.defaultExpectation.params)
		}
	}

	return mmDeletePipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmDeletePipelineTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.tagNames = &tagNames
	mmDeletePipelineTags.defaultExpectation.expectationOrigins.originTagNames = minimock.CallerInfo(1)

	return mmDeletePipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.inspectFuncDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeletePipelineTags")
	}

	mmDeletePipelineTags.mock.inspectFuncDeletePipelineTags = f

	return mmDeletePipelineTags
}

// Return sets up results that will be returned by Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Return(err error) *RepositoryMock {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{mock: mmDeletePipelineTags.mock}
	}
	mmDeletePipelineTags.defaultExpectation.results = &RepositoryMockDeletePipelineTagsResults{err}
	mmDeletePipelineTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineTags.mock
}

// Set uses given function f to mock the Repository.DeletePipelineTags method
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmDeletePipelineTags.defaultExpectation != nil {
		mmDeletePipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.DeletePipelineTags method")
	}

	if len(mmDeletePipelineTags.expectations) > 0 {
		mmDeletePipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.DeletePipelineTags method")
	}

	mmDeletePipelineTags.mock.funcDeletePipelineTags = f
	mmDeletePipelineTags.mock.funcDeletePipelineTagsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineTags.mock
}

// When sets expectation for the Repository.DeletePipelineTags which will trigger the result defined by the following
// Then helper
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) When(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *RepositoryMockDeletePipelineTagsExpectation {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockDeletePipelineTagsExpectation{
		mock:               mmDeletePipelineTags.mock,
		params:             &RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames},
		expectationOrigins: RepositoryMockDeletePipelineTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePipelineTags.expectations = append(mmDeletePipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeletePipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeletePipelineTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeletePipelineTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.DeletePipelineTags should be invoked
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Times(n uint64) *mRepositoryMockDeletePipelineTags {
	if n == 0 {
		mmDeletePipelineTags.mock.t.Fatalf("Times of RepositoryMock.DeletePipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelineTags.expectedInvocations, n)
	mmDeletePipelineTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePipelineTags
}

func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) invocationsDone() bool {
	if len(mmDeletePipelineTags.expectations) == 0 && mmDeletePipelineTags.defaultExpectation == nil && mmDeletePipelineTags.mock.funcDeletePipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelineTags.mock.afterDeletePipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelineTags implements mm_repository.Repository
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTags(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelineTags.beforeDeletePipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelineTags.afterDeletePipelineTagsCounter, 1)

	mmDeletePipelineTags.t.Helper()

	if mmDeletePipelineTags.inspectFuncDeletePipelineTags != nil {
		mmDeletePipelineTags.inspectFuncDeletePipelineTags(ctx, pipelineUID, tagNames)
	}

	mm_params := RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}

	// Record call args
	mmDeletePipelineTags.DeletePipelineTagsMock.mutex.Lock()
	mmDeletePipelineTags.DeletePipelineTagsMock.callArgs = append(mmDeletePipelineTags.DeletePipelineTagsMock.callArgs, &mm_params)
	mmDeletePipelineTags.DeletePipelineTagsMock.mutex.Unlock()

	for _, e := range mmDeletePipelineTags.DeletePipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter tagNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.originTagNames, *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelineTags.t.Fatal("No results are set for the RepositoryMock.DeletePipelineTags")
		}
		return (*mm_results).err
	}
	if mmDeletePipelineTags.funcDeletePipelineTags != nil {
		return mmDeletePipelineTags.funcDeletePipelineTags(ctx, pipelineUID, tagNames)
	}
	mmDeletePipelineTags.t.Fatalf("Unexpected call to RepositoryMock.DeletePipelineTags. %v %v %v", ctx, pipelineUID, tagNames)
	return
}

// DeletePipelineTagsAfterCounter returns a count of finished RepositoryMock.DeletePipelineTags invocations
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineTags.afterDeletePipelineTagsCounter)
}

// DeletePipelineTagsBeforeCounter returns a count of RepositoryMock.DeletePipelineTags invocations
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineTags.beforeDeletePipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeletePipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Calls() []*RepositoryMockDeletePipelineTagsParams {
	mmDeletePipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockDeletePipelineTagsParams, len(mmDeletePipelineTags.callArgs))
	copy(argCopy, mmDeletePipelineTags.callArgs)

	mmDeletePipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelineTagsDone returns true if the count of the DeletePipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeletePipelineTagsDone() bool {
	if m.DeletePipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelineTagsMock.invocationsDone()
}

// MinimockDeletePipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeletePipelineTagsInspect() {
	for _, e := range m.DeletePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePipelineTagsCounter := mm_atomic.LoadUint64(&m.afterDeletePipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelineTagsMock.defaultExpectation != nil && afterDeletePipelineTagsCounter < 1 {
		if m.DeletePipelineTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s", m.DeletePipelineTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s with params: %#v", m.DeletePipelineTagsMock.defaultExpectation.expectationOrigins.origin, *m.DeletePipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelineTags != nil && afterDeletePipelineTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags at\n%s", m.funcDeletePipelineTagsOrigin)
	}

	if !m.DeletePipelineTagsMock.invocationsDone() && afterDeletePipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeletePipelineTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelineTagsMock.expectedInvocations), m.DeletePipelineTagsMock.expectedInvocationsOrigin, afterDeletePipelineTagsCounter)
	}
}

type mRepositoryMockGetDefinitionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetDefinitionByUIDExpectation
	expectations       []*RepositoryMockGetDefinitionByUIDExpectation

	callArgs []*RepositoryMockGetDefinitionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetDefinitionByUIDExpectation specifies expectation struct of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetDefinitionByUIDParams
	paramPtrs          *RepositoryMockGetDefinitionByUIDParamPtrs
	expectationOrigins RepositoryMockGetDefinitionByUIDExpectationOrigins
	results            *RepositoryMockGetDefinitionByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetDefinitionByUIDParams contains parameters of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// RepositoryMockGetDefinitionByUIDParamPtrs contains pointers to parameters of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
}

// RepositoryMockGetDefinitionByUIDResults contains results of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDResults struct {
	cp1 *datamodel.ComponentDefinition
	err error
}

// RepositoryMockGetDefinitionByUIDOrigins contains origins of expectations of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Optional() *mRepositoryMockGetDefinitionByUID {
	mmGetDefinitionByUID.optional = true
	return mmGetDefinitionByUID
}

// Expect sets up expected params for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Expect(ctx context.Context, u1 uuid.UUID) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by ExpectParams functions")
	}

	mmGetDefinitionByUID.defaultExpectation.params = &RepositoryMockGetDefinitionByUIDParams{ctx, u1}
	mmGetDefinitionByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetDefinitionByUID.expectations {
		if minimock.Equal(e.params, mmGetDefinitionByUID.defaultExpectation.params) {
			mmGetDefinitionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDefinitionByUID.defaultExpectation.params)
		}
	}

	return mmGetDefinitionByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.params != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Expect")
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetDefinitionByUIDParamPtrs{}
	}
	mmGetDefinitionByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetDefinitionByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetDefinitionByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.params != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Expect")
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetDefinitionByUIDParamPtrs{}
	}
	mmGetDefinitionByUID.defaultExpectation.paramPtrs.u1 = &u1
	mmGetDefinitionByUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetDefinitionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.inspectFuncGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetDefinitionByUID")
	}

	mmGetDefinitionByUID.mock.inspectFuncGetDefinitionByUID = f

	return mmGetDefinitionByUID
}

// Return sets up results that will be returned by Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Return(cp1 *datamodel.ComponentDefinition, err error) *RepositoryMock {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{mock: mmGetDefinitionByUID.mock}
	}
	mmGetDefinitionByUID.defaultExpectation.results = &RepositoryMockGetDefinitionByUIDResults{cp1, err}
	mmGetDefinitionByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetDefinitionByUID.mock
}

// Set uses given function f to mock the Repository.GetDefinitionByUID method
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Set(f func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error)) *RepositoryMock {
	if mmGetDefinitionByUID.defaultExpectation != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetDefinitionByUID method")
	}

	if len(mmGetDefinitionByUID.expectations) > 0 {
		mmGetDefinitionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetDefinitionByUID method")
	}

	mmGetDefinitionByUID.mock.funcGetDefinitionByUID = f
	mmGetDefinitionByUID.mock.funcGetDefinitionByUIDOrigin = minimock.CallerInfo(1)
	return mmGetDefinitionByUID.mock
}

// When sets expectation for the Repository.GetDefinitionByUID which will trigger the result defined by the following
// Then helper
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) When(ctx context.Context, u1 uuid.UUID) *RepositoryMockGetDefinitionByUIDExpectation {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetDefinitionByUIDExpectation{
		mock:               mmGetDefinitionByUID.mock,
		params:             &RepositoryMockGetDefinitionByUIDParams{ctx, u1},
		expectationOrigins: RepositoryMockGetDefinitionByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetDefinitionByUID.expectations = append(mmGetDefinitionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetDefinitionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetDefinitionByUIDExpectation) Then(cp1 *datamodel.ComponentDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockGetDefinitionByUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetDefinitionByUID should be invoked
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Times(n uint64) *mRepositoryMockGetDefinitionByUID {
	if n == 0 {
		mmGetDefinitionByUID.mock.t.Fatalf("Times of RepositoryMock.GetDefinitionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDefinitionByUID.expectedInvocations, n)
	mmGetDefinitionByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetDefinitionByUID
}

func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) invocationsDone() bool {
	if len(mmGetDefinitionByUID.expectations) == 0 && mmGetDefinitionByUID.defaultExpectation == nil && mmGetDefinitionByUID.mock.funcGetDefinitionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDefinitionByUID.mock.afterGetDefinitionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDefinitionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDefinitionByUID implements mm_repository.Repository
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUID(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error) {
	mm_atomic.AddUint64(&mmGetDefinitionByUID.beforeGetDefinitionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefinitionByUID.afterGetDefinitionByUIDCounter, 1)

	mmGetDefinitionByUID.t.Helper()

	if mmGetDefinitionByUID.inspectFuncGetDefinitionByUID != nil {
		mmGetDefinitionByUID.inspectFuncGetDefinitionByUID(ctx, u1)
	}

	mm_params := RepositoryMockGetDefinitionByUIDParams{ctx, u1}

	// Record call args
	mmGetDefinitionByUID.GetDefinitionByUIDMock.mutex.Lock()
	mmGetDefinitionByUID.GetDefinitionByUIDMock.callArgs = append(mmGetDefinitionByUID.GetDefinitionByUIDMock.callArgs, &mm_params)
	mmGetDefinitionByUID.GetDefinitionByUIDMock.mutex.Unlock()

	for _, e := range mmGetDefinitionByUID.GetDefinitionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetDefinitionByUIDParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefinitionByUID.t.Fatal("No results are set for the RepositoryMock.GetDefinitionByUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetDefinitionByUID.funcGetDefinitionByUID != nil {
		return mmGetDefinitionByUID.funcGetDefinitionByUID(ctx, u1)
	}
	mmGetDefinitionByUID.t.Fatalf("Unexpected call to RepositoryMock.GetDefinitionByUID. %v %v", ctx, u1)
	return
}

// GetDefinitionByUIDAfterCounter returns a count of finished RepositoryMock.GetDefinitionByUID invocations
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefinitionByUID.afterGetDefinitionByUIDCounter)
}

// GetDefinitionByUIDBeforeCounter returns a count of RepositoryMock.GetDefinitionByUID invocations
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefinitionByUID.beforeGetDefinitionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetDefinitionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Calls() []*RepositoryMockGetDefinitionByUIDParams {
	mmGetDefinitionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetDefinitionByUIDParams, len(mmGetDefinitionByUID.callArgs))
	copy(argCopy, mmGetDefinitionByUID.callArgs)

	mmGetDefinitionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetDefinitionByUIDDone returns true if the count of the GetDefinitionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDefinitionByUIDDone() bool {
	if m.GetDefinitionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDefinitionByUIDMock.invocationsDone()
}

// MinimockGetDefinitionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetDefinitionByUIDInspect() {
	for _, e := range m.GetDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetDefinitionByUIDCounter := mm_atomic.LoadUint64(&m.afterGetDefinitionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefinitionByUIDMock.defaultExpectation != nil && afterGetDefinitionByUIDCounter < 1 {
		if m.GetDefinitionByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s", m.GetDefinitionByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s with params: %#v", m.GetDefinitionByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetDefinitionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefinitionByUID != nil && afterGetDefinitionByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID at\n%s", m.funcGetDefinitionByUIDOrigin)
	}

	if !m.GetDefinitionByUIDMock.invocationsDone() && afterGetDefinitionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetDefinitionByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetDefinitionByUIDMock.expectedInvocations), m.GetDefinitionByUIDMock.expectedInvocationsOrigin, afterGetDefinitionByUIDCounter)
	}
}

type mRepositoryMockGetHubStats struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetHubStatsExpectation
	expectations       []*RepositoryMockGetHubStatsExpectation

	callArgs []*RepositoryMockGetHubStatsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetHubStatsExpectation specifies expectation struct of the Repository.GetHubStats
type RepositoryMockGetHubStatsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetHubStatsParams
	paramPtrs          *RepositoryMockGetHubStatsParamPtrs
	expectationOrigins RepositoryMockGetHubStatsExpectationOrigins
	results            *RepositoryMockGetHubStatsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetHubStatsParams contains parameters of the Repository.GetHubStats
type RepositoryMockGetHubStatsParams struct {
	uidAllowList []uuid.UUID
}

// RepositoryMockGetHubStatsParamPtrs contains pointers to parameters of the Repository.GetHubStats
type RepositoryMockGetHubStatsParamPtrs struct {
	uidAllowList *[]uuid.UUID
}

// RepositoryMockGetHubStatsResults contains results of the Repository.GetHubStats
type RepositoryMockGetHubStatsResults struct {
	hp1 *datamodel.HubStats
	err error
}

// RepositoryMockGetHubStatsOrigins contains origins of expectations of the Repository.GetHubStats
type RepositoryMockGetHubStatsExpectationOrigins struct {
	origin             string
	originUidAllowList string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHubStats *mRepositoryMockGetHubStats) Optional() *mRepositoryMockGetHubStats {
	mmGetHubStats.optional = true
	return mmGetHubStats
}

// Expect sets up expected params for Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Expect(uidAllowList []uuid.UUID) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{}
	}

	if mmGetHubStats.defaultExpectation.paramPtrs != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by ExpectParams functions")
	}

	mmGetHubStats.defaultExpectation.params = &RepositoryMockGetHubStatsParams{uidAllowList}
	mmGetHubStats.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHubStats.expectations {
		if minimock.Equal(e.params, mmGetHubStats.defaultExpectation.params) {
			mmGetHubStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHubStats.defaultExpectation.params)
		}
	}

	return mmGetHubStats
}

// ExpectUidAllowListParam1 sets up expected param uidAllowList for Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) ExpectUidAllowListParam1(uidAllowList []uuid.UUID) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{}
	}

	if mmGetHubStats.defaultExpectation.params != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Expect")
	}

	if mmGetHubStats.defaultExpectation.paramPtrs == nil {
		mmGetHubStats.defaultExpectation.paramPtrs = &RepositoryMockGetHubStatsParamPtrs{}
	}
	mmGetHubStats.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmGetHubStats.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmGetHubStats
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Inspect(f func(uidAllowList []uuid.UUID)) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.inspectFuncGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetHubStats")
	}

	mmGetHubStats.mock.inspectFuncGetHubStats = f

	return mmGetHubStats
}

// Return sets up results that will be returned by Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Return(hp1 *datamodel.HubStats, err error) *RepositoryMock {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{mock: mmGetHubStats.mock}
	}
	mmGetHubStats.defaultExpectation.results = &RepositoryMockGetHubStatsResults{hp1, err}
	mmGetHubStats.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHubStats.mock
}

// Set uses given function f to mock the Repository.GetHubStats method
func (mmGetHubStats *mRepositoryMockGetHubStats) Set(f func(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error)) *RepositoryMock {
	if mmGetHubStats.defaultExpectation != nil {
		mmGetHubStats.mock.t.Fatalf("Default expectation is already set for the Repository.GetHubStats method")
	}

	if len(mmGetHubStats.expectations) > 0 {
		mmGetHubStats.mock.t.Fatalf("Some expectations are already set for the Repository.GetHubStats method")
	}

	mmGetHubStats.mock.funcGetHubStats = f
	mmGetHubStats.mock.funcGetHubStatsOrigin = minimock.CallerInfo(1)
	return mmGetHubStats.mock
}

// When sets expectation for the Repository.GetHubStats which will trigger the result defined by the following
// Then helper
func (mmGetHubStats *mRepositoryMockGetHubStats) When(uidAllowList []uuid.UUID) *RepositoryMockGetHubStatsExpectation {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	expectation := &RepositoryMockGetHubStatsExpectation{
		mock:               mmGetHubStats.mock,
		params:             &RepositoryMockGetHubStatsParams{uidAllowList},
		expectationOrigins: RepositoryMockGetHubStatsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHubStats.expectations = append(mmGetHubStats.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetHubStats return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetHubStatsExpectation) Then(hp1 *datamodel.HubStats, err error) *RepositoryMock {
	e.results = &RepositoryMockGetHubStatsResults{hp1, err}
	return e.mock
}

// Times sets number of times Repository.GetHubStats should be invoked
func (mmGetHubStats *mRepositoryMockGetHubStats) Times(n uint64) *mRepositoryMockGetHubStats {
	if n == 0 {
		mmGetHubStats.mock.t.Fatalf("Times of RepositoryMock.GetHubStats mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHubStats.expectedInvocations, n)
	mmGetHubStats.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHubStats
}

func (mmGetHubStats *mRepositoryMockGetHubStats) invocationsDone() bool {
	if len(mmGetHubStats.expectations) == 0 && mmGetHubStats.defaultExpectation == nil && mmGetHubStats.mock.funcGetHubStats == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHubStats.mock.afterGetHubStatsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHubStats.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHubStats implements mm_repository.Repository
func (mmGetHubStats *RepositoryMock) GetHubStats(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error) {
	mm_atomic.AddUint64(&mmGetHubStats.beforeGetHubStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHubStats.afterGetHubStatsCounter, 1)

	mmGetHubStats.t.Helper()

	if mmGetHubStats.inspectFuncGetHubStats != nil {
		mmGetHubStats.inspectFuncGetHubStats(uidAllowList)
	}

	mm_params := RepositoryMockGetHubStatsParams{uidAllowList}

	// Record call args
	mmGetHubStats.GetHubStatsMock.mutex.Lock()
	mmGetHubStats.GetHubStatsMock.callArgs = append(mmGetHubStats.GetHubStatsMock.callArgs, &mm_params)
	mmGetHubStats.GetHubStatsMock.mutex.Unlock()

	for _, e := range mmGetHubStats.GetHubStatsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmGetHubStats.GetHubStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHubStats.GetHubStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHubStats.GetHubStatsMock.defaultExpectation.params
		mm_want_ptrs := mmGetHubStats.GetHubStatsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetHubStatsParams{uidAllowList}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmGetHubStats.t.Errorf("RepositoryMock.GetHubStats got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHubStats.GetHubStatsMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHubStats.t.Errorf("RepositoryMock.GetHubStats got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHubStats.GetHubStatsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHubStats.GetHubStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHubStats.t.Fatal("No results are set for the RepositoryMock.GetHubStats")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmGetHubStats.funcGetHubStats != nil {
		return mmGetHubStats.funcGetHubStats(uidAllowList)
	}
	mmGetHubStats.t.Fatalf("Unexpected call to RepositoryMock.GetHubStats. %v", uidAllowList)
	return
}

// GetHubStatsAfterCounter returns a count of finished RepositoryMock.GetHubStats invocations
func (mmGetHubStats *RepositoryMock) GetHubStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHubStats.afterGetHubStatsCounter)
}

// GetHubStatsBeforeCounter returns a count of RepositoryMock.GetHubStats invocations
func (mmGetHubStats *RepositoryMock) GetHubStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHubStats.beforeGetHubStatsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetHubStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHubStats *mRepositoryMockGetHubStats) Calls() []*RepositoryMockGetHubStatsParams {
	mmGetHubStats.mutex.RLock()

	argCopy := make([]*RepositoryMockGetHubStatsParams, len(mmGetHubStats.callArgs))
	copy(argCopy, mmGetHubStats.callArgs)

	mmGetHubStats.mutex.RUnlock()

	return argCopy
}

// MinimockGetHubStatsDone returns true if the count of the GetHubStats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetHubStatsDone() bool {
	if m.GetHubStatsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHubStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHubStatsMock.invocationsDone()
}

// MinimockGetHubStatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetHubStatsInspect() {
	for _, e := range m.GetHubStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHubStatsCounter := mm_atomic.LoadUint64(&m.afterGetHubStatsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHubStatsMock.defaultExpectation != nil && afterGetHubStatsCounter < 1 {
		if m.GetHubStatsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s", m.GetHubStatsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s with params: %#v", m.GetHubStatsMock.defaultExpectation.expectationOrigins.origin, *m.GetHubStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHubStats != nil && afterGetHubStatsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetHubStats at\n%s", m.funcGetHubStatsOrigin)
	}

	if !m.GetHubStatsMock.invocationsDone() && afterGetHubStatsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetHubStats at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHubStatsMock.expectedInvocations), m.GetHubStatsMock.expectedInvocationsOrigin, afterGetHubStatsCounter)
	}
}

type mRepositoryMockGetLatestNamespacePipelineRelease struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestNamespacePipelineReleaseExpectation
	expectations       []*RepositoryMockGetLatestNamespacePipelineReleaseExpectation

	callArgs []*RepositoryMockGetLatestNamespacePipelineReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetLatestNamespacePipelineReleaseExpectation specifies expectation struct of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetLatestNamespacePipelineReleaseParams
	paramPtrs          *RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs
	expectationOrigins RepositoryMockGetLatestNamespacePipelineReleaseExpectationOrigins
	results            *RepositoryMockGetLatestNamespacePipelineReleaseResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetLatestNamespacePipelineReleaseParams contains parameters of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	isBasicView    bool
}

// RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs contains pointers to parameters of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	isBasicView    *bool
}

// RepositoryMockGetLatestNamespacePipelineReleaseResults contains results of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// RepositoryMockGetLatestNamespacePipelineReleaseOrigins contains origins of expectations of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originIsBasicView    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Optional() *mRepositoryMockGetLatestNamespacePipelineRelease {
	mmGetLatestNamespacePipelineRelease.optional = true
	return mmGetLatestNamespacePipelineRelease
}

// Expect sets up expected params for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by ExpectParams functions")
	}

	mmGetLatestNamespacePipelineRelease.defaultExpectation.params = &RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLatestNamespacePipelineRelease.expectations {
		if minimock.Equal(e.params, mmGetLatestNamespacePipelineRelease.defaultExpectation.params) {
			mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestNamespacePipelineRelease.defaultExpectation.params)
		}
	}

	return mmGetLatestNamespacePipelineRelease
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLatestNamespacePipelineRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLatestNamespacePipelineRelease
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetLatestNamespacePipelineRelease.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetLatestNamespacePipelineRelease
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmGetLatestNamespacePipelineRelease.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmGetLatestNamespacePipelineRelease
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetLatestNamespacePipelineRelease.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetLatestNamespacePipelineRelease
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool)) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.inspectFuncGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestNamespacePipelineRelease")
	}

	mmGetLatestNamespacePipelineRelease.mock.inspectFuncGetLatestNamespacePipelineRelease = f

	return mmGetLatestNamespacePipelineRelease
}

// Return sets up results that will be returned by Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{mock: mmGetLatestNamespacePipelineRelease.mock}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.results = &RepositoryMockGetLatestNamespacePipelineReleaseResults{pp1, err}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLatestNamespacePipelineRelease.mock
}

// Set uses given function f to mock the Repository.GetLatestNamespacePipelineRelease method
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetLatestNamespacePipelineRelease.defaultExpectation != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestNamespacePipelineRelease method")
	}

	if len(mmGetLatestNamespacePipelineRelease.expectations) > 0 {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestNamespacePipelineRelease method")
	}

	mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease = f
	mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineReleaseOrigin = minimock.CallerInfo(1)
	return mmGetLatestNamespacePipelineRelease.mock
}

// When sets expectation for the Repository.GetLatestNamespacePipelineRelease which will trigger the result defined by the following
// Then helper
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) *RepositoryMockGetLatestNamespacePipelineReleaseExpectation {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{
		mock:               mmGetLatestNamespacePipelineRelease.mock,
		params:             &RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView},
		expectationOrigins: RepositoryMockGetLatestNamespacePipelineReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLatestNamespacePipelineRelease.expectations = append(mmGetLatestNamespacePipelineRelease.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestNamespacePipelineRelease return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestNamespacePipelineReleaseExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestNamespacePipelineReleaseResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestNamespacePipelineRelease should be invoked
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Times(n uint64) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if n == 0 {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Times of RepositoryMock.GetLatestNamespacePipelineRelease mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestNamespacePipelineRelease.expectedInvocations, n)
	mmGetLatestNamespacePipelineRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLatestNamespacePipelineRelease
}

func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) invocationsDone() bool {
	if len(mmGetLatestNamespacePipelineRelease.expectations) == 0 && mmGetLatestNamespacePipelineRelease.defaultExpectation == nil && mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.mock.afterGetLatestNamespacePipelineReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestNamespacePipelineRelease implements mm_repository.Repository
func (mmGetLatestNamespacePipelineRelease *RepositoryMock) GetLatestNamespacePipelineRelease(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetLatestNamespacePipelineRelease.beforeGetLatestNamespacePipelineReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestNamespacePipelineRelease.afterGetLatestNamespacePipelineReleaseCounter, 1)

	mmGetLatestNamespacePipelineRelease.t.Helper()

	if mmGetLatestNamespacePipelineRelease.inspectFuncGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.inspectFuncGetLatestNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, isBasicView)
	}

	mm_params := RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}

	// Record call args
	mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.mutex.Lock()
	mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.callArgs = append(mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.callArgs, &mm_params)
	mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.mutex.Unlock()

	for _, e := range mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestNamespacePipelineRelease.t.Fatal("No results are set for the RepositoryMock.GetLatestNamespacePipelineRelease")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetLatestNamespacePipelineRelease.funcGetLatestNamespacePipelineRelease != nil {
		return mmGetLatestNamespacePipelineRelease.funcGetLatestNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, isBasicView)
	}
	mmGetLatestNamespacePipelineRelease.t.Fatalf("Unexpected call to RepositoryMock.GetLatestNamespacePipelineRelease. %v %v %v %v", ctx, ownerPermalink, pipelineUID, isBasicView)
	return
}

// GetLatestNamespacePipelineReleaseAfterCounter returns a count of finished RepositoryMock.GetLatestNamespacePipelineRelease invocations
func (mmGetLatestNamespacePipelineRelease *RepositoryMock) GetLatestNamespacePipelineReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.afterGetLatestNamespacePipelineReleaseCounter)
}

// GetLatestNamespacePipelineReleaseBeforeCounter returns a count of RepositoryMock.GetLatestNamespacePipelineRelease invocations
func (mmGetLatestNamespacePipelineRelease *RepositoryMock) GetLatestNamespacePipelineReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.beforeGetLatestNamespacePipelineReleaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestNamespacePipelineRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Calls() []*RepositoryMockGetLatestNamespacePipelineReleaseParams {
	mmGetLatestNamespacePipelineRelease.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestNamespacePipelineReleaseParams, len(mmGetLatestNamespacePipelineRelease.callArgs))
	copy(argCopy, mmGetLatestNamespacePipelineRelease.callArgs)

	mmGetLatestNamespacePipelineRelease.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestNamespacePipelineReleaseDone returns true if the count of the GetLatestNamespacePipelineRelease invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestNamespacePipelineReleaseDone() bool {
	if m.GetLatestNamespacePipelineReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestNamespacePipelineReleaseMock.invocationsDone()
}

// MinimockGetLatestNamespacePipelineReleaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestNamespacePipelineReleaseInspect() {
	for _, e := range m.GetLatestNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLatestNamespacePipelineReleaseCounter := mm_atomic.LoadUint64(&m.afterGetLatestNamespacePipelineReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestNamespacePipelineReleaseMock.defaultExpectation != nil && afterGetLatestNamespacePipelineReleaseCounter < 1 {
		if m.GetLatestNamespacePipelineReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease at\n%s", m.GetLatestNamespacePipelineReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease at\n%s with params: %#v", m.GetLatestNamespacePipelineReleaseMock.defaultExpectation.expectationOrigins.origin, *m.GetLatestNamespacePipelineReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestNamespacePipelineRelease != nil && afterGetLatestNamespacePipelineReleaseCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease at\n%s", m.funcGetLatestNamespacePipelineReleaseOrigin)
	}

	if !m.GetLatestNamespacePipelineReleaseMock.invocationsDone() && afterGetLatestNamespacePipelineReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestNamespacePipelineRelease at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestNamespacePipelineReleaseMock.expectedInvocations), m.GetLatestNamespacePipelineReleaseMock.expectedInvocationsOrigin, afterGetLatestNamespacePipelineReleaseCounter)
	}
}

type mRepositoryMockGetNamespaceConnectionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespaceConnectionByIDExpectation
	expectations       []*RepositoryMockGetNamespaceConnectionByIDExpectation

	callArgs []*RepositoryMockGetNamespaceConnectionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNamespaceConnectionByIDExpectation specifies expectation struct of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNamespaceConnectionByIDParams
	paramPtrs          *RepositoryMockGetNamespaceConnectionByIDParamPtrs
	expectationOrigins RepositoryMockGetNamespaceConnectionByIDExpectationOrigins
	results            *RepositoryMockGetNamespaceConnectionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNamespaceConnectionByIDParams contains parameters of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDParams struct {
	ctx   context.Context
	nsUID uuid.UUID
	id    string
}

// RepositoryMockGetNamespaceConnectionByIDParamPtrs contains pointers to parameters of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDParamPtrs struct {
	ctx   *context.Context
	nsUID *uuid.UUID
	id    *string
}

// RepositoryMockGetNamespaceConnectionByIDResults contains results of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDResults struct {
	cp1 *datamodel.Connection
	err error
}

// RepositoryMockGetNamespaceConnectionByIDOrigins contains origins of expectations of the Repository.GetNamespaceConnectionByID
type RepositoryMockGetNamespaceConnectionByIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originNsUID string
	originId    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Optional() *mRepositoryMockGetNamespaceConnectionByID {
	mmGetNamespaceConnectionByID.optional = true
	return mmGetNamespaceConnectionByID
}

// Expect sets up expected params for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Expect(ctx context.Context, nsUID uuid.UUID, id string) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceConnectionByID.defaultExpectation.params = &RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id}
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceConnectionByID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceConnectionByID.defaultExpectation.params) {
			mmGetNamespaceConnectionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceConnectionByID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceConnectionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.params != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Expect")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceConnectionByIDParamPtrs{}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceConnectionByID
}

// ExpectNsUIDParam2 sets up expected param nsUID for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) ExpectNsUIDParam2(nsUID uuid.UUID) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.params != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Expect")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceConnectionByIDParamPtrs{}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs.nsUID = &nsUID
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.originNsUID = minimock.CallerInfo(1)

	return mmGetNamespaceConnectionByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{}
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.params != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Expect")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceConnectionByIDParamPtrs{}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.paramPtrs.id = &id
	mmGetNamespaceConnectionByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetNamespaceConnectionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Inspect(f func(ctx context.Context, nsUID uuid.UUID, id string)) *mRepositoryMockGetNamespaceConnectionByID {
	if mmGetNamespaceConnectionByID.mock.inspectFuncGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespaceConnectionByID")
	}

	mmGetNamespaceConnectionByID.mock.inspectFuncGetNamespaceConnectionByID = f

	return mmGetNamespaceConnectionByID
}

// Return sets up results that will be returned by Repository.GetNamespaceConnectionByID
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Return(cp1 *datamodel.Connection, err error) *RepositoryMock {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	if mmGetNamespaceConnectionByID.defaultExpectation == nil {
		mmGetNamespaceConnectionByID.defaultExpectation = &RepositoryMockGetNamespaceConnectionByIDExpectation{mock: mmGetNamespaceConnectionByID.mock}
	}
	mmGetNamespaceConnectionByID.defaultExpectation.results = &RepositoryMockGetNamespaceConnectionByIDResults{cp1, err}
	mmGetNamespaceConnectionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceConnectionByID.mock
}

// Set uses given function f to mock the Repository.GetNamespaceConnectionByID method
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Set(f func(ctx context.Context, nsUID uuid.UUID, id string) (cp1 *datamodel.Connection, err error)) *RepositoryMock {
	if mmGetNamespaceConnectionByID.defaultExpectation != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespaceConnectionByID method")
	}

	if len(mmGetNamespaceConnectionByID.expectations) > 0 {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespaceConnectionByID method")
	}

	mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID = f
	mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceConnectionByID.mock
}

// When sets expectation for the Repository.GetNamespaceConnectionByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) When(ctx context.Context, nsUID uuid.UUID, id string) *RepositoryMockGetNamespaceConnectionByIDExpectation {
	if mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("RepositoryMock.GetNamespaceConnectionByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespaceConnectionByIDExpectation{
		mock:               mmGetNamespaceConnectionByID.mock,
		params:             &RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id},
		expectationOrigins: RepositoryMockGetNamespaceConnectionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceConnectionByID.expectations = append(mmGetNamespaceConnectionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespaceConnectionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespaceConnectionByIDExpectation) Then(cp1 *datamodel.Connection, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespaceConnectionByIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespaceConnectionByID should be invoked
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Times(n uint64) *mRepositoryMockGetNamespaceConnectionByID {
	if n == 0 {
		mmGetNamespaceConnectionByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespaceConnectionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceConnectionByID.expectedInvocations, n)
	mmGetNamespaceConnectionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceConnectionByID
}

func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) invocationsDone() bool {
	if len(mmGetNamespaceConnectionByID.expectations) == 0 && mmGetNamespaceConnectionByID.defaultExpectation == nil && mmGetNamespaceConnectionByID.mock.funcGetNamespaceConnectionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.mock.afterGetNamespaceConnectionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceConnectionByID implements mm_repository.Repository
func (mmGetNamespaceConnectionByID *RepositoryMock) GetNamespaceConnectionByID(ctx context.Context, nsUID uuid.UUID, id string) (cp1 *datamodel.Connection, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceConnectionByID.beforeGetNamespaceConnectionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceConnectionByID.afterGetNamespaceConnectionByIDCounter, 1)

	mmGetNamespaceConnectionByID.t.Helper()

	if mmGetNamespaceConnectionByID.inspectFuncGetNamespaceConnectionByID != nil {
		mmGetNamespaceConnectionByID.inspectFuncGetNamespaceConnectionByID(ctx, nsUID, id)
	}

	mm_params := RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id}

	// Record call args
	mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.mutex.Lock()
	mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.callArgs = append(mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.callArgs, &mm_params)
	mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespaceConnectionByIDParams{ctx, nsUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.nsUID != nil && !minimock.Equal(*mm_want_ptrs.nsUID, mm_got.nsUID) {
				mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameter nsUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originNsUID, *mm_want_ptrs.nsUID, mm_got.nsUID, minimock.Diff(*mm_want_ptrs.nsUID, mm_got.nsUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceConnectionByID.t.Errorf("RepositoryMock.GetNamespaceConnectionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceConnectionByID.GetNamespaceConnectionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceConnectionByID.t.Fatal("No results are set for the RepositoryMock.GetNamespaceConnectionByID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetNamespaceConnectionByID.funcGetNamespaceConnectionByID != nil {
		return mmGetNamespaceConnectionByID.funcGetNamespaceConnectionByID(ctx, nsUID, id)
	}
	mmGetNamespaceConnectionByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespaceConnectionByID. %v %v %v", ctx, nsUID, id)
	return
}

// GetNamespaceConnectionByIDAfterCounter returns a count of finished RepositoryMock.GetNamespaceConnectionByID invocations
func (mmGetNamespaceConnectionByID *RepositoryMock) GetNamespaceConnectionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.afterGetNamespaceConnectionByIDCounter)
}

// GetNamespaceConnectionByIDBeforeCounter returns a count of RepositoryMock.GetNamespaceConnectionByID invocations
func (mmGetNamespaceConnectionByID *RepositoryMock) GetNamespaceConnectionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceConnectionByID.beforeGetNamespaceConnectionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespaceConnectionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceConnectionByID *mRepositoryMockGetNamespaceConnectionByID) Calls() []*RepositoryMockGetNamespaceConnectionByIDParams {
	mmGetNamespaceConnectionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespaceConnectionByIDParams, len(mmGetNamespaceConnectionByID.callArgs))
	copy(argCopy, mmGetNamespaceConnectionByID.callArgs)

	mmGetNamespaceConnectionByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceConnectionByIDDone returns true if the count of the GetNamespaceConnectionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespaceConnectionByIDDone() bool {
	if m.GetNamespaceConnectionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceConnectionByIDMock.invocationsDone()
}

// MinimockGetNamespaceConnectionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespaceConnectionByIDInspect() {
	for _, e := range m.GetNamespaceConnectionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceConnectionByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceConnectionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceConnectionByIDMock.defaultExpectation != nil && afterGetNamespaceConnectionByIDCounter < 1 {
		if m.GetNamespaceConnectionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s", m.GetNamespaceConnectionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s with params: %#v", m.GetNamespaceConnectionByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceConnectionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceConnectionByID != nil && afterGetNamespaceConnectionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNamespaceConnectionByID at\n%s", m.funcGetNamespaceConnectionByIDOrigin)
	}

	if !m.GetNamespaceConnectionByIDMock.invocationsDone() && afterGetNamespaceConnectionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespaceConnectionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceConnectionByIDMock.expectedInvocations), m.GetNamespaceConnectionByIDMock.expectedInvocationsOrigin, afterGetNamespaceConnectionByIDCounter)
	}
}

type mRepositoryMockGetNamespacePipelineByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespacePipelineByIDExpectation
	expectations       []*RepositoryMockGetNamespacePipelineByIDExpectation

	callArgs []*RepositoryMockGetNamespacePipelineByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNamespacePipelineByIDExpectation specifies expectation struct of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNamespacePipelineByIDParams
	paramPtrs          *RepositoryMockGetNamespacePipelineByIDParamPtrs
	expectationOrigins RepositoryMockGetNamespacePipelineByIDExpectationOrigins
	results            *RepositoryMockGetNamespacePipelineByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNamespacePipelineByIDParams contains parameters of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	isBasicView    bool
	embedReleases  bool
}

// RepositoryMockGetNamespacePipelineByIDParamPtrs contains pointers to parameters of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	isBasicView    *bool
	embedReleases  *bool
}

// RepositoryMockGetNamespacePipelineByIDResults contains results of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// RepositoryMockGetNamespacePipelineByIDOrigins contains origins of expectations of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originIsBasicView    string
	originEmbedReleases  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Optional() *mRepositoryMockGetNamespacePipelineByID {
	mmGetNamespacePipelineByID.optional = true
	return mmGetNamespacePipelineByID
}

// Expect sets up expected params for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Expect(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by ExpectParams functions")
	}

	mmGetNamespacePipelineByID.defaultExpectation.params = &RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}
	mmGetNamespacePipelineByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespacePipelineByID.expectations {
		if minimock.Equal(e.params, mmGetNamespacePipelineByID.defaultExpectation.params) {
			mmGetNamespacePipelineByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespacePipelineByID.defaultExpectation.params)
		}
	}

	return mmGetNamespacePipelineByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespacePipelineByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespacePipelineByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetNamespacePipelineByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetNamespacePipelineByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.id = &id
	mmGetNamespacePipelineByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetNamespacePipelineByID
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetNamespacePipelineByID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetNamespacePipelineByID
}

// ExpectEmbedReleasesParam5 sets up expected param embedReleases for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectEmbedReleasesParam5(embedReleases bool) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmGetNamespacePipelineByID.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmGetNamespacePipelineByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool)) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.inspectFuncGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespacePipelineByID")
	}

	mmGetNamespacePipelineByID.mock.inspectFuncGetNamespacePipelineByID = f

	return mmGetNamespacePipelineByID
}

// Return sets up results that will be returned by Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{mock: mmGetNamespacePipelineByID.mock}
	}
	mmGetNamespacePipelineByID.defaultExpectation.results = &RepositoryMockGetNamespacePipelineByIDResults{pp1, err}
	mmGetNamespacePipelineByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespacePipelineByID.mock
}

// Set uses given function f to mock the Repository.GetNamespacePipelineByID method
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Set(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetNamespacePipelineByID.defaultExpectation != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespacePipelineByID method")
	}

	if len(mmGetNamespacePipelineByID.expectations) > 0 {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespacePipelineByID method")
	}

	mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID = f
	mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespacePipelineByID.mock
}

// When sets expectation for the Repository.GetNamespacePipelineByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) When(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) *RepositoryMockGetNamespacePipelineByIDExpectation {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespacePipelineByIDExpectation{
		mock:               mmGetNamespacePipelineByID.mock,
		params:             &RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases},
		expectationOrigins: RepositoryMockGetNamespacePipelineByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespacePipelineByID.expectations = append(mmGetNamespacePipelineByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespacePipelineByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespacePipelineByIDExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespacePipelineByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespacePipelineByID should be invoked
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Times(n uint64) *mRepositoryMockGetNamespacePipelineByID {
	if n == 0 {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespacePipelineByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespacePipelineByID.expectedInvocations, n)
	mmGetNamespacePipelineByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespacePipelineByID
}

func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) invocationsDone() bool {
	if len(mmGetNamespacePipelineByID.expectations) == 0 && mmGetNamespacePipelineByID.defaultExpectation == nil && mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.mock.afterGetNamespacePipelineByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespacePipelineByID implements mm_repository.Repository
func (mmGetNamespacePipelineByID *RepositoryMock) GetNamespacePipelineByID(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetNamespacePipelineByID.beforeGetNamespacePipelineByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespacePipelineByID.afterGetNamespacePipelineByIDCounter, 1)

	mmGetNamespacePipelineByID.t.Helper()

	if mmGetNamespacePipelineByID.inspectFuncGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.inspectFuncGetNamespacePipelineByID(ctx, ownerPermalink, id, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}

	// Record call args
	mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.mutex.Lock()
	mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.callArgs = append(mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.callArgs, &mm_params)
	mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespacePipelineByID.t.Fatal("No results are set for the RepositoryMock.GetNamespacePipelineByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetNamespacePipelineByID.funcGetNamespacePipelineByID != nil {
		return mmGetNamespacePipelineByID.funcGetNamespacePipelineByID(ctx, ownerPermalink, id, isBasicView, embedReleases)
	}
	mmGetNamespacePipelineByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespacePipelineByID. %v %v %v %v %v", ctx, ownerPermalink, id, isBasicView, embedReleases)
	return
}

// GetNamespacePipelineByIDAfterCounter returns a count of finished RepositoryMock.GetNamespacePipelineByID invocations
func (mmGetNamespacePipelineByID *RepositoryMock) GetNamespacePipelineByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.afterGetNamespacePipelineByIDCounter)
}

// GetNamespacePipelineByIDBeforeCounter returns a count of RepositoryMock.GetNamespacePipelineByID invocations
func (mmGetNamespacePipelineByID *RepositoryMock) GetNamespacePipelineByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.beforeGetNamespacePipelineByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespacePipelineByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Calls() []*RepositoryMockGetNamespacePipelineByIDParams {
	mmGetNamespacePipelineByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespacePipelineByIDParams, len(mmGetNamespacePipelineByID.callArgs))
	copy(argCopy, mmGetNamespacePipelineByID.callArgs)

	mmGetNamespacePipelineByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespacePipelineByIDDone returns true if the count of the GetNamespacePipelineByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespacePipelineByIDDone() bool {
	if m.GetNamespacePipelineByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespacePipelineByIDMock.invocationsDone()
}

// MinimockGetNamespacePipelineByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespacePipelineByIDInspect() {
	for _, e := range m.GetNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespacePipelineByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespacePipelineByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespacePipelineByIDMock.defaultExpectation != nil && afterGetNamespacePipelineByIDCounter < 1 {
		if m.GetNamespacePipelineByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineByID at\n%s", m.GetNamespacePipelineByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineByID at\n%s with params: %#v", m.GetNamespacePipelineByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespacePipelineByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespacePipelineByID != nil && afterGetNamespacePipelineByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineByID at\n%s", m.funcGetNamespacePipelineByIDOrigin)
	}

	if !m.GetNamespacePipelineByIDMock.invocationsDone() && afterGetNamespacePipelineByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespacePipelineByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespacePipelineByIDMock.expectedInvocations), m.GetNamespacePipelineByIDMock.expectedInvocationsOrigin, afterGetNamespacePipelineByIDCounter)
	}
}

type mRepositoryMockGetNamespacePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespacePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockGetNamespacePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockGetNamespacePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNamespacePipelineReleaseByIDExpectation specifies expectation struct of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNamespacePipelineReleaseByIDParams
	paramPtrs          *RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs
	expectationOrigins RepositoryMockGetNamespacePipelineReleaseByIDExpectationOrigins
	results            *RepositoryMockGetNamespacePipelineReleaseByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNamespacePipelineReleaseByIDParams contains parameters of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
	isBasicView    bool
}

// RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
	isBasicView    *bool
}

// RepositoryMockGetNamespacePipelineReleaseByIDResults contains results of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// RepositoryMockGetNamespacePipelineReleaseByIDOrigins contains origins of expectations of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originId             string
	originIsBasicView    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Optional() *mRepositoryMockGetNamespacePipelineReleaseByID {
	mmGetNamespacePipelineReleaseByID.optional = true
	return mmGetNamespacePipelineReleaseByID
}

// Expect sets up expected params for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmGetNamespacePipelineReleaseByID.defaultExpectation.params = &RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespacePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmGetNamespacePipelineReleaseByID.defaultExpectation.params) {
			mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespacePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmGetNamespacePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespacePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetNamespacePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmGetNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmGetNamespacePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id
	mmGetNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetNamespacePipelineReleaseByID
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetNamespacePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool)) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.inspectFuncGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespacePipelineReleaseByID")
	}

	mmGetNamespacePipelineReleaseByID.mock.inspectFuncGetNamespacePipelineReleaseByID = f

	return mmGetNamespacePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{mock: mmGetNamespacePipelineReleaseByID.mock}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.results = &RepositoryMockGetNamespacePipelineReleaseByIDResults{pp1, err}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespacePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.GetNamespacePipelineReleaseByID method
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetNamespacePipelineReleaseByID.defaultExpectation != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespacePipelineReleaseByID method")
	}

	if len(mmGetNamespacePipelineReleaseByID.expectations) > 0 {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespacePipelineReleaseByID method")
	}

	mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID = f
	mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespacePipelineReleaseByID.mock
}

// When sets expectation for the Repository.GetNamespacePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) *RepositoryMockGetNamespacePipelineReleaseByIDExpectation {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{
		mock:               mmGetNamespacePipelineReleaseByID.mock,
		params:             &RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView},
		expectationOrigins: RepositoryMockGetNamespacePipelineReleaseByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespacePipelineReleaseByID.expectations = append(mmGetNamespacePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespacePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespacePipelineReleaseByIDExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespacePipelineReleaseByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespacePipelineReleaseByID should be invoked
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Times(n uint64) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if n == 0 {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespacePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespacePipelineReleaseByID.expectedInvocations, n)
	mmGetNamespacePipelineReleaseByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespacePipelineReleaseByID
}

func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) invocationsDone() bool {
	if len(mmGetNamespacePipelineReleaseByID.expectations) == 0 && mmGetNamespacePipelineReleaseByID.defaultExpectation == nil && mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.mock.afterGetNamespacePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespacePipelineReleaseByID implements mm_repository.Repository
func (mmGetNamespacePipelineReleaseByID *RepositoryMock) GetNamespacePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetNamespacePipelineReleaseByID.beforeGetNamespacePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespacePipelineReleaseByID.afterGetNamespacePipelineReleaseByIDCounter, 1)

	mmGetNamespacePipelineReleaseByID.t.Helper()

	if mmGetNamespacePipelineReleaseByID.inspectFuncGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.inspectFuncGetNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, isBasicView)
	}

	mm_params := RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}

	// Record call args
	mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.mutex.Lock()
	mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.callArgs = append(mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.callArgs, &mm_params)
	mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespacePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.GetNamespacePipelineReleaseByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetNamespacePipelineReleaseByID.funcGetNamespacePipelineReleaseByID != nil {
		return mmGetNamespacePipelineReleaseByID.funcGetNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, isBasicView)
	}
	mmGetNamespacePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespacePipelineReleaseByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, isBasicView)
	return
}

// GetNamespacePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.GetNamespacePipelineReleaseByID invocations
func (mmGetNamespacePipelineReleaseByID *RepositoryMock) GetNamespacePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.afterGetNamespacePipelineReleaseByIDCounter)
}

// GetNamespacePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.GetNamespacePipelineReleaseByID invocations
func (mmGetNamespacePipelineReleaseByID *RepositoryMock) GetNamespacePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.beforeGetNamespacePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespacePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Calls() []*RepositoryMockGetNamespacePipelineReleaseByIDParams {
	mmGetNamespacePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespacePipelineReleaseByIDParams, len(mmGetNamespacePipelineReleaseByID.callArgs))
	copy(argCopy, mmGetNamespacePipelineReleaseByID.callArgs)

	mmGetNamespacePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespacePipelineReleaseByIDDone returns true if the count of the GetNamespacePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespacePipelineReleaseByIDDone() bool {
	if m.GetNamespacePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespacePipelineReleaseByIDMock.invocationsDone()
}

// MinimockGetNamespacePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespacePipelineReleaseByIDInspect() {
	for _, e := range m.GetNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespacePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespacePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespacePipelineReleaseByIDMock.defaultExpectation != nil && afterGetNamespacePipelineReleaseByIDCounter < 1 {
		if m.GetNamespacePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID at\n%s", m.GetNamespacePipelineReleaseByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID at\n%s with params: %#v", m.GetNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespacePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespacePipelineReleaseByID != nil && afterGetNamespacePipelineReleaseByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID at\n%s", m.funcGetNamespacePipelineReleaseByIDOrigin)
	}

	if !m.GetNamespacePipelineReleaseByIDMock.invocationsDone() && afterGetNamespacePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespacePipelineReleaseByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespacePipelineReleaseByIDMock.expectedInvocations), m.GetNamespacePipelineReleaseByIDMock.expectedInvocationsOrigin, afterGetNamespacePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockGetNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockGetNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockGetNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNamespaceSecretByIDExpectation specifies expectation struct of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNamespaceSecretByIDParams
	paramPtrs          *RepositoryMockGetNamespaceSecretByIDParamPtrs
	expectationOrigins RepositoryMockGetNamespaceSecretByIDExpectationOrigins
	results            *RepositoryMockGetNamespaceSecretByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNamespaceSecretByIDParams contains parameters of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockGetNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockGetNamespaceSecretByIDResults contains results of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDResults struct {
	sp1 *datamodel.Secret
	err error
}

// RepositoryMockGetNamespaceSecretByIDOrigins contains origins of expectations of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Optional() *mRepositoryMockGetNamespaceSecretByID {
	mmGetNamespaceSecretByID.optional = true
	return mmGetNamespaceSecretByID
}

// Expect sets up expected params for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceSecretByID.defaultExpectation.params = &RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceSecretByID.defaultExpectation.params) {
			mmGetNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id
	mmGetNamespaceSecretByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.inspectFuncGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespaceSecretByID")
	}

	mmGetNamespaceSecretByID.mock.inspectFuncGetNamespaceSecretByID = f

	return mmGetNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Return(sp1 *datamodel.Secret, err error) *RepositoryMock {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{mock: mmGetNamespaceSecretByID.mock}
	}
	mmGetNamespaceSecretByID.defaultExpectation.results = &RepositoryMockGetNamespaceSecretByIDResults{sp1, err}
	mmGetNamespaceSecretByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.GetNamespaceSecretByID method
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error)) *RepositoryMock {
	if mmGetNamespaceSecretByID.defaultExpectation != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespaceSecretByID method")
	}

	if len(mmGetNamespaceSecretByID.expectations) > 0 {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespaceSecretByID method")
	}

	mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID = f
	mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceSecretByID.mock
}

// When sets expectation for the Repository.GetNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockGetNamespaceSecretByIDExpectation {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespaceSecretByIDExpectation{
		mock:               mmGetNamespaceSecretByID.mock,
		params:             &RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id},
		expectationOrigins: RepositoryMockGetNamespaceSecretByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceSecretByID.expectations = append(mmGetNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespaceSecretByIDExpectation) Then(sp1 *datamodel.Secret, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespaceSecretByIDResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespaceSecretByID should be invoked
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Times(n uint64) *mRepositoryMockGetNamespaceSecretByID {
	if n == 0 {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceSecretByID.expectedInvocations, n)
	mmGetNamespaceSecretByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceSecretByID
}

func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) invocationsDone() bool {
	if len(mmGetNamespaceSecretByID.expectations) == 0 && mmGetNamespaceSecretByID.defaultExpectation == nil && mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.mock.afterGetNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceSecretByID implements mm_repository.Repository
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceSecretByID.beforeGetNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceSecretByID.afterGetNamespaceSecretByIDCounter, 1)

	mmGetNamespaceSecretByID.t.Helper()

	if mmGetNamespaceSecretByID.inspectFuncGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.inspectFuncGetNamespaceSecretByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.mutex.Lock()
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.callArgs = append(mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.callArgs, &mm_params)
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.GetNamespaceSecretByID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetNamespaceSecretByID.funcGetNamespaceSecretByID != nil {
		return mmGetNamespaceSecretByID.funcGetNamespaceSecretByID(ctx, ownerPermalink, id)
	}
	mmGetNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespaceSecretByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// GetNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.GetNamespaceSecretByID invocations
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.afterGetNamespaceSecretByIDCounter)
}

// GetNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.GetNamespaceSecretByID invocations
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.beforeGetNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Calls() []*RepositoryMockGetNamespaceSecretByIDParams {
	mmGetNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespaceSecretByIDParams, len(mmGetNamespaceSecretByID.callArgs))
	copy(argCopy, mmGetNamespaceSecretByID.callArgs)

	mmGetNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceSecretByIDDone returns true if the count of the GetNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespaceSecretByIDDone() bool {
	if m.GetNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceSecretByIDMock.invocationsDone()
}

// MinimockGetNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespaceSecretByIDInspect() {
	for _, e := range m.GetNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceSecretByIDMock.defaultExpectation != nil && afterGetNamespaceSecretByIDCounter < 1 {
		if m.GetNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s", m.GetNamespaceSecretByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s with params: %#v", m.GetNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceSecretByID != nil && afterGetNamespaceSecretByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID at\n%s", m.funcGetNamespaceSecretByIDOrigin)
	}

	if !m.GetNamespaceSecretByIDMock.invocationsDone() && afterGetNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespaceSecretByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceSecretByIDMock.expectedInvocations), m.GetNamespaceSecretByIDMock.expectedInvocationsOrigin, afterGetNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation
	expectations       []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation

	callArgs []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation specifies expectation struct of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams
	paramPtrs          *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs
	expectationOrigins RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectationOrigins
	results            *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams contains parameters of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams struct {
	ctx           context.Context
	pipelineRunID string
	page          int
	pageSize      int
	filter        filtering.Filter
	order         ordering.OrderBy
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs contains pointers to parameters of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs struct {
	ctx           *context.Context
	pipelineRunID *string
	page          *int
	pageSize      *int
	filter        *filtering.Filter
	order         *ordering.OrderBy
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults contains results of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults struct {
	ca1 []datamodel.ComponentRun
	i1  int64
	err error
}

// RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigins contains origins of expectations of the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
type RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectationOrigins struct {
	origin              string
	originCtx           string
	originPipelineRunID string
	originPage          string
	originPageSize      string
	originFilter        string
	originOrder         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Optional() *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.optional = true
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// Expect sets up expected params for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Expect(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by ExpectParams functions")
	}

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations {
		if minimock.Equal(e.params, mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params) {
			mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params)
		}
	}

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectPipelineRunIDParam2 sets up expected param pipelineRunID for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectPipelineRunIDParam2(pipelineRunID string) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.pipelineRunID = &pipelineRunID
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originPipelineRunID = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectPageParam3 sets up expected param page for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectPageParam3(page int) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.page = &page
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectPageSizeParam4 sets up expected param pageSize for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectPageSizeParam4(pageSize int) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectFilterParam5 sets up expected param filter for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.filter = &filter
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// ExpectOrderParam6 sets up expected param order for Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) ExpectOrderParam6(order ordering.OrderBy) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParamPtrs{}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.paramPtrs.order = &order
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Inspect(f func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy)) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions")
	}

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions = f

	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

// Return sets up results that will be returned by Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Return(ca1 []datamodel.ComponentRun, i1 int64, err error) *RepositoryMock {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{mock: mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock}
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.results = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults{ca1, i1, err}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock
}

// Set uses given function f to mock the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions method
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Set(f func(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) (ca1 []datamodel.ComponentRun, i1 int64, err error)) *RepositoryMock {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Default expectation is already set for the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions method")
	}

	if len(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations) > 0 {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Some expectations are already set for the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions method")
	}

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions = f
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock
}

// When sets expectation for the Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions which will trigger the result defined by the following
// Then helper
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) When(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation {
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock is already set by Set")
	}

	expectation := &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation{
		mock:               mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock,
		params:             &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order},
		expectationOrigins: RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations = append(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsExpectation) Then(ca1 []datamodel.ComponentRun, i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsResults{ca1, i1, err}
	return e.mock
}

// Times sets number of times Repository.GetPaginatedComponentRunsByPipelineRunIDWithPermissions should be invoked
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Times(n uint64) *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions {
	if n == 0 {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.t.Fatalf("Times of RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectedInvocations, n)
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions
}

func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) invocationsDone() bool {
	if len(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectations) == 0 && mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.defaultExpectation == nil && mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mock.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPaginatedComponentRunsByPipelineRunIDWithPermissions implements mm_repository.Repository
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *RepositoryMock) GetPaginatedComponentRunsByPipelineRunIDWithPermissions(ctx context.Context, pipelineRunID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy) (ca1 []datamodel.ComponentRun, i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.beforeGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter, 1)

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Helper()

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.inspectFuncGetPaginatedComponentRunsByPipelineRunIDWithPermissions(ctx, pipelineRunID, page, pageSize, filter, order)
	}

	mm_params := RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order}

	// Record call args
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.mutex.Lock()
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.callArgs = append(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.callArgs, &mm_params)
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.mutex.Unlock()

	for _, e := range mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.i1, e.results.err
		}
	}

	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams{ctx, pipelineRunID, page, pageSize, filter, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineRunID != nil && !minimock.Equal(*mm_want_ptrs.pipelineRunID, mm_got.pipelineRunID) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter pipelineRunID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originPipelineRunID, *mm_want_ptrs.pipelineRunID, mm_got.pipelineRunID, minimock.Diff(*mm_want_ptrs.pipelineRunID, mm_got.pipelineRunID))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Errorf("RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Fatal("No results are set for the RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions")
		}
		return (*mm_results).ca1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil {
		return mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions(ctx, pipelineRunID, page, pageSize, filter, order)
	}
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.t.Fatalf("Unexpected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions. %v %v %v %v %v %v", ctx, pipelineRunID, page, pageSize, filter, order)
	return
}

// GetPaginatedComponentRunsByPipelineRunIDWithPermissionsAfterCounter returns a count of finished RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions invocations
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *RepositoryMock) GetPaginatedComponentRunsByPipelineRunIDWithPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
}

// GetPaginatedComponentRunsByPipelineRunIDWithPermissionsBeforeCounter returns a count of RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions invocations
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *RepositoryMock) GetPaginatedComponentRunsByPipelineRunIDWithPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.beforeGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions *mRepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissions) Calls() []*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams {
	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsParams, len(mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.callArgs))
	copy(argCopy, mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.callArgs)

	mmGetPaginatedComponentRunsByPipelineRunIDWithPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsDone returns true if the count of the GetPaginatedComponentRunsByPipelineRunIDWithPermissions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsDone() bool {
	if m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.invocationsDone()
}

// MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsInspect() {
	for _, e := range m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter := mm_atomic.LoadUint64(&m.afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation != nil && afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter < 1 {
		if m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s", m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s with params: %#v", m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissions != nil && afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s", m.funcGetPaginatedComponentRunsByPipelineRunIDWithPermissionsOrigin)
	}

	if !m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.invocationsDone() && afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPaginatedComponentRunsByPipelineRunIDWithPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectedInvocations), m.GetPaginatedComponentRunsByPipelineRunIDWithPermissionsMock.expectedInvocationsOrigin, afterGetPaginatedComponentRunsByPipelineRunIDWithPermissionsCounter)
	}
}

type mRepositoryMockGetPaginatedPipelineRunsByRequester struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation
	expectations       []*RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation

	callArgs []*RepositoryMockGetPaginatedPipelineRunsByRequesterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation specifies expectation struct of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPaginatedPipelineRunsByRequesterParams
	paramPtrs          *RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs
	expectationOrigins RepositoryMockGetPaginatedPipelineRunsByRequesterExpectationOrigins
	results            *RepositoryMockGetPaginatedPipelineRunsByRequesterResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterParams contains parameters of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterParams struct {
	ctx    context.Context
	params mm_repository.GetPipelineRunsByRequesterParams
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs contains pointers to parameters of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs struct {
	ctx    *context.Context
	params *mm_repository.GetPipelineRunsByRequesterParams
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterResults contains results of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterResults struct {
	pa1 []datamodel.PipelineRun
	i1  int64
	err error
}

// RepositoryMockGetPaginatedPipelineRunsByRequesterOrigins contains origins of expectations of the Repository.GetPaginatedPipelineRunsByRequester
type RepositoryMockGetPaginatedPipelineRunsByRequesterExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Optional() *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	mmGetPaginatedPipelineRunsByRequester.optional = true
	return mmGetPaginatedPipelineRunsByRequester
}

// Expect sets up expected params for Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Expect(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{}
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by ExpectParams functions")
	}

	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params = &RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPaginatedPipelineRunsByRequester.expectations {
		if minimock.Equal(e.params, mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params) {
			mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params)
		}
	}

	return mmGetPaginatedPipelineRunsByRequester
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{}
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs{}
	}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsByRequester
}

// ExpectParamsParam2 sets up expected param params for Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) ExpectParamsParam2(params mm_repository.GetPipelineRunsByRequesterParams) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{}
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsByRequesterParamPtrs{}
	}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.paramPtrs.params = &params
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsByRequester
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Inspect(f func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams)) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if mmGetPaginatedPipelineRunsByRequester.mock.inspectFuncGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPaginatedPipelineRunsByRequester")
	}

	mmGetPaginatedPipelineRunsByRequester.mock.inspectFuncGetPaginatedPipelineRunsByRequester = f

	return mmGetPaginatedPipelineRunsByRequester
}

// Return sets up results that will be returned by Repository.GetPaginatedPipelineRunsByRequester
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Return(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsByRequester.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{mock: mmGetPaginatedPipelineRunsByRequester.mock}
	}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.results = &RepositoryMockGetPaginatedPipelineRunsByRequesterResults{pa1, i1, err}
	mmGetPaginatedPipelineRunsByRequester.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsByRequester.mock
}

// Set uses given function f to mock the Repository.GetPaginatedPipelineRunsByRequester method
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Set(f func(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) (pa1 []datamodel.PipelineRun, i1 int64, err error)) *RepositoryMock {
	if mmGetPaginatedPipelineRunsByRequester.defaultExpectation != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Default expectation is already set for the Repository.GetPaginatedPipelineRunsByRequester method")
	}

	if len(mmGetPaginatedPipelineRunsByRequester.expectations) > 0 {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Some expectations are already set for the Repository.GetPaginatedPipelineRunsByRequester method")
	}

	mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester = f
	mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequesterOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsByRequester.mock
}

// When sets expectation for the Repository.GetPaginatedPipelineRunsByRequester which will trigger the result defined by the following
// Then helper
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) When(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) *RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation {
	if mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsByRequester mock is already set by Set")
	}

	expectation := &RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation{
		mock:               mmGetPaginatedPipelineRunsByRequester.mock,
		params:             &RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params},
		expectationOrigins: RepositoryMockGetPaginatedPipelineRunsByRequesterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPaginatedPipelineRunsByRequester.expectations = append(mmGetPaginatedPipelineRunsByRequester.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPaginatedPipelineRunsByRequester return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPaginatedPipelineRunsByRequesterExpectation) Then(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPaginatedPipelineRunsByRequesterResults{pa1, i1, err}
	return e.mock
}

// Times sets number of times Repository.GetPaginatedPipelineRunsByRequester should be invoked
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Times(n uint64) *mRepositoryMockGetPaginatedPipelineRunsByRequester {
	if n == 0 {
		mmGetPaginatedPipelineRunsByRequester.mock.t.Fatalf("Times of RepositoryMock.GetPaginatedPipelineRunsByRequester mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPaginatedPipelineRunsByRequester.expectedInvocations, n)
	mmGetPaginatedPipelineRunsByRequester.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsByRequester
}

func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) invocationsDone() bool {
	if len(mmGetPaginatedPipelineRunsByRequester.expectations) == 0 && mmGetPaginatedPipelineRunsByRequester.defaultExpectation == nil && mmGetPaginatedPipelineRunsByRequester.mock.funcGetPaginatedPipelineRunsByRequester == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.mock.afterGetPaginatedPipelineRunsByRequesterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPaginatedPipelineRunsByRequester implements mm_repository.Repository
func (mmGetPaginatedPipelineRunsByRequester *RepositoryMock) GetPaginatedPipelineRunsByRequester(ctx context.Context, params mm_repository.GetPipelineRunsByRequesterParams) (pa1 []datamodel.PipelineRun, i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsByRequester.beforeGetPaginatedPipelineRunsByRequesterCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsByRequester.afterGetPaginatedPipelineRunsByRequesterCounter, 1)

	mmGetPaginatedPipelineRunsByRequester.t.Helper()

	if mmGetPaginatedPipelineRunsByRequester.inspectFuncGetPaginatedPipelineRunsByRequester != nil {
		mmGetPaginatedPipelineRunsByRequester.inspectFuncGetPaginatedPipelineRunsByRequester(ctx, params)
	}

	mm_params := RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params}

	// Record call args
	mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.mutex.Lock()
	mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.callArgs = append(mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.callArgs, &mm_params)
	mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.mutex.Unlock()

	for _, e := range mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.i1, e.results.err
		}
	}

	if mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.params
		mm_want_ptrs := mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPaginatedPipelineRunsByRequesterParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPaginatedPipelineRunsByRequester.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsByRequester got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetPaginatedPipelineRunsByRequester.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsByRequester got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPaginatedPipelineRunsByRequester.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsByRequester got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPaginatedPipelineRunsByRequester.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPaginatedPipelineRunsByRequester.t.Fatal("No results are set for the RepositoryMock.GetPaginatedPipelineRunsByRequester")
		}
		return (*mm_results).pa1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetPaginatedPipelineRunsByRequester.funcGetPaginatedPipelineRunsByRequester != nil {
		return mmGetPaginatedPipelineRunsByRequester.funcGetPaginatedPipelineRunsByRequester(ctx, params)
	}
	mmGetPaginatedPipelineRunsByRequester.t.Fatalf("Unexpected call to RepositoryMock.GetPaginatedPipelineRunsByRequester. %v %v", ctx, params)
	return
}

// GetPaginatedPipelineRunsByRequesterAfterCounter returns a count of finished RepositoryMock.GetPaginatedPipelineRunsByRequester invocations
func (mmGetPaginatedPipelineRunsByRequester *RepositoryMock) GetPaginatedPipelineRunsByRequesterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.afterGetPaginatedPipelineRunsByRequesterCounter)
}

// GetPaginatedPipelineRunsByRequesterBeforeCounter returns a count of RepositoryMock.GetPaginatedPipelineRunsByRequester invocations
func (mmGetPaginatedPipelineRunsByRequester *RepositoryMock) GetPaginatedPipelineRunsByRequesterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsByRequester.beforeGetPaginatedPipelineRunsByRequesterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPaginatedPipelineRunsByRequester.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPaginatedPipelineRunsByRequester *mRepositoryMockGetPaginatedPipelineRunsByRequester) Calls() []*RepositoryMockGetPaginatedPipelineRunsByRequesterParams {
	mmGetPaginatedPipelineRunsByRequester.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPaginatedPipelineRunsByRequesterParams, len(mmGetPaginatedPipelineRunsByRequester.callArgs))
	copy(argCopy, mmGetPaginatedPipelineRunsByRequester.callArgs)

	mmGetPaginatedPipelineRunsByRequester.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaginatedPipelineRunsByRequesterDone returns true if the count of the GetPaginatedPipelineRunsByRequester invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsByRequesterDone() bool {
	if m.GetPaginatedPipelineRunsByRequesterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaginatedPipelineRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaginatedPipelineRunsByRequesterMock.invocationsDone()
}

// MinimockGetPaginatedPipelineRunsByRequesterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsByRequesterInspect() {
	for _, e := range m.GetPaginatedPipelineRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaginatedPipelineRunsByRequesterCounter := mm_atomic.LoadUint64(&m.afterGetPaginatedPipelineRunsByRequesterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation != nil && afterGetPaginatedPipelineRunsByRequesterCounter < 1 {
		if m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s", m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s with params: %#v", m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *m.GetPaginatedPipelineRunsByRequesterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPaginatedPipelineRunsByRequester != nil && afterGetPaginatedPipelineRunsByRequesterCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s", m.funcGetPaginatedPipelineRunsByRequesterOrigin)
	}

	if !m.GetPaginatedPipelineRunsByRequesterMock.invocationsDone() && afterGetPaginatedPipelineRunsByRequesterCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPaginatedPipelineRunsByRequester at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaginatedPipelineRunsByRequesterMock.expectedInvocations), m.GetPaginatedPipelineRunsByRequesterMock.expectedInvocationsOrigin, afterGetPaginatedPipelineRunsByRequesterCounter)
	}
}

type mRepositoryMockGetPaginatedPipelineRunsWithPermissions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation
	expectations       []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation

	callArgs []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation specifies expectation struct of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams
	paramPtrs          *RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs
	expectationOrigins RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectationOrigins
	results            *RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams contains parameters of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams struct {
	ctx          context.Context
	requesterUID string
	pipelineUID  string
	page         int
	pageSize     int
	filter       filtering.Filter
	order        ordering.OrderBy
	isOwner      bool
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs contains pointers to parameters of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs struct {
	ctx          *context.Context
	requesterUID *string
	pipelineUID  *string
	page         *int
	pageSize     *int
	filter       *filtering.Filter
	order        *ordering.OrderBy
	isOwner      *bool
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults contains results of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults struct {
	pa1 []datamodel.PipelineRun
	i1  int64
	err error
}

// RepositoryMockGetPaginatedPipelineRunsWithPermissionsOrigins contains origins of expectations of the Repository.GetPaginatedPipelineRunsWithPermissions
type RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectationOrigins struct {
	origin             string
	originCtx          string
	originRequesterUID string
	originPipelineUID  string
	originPage         string
	originPageSize     string
	originFilter       string
	originOrder        string
	originIsOwner      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Optional() *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	mmGetPaginatedPipelineRunsWithPermissions.optional = true
	return mmGetPaginatedPipelineRunsWithPermissions
}

// Expect sets up expected params for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Expect(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by ExpectParams functions")
	}

	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPaginatedPipelineRunsWithPermissions.expectations {
		if minimock.Equal(e.params, mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params) {
			mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params)
		}
	}

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectRequesterUIDParam2 sets up expected param requesterUID for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectRequesterUIDParam2(requesterUID string) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.requesterUID = &requesterUID
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originRequesterUID = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectPipelineUIDParam3(pipelineUID string) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectPageParam4 sets up expected param page for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectPageParam4(page int) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.page = &page
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectPageSizeParam5 sets up expected param pageSize for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectPageSizeParam5(pageSize int) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectFilterParam6 sets up expected param filter for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectFilterParam6(filter filtering.Filter) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.filter = &filter
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectOrderParam7 sets up expected param order for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectOrderParam7(order ordering.OrderBy) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.order = &order
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// ExpectIsOwnerParam8 sets up expected param isOwner for Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) ExpectIsOwnerParam8(isOwner bool) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.params != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Expect")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParamPtrs{}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.paramPtrs.isOwner = &isOwner
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.expectationOrigins.originIsOwner = minimock.CallerInfo(1)

	return mmGetPaginatedPipelineRunsWithPermissions
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Inspect(f func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool)) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.inspectFuncGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPaginatedPipelineRunsWithPermissions")
	}

	mmGetPaginatedPipelineRunsWithPermissions.mock.inspectFuncGetPaginatedPipelineRunsWithPermissions = f

	return mmGetPaginatedPipelineRunsWithPermissions
}

// Return sets up results that will be returned by Repository.GetPaginatedPipelineRunsWithPermissions
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Return(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil {
		mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{mock: mmGetPaginatedPipelineRunsWithPermissions.mock}
	}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.results = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults{pa1, i1, err}
	mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsWithPermissions.mock
}

// Set uses given function f to mock the Repository.GetPaginatedPipelineRunsWithPermissions method
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Set(f func(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) (pa1 []datamodel.PipelineRun, i1 int64, err error)) *RepositoryMock {
	if mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Default expectation is already set for the Repository.GetPaginatedPipelineRunsWithPermissions method")
	}

	if len(mmGetPaginatedPipelineRunsWithPermissions.expectations) > 0 {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Some expectations are already set for the Repository.GetPaginatedPipelineRunsWithPermissions method")
	}

	mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions = f
	mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissionsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsWithPermissions.mock
}

// When sets expectation for the Repository.GetPaginatedPipelineRunsWithPermissions which will trigger the result defined by the following
// Then helper
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) When(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) *RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation {
	if mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock is already set by Set")
	}

	expectation := &RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation{
		mock:               mmGetPaginatedPipelineRunsWithPermissions.mock,
		params:             &RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner},
		expectationOrigins: RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPaginatedPipelineRunsWithPermissions.expectations = append(mmGetPaginatedPipelineRunsWithPermissions.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPaginatedPipelineRunsWithPermissions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPaginatedPipelineRunsWithPermissionsExpectation) Then(pa1 []datamodel.PipelineRun, i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPaginatedPipelineRunsWithPermissionsResults{pa1, i1, err}
	return e.mock
}

// Times sets number of times Repository.GetPaginatedPipelineRunsWithPermissions should be invoked
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Times(n uint64) *mRepositoryMockGetPaginatedPipelineRunsWithPermissions {
	if n == 0 {
		mmGetPaginatedPipelineRunsWithPermissions.mock.t.Fatalf("Times of RepositoryMock.GetPaginatedPipelineRunsWithPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPaginatedPipelineRunsWithPermissions.expectedInvocations, n)
	mmGetPaginatedPipelineRunsWithPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPaginatedPipelineRunsWithPermissions
}

func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) invocationsDone() bool {
	if len(mmGetPaginatedPipelineRunsWithPermissions.expectations) == 0 && mmGetPaginatedPipelineRunsWithPermissions.defaultExpectation == nil && mmGetPaginatedPipelineRunsWithPermissions.mock.funcGetPaginatedPipelineRunsWithPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.mock.afterGetPaginatedPipelineRunsWithPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPaginatedPipelineRunsWithPermissions implements mm_repository.Repository
func (mmGetPaginatedPipelineRunsWithPermissions *RepositoryMock) GetPaginatedPipelineRunsWithPermissions(ctx context.Context, requesterUID string, pipelineUID string, page int, pageSize int, filter filtering.Filter, order ordering.OrderBy, isOwner bool) (pa1 []datamodel.PipelineRun, i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsWithPermissions.beforeGetPaginatedPipelineRunsWithPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsWithPermissions.afterGetPaginatedPipelineRunsWithPermissionsCounter, 1)

	mmGetPaginatedPipelineRunsWithPermissions.t.Helper()

	if mmGetPaginatedPipelineRunsWithPermissions.inspectFuncGetPaginatedPipelineRunsWithPermissions != nil {
		mmGetPaginatedPipelineRunsWithPermissions.inspectFuncGetPaginatedPipelineRunsWithPermissions(ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner)
	}

	mm_params := RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner}

	// Record call args
	mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.mutex.Lock()
	mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.callArgs = append(mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.callArgs, &mm_params)
	mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.mutex.Unlock()

	for _, e := range mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.i1, e.results.err
		}
	}

	if mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams{ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.requesterUID != nil && !minimock.Equal(*mm_want_ptrs.requesterUID, mm_got.requesterUID) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter requesterUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originRequesterUID, *mm_want_ptrs.requesterUID, mm_got.requesterUID, minimock.Diff(*mm_want_ptrs.requesterUID, mm_got.requesterUID))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.isOwner != nil && !minimock.Equal(*mm_want_ptrs.isOwner, mm_got.isOwner) {
				mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameter isOwner, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.originIsOwner, *mm_want_ptrs.isOwner, mm_got.isOwner, minimock.Diff(*mm_want_ptrs.isOwner, mm_got.isOwner))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPaginatedPipelineRunsWithPermissions.t.Errorf("RepositoryMock.GetPaginatedPipelineRunsWithPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPaginatedPipelineRunsWithPermissions.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPaginatedPipelineRunsWithPermissions.t.Fatal("No results are set for the RepositoryMock.GetPaginatedPipelineRunsWithPermissions")
		}
		return (*mm_results).pa1, (*mm_results).i1, (*mm_results).err
	}
	if mmGetPaginatedPipelineRunsWithPermissions.funcGetPaginatedPipelineRunsWithPermissions != nil {
		return mmGetPaginatedPipelineRunsWithPermissions.funcGetPaginatedPipelineRunsWithPermissions(ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner)
	}
	mmGetPaginatedPipelineRunsWithPermissions.t.Fatalf("Unexpected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions. %v %v %v %v %v %v %v %v", ctx, requesterUID, pipelineUID, page, pageSize, filter, order, isOwner)
	return
}

// GetPaginatedPipelineRunsWithPermissionsAfterCounter returns a count of finished RepositoryMock.GetPaginatedPipelineRunsWithPermissions invocations
func (mmGetPaginatedPipelineRunsWithPermissions *RepositoryMock) GetPaginatedPipelineRunsWithPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.afterGetPaginatedPipelineRunsWithPermissionsCounter)
}

// GetPaginatedPipelineRunsWithPermissionsBeforeCounter returns a count of RepositoryMock.GetPaginatedPipelineRunsWithPermissions invocations
func (mmGetPaginatedPipelineRunsWithPermissions *RepositoryMock) GetPaginatedPipelineRunsWithPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPaginatedPipelineRunsWithPermissions.beforeGetPaginatedPipelineRunsWithPermissionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPaginatedPipelineRunsWithPermissions *mRepositoryMockGetPaginatedPipelineRunsWithPermissions) Calls() []*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams {
	mmGetPaginatedPipelineRunsWithPermissions.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPaginatedPipelineRunsWithPermissionsParams, len(mmGetPaginatedPipelineRunsWithPermissions.callArgs))
	copy(argCopy, mmGetPaginatedPipelineRunsWithPermissions.callArgs)

	mmGetPaginatedPipelineRunsWithPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockGetPaginatedPipelineRunsWithPermissionsDone returns true if the count of the GetPaginatedPipelineRunsWithPermissions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsWithPermissionsDone() bool {
	if m.GetPaginatedPipelineRunsWithPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPaginatedPipelineRunsWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPaginatedPipelineRunsWithPermissionsMock.invocationsDone()
}

// MinimockGetPaginatedPipelineRunsWithPermissionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPaginatedPipelineRunsWithPermissionsInspect() {
	for _, e := range m.GetPaginatedPipelineRunsWithPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPaginatedPipelineRunsWithPermissionsCounter := mm_atomic.LoadUint64(&m.afterGetPaginatedPipelineRunsWithPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation != nil && afterGetPaginatedPipelineRunsWithPermissionsCounter < 1 {
		if m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s", m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s with params: %#v", m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.GetPaginatedPipelineRunsWithPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPaginatedPipelineRunsWithPermissions != nil && afterGetPaginatedPipelineRunsWithPermissionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s", m.funcGetPaginatedPipelineRunsWithPermissionsOrigin)
	}

	if !m.GetPaginatedPipelineRunsWithPermissionsMock.invocationsDone() && afterGetPaginatedPipelineRunsWithPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPaginatedPipelineRunsWithPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPaginatedPipelineRunsWithPermissionsMock.expectedInvocations), m.GetPaginatedPipelineRunsWithPermissionsMock.expectedInvocationsOrigin, afterGetPaginatedPipelineRunsWithPermissionsCounter)
	}
}

type mRepositoryMockGetPipelineByIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByIDAdminExpectation
	expectations       []*RepositoryMockGetPipelineByIDAdminExpectation

	callArgs []*RepositoryMockGetPipelineByIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineByIDAdminExpectation specifies expectation struct of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineByIDAdminParams
	paramPtrs          *RepositoryMockGetPipelineByIDAdminParamPtrs
	expectationOrigins RepositoryMockGetPipelineByIDAdminExpectationOrigins
	results            *RepositoryMockGetPipelineByIDAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineByIDAdminParams contains parameters of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminParams struct {
	ctx           context.Context
	id            string
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByIDAdminParamPtrs contains pointers to parameters of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminParamPtrs struct {
	ctx           *context.Context
	id            *string
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByIDAdminResults contains results of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// RepositoryMockGetPipelineByIDAdminOrigins contains origins of expectations of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminExpectationOrigins struct {
	origin              string
	originCtx           string
	originId            string
	originIsBasicView   string
	originEmbedReleases string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Optional() *mRepositoryMockGetPipelineByIDAdmin {
	mmGetPipelineByIDAdmin.optional = true
	return mmGetPipelineByIDAdmin
}

// Expect sets up expected params for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Expect(ctx context.Context, id string, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetPipelineByIDAdmin.defaultExpectation.params = &RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineByIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetPipelineByIDAdmin.defaultExpectation.params) {
			mmGetPipelineByIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetPipelineByIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// ExpectIdParam2 sets up expected param id for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectIdParam2(id string) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.id = &id
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmGetPipelineByIDAdmin.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmGetPipelineByIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Inspect(f func(ctx context.Context, id string, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.inspectFuncGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByIDAdmin")
	}

	mmGetPipelineByIDAdmin.mock.inspectFuncGetPipelineByIDAdmin = f

	return mmGetPipelineByIDAdmin
}

// Return sets up results that will be returned by Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{mock: mmGetPipelineByIDAdmin.mock}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.results = &RepositoryMockGetPipelineByIDAdminResults{pp1, err}
	mmGetPipelineByIDAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetPipelineByIDAdmin method
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Set(f func(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByIDAdmin.defaultExpectation != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByIDAdmin method")
	}

	if len(mmGetPipelineByIDAdmin.expectations) > 0 {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByIDAdmin method")
	}

	mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin = f
	mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdminOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByIDAdmin.mock
}

// When sets expectation for the Repository.GetPipelineByIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) When(ctx context.Context, id string, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByIDAdminExpectation {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByIDAdminExpectation{
		mock:               mmGetPipelineByIDAdmin.mock,
		params:             &RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases},
		expectationOrigins: RepositoryMockGetPipelineByIDAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineByIDAdmin.expectations = append(mmGetPipelineByIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByIDAdminExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByIDAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByIDAdmin should be invoked
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Times(n uint64) *mRepositoryMockGetPipelineByIDAdmin {
	if n == 0 {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByIDAdmin.expectedInvocations, n)
	mmGetPipelineByIDAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByIDAdmin
}

func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) invocationsDone() bool {
	if len(mmGetPipelineByIDAdmin.expectations) == 0 && mmGetPipelineByIDAdmin.defaultExpectation == nil && mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.mock.afterGetPipelineByIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByIDAdmin implements mm_repository.Repository
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdmin(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.beforeGetPipelineByIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.afterGetPipelineByIDAdminCounter, 1)

	mmGetPipelineByIDAdmin.t.Helper()

	if mmGetPipelineByIDAdmin.inspectFuncGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.inspectFuncGetPipelineByIDAdmin(ctx, id, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.mutex.Lock()
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.callArgs = append(mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.callArgs, &mm_params)
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.mutex.Unlock()

	for _, e := range mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetPipelineByIDAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByIDAdmin.funcGetPipelineByIDAdmin != nil {
		return mmGetPipelineByIDAdmin.funcGetPipelineByIDAdmin(ctx, id, isBasicView, embedReleases)
	}
	mmGetPipelineByIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByIDAdmin. %v %v %v %v", ctx, id, isBasicView, embedReleases)
	return
}

// GetPipelineByIDAdminAfterCounter returns a count of finished RepositoryMock.GetPipelineByIDAdmin invocations
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.afterGetPipelineByIDAdminCounter)
}

// GetPipelineByIDAdminBeforeCounter returns a count of RepositoryMock.GetPipelineByIDAdmin invocations
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.beforeGetPipelineByIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Calls() []*RepositoryMockGetPipelineByIDAdminParams {
	mmGetPipelineByIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByIDAdminParams, len(mmGetPipelineByIDAdmin.callArgs))
	copy(argCopy, mmGetPipelineByIDAdmin.callArgs)

	mmGetPipelineByIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByIDAdminDone returns true if the count of the GetPipelineByIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByIDAdminDone() bool {
	if m.GetPipelineByIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByIDAdminMock.invocationsDone()
}

// MinimockGetPipelineByIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByIDAdminInspect() {
	for _, e := range m.GetPipelineByIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineByIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByIDAdminMock.defaultExpectation != nil && afterGetPipelineByIDAdminCounter < 1 {
		if m.GetPipelineByIDAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s", m.GetPipelineByIDAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s with params: %#v", m.GetPipelineByIDAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineByIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByIDAdmin != nil && afterGetPipelineByIDAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin at\n%s", m.funcGetPipelineByIDAdminOrigin)
	}

	if !m.GetPipelineByIDAdminMock.invocationsDone() && afterGetPipelineByIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByIDAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByIDAdminMock.expectedInvocations), m.GetPipelineByIDAdminMock.expectedInvocationsOrigin, afterGetPipelineByIDAdminCounter)
	}
}

type mRepositoryMockGetPipelineByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByUIDExpectation
	expectations       []*RepositoryMockGetPipelineByUIDExpectation

	callArgs []*RepositoryMockGetPipelineByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineByUIDExpectation specifies expectation struct of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineByUIDParams
	paramPtrs          *RepositoryMockGetPipelineByUIDParamPtrs
	expectationOrigins RepositoryMockGetPipelineByUIDExpectationOrigins
	results            *RepositoryMockGetPipelineByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineByUIDParams contains parameters of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByUIDParamPtrs contains pointers to parameters of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByUIDResults contains results of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// RepositoryMockGetPipelineByUIDOrigins contains origins of expectations of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDExpectationOrigins struct {
	origin              string
	originCtx           string
	originUid           string
	originIsBasicView   string
	originEmbedReleases string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Optional() *mRepositoryMockGetPipelineByUID {
	mmGetPipelineByUID.optional = true
	return mmGetPipelineByUID
}

// Expect sets up expected params for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by ExpectParams functions")
	}

	mmGetPipelineByUID.defaultExpectation.params = &RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineByUID.expectations {
		if minimock.Equal(e.params, mmGetPipelineByUID.defaultExpectation.params) {
			mmGetPipelineByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByUID.defaultExpectation.params)
		}
	}

	return mmGetPipelineByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmGetPipelineByUID.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmGetPipelineByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.inspectFuncGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByUID")
	}

	mmGetPipelineByUID.mock.inspectFuncGetPipelineByUID = f

	return mmGetPipelineByUID
}

// Return sets up results that will be returned by Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{mock: mmGetPipelineByUID.mock}
	}
	mmGetPipelineByUID.defaultExpectation.results = &RepositoryMockGetPipelineByUIDResults{pp1, err}
	mmGetPipelineByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUID.mock
}

// Set uses given function f to mock the Repository.GetPipelineByUID method
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByUID.defaultExpectation != nil {
		mmGetPipelineByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByUID method")
	}

	if len(mmGetPipelineByUID.expectations) > 0 {
		mmGetPipelineByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByUID method")
	}

	mmGetPipelineByUID.mock.funcGetPipelineByUID = f
	mmGetPipelineByUID.mock.funcGetPipelineByUIDOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUID.mock
}

// When sets expectation for the Repository.GetPipelineByUID which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) When(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByUIDExpectation {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByUIDExpectation{
		mock:               mmGetPipelineByUID.mock,
		params:             &RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases},
		expectationOrigins: RepositoryMockGetPipelineByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineByUID.expectations = append(mmGetPipelineByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByUIDExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByUIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByUID should be invoked
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Times(n uint64) *mRepositoryMockGetPipelineByUID {
	if n == 0 {
		mmGetPipelineByUID.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByUID.expectedInvocations, n)
	mmGetPipelineByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUID
}

func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) invocationsDone() bool {
	if len(mmGetPipelineByUID.expectations) == 0 && mmGetPipelineByUID.defaultExpectation == nil && mmGetPipelineByUID.mock.funcGetPipelineByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUID.mock.afterGetPipelineByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByUID implements mm_repository.Repository
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUID(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByUID.beforeGetPipelineByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByUID.afterGetPipelineByUIDCounter, 1)

	mmGetPipelineByUID.t.Helper()

	if mmGetPipelineByUID.inspectFuncGetPipelineByUID != nil {
		mmGetPipelineByUID.inspectFuncGetPipelineByUID(ctx, uid, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByUID.GetPipelineByUIDMock.mutex.Lock()
	mmGetPipelineByUID.GetPipelineByUIDMock.callArgs = append(mmGetPipelineByUID.GetPipelineByUIDMock.callArgs, &mm_params)
	mmGetPipelineByUID.GetPipelineByUIDMock.mutex.Unlock()

	for _, e := range mmGetPipelineByUID.GetPipelineByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByUID.t.Fatal("No results are set for the RepositoryMock.GetPipelineByUID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByUID.funcGetPipelineByUID != nil {
		return mmGetPipelineByUID.funcGetPipelineByUID(ctx, uid, isBasicView, embedReleases)
	}
	mmGetPipelineByUID.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByUID. %v %v %v %v", ctx, uid, isBasicView, embedReleases)
	return
}

// GetPipelineByUIDAfterCounter returns a count of finished RepositoryMock.GetPipelineByUID invocations
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUID.afterGetPipelineByUIDCounter)
}

// GetPipelineByUIDBeforeCounter returns a count of RepositoryMock.GetPipelineByUID invocations
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUID.beforeGetPipelineByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Calls() []*RepositoryMockGetPipelineByUIDParams {
	mmGetPipelineByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByUIDParams, len(mmGetPipelineByUID.callArgs))
	copy(argCopy, mmGetPipelineByUID.callArgs)

	mmGetPipelineByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByUIDDone returns true if the count of the GetPipelineByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByUIDDone() bool {
	if m.GetPipelineByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByUIDMock.invocationsDone()
}

// MinimockGetPipelineByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByUIDInspect() {
	for _, e := range m.GetPipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineByUIDCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByUIDMock.defaultExpectation != nil && afterGetPipelineByUIDCounter < 1 {
		if m.GetPipelineByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s", m.GetPipelineByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s with params: %#v", m.GetPipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByUID != nil && afterGetPipelineByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID at\n%s", m.funcGetPipelineByUIDOrigin)
	}

	if !m.GetPipelineByUIDMock.invocationsDone() && afterGetPipelineByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByUIDMock.expectedInvocations), m.GetPipelineByUIDMock.expectedInvocationsOrigin, afterGetPipelineByUIDCounter)
	}
}

type mRepositoryMockGetPipelineByUIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByUIDAdminExpectation
	expectations       []*RepositoryMockGetPipelineByUIDAdminExpectation

	callArgs []*RepositoryMockGetPipelineByUIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineByUIDAdminExpectation specifies expectation struct of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineByUIDAdminParams
	paramPtrs          *RepositoryMockGetPipelineByUIDAdminParamPtrs
	expectationOrigins RepositoryMockGetPipelineByUIDAdminExpectationOrigins
	results            *RepositoryMockGetPipelineByUIDAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineByUIDAdminParams contains parameters of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByUIDAdminParamPtrs contains pointers to parameters of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByUIDAdminResults contains results of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// RepositoryMockGetPipelineByUIDAdminOrigins contains origins of expectations of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminExpectationOrigins struct {
	origin              string
	originCtx           string
	originUid           string
	originIsBasicView   string
	originEmbedReleases string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Optional() *mRepositoryMockGetPipelineByUIDAdmin {
	mmGetPipelineByUIDAdmin.optional = true
	return mmGetPipelineByUIDAdmin
}

// Expect sets up expected params for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetPipelineByUIDAdmin.defaultExpectation.params = &RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases}
	mmGetPipelineByUIDAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineByUIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetPipelineByUIDAdmin.defaultExpectation.params) {
			mmGetPipelineByUIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByUIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetPipelineByUIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineByUIDAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineByUIDAdmin
}

// ExpectUidParam2 sets up expected param uid for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.uid = &uid
	mmGetPipelineByUIDAdmin.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetPipelineByUIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineByUIDAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineByUIDAdmin
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmGetPipelineByUIDAdmin.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmGetPipelineByUIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.inspectFuncGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByUIDAdmin")
	}

	mmGetPipelineByUIDAdmin.mock.inspectFuncGetPipelineByUIDAdmin = f

	return mmGetPipelineByUIDAdmin
}

// Return sets up results that will be returned by Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{mock: mmGetPipelineByUIDAdmin.mock}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.results = &RepositoryMockGetPipelineByUIDAdminResults{pp1, err}
	mmGetPipelineByUIDAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetPipelineByUIDAdmin method
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByUIDAdmin.defaultExpectation != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByUIDAdmin method")
	}

	if len(mmGetPipelineByUIDAdmin.expectations) > 0 {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByUIDAdmin method")
	}

	mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin = f
	mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdminOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUIDAdmin.mock
}

// When sets expectation for the Repository.GetPipelineByUIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) When(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByUIDAdminExpectation {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByUIDAdminExpectation{
		mock:               mmGetPipelineByUIDAdmin.mock,
		params:             &RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases},
		expectationOrigins: RepositoryMockGetPipelineByUIDAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineByUIDAdmin.expectations = append(mmGetPipelineByUIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByUIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByUIDAdminExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByUIDAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByUIDAdmin should be invoked
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Times(n uint64) *mRepositoryMockGetPipelineByUIDAdmin {
	if n == 0 {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByUIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByUIDAdmin.expectedInvocations, n)
	mmGetPipelineByUIDAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineByUIDAdmin
}

func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) invocationsDone() bool {
	if len(mmGetPipelineByUIDAdmin.expectations) == 0 && mmGetPipelineByUIDAdmin.defaultExpectation == nil && mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.mock.afterGetPipelineByUIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByUIDAdmin implements mm_repository.Repository
func (mmGetPipelineByUIDAdmin *RepositoryMock) GetPipelineByUIDAdmin(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByUIDAdmin.beforeGetPipelineByUIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByUIDAdmin.afterGetPipelineByUIDAdminCounter, 1)

	mmGetPipelineByUIDAdmin.t.Helper()

	if mmGetPipelineByUIDAdmin.inspectFuncGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.inspectFuncGetPipelineByUIDAdmin(ctx, uid, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.mutex.Lock()
	mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.callArgs = append(mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.callArgs, &mm_params)
	mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.mutex.Unlock()

	for _, e := range mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByUIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetPipelineByUIDAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByUIDAdmin.funcGetPipelineByUIDAdmin != nil {
		return mmGetPipelineByUIDAdmin.funcGetPipelineByUIDAdmin(ctx, uid, isBasicView, embedReleases)
	}
	mmGetPipelineByUIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByUIDAdmin. %v %v %v %v", ctx, uid, isBasicView, embedReleases)
	return
}

// GetPipelineByUIDAdminAfterCounter returns a count of finished RepositoryMock.GetPipelineByUIDAdmin invocations
func (mmGetPipelineByUIDAdmin *RepositoryMock) GetPipelineByUIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.afterGetPipelineByUIDAdminCounter)
}

// GetPipelineByUIDAdminBeforeCounter returns a count of RepositoryMock.GetPipelineByUIDAdmin invocations
func (mmGetPipelineByUIDAdmin *RepositoryMock) GetPipelineByUIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.beforeGetPipelineByUIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByUIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Calls() []*RepositoryMockGetPipelineByUIDAdminParams {
	mmGetPipelineByUIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByUIDAdminParams, len(mmGetPipelineByUIDAdmin.callArgs))
	copy(argCopy, mmGetPipelineByUIDAdmin.callArgs)

	mmGetPipelineByUIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByUIDAdminDone returns true if the count of the GetPipelineByUIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByUIDAdminDone() bool {
	if m.GetPipelineByUIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByUIDAdminMock.invocationsDone()
}

// MinimockGetPipelineByUIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByUIDAdminInspect() {
	for _, e := range m.GetPipelineByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUIDAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineByUIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByUIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByUIDAdminMock.defaultExpectation != nil && afterGetPipelineByUIDAdminCounter < 1 {
		if m.GetPipelineByUIDAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUIDAdmin at\n%s", m.GetPipelineByUIDAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUIDAdmin at\n%s with params: %#v", m.GetPipelineByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineByUIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByUIDAdmin != nil && afterGetPipelineByUIDAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUIDAdmin at\n%s", m.funcGetPipelineByUIDAdminOrigin)
	}

	if !m.GetPipelineByUIDAdminMock.invocationsDone() && afterGetPipelineByUIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByUIDAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByUIDAdminMock.expectedInvocations), m.GetPipelineByUIDAdminMock.expectedInvocationsOrigin, afterGetPipelineByUIDAdminCounter)
	}
}

type mRepositoryMockGetPipelineReleaseByUIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineReleaseByUIDAdminExpectation
	expectations       []*RepositoryMockGetPipelineReleaseByUIDAdminExpectation

	callArgs []*RepositoryMockGetPipelineReleaseByUIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineReleaseByUIDAdminExpectation specifies expectation struct of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineReleaseByUIDAdminParams
	paramPtrs          *RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs
	expectationOrigins RepositoryMockGetPipelineReleaseByUIDAdminExpectationOrigins
	results            *RepositoryMockGetPipelineReleaseByUIDAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineReleaseByUIDAdminParams contains parameters of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminParams struct {
	ctx         context.Context
	uid         uuid.UUID
	isBasicView bool
}

// RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs contains pointers to parameters of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs struct {
	ctx         *context.Context
	uid         *uuid.UUID
	isBasicView *bool
}

// RepositoryMockGetPipelineReleaseByUIDAdminResults contains results of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// RepositoryMockGetPipelineReleaseByUIDAdminOrigins contains origins of expectations of the Repository.GetPipelineReleaseByUIDAdmin
type RepositoryMockGetPipelineReleaseByUIDAdminExpectationOrigins struct {
	origin            string
	originCtx         string
	originUid         string
	originIsBasicView string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Optional() *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	mmGetPipelineReleaseByUIDAdmin.optional = true
	return mmGetPipelineReleaseByUIDAdmin
}

// Expect sets up expected params for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params = &RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineReleaseByUIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params) {
			mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetPipelineReleaseByUIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs{}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByUIDAdmin
}

// ExpectUidParam2 sets up expected param uid for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs{}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs.uid = &uid
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByUIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{}
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineReleaseByUIDAdminParamPtrs{}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetPipelineReleaseByUIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool)) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if mmGetPipelineReleaseByUIDAdmin.mock.inspectFuncGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineReleaseByUIDAdmin")
	}

	mmGetPipelineReleaseByUIDAdmin.mock.inspectFuncGetPipelineReleaseByUIDAdmin = f

	return mmGetPipelineReleaseByUIDAdmin
}

// Return sets up results that will be returned by Repository.GetPipelineReleaseByUIDAdmin
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineReleaseByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{mock: mmGetPipelineReleaseByUIDAdmin.mock}
	}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.results = &RepositoryMockGetPipelineReleaseByUIDAdminResults{pp1, err}
	mmGetPipelineReleaseByUIDAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByUIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetPipelineReleaseByUIDAdmin method
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetPipelineReleaseByUIDAdmin.defaultExpectation != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineReleaseByUIDAdmin method")
	}

	if len(mmGetPipelineReleaseByUIDAdmin.expectations) > 0 {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineReleaseByUIDAdmin method")
	}

	mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin = f
	mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdminOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByUIDAdmin.mock
}

// When sets expectation for the Repository.GetPipelineReleaseByUIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) When(ctx context.Context, uid uuid.UUID, isBasicView bool) *RepositoryMockGetPipelineReleaseByUIDAdminExpectation {
	if mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineReleaseByUIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineReleaseByUIDAdminExpectation{
		mock:               mmGetPipelineReleaseByUIDAdmin.mock,
		params:             &RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView},
		expectationOrigins: RepositoryMockGetPipelineReleaseByUIDAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineReleaseByUIDAdmin.expectations = append(mmGetPipelineReleaseByUIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineReleaseByUIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineReleaseByUIDAdminExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineReleaseByUIDAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineReleaseByUIDAdmin should be invoked
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Times(n uint64) *mRepositoryMockGetPipelineReleaseByUIDAdmin {
	if n == 0 {
		mmGetPipelineReleaseByUIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetPipelineReleaseByUIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineReleaseByUIDAdmin.expectedInvocations, n)
	mmGetPipelineReleaseByUIDAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineReleaseByUIDAdmin
}

func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) invocationsDone() bool {
	if len(mmGetPipelineReleaseByUIDAdmin.expectations) == 0 && mmGetPipelineReleaseByUIDAdmin.defaultExpectation == nil && mmGetPipelineReleaseByUIDAdmin.mock.funcGetPipelineReleaseByUIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.mock.afterGetPipelineReleaseByUIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineReleaseByUIDAdmin implements mm_repository.Repository
func (mmGetPipelineReleaseByUIDAdmin *RepositoryMock) GetPipelineReleaseByUIDAdmin(ctx context.Context, uid uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetPipelineReleaseByUIDAdmin.beforeGetPipelineReleaseByUIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineReleaseByUIDAdmin.afterGetPipelineReleaseByUIDAdminCounter, 1)

	mmGetPipelineReleaseByUIDAdmin.t.Helper()

	if mmGetPipelineReleaseByUIDAdmin.inspectFuncGetPipelineReleaseByUIDAdmin != nil {
		mmGetPipelineReleaseByUIDAdmin.inspectFuncGetPipelineReleaseByUIDAdmin(ctx, uid, isBasicView)
	}

	mm_params := RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView}

	// Record call args
	mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.mutex.Lock()
	mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.callArgs = append(mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.callArgs, &mm_params)
	mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.mutex.Unlock()

	for _, e := range mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineReleaseByUIDAdminParams{ctx, uid, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineReleaseByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineReleaseByUIDAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineReleaseByUIDAdmin.GetPipelineReleaseByUIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineReleaseByUIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetPipelineReleaseByUIDAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineReleaseByUIDAdmin.funcGetPipelineReleaseByUIDAdmin != nil {
		return mmGetPipelineReleaseByUIDAdmin.funcGetPipelineReleaseByUIDAdmin(ctx, uid, isBasicView)
	}
	mmGetPipelineReleaseByUIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineReleaseByUIDAdmin. %v %v %v", ctx, uid, isBasicView)
	return
}

// GetPipelineReleaseByUIDAdminAfterCounter returns a count of finished RepositoryMock.GetPipelineReleaseByUIDAdmin invocations
func (mmGetPipelineReleaseByUIDAdmin *RepositoryMock) GetPipelineReleaseByUIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.afterGetPipelineReleaseByUIDAdminCounter)
}

// GetPipelineReleaseByUIDAdminBeforeCounter returns a count of RepositoryMock.GetPipelineReleaseByUIDAdmin invocations
func (mmGetPipelineReleaseByUIDAdmin *RepositoryMock) GetPipelineReleaseByUIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineReleaseByUIDAdmin.beforeGetPipelineReleaseByUIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineReleaseByUIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineReleaseByUIDAdmin *mRepositoryMockGetPipelineReleaseByUIDAdmin) Calls() []*RepositoryMockGetPipelineReleaseByUIDAdminParams {
	mmGetPipelineReleaseByUIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineReleaseByUIDAdminParams, len(mmGetPipelineReleaseByUIDAdmin.callArgs))
	copy(argCopy, mmGetPipelineReleaseByUIDAdmin.callArgs)

	mmGetPipelineReleaseByUIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineReleaseByUIDAdminDone returns true if the count of the GetPipelineReleaseByUIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineReleaseByUIDAdminDone() bool {
	if m.GetPipelineReleaseByUIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineReleaseByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineReleaseByUIDAdminMock.invocationsDone()
}

// MinimockGetPipelineReleaseByUIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineReleaseByUIDAdminInspect() {
	for _, e := range m.GetPipelineReleaseByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineReleaseByUIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetPipelineReleaseByUIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineReleaseByUIDAdminMock.defaultExpectation != nil && afterGetPipelineReleaseByUIDAdminCounter < 1 {
		if m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s", m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s with params: %#v", m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineReleaseByUIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineReleaseByUIDAdmin != nil && afterGetPipelineReleaseByUIDAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s", m.funcGetPipelineReleaseByUIDAdminOrigin)
	}

	if !m.GetPipelineReleaseByUIDAdminMock.invocationsDone() && afterGetPipelineReleaseByUIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineReleaseByUIDAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineReleaseByUIDAdminMock.expectedInvocations), m.GetPipelineReleaseByUIDAdminMock.expectedInvocationsOrigin, afterGetPipelineReleaseByUIDAdminCounter)
	}
}

type mRepositoryMockGetPipelineRunByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineRunByUIDExpectation
	expectations       []*RepositoryMockGetPipelineRunByUIDExpectation

	callArgs []*RepositoryMockGetPipelineRunByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetPipelineRunByUIDExpectation specifies expectation struct of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetPipelineRunByUIDParams
	paramPtrs          *RepositoryMockGetPipelineRunByUIDParamPtrs
	expectationOrigins RepositoryMockGetPipelineRunByUIDExpectationOrigins
	results            *RepositoryMockGetPipelineRunByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetPipelineRunByUIDParams contains parameters of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// RepositoryMockGetPipelineRunByUIDParamPtrs contains pointers to parameters of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
}

// RepositoryMockGetPipelineRunByUIDResults contains results of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDResults struct {
	pp1 *datamodel.PipelineRun
	err error
}

// RepositoryMockGetPipelineRunByUIDOrigins contains origins of expectations of the Repository.GetPipelineRunByUID
type RepositoryMockGetPipelineRunByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Optional() *mRepositoryMockGetPipelineRunByUID {
	mmGetPipelineRunByUID.optional = true
	return mmGetPipelineRunByUID
}

// Expect sets up expected params for Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Expect(ctx context.Context, u1 uuid.UUID) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{}
	}

	if mmGetPipelineRunByUID.defaultExpectation.paramPtrs != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by ExpectParams functions")
	}

	mmGetPipelineRunByUID.defaultExpectation.params = &RepositoryMockGetPipelineRunByUIDParams{ctx, u1}
	mmGetPipelineRunByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPipelineRunByUID.expectations {
		if minimock.Equal(e.params, mmGetPipelineRunByUID.defaultExpectation.params) {
			mmGetPipelineRunByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineRunByUID.defaultExpectation.params)
		}
	}

	return mmGetPipelineRunByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{}
	}

	if mmGetPipelineRunByUID.defaultExpectation.params != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Expect")
	}

	if mmGetPipelineRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineRunByUIDParamPtrs{}
	}
	mmGetPipelineRunByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPipelineRunByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPipelineRunByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{}
	}

	if mmGetPipelineRunByUID.defaultExpectation.params != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Expect")
	}

	if mmGetPipelineRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineRunByUIDParamPtrs{}
	}
	mmGetPipelineRunByUID.defaultExpectation.paramPtrs.u1 = &u1
	mmGetPipelineRunByUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmGetPipelineRunByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mRepositoryMockGetPipelineRunByUID {
	if mmGetPipelineRunByUID.mock.inspectFuncGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineRunByUID")
	}

	mmGetPipelineRunByUID.mock.inspectFuncGetPipelineRunByUID = f

	return mmGetPipelineRunByUID
}

// Return sets up results that will be returned by Repository.GetPipelineRunByUID
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Return(pp1 *datamodel.PipelineRun, err error) *RepositoryMock {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	if mmGetPipelineRunByUID.defaultExpectation == nil {
		mmGetPipelineRunByUID.defaultExpectation = &RepositoryMockGetPipelineRunByUIDExpectation{mock: mmGetPipelineRunByUID.mock}
	}
	mmGetPipelineRunByUID.defaultExpectation.results = &RepositoryMockGetPipelineRunByUIDResults{pp1, err}
	mmGetPipelineRunByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPipelineRunByUID.mock
}

// Set uses given function f to mock the Repository.GetPipelineRunByUID method
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Set(f func(ctx context.Context, u1 uuid.UUID) (pp1 *datamodel.PipelineRun, err error)) *RepositoryMock {
	if mmGetPipelineRunByUID.defaultExpectation != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineRunByUID method")
	}

	if len(mmGetPipelineRunByUID.expectations) > 0 {
		mmGetPipelineRunByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineRunByUID method")
	}

	mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID = f
	mmGetPipelineRunByUID.mock.funcGetPipelineRunByUIDOrigin = minimock.CallerInfo(1)
	return mmGetPipelineRunByUID.mock
}

// When sets expectation for the Repository.GetPipelineRunByUID which will trigger the result defined by the following
// Then helper
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) When(ctx context.Context, u1 uuid.UUID) *RepositoryMockGetPipelineRunByUIDExpectation {
	if mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.mock.t.Fatalf("RepositoryMock.GetPipelineRunByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineRunByUIDExpectation{
		mock:               mmGetPipelineRunByUID.mock,
		params:             &RepositoryMockGetPipelineRunByUIDParams{ctx, u1},
		expectationOrigins: RepositoryMockGetPipelineRunByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPipelineRunByUID.expectations = append(mmGetPipelineRunByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineRunByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineRunByUIDExpectation) Then(pp1 *datamodel.PipelineRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineRunByUIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineRunByUID should be invoked
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Times(n uint64) *mRepositoryMockGetPipelineRunByUID {
	if n == 0 {
		mmGetPipelineRunByUID.mock.t.Fatalf("Times of RepositoryMock.GetPipelineRunByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineRunByUID.expectedInvocations, n)
	mmGetPipelineRunByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPipelineRunByUID
}

func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) invocationsDone() bool {
	if len(mmGetPipelineRunByUID.expectations) == 0 && mmGetPipelineRunByUID.defaultExpectation == nil && mmGetPipelineRunByUID.mock.funcGetPipelineRunByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineRunByUID.mock.afterGetPipelineRunByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineRunByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineRunByUID implements mm_repository.Repository
func (mmGetPipelineRunByUID *RepositoryMock) GetPipelineRunByUID(ctx context.Context, u1 uuid.UUID) (pp1 *datamodel.PipelineRun, err error) {
	mm_atomic.AddUint64(&mmGetPipelineRunByUID.beforeGetPipelineRunByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineRunByUID.afterGetPipelineRunByUIDCounter, 1)

	mmGetPipelineRunByUID.t.Helper()

	if mmGetPipelineRunByUID.inspectFuncGetPipelineRunByUID != nil {
		mmGetPipelineRunByUID.inspectFuncGetPipelineRunByUID(ctx, u1)
	}

	mm_params := RepositoryMockGetPipelineRunByUIDParams{ctx, u1}

	// Record call args
	mmGetPipelineRunByUID.GetPipelineRunByUIDMock.mutex.Lock()
	mmGetPipelineRunByUID.GetPipelineRunByUIDMock.callArgs = append(mmGetPipelineRunByUID.GetPipelineRunByUIDMock.callArgs, &mm_params)
	mmGetPipelineRunByUID.GetPipelineRunByUIDMock.mutex.Unlock()

	for _, e := range mmGetPipelineRunByUID.GetPipelineRunByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineRunByUIDParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineRunByUID.t.Errorf("RepositoryMock.GetPipelineRunByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetPipelineRunByUID.t.Errorf("RepositoryMock.GetPipelineRunByUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineRunByUID.t.Errorf("RepositoryMock.GetPipelineRunByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineRunByUID.GetPipelineRunByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineRunByUID.t.Fatal("No results are set for the RepositoryMock.GetPipelineRunByUID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineRunByUID.funcGetPipelineRunByUID != nil {
		return mmGetPipelineRunByUID.funcGetPipelineRunByUID(ctx, u1)
	}
	mmGetPipelineRunByUID.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineRunByUID. %v %v", ctx, u1)
	return
}

// GetPipelineRunByUIDAfterCounter returns a count of finished RepositoryMock.GetPipelineRunByUID invocations
func (mmGetPipelineRunByUID *RepositoryMock) GetPipelineRunByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineRunByUID.afterGetPipelineRunByUIDCounter)
}

// GetPipelineRunByUIDBeforeCounter returns a count of RepositoryMock.GetPipelineRunByUID invocations
func (mmGetPipelineRunByUID *RepositoryMock) GetPipelineRunByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineRunByUID.beforeGetPipelineRunByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineRunByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineRunByUID *mRepositoryMockGetPipelineRunByUID) Calls() []*RepositoryMockGetPipelineRunByUIDParams {
	mmGetPipelineRunByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineRunByUIDParams, len(mmGetPipelineRunByUID.callArgs))
	copy(argCopy, mmGetPipelineRunByUID.callArgs)

	mmGetPipelineRunByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineRunByUIDDone returns true if the count of the GetPipelineRunByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineRunByUIDDone() bool {
	if m.GetPipelineRunByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineRunByUIDMock.invocationsDone()
}

// MinimockGetPipelineRunByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineRunByUIDInspect() {
	for _, e := range m.GetPipelineRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPipelineRunByUIDCounter := mm_atomic.LoadUint64(&m.afterGetPipelineRunByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineRunByUIDMock.defaultExpectation != nil && afterGetPipelineRunByUIDCounter < 1 {
		if m.GetPipelineRunByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s", m.GetPipelineRunByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s with params: %#v", m.GetPipelineRunByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPipelineRunByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineRunByUID != nil && afterGetPipelineRunByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetPipelineRunByUID at\n%s", m.funcGetPipelineRunByUIDOrigin)
	}

	if !m.GetPipelineRunByUIDMock.invocationsDone() && afterGetPipelineRunByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineRunByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineRunByUIDMock.expectedInvocations), m.GetPipelineRunByUIDMock.expectedInvocationsOrigin, afterGetPipelineRunByUIDCounter)
	}
}

type mRepositoryMockListComponentDefinitionUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListComponentDefinitionUIDsExpectation
	expectations       []*RepositoryMockListComponentDefinitionUIDsExpectation

	callArgs []*RepositoryMockListComponentDefinitionUIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListComponentDefinitionUIDsExpectation specifies expectation struct of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListComponentDefinitionUIDsParams
	paramPtrs          *RepositoryMockListComponentDefinitionUIDsParamPtrs
	expectationOrigins RepositoryMockListComponentDefinitionUIDsExpectationOrigins
	results            *RepositoryMockListComponentDefinitionUIDsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListComponentDefinitionUIDsParams contains parameters of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsParams struct {
	ctx context.Context
	l1  mm_repository.ListComponentDefinitionsParams
}

// RepositoryMockListComponentDefinitionUIDsParamPtrs contains pointers to parameters of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListComponentDefinitionsParams
}

// RepositoryMockListComponentDefinitionUIDsResults contains results of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsResults struct {
	uids      []*datamodel.ComponentDefinition
	totalSize int64
	err       error
}

// RepositoryMockListComponentDefinitionUIDsOrigins contains origins of expectations of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Optional() *mRepositoryMockListComponentDefinitionUIDs {
	mmListComponentDefinitionUIDs.optional = true
	return mmListComponentDefinitionUIDs
}

// Expect sets up expected params for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Expect(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by ExpectParams functions")
	}

	mmListComponentDefinitionUIDs.defaultExpectation.params = &RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}
	mmListComponentDefinitionUIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListComponentDefinitionUIDs.expectations {
		if minimock.Equal(e.params, mmListComponentDefinitionUIDs.defaultExpectation.params) {
			mmListComponentDefinitionUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListComponentDefinitionUIDs.defaultExpectation.params)
		}
	}

	return mmListComponentDefinitionUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.params != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Expect")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs == nil {
		mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs = &RepositoryMockListComponentDefinitionUIDsParamPtrs{}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmListComponentDefinitionUIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListComponentDefinitionUIDs
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) ExpectL1Param2(l1 mm_repository.ListComponentDefinitionsParams) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.params != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Expect")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs == nil {
		mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs = &RepositoryMockListComponentDefinitionUIDsParamPtrs{}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs.l1 = &l1
	mmListComponentDefinitionUIDs.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListComponentDefinitionUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Inspect(f func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams)) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.inspectFuncListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListComponentDefinitionUIDs")
	}

	mmListComponentDefinitionUIDs.mock.inspectFuncListComponentDefinitionUIDs = f

	return mmListComponentDefinitionUIDs
}

// Return sets up results that will be returned by Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Return(uids []*datamodel.ComponentDefinition, totalSize int64, err error) *RepositoryMock {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{mock: mmListComponentDefinitionUIDs.mock}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.results = &RepositoryMockListComponentDefinitionUIDsResults{uids, totalSize, err}
	mmListComponentDefinitionUIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListComponentDefinitionUIDs.mock
}

// Set uses given function f to mock the Repository.ListComponentDefinitionUIDs method
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Set(f func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error)) *RepositoryMock {
	if mmListComponentDefinitionUIDs.defaultExpectation != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.ListComponentDefinitionUIDs method")
	}

	if len(mmListComponentDefinitionUIDs.expectations) > 0 {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.ListComponentDefinitionUIDs method")
	}

	mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs = f
	mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDsOrigin = minimock.CallerInfo(1)
	return mmListComponentDefinitionUIDs.mock
}

// When sets expectation for the Repository.ListComponentDefinitionUIDs which will trigger the result defined by the following
// Then helper
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) When(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) *RepositoryMockListComponentDefinitionUIDsExpectation {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockListComponentDefinitionUIDsExpectation{
		mock:               mmListComponentDefinitionUIDs.mock,
		params:             &RepositoryMockListComponentDefinitionUIDsParams{ctx, l1},
		expectationOrigins: RepositoryMockListComponentDefinitionUIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListComponentDefinitionUIDs.expectations = append(mmListComponentDefinitionUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListComponentDefinitionUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListComponentDefinitionUIDsExpectation) Then(uids []*datamodel.ComponentDefinition, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListComponentDefinitionUIDsResults{uids, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListComponentDefinitionUIDs should be invoked
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Times(n uint64) *mRepositoryMockListComponentDefinitionUIDs {
	if n == 0 {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Times of RepositoryMock.ListComponentDefinitionUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListComponentDefinitionUIDs.expectedInvocations, n)
	mmListComponentDefinitionUIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListComponentDefinitionUIDs
}

func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) invocationsDone() bool {
	if len(mmListComponentDefinitionUIDs.expectations) == 0 && mmListComponentDefinitionUIDs.defaultExpectation == nil && mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.mock.afterListComponentDefinitionUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListComponentDefinitionUIDs implements mm_repository.Repository
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDs(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.beforeListComponentDefinitionUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.afterListComponentDefinitionUIDsCounter, 1)

	mmListComponentDefinitionUIDs.t.Helper()

	if mmListComponentDefinitionUIDs.inspectFuncListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.inspectFuncListComponentDefinitionUIDs(ctx, l1)
	}

	mm_params := RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}

	// Record call args
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.mutex.Lock()
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.callArgs = append(mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.callArgs, &mm_params)
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.mutex.Unlock()

	for _, e := range mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uids, e.results.totalSize, e.results.err
		}
	}

	if mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmListComponentDefinitionUIDs.t.Fatal("No results are set for the RepositoryMock.ListComponentDefinitionUIDs")
		}
		return (*mm_results).uids, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListComponentDefinitionUIDs.funcListComponentDefinitionUIDs != nil {
		return mmListComponentDefinitionUIDs.funcListComponentDefinitionUIDs(ctx, l1)
	}
	mmListComponentDefinitionUIDs.t.Fatalf("Unexpected call to RepositoryMock.ListComponentDefinitionUIDs. %v %v", ctx, l1)
	return
}

// ListComponentDefinitionUIDsAfterCounter returns a count of finished RepositoryMock.ListComponentDefinitionUIDs invocations
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.afterListComponentDefinitionUIDsCounter)
}

// ListComponentDefinitionUIDsBeforeCounter returns a count of RepositoryMock.ListComponentDefinitionUIDs invocations
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.beforeListComponentDefinitionUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListComponentDefinitionUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Calls() []*RepositoryMockListComponentDefinitionUIDsParams {
	mmListComponentDefinitionUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockListComponentDefinitionUIDsParams, len(mmListComponentDefinitionUIDs.callArgs))
	copy(argCopy, mmListComponentDefinitionUIDs.callArgs)

	mmListComponentDefinitionUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockListComponentDefinitionUIDsDone returns true if the count of the ListComponentDefinitionUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListComponentDefinitionUIDsDone() bool {
	if m.ListComponentDefinitionUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListComponentDefinitionUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListComponentDefinitionUIDsMock.invocationsDone()
}

// MinimockListComponentDefinitionUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListComponentDefinitionUIDsInspect() {
	for _, e := range m.ListComponentDefinitionUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListComponentDefinitionUIDsCounter := mm_atomic.LoadUint64(&m.afterListComponentDefinitionUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListComponentDefinitionUIDsMock.defaultExpectation != nil && afterListComponentDefinitionUIDsCounter < 1 {
		if m.ListComponentDefinitionUIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s", m.ListComponentDefinitionUIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s with params: %#v", m.ListComponentDefinitionUIDsMock.defaultExpectation.expectationOrigins.origin, *m.ListComponentDefinitionUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListComponentDefinitionUIDs != nil && afterListComponentDefinitionUIDsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs at\n%s", m.funcListComponentDefinitionUIDsOrigin)
	}

	if !m.ListComponentDefinitionUIDsMock.invocationsDone() && afterListComponentDefinitionUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListComponentDefinitionUIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListComponentDefinitionUIDsMock.expectedInvocations), m.ListComponentDefinitionUIDsMock.expectedInvocationsOrigin, afterListComponentDefinitionUIDsCounter)
	}
}

type mRepositoryMockListIntegrations struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListIntegrationsExpectation
	expectations       []*RepositoryMockListIntegrationsExpectation

	callArgs []*RepositoryMockListIntegrationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListIntegrationsExpectation specifies expectation struct of the Repository.ListIntegrations
type RepositoryMockListIntegrationsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListIntegrationsParams
	paramPtrs          *RepositoryMockListIntegrationsParamPtrs
	expectationOrigins RepositoryMockListIntegrationsExpectationOrigins
	results            *RepositoryMockListIntegrationsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListIntegrationsParams contains parameters of the Repository.ListIntegrations
type RepositoryMockListIntegrationsParams struct {
	ctx context.Context
	l1  mm_repository.ListIntegrationsParams
}

// RepositoryMockListIntegrationsParamPtrs contains pointers to parameters of the Repository.ListIntegrations
type RepositoryMockListIntegrationsParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListIntegrationsParams
}

// RepositoryMockListIntegrationsResults contains results of the Repository.ListIntegrations
type RepositoryMockListIntegrationsResults struct {
	i1  mm_repository.IntegrationList
	err error
}

// RepositoryMockListIntegrationsOrigins contains origins of expectations of the Repository.ListIntegrations
type RepositoryMockListIntegrationsExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListIntegrations *mRepositoryMockListIntegrations) Optional() *mRepositoryMockListIntegrations {
	mmListIntegrations.optional = true
	return mmListIntegrations
}

// Expect sets up expected params for Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) Expect(ctx context.Context, l1 mm_repository.ListIntegrationsParams) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{}
	}

	if mmListIntegrations.defaultExpectation.paramPtrs != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by ExpectParams functions")
	}

	mmListIntegrations.defaultExpectation.params = &RepositoryMockListIntegrationsParams{ctx, l1}
	mmListIntegrations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListIntegrations.expectations {
		if minimock.Equal(e.params, mmListIntegrations.defaultExpectation.params) {
			mmListIntegrations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListIntegrations.defaultExpectation.params)
		}
	}

	return mmListIntegrations
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{}
	}

	if mmListIntegrations.defaultExpectation.params != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Expect")
	}

	if mmListIntegrations.defaultExpectation.paramPtrs == nil {
		mmListIntegrations.defaultExpectation.paramPtrs = &RepositoryMockListIntegrationsParamPtrs{}
	}
	mmListIntegrations.defaultExpectation.paramPtrs.ctx = &ctx
	mmListIntegrations.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListIntegrations
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) ExpectL1Param2(l1 mm_repository.ListIntegrationsParams) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{}
	}

	if mmListIntegrations.defaultExpectation.params != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Expect")
	}

	if mmListIntegrations.defaultExpectation.paramPtrs == nil {
		mmListIntegrations.defaultExpectation.paramPtrs = &RepositoryMockListIntegrationsParamPtrs{}
	}
	mmListIntegrations.defaultExpectation.paramPtrs.l1 = &l1
	mmListIntegrations.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListIntegrations
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) Inspect(f func(ctx context.Context, l1 mm_repository.ListIntegrationsParams)) *mRepositoryMockListIntegrations {
	if mmListIntegrations.mock.inspectFuncListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListIntegrations")
	}

	mmListIntegrations.mock.inspectFuncListIntegrations = f

	return mmListIntegrations
}

// Return sets up results that will be returned by Repository.ListIntegrations
func (mmListIntegrations *mRepositoryMockListIntegrations) Return(i1 mm_repository.IntegrationList, err error) *RepositoryMock {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	if mmListIntegrations.defaultExpectation == nil {
		mmListIntegrations.defaultExpectation = &RepositoryMockListIntegrationsExpectation{mock: mmListIntegrations.mock}
	}
	mmListIntegrations.defaultExpectation.results = &RepositoryMockListIntegrationsResults{i1, err}
	mmListIntegrations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListIntegrations.mock
}

// Set uses given function f to mock the Repository.ListIntegrations method
func (mmListIntegrations *mRepositoryMockListIntegrations) Set(f func(ctx context.Context, l1 mm_repository.ListIntegrationsParams) (i1 mm_repository.IntegrationList, err error)) *RepositoryMock {
	if mmListIntegrations.defaultExpectation != nil {
		mmListIntegrations.mock.t.Fatalf("Default expectation is already set for the Repository.ListIntegrations method")
	}

	if len(mmListIntegrations.expectations) > 0 {
		mmListIntegrations.mock.t.Fatalf("Some expectations are already set for the Repository.ListIntegrations method")
	}

	mmListIntegrations.mock.funcListIntegrations = f
	mmListIntegrations.mock.funcListIntegrationsOrigin = minimock.CallerInfo(1)
	return mmListIntegrations.mock
}

// When sets expectation for the Repository.ListIntegrations which will trigger the result defined by the following
// Then helper
func (mmListIntegrations *mRepositoryMockListIntegrations) When(ctx context.Context, l1 mm_repository.ListIntegrationsParams) *RepositoryMockListIntegrationsExpectation {
	if mmListIntegrations.mock.funcListIntegrations != nil {
		mmListIntegrations.mock.t.Fatalf("RepositoryMock.ListIntegrations mock is already set by Set")
	}

	expectation := &RepositoryMockListIntegrationsExpectation{
		mock:               mmListIntegrations.mock,
		params:             &RepositoryMockListIntegrationsParams{ctx, l1},
		expectationOrigins: RepositoryMockListIntegrationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListIntegrations.expectations = append(mmListIntegrations.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListIntegrations return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListIntegrationsExpectation) Then(i1 mm_repository.IntegrationList, err error) *RepositoryMock {
	e.results = &RepositoryMockListIntegrationsResults{i1, err}
	return e.mock
}

// Times sets number of times Repository.ListIntegrations should be invoked
func (mmListIntegrations *mRepositoryMockListIntegrations) Times(n uint64) *mRepositoryMockListIntegrations {
	if n == 0 {
		mmListIntegrations.mock.t.Fatalf("Times of RepositoryMock.ListIntegrations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListIntegrations.expectedInvocations, n)
	mmListIntegrations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListIntegrations
}

func (mmListIntegrations *mRepositoryMockListIntegrations) invocationsDone() bool {
	if len(mmListIntegrations.expectations) == 0 && mmListIntegrations.defaultExpectation == nil && mmListIntegrations.mock.funcListIntegrations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListIntegrations.mock.afterListIntegrationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListIntegrations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListIntegrations implements mm_repository.Repository
func (mmListIntegrations *RepositoryMock) ListIntegrations(ctx context.Context, l1 mm_repository.ListIntegrationsParams) (i1 mm_repository.IntegrationList, err error) {
	mm_atomic.AddUint64(&mmListIntegrations.beforeListIntegrationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListIntegrations.afterListIntegrationsCounter, 1)

	mmListIntegrations.t.Helper()

	if mmListIntegrations.inspectFuncListIntegrations != nil {
		mmListIntegrations.inspectFuncListIntegrations(ctx, l1)
	}

	mm_params := RepositoryMockListIntegrationsParams{ctx, l1}

	// Record call args
	mmListIntegrations.ListIntegrationsMock.mutex.Lock()
	mmListIntegrations.ListIntegrationsMock.callArgs = append(mmListIntegrations.ListIntegrationsMock.callArgs, &mm_params)
	mmListIntegrations.ListIntegrationsMock.mutex.Unlock()

	for _, e := range mmListIntegrations.ListIntegrationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmListIntegrations.ListIntegrationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListIntegrations.ListIntegrationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListIntegrations.ListIntegrationsMock.defaultExpectation.params
		mm_want_ptrs := mmListIntegrations.ListIntegrationsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListIntegrationsParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListIntegrations.t.Errorf("RepositoryMock.ListIntegrations got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListIntegrations.ListIntegrationsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListIntegrations.t.Errorf("RepositoryMock.ListIntegrations got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListIntegrations.ListIntegrationsMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListIntegrations.t.Errorf("RepositoryMock.ListIntegrations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListIntegrations.ListIntegrationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListIntegrations.ListIntegrationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListIntegrations.t.Fatal("No results are set for the RepositoryMock.ListIntegrations")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmListIntegrations.funcListIntegrations != nil {
		return mmListIntegrations.funcListIntegrations(ctx, l1)
	}
	mmListIntegrations.t.Fatalf("Unexpected call to RepositoryMock.ListIntegrations. %v %v", ctx, l1)
	return
}

// ListIntegrationsAfterCounter returns a count of finished RepositoryMock.ListIntegrations invocations
func (mmListIntegrations *RepositoryMock) ListIntegrationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListIntegrations.afterListIntegrationsCounter)
}

// ListIntegrationsBeforeCounter returns a count of RepositoryMock.ListIntegrations invocations
func (mmListIntegrations *RepositoryMock) ListIntegrationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListIntegrations.beforeListIntegrationsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListIntegrations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListIntegrations *mRepositoryMockListIntegrations) Calls() []*RepositoryMockListIntegrationsParams {
	mmListIntegrations.mutex.RLock()

	argCopy := make([]*RepositoryMockListIntegrationsParams, len(mmListIntegrations.callArgs))
	copy(argCopy, mmListIntegrations.callArgs)

	mmListIntegrations.mutex.RUnlock()

	return argCopy
}

// MinimockListIntegrationsDone returns true if the count of the ListIntegrations invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListIntegrationsDone() bool {
	if m.ListIntegrationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListIntegrationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListIntegrationsMock.invocationsDone()
}

// MinimockListIntegrationsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListIntegrationsInspect() {
	for _, e := range m.ListIntegrationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListIntegrationsCounter := mm_atomic.LoadUint64(&m.afterListIntegrationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListIntegrationsMock.defaultExpectation != nil && afterListIntegrationsCounter < 1 {
		if m.ListIntegrationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s", m.ListIntegrationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s with params: %#v", m.ListIntegrationsMock.defaultExpectation.expectationOrigins.origin, *m.ListIntegrationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListIntegrations != nil && afterListIntegrationsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListIntegrations at\n%s", m.funcListIntegrationsOrigin)
	}

	if !m.ListIntegrationsMock.invocationsDone() && afterListIntegrationsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListIntegrations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListIntegrationsMock.expectedInvocations), m.ListIntegrationsMock.expectedInvocationsOrigin, afterListIntegrationsCounter)
	}
}

type mRepositoryMockListNamespaceConnections struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespaceConnectionsExpectation
	expectations       []*RepositoryMockListNamespaceConnectionsExpectation

	callArgs []*RepositoryMockListNamespaceConnectionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListNamespaceConnectionsExpectation specifies expectation struct of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListNamespaceConnectionsParams
	paramPtrs          *RepositoryMockListNamespaceConnectionsParamPtrs
	expectationOrigins RepositoryMockListNamespaceConnectionsExpectationOrigins
	results            *RepositoryMockListNamespaceConnectionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListNamespaceConnectionsParams contains parameters of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsParams struct {
	ctx context.Context
	l1  mm_repository.ListNamespaceConnectionsParams
}

// RepositoryMockListNamespaceConnectionsParamPtrs contains pointers to parameters of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListNamespaceConnectionsParams
}

// RepositoryMockListNamespaceConnectionsResults contains results of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsResults struct {
	c2  mm_repository.ConnectionList
	err error
}

// RepositoryMockListNamespaceConnectionsOrigins contains origins of expectations of the Repository.ListNamespaceConnections
type RepositoryMockListNamespaceConnectionsExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Optional() *mRepositoryMockListNamespaceConnections {
	mmListNamespaceConnections.optional = true
	return mmListNamespaceConnections
}

// Expect sets up expected params for Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Expect(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{}
	}

	if mmListNamespaceConnections.defaultExpectation.paramPtrs != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by ExpectParams functions")
	}

	mmListNamespaceConnections.defaultExpectation.params = &RepositoryMockListNamespaceConnectionsParams{ctx, l1}
	mmListNamespaceConnections.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespaceConnections.expectations {
		if minimock.Equal(e.params, mmListNamespaceConnections.defaultExpectation.params) {
			mmListNamespaceConnections.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceConnections.defaultExpectation.params)
		}
	}

	return mmListNamespaceConnections
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{}
	}

	if mmListNamespaceConnections.defaultExpectation.params != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Expect")
	}

	if mmListNamespaceConnections.defaultExpectation.paramPtrs == nil {
		mmListNamespaceConnections.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceConnectionsParamPtrs{}
	}
	mmListNamespaceConnections.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespaceConnections.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespaceConnections
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) ExpectL1Param2(l1 mm_repository.ListNamespaceConnectionsParams) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{}
	}

	if mmListNamespaceConnections.defaultExpectation.params != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Expect")
	}

	if mmListNamespaceConnections.defaultExpectation.paramPtrs == nil {
		mmListNamespaceConnections.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceConnectionsParamPtrs{}
	}
	mmListNamespaceConnections.defaultExpectation.paramPtrs.l1 = &l1
	mmListNamespaceConnections.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListNamespaceConnections
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Inspect(f func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams)) *mRepositoryMockListNamespaceConnections {
	if mmListNamespaceConnections.mock.inspectFuncListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespaceConnections")
	}

	mmListNamespaceConnections.mock.inspectFuncListNamespaceConnections = f

	return mmListNamespaceConnections
}

// Return sets up results that will be returned by Repository.ListNamespaceConnections
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Return(c2 mm_repository.ConnectionList, err error) *RepositoryMock {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	if mmListNamespaceConnections.defaultExpectation == nil {
		mmListNamespaceConnections.defaultExpectation = &RepositoryMockListNamespaceConnectionsExpectation{mock: mmListNamespaceConnections.mock}
	}
	mmListNamespaceConnections.defaultExpectation.results = &RepositoryMockListNamespaceConnectionsResults{c2, err}
	mmListNamespaceConnections.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespaceConnections.mock
}

// Set uses given function f to mock the Repository.ListNamespaceConnections method
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Set(f func(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) (c2 mm_repository.ConnectionList, err error)) *RepositoryMock {
	if mmListNamespaceConnections.defaultExpectation != nil {
		mmListNamespaceConnections.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespaceConnections method")
	}

	if len(mmListNamespaceConnections.expectations) > 0 {
		mmListNamespaceConnections.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespaceConnections method")
	}

	mmListNamespaceConnections.mock.funcListNamespaceConnections = f
	mmListNamespaceConnections.mock.funcListNamespaceConnectionsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceConnections.mock
}

// When sets expectation for the Repository.ListNamespaceConnections which will trigger the result defined by the following
// Then helper
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) When(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) *RepositoryMockListNamespaceConnectionsExpectation {
	if mmListNamespaceConnections.mock.funcListNamespaceConnections != nil {
		mmListNamespaceConnections.mock.t.Fatalf("RepositoryMock.ListNamespaceConnections mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespaceConnectionsExpectation{
		mock:               mmListNamespaceConnections.mock,
		params:             &RepositoryMockListNamespaceConnectionsParams{ctx, l1},
		expectationOrigins: RepositoryMockListNamespaceConnectionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespaceConnections.expectations = append(mmListNamespaceConnections.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespaceConnections return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespaceConnectionsExpectation) Then(c2 mm_repository.ConnectionList, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespaceConnectionsResults{c2, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespaceConnections should be invoked
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Times(n uint64) *mRepositoryMockListNamespaceConnections {
	if n == 0 {
		mmListNamespaceConnections.mock.t.Fatalf("Times of RepositoryMock.ListNamespaceConnections mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceConnections.expectedInvocations, n)
	mmListNamespaceConnections.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceConnections
}

func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) invocationsDone() bool {
	if len(mmListNamespaceConnections.expectations) == 0 && mmListNamespaceConnections.defaultExpectation == nil && mmListNamespaceConnections.mock.funcListNamespaceConnections == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceConnections.mock.afterListNamespaceConnectionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceConnections.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceConnections implements mm_repository.Repository
func (mmListNamespaceConnections *RepositoryMock) ListNamespaceConnections(ctx context.Context, l1 mm_repository.ListNamespaceConnectionsParams) (c2 mm_repository.ConnectionList, err error) {
	mm_atomic.AddUint64(&mmListNamespaceConnections.beforeListNamespaceConnectionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceConnections.afterListNamespaceConnectionsCounter, 1)

	mmListNamespaceConnections.t.Helper()

	if mmListNamespaceConnections.inspectFuncListNamespaceConnections != nil {
		mmListNamespaceConnections.inspectFuncListNamespaceConnections(ctx, l1)
	}

	mm_params := RepositoryMockListNamespaceConnectionsParams{ctx, l1}

	// Record call args
	mmListNamespaceConnections.ListNamespaceConnectionsMock.mutex.Lock()
	mmListNamespaceConnections.ListNamespaceConnectionsMock.callArgs = append(mmListNamespaceConnections.ListNamespaceConnectionsMock.callArgs, &mm_params)
	mmListNamespaceConnections.ListNamespaceConnectionsMock.mutex.Unlock()

	for _, e := range mmListNamespaceConnections.ListNamespaceConnectionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespaceConnectionsParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceConnections.t.Errorf("RepositoryMock.ListNamespaceConnections got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListNamespaceConnections.t.Errorf("RepositoryMock.ListNamespaceConnections got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceConnections.t.Errorf("RepositoryMock.ListNamespaceConnections got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceConnections.ListNamespaceConnectionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceConnections.t.Fatal("No results are set for the RepositoryMock.ListNamespaceConnections")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmListNamespaceConnections.funcListNamespaceConnections != nil {
		return mmListNamespaceConnections.funcListNamespaceConnections(ctx, l1)
	}
	mmListNamespaceConnections.t.Fatalf("Unexpected call to RepositoryMock.ListNamespaceConnections. %v %v", ctx, l1)
	return
}

// ListNamespaceConnectionsAfterCounter returns a count of finished RepositoryMock.ListNamespaceConnections invocations
func (mmListNamespaceConnections *RepositoryMock) ListNamespaceConnectionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceConnections.afterListNamespaceConnectionsCounter)
}

// ListNamespaceConnectionsBeforeCounter returns a count of RepositoryMock.ListNamespaceConnections invocations
func (mmListNamespaceConnections *RepositoryMock) ListNamespaceConnectionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceConnections.beforeListNamespaceConnectionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespaceConnections.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceConnections *mRepositoryMockListNamespaceConnections) Calls() []*RepositoryMockListNamespaceConnectionsParams {
	mmListNamespaceConnections.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespaceConnectionsParams, len(mmListNamespaceConnections.callArgs))
	copy(argCopy, mmListNamespaceConnections.callArgs)

	mmListNamespaceConnections.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceConnectionsDone returns true if the count of the ListNamespaceConnections invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespaceConnectionsDone() bool {
	if m.ListNamespaceConnectionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceConnectionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceConnectionsMock.invocationsDone()
}

// MinimockListNamespaceConnectionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespaceConnectionsInspect() {
	for _, e := range m.ListNamespaceConnectionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespaceConnectionsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceConnectionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceConnectionsMock.defaultExpectation != nil && afterListNamespaceConnectionsCounter < 1 {
		if m.ListNamespaceConnectionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s", m.ListNamespaceConnectionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s with params: %#v", m.ListNamespaceConnectionsMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespaceConnectionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceConnections != nil && afterListNamespaceConnectionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListNamespaceConnections at\n%s", m.funcListNamespaceConnectionsOrigin)
	}

	if !m.ListNamespaceConnectionsMock.invocationsDone() && afterListNamespaceConnectionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespaceConnections at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceConnectionsMock.expectedInvocations), m.ListNamespaceConnectionsMock.expectedInvocationsOrigin, afterListNamespaceConnectionsCounter)
	}
}

type mRepositoryMockListNamespacePipelineReleases struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespacePipelineReleasesExpectation
	expectations       []*RepositoryMockListNamespacePipelineReleasesExpectation

	callArgs []*RepositoryMockListNamespacePipelineReleasesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListNamespacePipelineReleasesExpectation specifies expectation struct of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListNamespacePipelineReleasesParams
	paramPtrs          *RepositoryMockListNamespacePipelineReleasesParamPtrs
	expectationOrigins RepositoryMockListNamespacePipelineReleasesExpectationOrigins
	results            *RepositoryMockListNamespacePipelineReleasesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListNamespacePipelineReleasesParams contains parameters of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	showDeleted    bool
	returnCount    bool
}

// RepositoryMockListNamespacePipelineReleasesParamPtrs contains pointers to parameters of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	showDeleted    *bool
	returnCount    *bool
}

// RepositoryMockListNamespacePipelineReleasesResults contains results of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesResults struct {
	ppa1 []*datamodel.PipelineRelease
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListNamespacePipelineReleasesOrigins contains origins of expectations of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originPageSize       string
	originPageToken      string
	originIsBasicView    string
	originFilter         string
	originShowDeleted    string
	originReturnCount    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Optional() *mRepositoryMockListNamespacePipelineReleases {
	mmListNamespacePipelineReleases.optional = true
	return mmListNamespacePipelineReleases
}

// Expect sets up expected params for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by ExpectParams functions")
	}

	mmListNamespacePipelineReleases.defaultExpectation.params = &RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespacePipelineReleases.expectations {
		if minimock.Equal(e.params, mmListNamespacePipelineReleases.defaultExpectation.params) {
			mmListNamespacePipelineReleases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespacePipelineReleases.defaultExpectation.params)
		}
	}

	return mmListNamespacePipelineReleases
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectPageSizeParam4 sets up expected param pageSize for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectPageSizeParam4(pageSize int64) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectPageTokenParam5 sets up expected param pageToken for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectPageTokenParam5(pageToken string) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectIsBasicViewParam6 sets up expected param isBasicView for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectIsBasicViewParam6(isBasicView bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectFilterParam7 sets up expected param filter for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectFilterParam7(filter filtering.Filter) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.filter = &filter
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// ExpectReturnCountParam9 sets up expected param returnCount for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectReturnCountParam9(returnCount bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.returnCount = &returnCount
	mmListNamespacePipelineReleases.defaultExpectation.expectationOrigins.originReturnCount = minimock.CallerInfo(1)

	return mmListNamespacePipelineReleases
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool)) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.inspectFuncListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespacePipelineReleases")
	}

	mmListNamespacePipelineReleases.mock.inspectFuncListNamespacePipelineReleases = f

	return mmListNamespacePipelineReleases
}

// Return sets up results that will be returned by Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Return(ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{mock: mmListNamespacePipelineReleases.mock}
	}
	mmListNamespacePipelineReleases.defaultExpectation.results = &RepositoryMockListNamespacePipelineReleasesResults{ppa1, i1, s1, err}
	mmListNamespacePipelineReleases.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespacePipelineReleases.mock
}

// Set uses given function f to mock the Repository.ListNamespacePipelineReleases method
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListNamespacePipelineReleases.defaultExpectation != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespacePipelineReleases method")
	}

	if len(mmListNamespacePipelineReleases.expectations) > 0 {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespacePipelineReleases method")
	}

	mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases = f
	mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleasesOrigin = minimock.CallerInfo(1)
	return mmListNamespacePipelineReleases.mock
}

// When sets expectation for the Repository.ListNamespacePipelineReleases which will trigger the result defined by the following
// Then helper
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) *RepositoryMockListNamespacePipelineReleasesExpectation {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespacePipelineReleasesExpectation{
		mock:               mmListNamespacePipelineReleases.mock,
		params:             &RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount},
		expectationOrigins: RepositoryMockListNamespacePipelineReleasesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespacePipelineReleases.expectations = append(mmListNamespacePipelineReleases.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespacePipelineReleases return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespacePipelineReleasesExpectation) Then(ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespacePipelineReleasesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespacePipelineReleases should be invoked
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Times(n uint64) *mRepositoryMockListNamespacePipelineReleases {
	if n == 0 {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Times of RepositoryMock.ListNamespacePipelineReleases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespacePipelineReleases.expectedInvocations, n)
	mmListNamespacePipelineReleases.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespacePipelineReleases
}

func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) invocationsDone() bool {
	if len(mmListNamespacePipelineReleases.expectations) == 0 && mmListNamespacePipelineReleases.defaultExpectation == nil && mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.mock.afterListNamespacePipelineReleasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespacePipelineReleases implements mm_repository.Repository
func (mmListNamespacePipelineReleases *RepositoryMock) ListNamespacePipelineReleases(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListNamespacePipelineReleases.beforeListNamespacePipelineReleasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespacePipelineReleases.afterListNamespacePipelineReleasesCounter, 1)

	mmListNamespacePipelineReleases.t.Helper()

	if mmListNamespacePipelineReleases.inspectFuncListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.inspectFuncListNamespacePipelineReleases(ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	}

	mm_params := RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}

	// Record call args
	mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.mutex.Lock()
	mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.callArgs = append(mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.callArgs, &mm_params)
	mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.mutex.Unlock()

	for _, e := range mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.returnCount != nil && !minimock.Equal(*mm_want_ptrs.returnCount, mm_got.returnCount) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter returnCount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.originReturnCount, *mm_want_ptrs.returnCount, mm_got.returnCount, minimock.Diff(*mm_want_ptrs.returnCount, mm_got.returnCount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespacePipelineReleases.t.Fatal("No results are set for the RepositoryMock.ListNamespacePipelineReleases")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListNamespacePipelineReleases.funcListNamespacePipelineReleases != nil {
		return mmListNamespacePipelineReleases.funcListNamespacePipelineReleases(ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	}
	mmListNamespacePipelineReleases.t.Fatalf("Unexpected call to RepositoryMock.ListNamespacePipelineReleases. %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	return
}

// ListNamespacePipelineReleasesAfterCounter returns a count of finished RepositoryMock.ListNamespacePipelineReleases invocations
func (mmListNamespacePipelineReleases *RepositoryMock) ListNamespacePipelineReleasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.afterListNamespacePipelineReleasesCounter)
}

// ListNamespacePipelineReleasesBeforeCounter returns a count of RepositoryMock.ListNamespacePipelineReleases invocations
func (mmListNamespacePipelineReleases *RepositoryMock) ListNamespacePipelineReleasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.beforeListNamespacePipelineReleasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespacePipelineReleases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Calls() []*RepositoryMockListNamespacePipelineReleasesParams {
	mmListNamespacePipelineReleases.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespacePipelineReleasesParams, len(mmListNamespacePipelineReleases.callArgs))
	copy(argCopy, mmListNamespacePipelineReleases.callArgs)

	mmListNamespacePipelineReleases.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespacePipelineReleasesDone returns true if the count of the ListNamespacePipelineReleases invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespacePipelineReleasesDone() bool {
	if m.ListNamespacePipelineReleasesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespacePipelineReleasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespacePipelineReleasesMock.invocationsDone()
}

// MinimockListNamespacePipelineReleasesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespacePipelineReleasesInspect() {
	for _, e := range m.ListNamespacePipelineReleasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelineReleases at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespacePipelineReleasesCounter := mm_atomic.LoadUint64(&m.afterListNamespacePipelineReleasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespacePipelineReleasesMock.defaultExpectation != nil && afterListNamespacePipelineReleasesCounter < 1 {
		if m.ListNamespacePipelineReleasesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelineReleases at\n%s", m.ListNamespacePipelineReleasesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelineReleases at\n%s with params: %#v", m.ListNamespacePipelineReleasesMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespacePipelineReleasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespacePipelineReleases != nil && afterListNamespacePipelineReleasesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelineReleases at\n%s", m.funcListNamespacePipelineReleasesOrigin)
	}

	if !m.ListNamespacePipelineReleasesMock.invocationsDone() && afterListNamespacePipelineReleasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespacePipelineReleases at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespacePipelineReleasesMock.expectedInvocations), m.ListNamespacePipelineReleasesMock.expectedInvocationsOrigin, afterListNamespacePipelineReleasesCounter)
	}
}

type mRepositoryMockListNamespacePipelines struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespacePipelinesExpectation
	expectations       []*RepositoryMockListNamespacePipelinesExpectation

	callArgs []*RepositoryMockListNamespacePipelinesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListNamespacePipelinesExpectation specifies expectation struct of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListNamespacePipelinesParams
	paramPtrs          *RepositoryMockListNamespacePipelinesParamPtrs
	expectationOrigins RepositoryMockListNamespacePipelinesExpectationOrigins
	results            *RepositoryMockListNamespacePipelinesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListNamespacePipelinesParams contains parameters of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	uidAllowList   []uuid.UUID
	showDeleted    bool
	embedReleases  bool
	order          ordering.OrderBy
}

// RepositoryMockListNamespacePipelinesParamPtrs contains pointers to parameters of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	uidAllowList   *[]uuid.UUID
	showDeleted    *bool
	embedReleases  *bool
	order          *ordering.OrderBy
}

// RepositoryMockListNamespacePipelinesResults contains results of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListNamespacePipelinesOrigins contains origins of expectations of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPageSize       string
	originPageToken      string
	originIsBasicView    string
	originFilter         string
	originUidAllowList   string
	originShowDeleted    string
	originEmbedReleases  string
	originOrder          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Optional() *mRepositoryMockListNamespacePipelines {
	mmListNamespacePipelines.optional = true
	return mmListNamespacePipelines
}

// Expect sets up expected params for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by ExpectParams functions")
	}

	mmListNamespacePipelines.defaultExpectation.params = &RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespacePipelines.expectations {
		if minimock.Equal(e.params, mmListNamespacePipelines.defaultExpectation.params) {
			mmListNamespacePipelines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespacePipelines.defaultExpectation.params)
		}
	}

	return mmListNamespacePipelines
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectFilterParam6 sets up expected param filter for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectFilterParam6(filter filtering.Filter) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.filter = &filter
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectUidAllowListParam7 sets up expected param uidAllowList for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectUidAllowListParam7(uidAllowList []uuid.UUID) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectEmbedReleasesParam9 sets up expected param embedReleases for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectEmbedReleasesParam9(embedReleases bool) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// ExpectOrderParam10 sets up expected param order for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectOrderParam10(order ordering.OrderBy) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.order = &order
	mmListNamespacePipelines.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmListNamespacePipelines
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.inspectFuncListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespacePipelines")
	}

	mmListNamespacePipelines.mock.inspectFuncListNamespacePipelines = f

	return mmListNamespacePipelines
}

// Return sets up results that will be returned by Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{mock: mmListNamespacePipelines.mock}
	}
	mmListNamespacePipelines.defaultExpectation.results = &RepositoryMockListNamespacePipelinesResults{ppa1, i1, s1, err}
	mmListNamespacePipelines.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespacePipelines.mock
}

// Set uses given function f to mock the Repository.ListNamespacePipelines method
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListNamespacePipelines.defaultExpectation != nil {
		mmListNamespacePipelines.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespacePipelines method")
	}

	if len(mmListNamespacePipelines.expectations) > 0 {
		mmListNamespacePipelines.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespacePipelines method")
	}

	mmListNamespacePipelines.mock.funcListNamespacePipelines = f
	mmListNamespacePipelines.mock.funcListNamespacePipelinesOrigin = minimock.CallerInfo(1)
	return mmListNamespacePipelines.mock
}

// When sets expectation for the Repository.ListNamespacePipelines which will trigger the result defined by the following
// Then helper
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *RepositoryMockListNamespacePipelinesExpectation {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespacePipelinesExpectation{
		mock:               mmListNamespacePipelines.mock,
		params:             &RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order},
		expectationOrigins: RepositoryMockListNamespacePipelinesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespacePipelines.expectations = append(mmListNamespacePipelines.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespacePipelines return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespacePipelinesExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespacePipelinesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespacePipelines should be invoked
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Times(n uint64) *mRepositoryMockListNamespacePipelines {
	if n == 0 {
		mmListNamespacePipelines.mock.t.Fatalf("Times of RepositoryMock.ListNamespacePipelines mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespacePipelines.expectedInvocations, n)
	mmListNamespacePipelines.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespacePipelines
}

func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) invocationsDone() bool {
	if len(mmListNamespacePipelines.expectations) == 0 && mmListNamespacePipelines.defaultExpectation == nil && mmListNamespacePipelines.mock.funcListNamespacePipelines == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelines.mock.afterListNamespacePipelinesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelines.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespacePipelines implements mm_repository.Repository
func (mmListNamespacePipelines *RepositoryMock) ListNamespacePipelines(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListNamespacePipelines.beforeListNamespacePipelinesCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespacePipelines.afterListNamespacePipelinesCounter, 1)

	mmListNamespacePipelines.t.Helper()

	if mmListNamespacePipelines.inspectFuncListNamespacePipelines != nil {
		mmListNamespacePipelines.inspectFuncListNamespacePipelines(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}

	mm_params := RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

	// Record call args
	mmListNamespacePipelines.ListNamespacePipelinesMock.mutex.Lock()
	mmListNamespacePipelines.ListNamespacePipelinesMock.callArgs = append(mmListNamespacePipelines.ListNamespacePipelinesMock.callArgs, &mm_params)
	mmListNamespacePipelines.ListNamespacePipelinesMock.mutex.Unlock()

	for _, e := range mmListNamespacePipelines.ListNamespacePipelinesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespacePipelines.t.Fatal("No results are set for the RepositoryMock.ListNamespacePipelines")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListNamespacePipelines.funcListNamespacePipelines != nil {
		return mmListNamespacePipelines.funcListNamespacePipelines(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}
	mmListNamespacePipelines.t.Fatalf("Unexpected call to RepositoryMock.ListNamespacePipelines. %v %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	return
}

// ListNamespacePipelinesAfterCounter returns a count of finished RepositoryMock.ListNamespacePipelines invocations
func (mmListNamespacePipelines *RepositoryMock) ListNamespacePipelinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelines.afterListNamespacePipelinesCounter)
}

// ListNamespacePipelinesBeforeCounter returns a count of RepositoryMock.ListNamespacePipelines invocations
func (mmListNamespacePipelines *RepositoryMock) ListNamespacePipelinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelines.beforeListNamespacePipelinesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespacePipelines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Calls() []*RepositoryMockListNamespacePipelinesParams {
	mmListNamespacePipelines.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespacePipelinesParams, len(mmListNamespacePipelines.callArgs))
	copy(argCopy, mmListNamespacePipelines.callArgs)

	mmListNamespacePipelines.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespacePipelinesDone returns true if the count of the ListNamespacePipelines invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespacePipelinesDone() bool {
	if m.ListNamespacePipelinesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespacePipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespacePipelinesMock.invocationsDone()
}

// MinimockListNamespacePipelinesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespacePipelinesInspect() {
	for _, e := range m.ListNamespacePipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelines at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespacePipelinesCounter := mm_atomic.LoadUint64(&m.afterListNamespacePipelinesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespacePipelinesMock.defaultExpectation != nil && afterListNamespacePipelinesCounter < 1 {
		if m.ListNamespacePipelinesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelines at\n%s", m.ListNamespacePipelinesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelines at\n%s with params: %#v", m.ListNamespacePipelinesMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespacePipelinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespacePipelines != nil && afterListNamespacePipelinesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelines at\n%s", m.funcListNamespacePipelinesOrigin)
	}

	if !m.ListNamespacePipelinesMock.invocationsDone() && afterListNamespacePipelinesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespacePipelines at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespacePipelinesMock.expectedInvocations), m.ListNamespacePipelinesMock.expectedInvocationsOrigin, afterListNamespacePipelinesCounter)
	}
}

type mRepositoryMockListNamespaceSecrets struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespaceSecretsExpectation
	expectations       []*RepositoryMockListNamespaceSecretsExpectation

	callArgs []*RepositoryMockListNamespaceSecretsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListNamespaceSecretsExpectation specifies expectation struct of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListNamespaceSecretsParams
	paramPtrs          *RepositoryMockListNamespaceSecretsParamPtrs
	expectationOrigins RepositoryMockListNamespaceSecretsExpectationOrigins
	results            *RepositoryMockListNamespaceSecretsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListNamespaceSecretsParams contains parameters of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	filter         filtering.Filter
}

// RepositoryMockListNamespaceSecretsParamPtrs contains pointers to parameters of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	filter         *filtering.Filter
}

// RepositoryMockListNamespaceSecretsResults contains results of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsResults struct {
	spa1 []*datamodel.Secret
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListNamespaceSecretsOrigins contains origins of expectations of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPageSize       string
	originPageToken      string
	originFilter         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Optional() *mRepositoryMockListNamespaceSecrets {
	mmListNamespaceSecrets.optional = true
	return mmListNamespaceSecrets
}

// Expect sets up expected params for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by ExpectParams functions")
	}

	mmListNamespaceSecrets.defaultExpectation.params = &RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespaceSecrets.expectations {
		if minimock.Equal(e.params, mmListNamespaceSecrets.defaultExpectation.params) {
			mmListNamespaceSecrets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceSecrets.defaultExpectation.params)
		}
	}

	return mmListNamespaceSecrets
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.filter = &filter
	mmListNamespaceSecrets.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListNamespaceSecrets
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter)) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.inspectFuncListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespaceSecrets")
	}

	mmListNamespaceSecrets.mock.inspectFuncListNamespaceSecrets = f

	return mmListNamespaceSecrets
}

// Return sets up results that will be returned by Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Return(spa1 []*datamodel.Secret, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{mock: mmListNamespaceSecrets.mock}
	}
	mmListNamespaceSecrets.defaultExpectation.results = &RepositoryMockListNamespaceSecretsResults{spa1, i1, s1, err}
	mmListNamespaceSecrets.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespaceSecrets.mock
}

// Set uses given function f to mock the Repository.ListNamespaceSecrets method
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListNamespaceSecrets.defaultExpectation != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespaceSecrets method")
	}

	if len(mmListNamespaceSecrets.expectations) > 0 {
		mmListNamespaceSecrets.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespaceSecrets method")
	}

	mmListNamespaceSecrets.mock.funcListNamespaceSecrets = f
	mmListNamespaceSecrets.mock.funcListNamespaceSecretsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceSecrets.mock
}

// When sets expectation for the Repository.ListNamespaceSecrets which will trigger the result defined by the following
// Then helper
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) *RepositoryMockListNamespaceSecretsExpectation {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespaceSecretsExpectation{
		mock:               mmListNamespaceSecrets.mock,
		params:             &RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter},
		expectationOrigins: RepositoryMockListNamespaceSecretsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespaceSecrets.expectations = append(mmListNamespaceSecrets.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespaceSecrets return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespaceSecretsExpectation) Then(spa1 []*datamodel.Secret, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespaceSecretsResults{spa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespaceSecrets should be invoked
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Times(n uint64) *mRepositoryMockListNamespaceSecrets {
	if n == 0 {
		mmListNamespaceSecrets.mock.t.Fatalf("Times of RepositoryMock.ListNamespaceSecrets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceSecrets.expectedInvocations, n)
	mmListNamespaceSecrets.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceSecrets
}

func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) invocationsDone() bool {
	if len(mmListNamespaceSecrets.expectations) == 0 && mmListNamespaceSecrets.defaultExpectation == nil && mmListNamespaceSecrets.mock.funcListNamespaceSecrets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceSecrets.mock.afterListNamespaceSecretsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceSecrets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceSecrets implements mm_repository.Repository
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecrets(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListNamespaceSecrets.beforeListNamespaceSecretsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceSecrets.afterListNamespaceSecretsCounter, 1)

	mmListNamespaceSecrets.t.Helper()

	if mmListNamespaceSecrets.inspectFuncListNamespaceSecrets != nil {
		mmListNamespaceSecrets.inspectFuncListNamespaceSecrets(ctx, ownerPermalink, pageSize, pageToken, filter)
	}

	mm_params := RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}

	// Record call args
	mmListNamespaceSecrets.ListNamespaceSecretsMock.mutex.Lock()
	mmListNamespaceSecrets.ListNamespaceSecretsMock.callArgs = append(mmListNamespaceSecrets.ListNamespaceSecretsMock.callArgs, &mm_params)
	mmListNamespaceSecrets.ListNamespaceSecretsMock.mutex.Unlock()

	for _, e := range mmListNamespaceSecrets.ListNamespaceSecretsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceSecrets.t.Fatal("No results are set for the RepositoryMock.ListNamespaceSecrets")
		}
		return (*mm_results).spa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListNamespaceSecrets.funcListNamespaceSecrets != nil {
		return mmListNamespaceSecrets.funcListNamespaceSecrets(ctx, ownerPermalink, pageSize, pageToken, filter)
	}
	mmListNamespaceSecrets.t.Fatalf("Unexpected call to RepositoryMock.ListNamespaceSecrets. %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, filter)
	return
}

// ListNamespaceSecretsAfterCounter returns a count of finished RepositoryMock.ListNamespaceSecrets invocations
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecretsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceSecrets.afterListNamespaceSecretsCounter)
}

// ListNamespaceSecretsBeforeCounter returns a count of RepositoryMock.ListNamespaceSecrets invocations
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecretsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceSecrets.beforeListNamespaceSecretsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespaceSecrets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Calls() []*RepositoryMockListNamespaceSecretsParams {
	mmListNamespaceSecrets.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespaceSecretsParams, len(mmListNamespaceSecrets.callArgs))
	copy(argCopy, mmListNamespaceSecrets.callArgs)

	mmListNamespaceSecrets.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceSecretsDone returns true if the count of the ListNamespaceSecrets invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespaceSecretsDone() bool {
	if m.ListNamespaceSecretsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceSecretsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceSecretsMock.invocationsDone()
}

// MinimockListNamespaceSecretsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespaceSecretsInspect() {
	for _, e := range m.ListNamespaceSecretsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespaceSecretsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceSecretsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceSecretsMock.defaultExpectation != nil && afterListNamespaceSecretsCounter < 1 {
		if m.ListNamespaceSecretsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s", m.ListNamespaceSecretsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s with params: %#v", m.ListNamespaceSecretsMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespaceSecretsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceSecrets != nil && afterListNamespaceSecretsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets at\n%s", m.funcListNamespaceSecretsOrigin)
	}

	if !m.ListNamespaceSecretsMock.invocationsDone() && afterListNamespaceSecretsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespaceSecrets at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceSecretsMock.expectedInvocations), m.ListNamespaceSecretsMock.expectedInvocationsOrigin, afterListNamespaceSecretsCounter)
	}
}

type mRepositoryMockListPipelineIDsByConnectionID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineIDsByConnectionIDExpectation
	expectations       []*RepositoryMockListPipelineIDsByConnectionIDExpectation

	callArgs []*RepositoryMockListPipelineIDsByConnectionIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelineIDsByConnectionIDExpectation specifies expectation struct of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelineIDsByConnectionIDParams
	paramPtrs          *RepositoryMockListPipelineIDsByConnectionIDParamPtrs
	expectationOrigins RepositoryMockListPipelineIDsByConnectionIDExpectationOrigins
	results            *RepositoryMockListPipelineIDsByConnectionIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelineIDsByConnectionIDParams contains parameters of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDParams struct {
	ctx context.Context
	l1  mm_repository.ListPipelineIDsByConnectionIDParams
}

// RepositoryMockListPipelineIDsByConnectionIDParamPtrs contains pointers to parameters of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListPipelineIDsByConnectionIDParams
}

// RepositoryMockListPipelineIDsByConnectionIDResults contains results of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDResults struct {
	p1  mm_repository.PipelinesByConnectionList
	err error
}

// RepositoryMockListPipelineIDsByConnectionIDOrigins contains origins of expectations of the Repository.ListPipelineIDsByConnectionID
type RepositoryMockListPipelineIDsByConnectionIDExpectationOrigins struct {
	origin    string
	originCtx string
	originL1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Optional() *mRepositoryMockListPipelineIDsByConnectionID {
	mmListPipelineIDsByConnectionID.optional = true
	return mmListPipelineIDsByConnectionID
}

// Expect sets up expected params for Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Expect(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{}
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by ExpectParams functions")
	}

	mmListPipelineIDsByConnectionID.defaultExpectation.params = &RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1}
	mmListPipelineIDsByConnectionID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelineIDsByConnectionID.expectations {
		if minimock.Equal(e.params, mmListPipelineIDsByConnectionID.defaultExpectation.params) {
			mmListPipelineIDsByConnectionID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineIDsByConnectionID.defaultExpectation.params)
		}
	}

	return mmListPipelineIDsByConnectionID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{}
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.params != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Expect")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs = &RepositoryMockListPipelineIDsByConnectionIDParamPtrs{}
	}
	mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelineIDsByConnectionID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelineIDsByConnectionID
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) ExpectL1Param2(l1 mm_repository.ListPipelineIDsByConnectionIDParams) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{}
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.params != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Expect")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs = &RepositoryMockListPipelineIDsByConnectionIDParamPtrs{}
	}
	mmListPipelineIDsByConnectionID.defaultExpectation.paramPtrs.l1 = &l1
	mmListPipelineIDsByConnectionID.defaultExpectation.expectationOrigins.originL1 = minimock.CallerInfo(1)

	return mmListPipelineIDsByConnectionID
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Inspect(f func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams)) *mRepositoryMockListPipelineIDsByConnectionID {
	if mmListPipelineIDsByConnectionID.mock.inspectFuncListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineIDsByConnectionID")
	}

	mmListPipelineIDsByConnectionID.mock.inspectFuncListPipelineIDsByConnectionID = f

	return mmListPipelineIDsByConnectionID
}

// Return sets up results that will be returned by Repository.ListPipelineIDsByConnectionID
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Return(p1 mm_repository.PipelinesByConnectionList, err error) *RepositoryMock {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	if mmListPipelineIDsByConnectionID.defaultExpectation == nil {
		mmListPipelineIDsByConnectionID.defaultExpectation = &RepositoryMockListPipelineIDsByConnectionIDExpectation{mock: mmListPipelineIDsByConnectionID.mock}
	}
	mmListPipelineIDsByConnectionID.defaultExpectation.results = &RepositoryMockListPipelineIDsByConnectionIDResults{p1, err}
	mmListPipelineIDsByConnectionID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelineIDsByConnectionID.mock
}

// Set uses given function f to mock the Repository.ListPipelineIDsByConnectionID method
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Set(f func(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) (p1 mm_repository.PipelinesByConnectionList, err error)) *RepositoryMock {
	if mmListPipelineIDsByConnectionID.defaultExpectation != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineIDsByConnectionID method")
	}

	if len(mmListPipelineIDsByConnectionID.expectations) > 0 {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineIDsByConnectionID method")
	}

	mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID = f
	mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionIDOrigin = minimock.CallerInfo(1)
	return mmListPipelineIDsByConnectionID.mock
}

// When sets expectation for the Repository.ListPipelineIDsByConnectionID which will trigger the result defined by the following
// Then helper
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) When(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) *RepositoryMockListPipelineIDsByConnectionIDExpectation {
	if mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("RepositoryMock.ListPipelineIDsByConnectionID mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineIDsByConnectionIDExpectation{
		mock:               mmListPipelineIDsByConnectionID.mock,
		params:             &RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1},
		expectationOrigins: RepositoryMockListPipelineIDsByConnectionIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelineIDsByConnectionID.expectations = append(mmListPipelineIDsByConnectionID.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineIDsByConnectionID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineIDsByConnectionIDExpectation) Then(p1 mm_repository.PipelinesByConnectionList, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineIDsByConnectionIDResults{p1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineIDsByConnectionID should be invoked
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Times(n uint64) *mRepositoryMockListPipelineIDsByConnectionID {
	if n == 0 {
		mmListPipelineIDsByConnectionID.mock.t.Fatalf("Times of RepositoryMock.ListPipelineIDsByConnectionID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineIDsByConnectionID.expectedInvocations, n)
	mmListPipelineIDsByConnectionID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelineIDsByConnectionID
}

func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) invocationsDone() bool {
	if len(mmListPipelineIDsByConnectionID.expectations) == 0 && mmListPipelineIDsByConnectionID.defaultExpectation == nil && mmListPipelineIDsByConnectionID.mock.funcListPipelineIDsByConnectionID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.mock.afterListPipelineIDsByConnectionIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineIDsByConnectionID implements mm_repository.Repository
func (mmListPipelineIDsByConnectionID *RepositoryMock) ListPipelineIDsByConnectionID(ctx context.Context, l1 mm_repository.ListPipelineIDsByConnectionIDParams) (p1 mm_repository.PipelinesByConnectionList, err error) {
	mm_atomic.AddUint64(&mmListPipelineIDsByConnectionID.beforeListPipelineIDsByConnectionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineIDsByConnectionID.afterListPipelineIDsByConnectionIDCounter, 1)

	mmListPipelineIDsByConnectionID.t.Helper()

	if mmListPipelineIDsByConnectionID.inspectFuncListPipelineIDsByConnectionID != nil {
		mmListPipelineIDsByConnectionID.inspectFuncListPipelineIDsByConnectionID(ctx, l1)
	}

	mm_params := RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1}

	// Record call args
	mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.mutex.Lock()
	mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.callArgs = append(mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.callArgs, &mm_params)
	mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.mutex.Unlock()

	for _, e := range mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineIDsByConnectionIDParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineIDsByConnectionID.t.Errorf("RepositoryMock.ListPipelineIDsByConnectionID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListPipelineIDsByConnectionID.t.Errorf("RepositoryMock.ListPipelineIDsByConnectionID got unexpected parameter l1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.originL1, *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineIDsByConnectionID.t.Errorf("RepositoryMock.ListPipelineIDsByConnectionID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineIDsByConnectionID.ListPipelineIDsByConnectionIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineIDsByConnectionID.t.Fatal("No results are set for the RepositoryMock.ListPipelineIDsByConnectionID")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmListPipelineIDsByConnectionID.funcListPipelineIDsByConnectionID != nil {
		return mmListPipelineIDsByConnectionID.funcListPipelineIDsByConnectionID(ctx, l1)
	}
	mmListPipelineIDsByConnectionID.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineIDsByConnectionID. %v %v", ctx, l1)
	return
}

// ListPipelineIDsByConnectionIDAfterCounter returns a count of finished RepositoryMock.ListPipelineIDsByConnectionID invocations
func (mmListPipelineIDsByConnectionID *RepositoryMock) ListPipelineIDsByConnectionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.afterListPipelineIDsByConnectionIDCounter)
}

// ListPipelineIDsByConnectionIDBeforeCounter returns a count of RepositoryMock.ListPipelineIDsByConnectionID invocations
func (mmListPipelineIDsByConnectionID *RepositoryMock) ListPipelineIDsByConnectionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineIDsByConnectionID.beforeListPipelineIDsByConnectionIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineIDsByConnectionID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineIDsByConnectionID *mRepositoryMockListPipelineIDsByConnectionID) Calls() []*RepositoryMockListPipelineIDsByConnectionIDParams {
	mmListPipelineIDsByConnectionID.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineIDsByConnectionIDParams, len(mmListPipelineIDsByConnectionID.callArgs))
	copy(argCopy, mmListPipelineIDsByConnectionID.callArgs)

	mmListPipelineIDsByConnectionID.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineIDsByConnectionIDDone returns true if the count of the ListPipelineIDsByConnectionID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineIDsByConnectionIDDone() bool {
	if m.ListPipelineIDsByConnectionIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineIDsByConnectionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineIDsByConnectionIDMock.invocationsDone()
}

// MinimockListPipelineIDsByConnectionIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineIDsByConnectionIDInspect() {
	for _, e := range m.ListPipelineIDsByConnectionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelineIDsByConnectionIDCounter := mm_atomic.LoadUint64(&m.afterListPipelineIDsByConnectionIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineIDsByConnectionIDMock.defaultExpectation != nil && afterListPipelineIDsByConnectionIDCounter < 1 {
		if m.ListPipelineIDsByConnectionIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s", m.ListPipelineIDsByConnectionIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s with params: %#v", m.ListPipelineIDsByConnectionIDMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelineIDsByConnectionIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineIDsByConnectionID != nil && afterListPipelineIDsByConnectionIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelineIDsByConnectionID at\n%s", m.funcListPipelineIDsByConnectionIDOrigin)
	}

	if !m.ListPipelineIDsByConnectionIDMock.invocationsDone() && afterListPipelineIDsByConnectionIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineIDsByConnectionID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineIDsByConnectionIDMock.expectedInvocations), m.ListPipelineIDsByConnectionIDMock.expectedInvocationsOrigin, afterListPipelineIDsByConnectionIDCounter)
	}
}

type mRepositoryMockListPipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineTagsExpectation
	expectations       []*RepositoryMockListPipelineTagsExpectation

	callArgs []*RepositoryMockListPipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelineTagsExpectation specifies expectation struct of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelineTagsParams
	paramPtrs          *RepositoryMockListPipelineTagsParamPtrs
	expectationOrigins RepositoryMockListPipelineTagsExpectationOrigins
	results            *RepositoryMockListPipelineTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelineTagsParams contains parameters of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
}

// RepositoryMockListPipelineTagsParamPtrs contains pointers to parameters of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
}

// RepositoryMockListPipelineTagsResults contains results of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsResults struct {
	ta1 []datamodel.Tag
	err error
}

// RepositoryMockListPipelineTagsOrigins contains origins of expectations of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Optional() *mRepositoryMockListPipelineTags {
	mmListPipelineTags.optional = true
	return mmListPipelineTags
}

// Expect sets up expected params for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by ExpectParams functions")
	}

	mmListPipelineTags.defaultExpectation.params = &RepositoryMockListPipelineTagsParams{ctx, pipelineUID}
	mmListPipelineTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelineTags.expectations {
		if minimock.Equal(e.params, mmListPipelineTags.defaultExpectation.params) {
			mmListPipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineTags.defaultExpectation.params)
		}
	}

	return mmListPipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.params != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Expect")
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs == nil {
		mmListPipelineTags.defaultExpectation.paramPtrs = &RepositoryMockListPipelineTagsParamPtrs{}
	}
	mmListPipelineTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelineTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.params != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Expect")
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs == nil {
		mmListPipelineTags.defaultExpectation.paramPtrs = &RepositoryMockListPipelineTagsParamPtrs{}
	}
	mmListPipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmListPipelineTags.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmListPipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID)) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.inspectFuncListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineTags")
	}

	mmListPipelineTags.mock.inspectFuncListPipelineTags = f

	return mmListPipelineTags
}

// Return sets up results that will be returned by Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Return(ta1 []datamodel.Tag, err error) *RepositoryMock {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{mock: mmListPipelineTags.mock}
	}
	mmListPipelineTags.defaultExpectation.results = &RepositoryMockListPipelineTagsResults{ta1, err}
	mmListPipelineTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelineTags.mock
}

// Set uses given function f to mock the Repository.ListPipelineTags method
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error)) *RepositoryMock {
	if mmListPipelineTags.defaultExpectation != nil {
		mmListPipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineTags method")
	}

	if len(mmListPipelineTags.expectations) > 0 {
		mmListPipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineTags method")
	}

	mmListPipelineTags.mock.funcListPipelineTags = f
	mmListPipelineTags.mock.funcListPipelineTagsOrigin = minimock.CallerInfo(1)
	return mmListPipelineTags.mock
}

// When sets expectation for the Repository.ListPipelineTags which will trigger the result defined by the following
// Then helper
func (mmListPipelineTags *mRepositoryMockListPipelineTags) When(ctx context.Context, pipelineUID uuid.UUID) *RepositoryMockListPipelineTagsExpectation {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineTagsExpectation{
		mock:               mmListPipelineTags.mock,
		params:             &RepositoryMockListPipelineTagsParams{ctx, pipelineUID},
		expectationOrigins: RepositoryMockListPipelineTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelineTags.expectations = append(mmListPipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineTagsExpectation) Then(ta1 []datamodel.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineTagsResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineTags should be invoked
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Times(n uint64) *mRepositoryMockListPipelineTags {
	if n == 0 {
		mmListPipelineTags.mock.t.Fatalf("Times of RepositoryMock.ListPipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineTags.expectedInvocations, n)
	mmListPipelineTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelineTags
}

func (mmListPipelineTags *mRepositoryMockListPipelineTags) invocationsDone() bool {
	if len(mmListPipelineTags.expectations) == 0 && mmListPipelineTags.defaultExpectation == nil && mmListPipelineTags.mock.funcListPipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineTags.mock.afterListPipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineTags implements mm_repository.Repository
func (mmListPipelineTags *RepositoryMock) ListPipelineTags(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error) {
	mm_atomic.AddUint64(&mmListPipelineTags.beforeListPipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineTags.afterListPipelineTagsCounter, 1)

	mmListPipelineTags.t.Helper()

	if mmListPipelineTags.inspectFuncListPipelineTags != nil {
		mmListPipelineTags.inspectFuncListPipelineTags(ctx, pipelineUID)
	}

	mm_params := RepositoryMockListPipelineTagsParams{ctx, pipelineUID}

	// Record call args
	mmListPipelineTags.ListPipelineTagsMock.mutex.Lock()
	mmListPipelineTags.ListPipelineTagsMock.callArgs = append(mmListPipelineTags.ListPipelineTagsMock.callArgs, &mm_params)
	mmListPipelineTags.ListPipelineTagsMock.mutex.Unlock()

	for _, e := range mmListPipelineTags.ListPipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListPipelineTags.ListPipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineTagsParams{ctx, pipelineUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineTags.t.Fatal("No results are set for the RepositoryMock.ListPipelineTags")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListPipelineTags.funcListPipelineTags != nil {
		return mmListPipelineTags.funcListPipelineTags(ctx, pipelineUID)
	}
	mmListPipelineTags.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineTags. %v %v", ctx, pipelineUID)
	return
}

// ListPipelineTagsAfterCounter returns a count of finished RepositoryMock.ListPipelineTags invocations
func (mmListPipelineTags *RepositoryMock) ListPipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineTags.afterListPipelineTagsCounter)
}

// ListPipelineTagsBeforeCounter returns a count of RepositoryMock.ListPipelineTags invocations
func (mmListPipelineTags *RepositoryMock) ListPipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineTags.beforeListPipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Calls() []*RepositoryMockListPipelineTagsParams {
	mmListPipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineTagsParams, len(mmListPipelineTags.callArgs))
	copy(argCopy, mmListPipelineTags.callArgs)

	mmListPipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineTagsDone returns true if the count of the ListPipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineTagsDone() bool {
	if m.ListPipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineTagsMock.invocationsDone()
}

// MinimockListPipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineTagsInspect() {
	for _, e := range m.ListPipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelineTagsCounter := mm_atomic.LoadUint64(&m.afterListPipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineTagsMock.defaultExpectation != nil && afterListPipelineTagsCounter < 1 {
		if m.ListPipelineTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s", m.ListPipelineTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s with params: %#v", m.ListPipelineTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineTags != nil && afterListPipelineTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags at\n%s", m.funcListPipelineTagsOrigin)
	}

	if !m.ListPipelineTagsMock.invocationsDone() && afterListPipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineTagsMock.expectedInvocations), m.ListPipelineTagsMock.expectedInvocationsOrigin, afterListPipelineTagsCounter)
	}
}

type mRepositoryMockListPipelines struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelinesExpectation
	expectations       []*RepositoryMockListPipelinesExpectation

	callArgs []*RepositoryMockListPipelinesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelinesExpectation specifies expectation struct of the Repository.ListPipelines
type RepositoryMockListPipelinesExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelinesParams
	paramPtrs          *RepositoryMockListPipelinesParamPtrs
	expectationOrigins RepositoryMockListPipelinesExpectationOrigins
	results            *RepositoryMockListPipelinesResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelinesParams contains parameters of the Repository.ListPipelines
type RepositoryMockListPipelinesParams struct {
	ctx                context.Context
	pageSize           int64
	pageToken          string
	isBasicView        bool
	filter             filtering.Filter
	uidAllowList       []uuid.UUID
	showDeleted        bool
	embedReleases      bool
	order              ordering.OrderBy
	presetNamespaceUID uuid.UUID
}

// RepositoryMockListPipelinesParamPtrs contains pointers to parameters of the Repository.ListPipelines
type RepositoryMockListPipelinesParamPtrs struct {
	ctx                *context.Context
	pageSize           *int64
	pageToken          *string
	isBasicView        *bool
	filter             *filtering.Filter
	uidAllowList       *[]uuid.UUID
	showDeleted        *bool
	embedReleases      *bool
	order              *ordering.OrderBy
	presetNamespaceUID *uuid.UUID
}

// RepositoryMockListPipelinesResults contains results of the Repository.ListPipelines
type RepositoryMockListPipelinesResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListPipelinesOrigins contains origins of expectations of the Repository.ListPipelines
type RepositoryMockListPipelinesExpectationOrigins struct {
	origin                   string
	originCtx                string
	originPageSize           string
	originPageToken          string
	originIsBasicView        string
	originFilter             string
	originUidAllowList       string
	originShowDeleted        string
	originEmbedReleases      string
	originOrder              string
	originPresetNamespaceUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelines *mRepositoryMockListPipelines) Optional() *mRepositoryMockListPipelines {
	mmListPipelines.optional = true
	return mmListPipelines
}

// Expect sets up expected params for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.paramPtrs != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by ExpectParams functions")
	}

	mmListPipelines.defaultExpectation.params = &RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID}
	mmListPipelines.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelines.expectations {
		if minimock.Equal(e.params, mmListPipelines.defaultExpectation.params) {
			mmListPipelines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelines.defaultExpectation.params)
		}
	}

	return mmListPipelines
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelines.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListPipelines.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListPipelines.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListPipelines.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.filter = &filter
	mmListPipelines.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectUidAllowListParam6 sets up expected param uidAllowList for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectUidAllowListParam6(uidAllowList []uuid.UUID) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmListPipelines.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectShowDeletedParam7 sets up expected param showDeleted for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectShowDeletedParam7(showDeleted bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListPipelines.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectEmbedReleasesParam8 sets up expected param embedReleases for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectEmbedReleasesParam8(embedReleases bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmListPipelines.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectOrderParam9 sets up expected param order for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectOrderParam9(order ordering.OrderBy) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.order = &order
	mmListPipelines.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmListPipelines
}

// ExpectPresetNamespaceUIDParam10 sets up expected param presetNamespaceUID for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectPresetNamespaceUIDParam10(presetNamespaceUID uuid.UUID) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.presetNamespaceUID = &presetNamespaceUID
	mmListPipelines.defaultExpectation.expectationOrigins.originPresetNamespaceUID = minimock.CallerInfo(1)

	return mmListPipelines
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID)) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.inspectFuncListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelines")
	}

	mmListPipelines.mock.inspectFuncListPipelines = f

	return mmListPipelines
}

// Return sets up results that will be returned by Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{mock: mmListPipelines.mock}
	}
	mmListPipelines.defaultExpectation.results = &RepositoryMockListPipelinesResults{ppa1, i1, s1, err}
	mmListPipelines.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelines.mock
}

// Set uses given function f to mock the Repository.ListPipelines method
func (mmListPipelines *mRepositoryMockListPipelines) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPipelines.defaultExpectation != nil {
		mmListPipelines.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelines method")
	}

	if len(mmListPipelines.expectations) > 0 {
		mmListPipelines.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelines method")
	}

	mmListPipelines.mock.funcListPipelines = f
	mmListPipelines.mock.funcListPipelinesOrigin = minimock.CallerInfo(1)
	return mmListPipelines.mock
}

// When sets expectation for the Repository.ListPipelines which will trigger the result defined by the following
// Then helper
func (mmListPipelines *mRepositoryMockListPipelines) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) *RepositoryMockListPipelinesExpectation {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelinesExpectation{
		mock:               mmListPipelines.mock,
		params:             &RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID},
		expectationOrigins: RepositoryMockListPipelinesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelines.expectations = append(mmListPipelines.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelines return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelinesExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelinesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelines should be invoked
func (mmListPipelines *mRepositoryMockListPipelines) Times(n uint64) *mRepositoryMockListPipelines {
	if n == 0 {
		mmListPipelines.mock.t.Fatalf("Times of RepositoryMock.ListPipelines mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelines.expectedInvocations, n)
	mmListPipelines.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelines
}

func (mmListPipelines *mRepositoryMockListPipelines) invocationsDone() bool {
	if len(mmListPipelines.expectations) == 0 && mmListPipelines.defaultExpectation == nil && mmListPipelines.mock.funcListPipelines == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelines.mock.afterListPipelinesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelines.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelines implements mm_repository.Repository
func (mmListPipelines *RepositoryMock) ListPipelines(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy, presetNamespaceUID uuid.UUID) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPipelines.beforeListPipelinesCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelines.afterListPipelinesCounter, 1)

	mmListPipelines.t.Helper()

	if mmListPipelines.inspectFuncListPipelines != nil {
		mmListPipelines.inspectFuncListPipelines(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID)
	}

	mm_params := RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID}

	// Record call args
	mmListPipelines.ListPipelinesMock.mutex.Lock()
	mmListPipelines.ListPipelinesMock.callArgs = append(mmListPipelines.ListPipelinesMock.callArgs, &mm_params)
	mmListPipelines.ListPipelinesMock.mutex.Unlock()

	for _, e := range mmListPipelines.ListPipelinesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPipelines.ListPipelinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelines.ListPipelinesMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelines.ListPipelinesMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelines.ListPipelinesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.presetNamespaceUID != nil && !minimock.Equal(*mm_want_ptrs.presetNamespaceUID, mm_got.presetNamespaceUID) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter presetNamespaceUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.originPresetNamespaceUID, *mm_want_ptrs.presetNamespaceUID, mm_got.presetNamespaceUID, minimock.Diff(*mm_want_ptrs.presetNamespaceUID, mm_got.presetNamespaceUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelines.ListPipelinesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelines.ListPipelinesMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelines.t.Fatal("No results are set for the RepositoryMock.ListPipelines")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPipelines.funcListPipelines != nil {
		return mmListPipelines.funcListPipelines(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID)
	}
	mmListPipelines.t.Fatalf("Unexpected call to RepositoryMock.ListPipelines. %v %v %v %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order, presetNamespaceUID)
	return
}

// ListPipelinesAfterCounter returns a count of finished RepositoryMock.ListPipelines invocations
func (mmListPipelines *RepositoryMock) ListPipelinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelines.afterListPipelinesCounter)
}

// ListPipelinesBeforeCounter returns a count of RepositoryMock.ListPipelines invocations
func (mmListPipelines *RepositoryMock) ListPipelinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelines.beforeListPipelinesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelines *mRepositoryMockListPipelines) Calls() []*RepositoryMockListPipelinesParams {
	mmListPipelines.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelinesParams, len(mmListPipelines.callArgs))
	copy(argCopy, mmListPipelines.callArgs)

	mmListPipelines.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelinesDone returns true if the count of the ListPipelines invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelinesDone() bool {
	if m.ListPipelinesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelinesMock.invocationsDone()
}

// MinimockListPipelinesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelinesInspect() {
	for _, e := range m.ListPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelinesCounter := mm_atomic.LoadUint64(&m.afterListPipelinesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelinesMock.defaultExpectation != nil && afterListPipelinesCounter < 1 {
		if m.ListPipelinesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s", m.ListPipelinesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s with params: %#v", m.ListPipelinesMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelines != nil && afterListPipelinesCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelines at\n%s", m.funcListPipelinesOrigin)
	}

	if !m.ListPipelinesMock.invocationsDone() && afterListPipelinesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelines at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelinesMock.expectedInvocations), m.ListPipelinesMock.expectedInvocationsOrigin, afterListPipelinesCounter)
	}
}

type mRepositoryMockListPipelinesAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelinesAdminExpectation
	expectations       []*RepositoryMockListPipelinesAdminExpectation

	callArgs []*RepositoryMockListPipelinesAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListPipelinesAdminExpectation specifies expectation struct of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListPipelinesAdminParams
	paramPtrs          *RepositoryMockListPipelinesAdminParamPtrs
	expectationOrigins RepositoryMockListPipelinesAdminExpectationOrigins
	results            *RepositoryMockListPipelinesAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListPipelinesAdminParams contains parameters of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminParams struct {
	ctx           context.Context
	pageSize      int64
	pageToken     string
	isBasicView   bool
	filter        filtering.Filter
	showDeleted   bool
	embedReleases bool
}

// RepositoryMockListPipelinesAdminParamPtrs contains pointers to parameters of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminParamPtrs struct {
	ctx           *context.Context
	pageSize      *int64
	pageToken     *string
	isBasicView   *bool
	filter        *filtering.Filter
	showDeleted   *bool
	embedReleases *bool
}

// RepositoryMockListPipelinesAdminResults contains results of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListPipelinesAdminOrigins contains origins of expectations of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminExpectationOrigins struct {
	origin              string
	originCtx           string
	originPageSize      string
	originPageToken     string
	originIsBasicView   string
	originFilter        string
	originShowDeleted   string
	originEmbedReleases string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Optional() *mRepositoryMockListPipelinesAdmin {
	mmListPipelinesAdmin.optional = true
	return mmListPipelinesAdmin
}

// Expect sets up expected params for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by ExpectParams functions")
	}

	mmListPipelinesAdmin.defaultExpectation.params = &RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPipelinesAdmin.expectations {
		if minimock.Equal(e.params, mmListPipelinesAdmin.defaultExpectation.params) {
			mmListPipelinesAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelinesAdmin.defaultExpectation.params)
		}
	}

	return mmListPipelinesAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.filter = &filter
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectShowDeletedParam6 sets up expected param showDeleted for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectShowDeletedParam6(showDeleted bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// ExpectEmbedReleasesParam7 sets up expected param embedReleases for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectEmbedReleasesParam7(embedReleases bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases
	mmListPipelinesAdmin.defaultExpectation.expectationOrigins.originEmbedReleases = minimock.CallerInfo(1)

	return mmListPipelinesAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool)) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.inspectFuncListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelinesAdmin")
	}

	mmListPipelinesAdmin.mock.inspectFuncListPipelinesAdmin = f

	return mmListPipelinesAdmin
}

// Return sets up results that will be returned by Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{mock: mmListPipelinesAdmin.mock}
	}
	mmListPipelinesAdmin.defaultExpectation.results = &RepositoryMockListPipelinesAdminResults{ppa1, i1, s1, err}
	mmListPipelinesAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPipelinesAdmin.mock
}

// Set uses given function f to mock the Repository.ListPipelinesAdmin method
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPipelinesAdmin.defaultExpectation != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelinesAdmin method")
	}

	if len(mmListPipelinesAdmin.expectations) > 0 {
		mmListPipelinesAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelinesAdmin method")
	}

	mmListPipelinesAdmin.mock.funcListPipelinesAdmin = f
	mmListPipelinesAdmin.mock.funcListPipelinesAdminOrigin = minimock.CallerInfo(1)
	return mmListPipelinesAdmin.mock
}

// When sets expectation for the Repository.ListPipelinesAdmin which will trigger the result defined by the following
// Then helper
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) *RepositoryMockListPipelinesAdminExpectation {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelinesAdminExpectation{
		mock:               mmListPipelinesAdmin.mock,
		params:             &RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases},
		expectationOrigins: RepositoryMockListPipelinesAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPipelinesAdmin.expectations = append(mmListPipelinesAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelinesAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelinesAdminExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelinesAdminResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelinesAdmin should be invoked
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Times(n uint64) *mRepositoryMockListPipelinesAdmin {
	if n == 0 {
		mmListPipelinesAdmin.mock.t.Fatalf("Times of RepositoryMock.ListPipelinesAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelinesAdmin.expectedInvocations, n)
	mmListPipelinesAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPipelinesAdmin
}

func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) invocationsDone() bool {
	if len(mmListPipelinesAdmin.expectations) == 0 && mmListPipelinesAdmin.defaultExpectation == nil && mmListPipelinesAdmin.mock.funcListPipelinesAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelinesAdmin.mock.afterListPipelinesAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelinesAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelinesAdmin implements mm_repository.Repository
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdmin(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPipelinesAdmin.beforeListPipelinesAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelinesAdmin.afterListPipelinesAdminCounter, 1)

	mmListPipelinesAdmin.t.Helper()

	if mmListPipelinesAdmin.inspectFuncListPipelinesAdmin != nil {
		mmListPipelinesAdmin.inspectFuncListPipelinesAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	}

	mm_params := RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}

	// Record call args
	mmListPipelinesAdmin.ListPipelinesAdminMock.mutex.Lock()
	mmListPipelinesAdmin.ListPipelinesAdminMock.callArgs = append(mmListPipelinesAdmin.ListPipelinesAdminMock.callArgs, &mm_params)
	mmListPipelinesAdmin.ListPipelinesAdminMock.mutex.Unlock()

	for _, e := range mmListPipelinesAdmin.ListPipelinesAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter embedReleases, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.originEmbedReleases, *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelinesAdmin.t.Fatal("No results are set for the RepositoryMock.ListPipelinesAdmin")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPipelinesAdmin.funcListPipelinesAdmin != nil {
		return mmListPipelinesAdmin.funcListPipelinesAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	}
	mmListPipelinesAdmin.t.Fatalf("Unexpected call to RepositoryMock.ListPipelinesAdmin. %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	return
}

// ListPipelinesAdminAfterCounter returns a count of finished RepositoryMock.ListPipelinesAdmin invocations
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelinesAdmin.afterListPipelinesAdminCounter)
}

// ListPipelinesAdminBeforeCounter returns a count of RepositoryMock.ListPipelinesAdmin invocations
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelinesAdmin.beforeListPipelinesAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelinesAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Calls() []*RepositoryMockListPipelinesAdminParams {
	mmListPipelinesAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelinesAdminParams, len(mmListPipelinesAdmin.callArgs))
	copy(argCopy, mmListPipelinesAdmin.callArgs)

	mmListPipelinesAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelinesAdminDone returns true if the count of the ListPipelinesAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelinesAdminDone() bool {
	if m.ListPipelinesAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelinesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelinesAdminMock.invocationsDone()
}

// MinimockListPipelinesAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelinesAdminInspect() {
	for _, e := range m.ListPipelinesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPipelinesAdminCounter := mm_atomic.LoadUint64(&m.afterListPipelinesAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelinesAdminMock.defaultExpectation != nil && afterListPipelinesAdminCounter < 1 {
		if m.ListPipelinesAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s", m.ListPipelinesAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s with params: %#v", m.ListPipelinesAdminMock.defaultExpectation.expectationOrigins.origin, *m.ListPipelinesAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelinesAdmin != nil && afterListPipelinesAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin at\n%s", m.funcListPipelinesAdminOrigin)
	}

	if !m.ListPipelinesAdminMock.invocationsDone() && afterListPipelinesAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelinesAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelinesAdminMock.expectedInvocations), m.ListPipelinesAdminMock.expectedInvocationsOrigin, afterListPipelinesAdminCounter)
	}
}

type mRepositoryMockPinUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockPinUserExpectation
	expectations       []*RepositoryMockPinUserExpectation

	callArgs []*RepositoryMockPinUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockPinUserExpectation specifies expectation struct of the Repository.PinUser
type RepositoryMockPinUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockPinUserParams
	paramPtrs          *RepositoryMockPinUserParamPtrs
	expectationOrigins RepositoryMockPinUserExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// RepositoryMockPinUserParams contains parameters of the Repository.PinUser
type RepositoryMockPinUserParams struct {
	ctx   context.Context
	table string
}

// RepositoryMockPinUserParamPtrs contains pointers to parameters of the Repository.PinUser
type RepositoryMockPinUserParamPtrs struct {
	ctx   *context.Context
	table *string
}

// RepositoryMockPinUserOrigins contains origins of expectations of the Repository.PinUser
type RepositoryMockPinUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originTable string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPinUser *mRepositoryMockPinUser) Optional() *mRepositoryMockPinUser {
	mmPinUser.optional = true
	return mmPinUser
}

// Expect sets up expected params for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Expect(ctx context.Context, table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.paramPtrs != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by ExpectParams functions")
	}

	mmPinUser.defaultExpectation.params = &RepositoryMockPinUserParams{ctx, table}
	mmPinUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPinUser.expectations {
		if minimock.Equal(e.params, mmPinUser.defaultExpectation.params) {
			mmPinUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPinUser.defaultExpectation.params)
		}
	}

	return mmPinUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmPinUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPinUser
}

// ExpectTableParam2 sets up expected param table for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectTableParam2(table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.table = &table
	mmPinUser.defaultExpectation.expectationOrigins.originTable = minimock.CallerInfo(1)

	return mmPinUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Inspect(f func(ctx context.Context, table string)) *mRepositoryMockPinUser {
	if mmPinUser.mock.inspectFuncPinUser != nil {
		mmPinUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.PinUser")
	}

	mmPinUser.mock.inspectFuncPinUser = f

	return mmPinUser
}

// Return sets up results that will be returned by Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Return() *RepositoryMock {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{mock: mmPinUser.mock}
	}

	mmPinUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPinUser.mock
}

// Set uses given function f to mock the Repository.PinUser method
func (mmPinUser *mRepositoryMockPinUser) Set(f func(ctx context.Context, table string)) *RepositoryMock {
	if mmPinUser.defaultExpectation != nil {
		mmPinUser.mock.t.Fatalf("Default expectation is already set for the Repository.PinUser method")
	}

	if len(mmPinUser.expectations) > 0 {
		mmPinUser.mock.t.Fatalf("Some expectations are already set for the Repository.PinUser method")
	}

	mmPinUser.mock.funcPinUser = f
	mmPinUser.mock.funcPinUserOrigin = minimock.CallerInfo(1)
	return mmPinUser.mock
}

// Times sets number of times Repository.PinUser should be invoked
func (mmPinUser *mRepositoryMockPinUser) Times(n uint64) *mRepositoryMockPinUser {
	if n == 0 {
		mmPinUser.mock.t.Fatalf("Times of RepositoryMock.PinUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPinUser.expectedInvocations, n)
	mmPinUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPinUser
}

func (mmPinUser *mRepositoryMockPinUser) invocationsDone() bool {
	if len(mmPinUser.expectations) == 0 && mmPinUser.defaultExpectation == nil && mmPinUser.mock.funcPinUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPinUser.mock.afterPinUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPinUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PinUser implements mm_repository.Repository
func (mmPinUser *RepositoryMock) PinUser(ctx context.Context, table string) {
	mm_atomic.AddUint64(&mmPinUser.beforePinUserCounter, 1)
	defer mm_atomic.AddUint64(&mmPinUser.afterPinUserCounter, 1)

	mmPinUser.t.Helper()

	if mmPinUser.inspectFuncPinUser != nil {
		mmPinUser.inspectFuncPinUser(ctx, table)
	}

	mm_params := RepositoryMockPinUserParams{ctx, table}

	// Record call args
	mmPinUser.PinUserMock.mutex.Lock()
	mmPinUser.PinUserMock.callArgs = append(mmPinUser.PinUserMock.callArgs, &mm_params)
	mmPinUser.PinUserMock.mutex.Unlock()

	for _, e := range mmPinUser.PinUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPinUser.PinUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPinUser.PinUserMock.defaultExpectation.Counter, 1)
		mm_want := mmPinUser.PinUserMock.defaultExpectation.params
		mm_want_ptrs := mmPinUser.PinUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockPinUserParams{ctx, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter table, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.originTable, *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPinUser.funcPinUser != nil {
		mmPinUser.funcPinUser(ctx, table)
		return
	}
	mmPinUser.t.Fatalf("Unexpected call to RepositoryMock.PinUser. %v %v", ctx, table)

}

// PinUserAfterCounter returns a count of finished RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.afterPinUserCounter)
}

// PinUserBeforeCounter returns a count of RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.beforePinUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.PinUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPinUser *mRepositoryMockPinUser) Calls() []*RepositoryMockPinUserParams {
	mmPinUser.mutex.RLock()

	argCopy := make([]*RepositoryMockPinUserParams, len(mmPinUser.callArgs))
	copy(argCopy, mmPinUser.callArgs)

	mmPinUser.mutex.RUnlock()

	return argCopy
}

// MinimockPinUserDone returns true if the count of the PinUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockPinUserDone() bool {
	if m.PinUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PinUserMock.invocationsDone()
}

// MinimockPinUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockPinUserInspect() {
	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPinUserCounter := mm_atomic.LoadUint64(&m.afterPinUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PinUserMock.defaultExpectation != nil && afterPinUserCounter < 1 {
		if m.PinUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s", m.PinUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s with params: %#v", m.PinUserMock.defaultExpectation.expectationOrigins.origin, *m.PinUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPinUser != nil && afterPinUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s", m.funcPinUserOrigin)
	}

	if !m.PinUserMock.invocationsDone() && afterPinUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.PinUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PinUserMock.expectedInvocations), m.PinUserMock.expectedInvocationsOrigin, afterPinUserCounter)
	}
}

type mRepositoryMockTranspileFilter struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTranspileFilterExpectation
	expectations       []*RepositoryMockTranspileFilterExpectation

	callArgs []*RepositoryMockTranspileFilterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockTranspileFilterExpectation specifies expectation struct of the Repository.TranspileFilter
type RepositoryMockTranspileFilterExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockTranspileFilterParams
	paramPtrs          *RepositoryMockTranspileFilterParamPtrs
	expectationOrigins RepositoryMockTranspileFilterExpectationOrigins
	results            *RepositoryMockTranspileFilterResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockTranspileFilterParams contains parameters of the Repository.TranspileFilter
type RepositoryMockTranspileFilterParams struct {
	f1 filtering.Filter
}

// RepositoryMockTranspileFilterParamPtrs contains pointers to parameters of the Repository.TranspileFilter
type RepositoryMockTranspileFilterParamPtrs struct {
	f1 *filtering.Filter
}

// RepositoryMockTranspileFilterResults contains results of the Repository.TranspileFilter
type RepositoryMockTranspileFilterResults struct {
	ep1 *clause.Expr
	err error
}

// RepositoryMockTranspileFilterOrigins contains origins of expectations of the Repository.TranspileFilter
type RepositoryMockTranspileFilterExpectationOrigins struct {
	origin   string
	originF1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Optional() *mRepositoryMockTranspileFilter {
	mmTranspileFilter.optional = true
	return mmTranspileFilter
}

// Expect sets up expected params for Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Expect(f1 filtering.Filter) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{}
	}

	if mmTranspileFilter.defaultExpectation.paramPtrs != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by ExpectParams functions")
	}

	mmTranspileFilter.defaultExpectation.params = &RepositoryMockTranspileFilterParams{f1}
	mmTranspileFilter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTranspileFilter.expectations {
		if minimock.Equal(e.params, mmTranspileFilter.defaultExpectation.params) {
			mmTranspileFilter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTranspileFilter.defaultExpectation.params)
		}
	}

	return mmTranspileFilter
}

// ExpectF1Param1 sets up expected param f1 for Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) ExpectF1Param1(f1 filtering.Filter) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{}
	}

	if mmTranspileFilter.defaultExpectation.params != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Expect")
	}

	if mmTranspileFilter.defaultExpectation.paramPtrs == nil {
		mmTranspileFilter.defaultExpectation.paramPtrs = &RepositoryMockTranspileFilterParamPtrs{}
	}
	mmTranspileFilter.defaultExpectation.paramPtrs.f1 = &f1
	mmTranspileFilter.defaultExpectation.expectationOrigins.originF1 = minimock.CallerInfo(1)

	return mmTranspileFilter
}

// Inspect accepts an inspector function that has same arguments as the Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Inspect(f func(f1 filtering.Filter)) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.inspectFuncTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("Inspect function is already set for RepositoryMock.TranspileFilter")
	}

	mmTranspileFilter.mock.inspectFuncTranspileFilter = f

	return mmTranspileFilter
}

// Return sets up results that will be returned by Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Return(ep1 *clause.Expr, err error) *RepositoryMock {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{mock: mmTranspileFilter.mock}
	}
	mmTranspileFilter.defaultExpectation.results = &RepositoryMockTranspileFilterResults{ep1, err}
	mmTranspileFilter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTranspileFilter.mock
}

// Set uses given function f to mock the Repository.TranspileFilter method
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Set(f func(f1 filtering.Filter) (ep1 *clause.Expr, err error)) *RepositoryMock {
	if mmTranspileFilter.defaultExpectation != nil {
		mmTranspileFilter.mock.t.Fatalf("Default expectation is already set for the Repository.TranspileFilter method")
	}

	if len(mmTranspileFilter.expectations) > 0 {
		mmTranspileFilter.mock.t.Fatalf("Some expectations are already set for the Repository.TranspileFilter method")
	}

	mmTranspileFilter.mock.funcTranspileFilter = f
	mmTranspileFilter.mock.funcTranspileFilterOrigin = minimock.CallerInfo(1)
	return mmTranspileFilter.mock
}

// When sets expectation for the Repository.TranspileFilter which will trigger the result defined by the following
// Then helper
func (mmTranspileFilter *mRepositoryMockTranspileFilter) When(f1 filtering.Filter) *RepositoryMockTranspileFilterExpectation {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	expectation := &RepositoryMockTranspileFilterExpectation{
		mock:               mmTranspileFilter.mock,
		params:             &RepositoryMockTranspileFilterParams{f1},
		expectationOrigins: RepositoryMockTranspileFilterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTranspileFilter.expectations = append(mmTranspileFilter.expectations, expectation)
	return expectation
}

// Then sets up Repository.TranspileFilter return parameters for the expectation previously defined by the When method
func (e *RepositoryMockTranspileFilterExpectation) Then(ep1 *clause.Expr, err error) *RepositoryMock {
	e.results = &RepositoryMockTranspileFilterResults{ep1, err}
	return e.mock
}

// Times sets number of times Repository.TranspileFilter should be invoked
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Times(n uint64) *mRepositoryMockTranspileFilter {
	if n == 0 {
		mmTranspileFilter.mock.t.Fatalf("Times of RepositoryMock.TranspileFilter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTranspileFilter.expectedInvocations, n)
	mmTranspileFilter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTranspileFilter
}

func (mmTranspileFilter *mRepositoryMockTranspileFilter) invocationsDone() bool {
	if len(mmTranspileFilter.expectations) == 0 && mmTranspileFilter.defaultExpectation == nil && mmTranspileFilter.mock.funcTranspileFilter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTranspileFilter.mock.afterTranspileFilterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTranspileFilter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TranspileFilter implements mm_repository.Repository
func (mmTranspileFilter *RepositoryMock) TranspileFilter(f1 filtering.Filter) (ep1 *clause.Expr, err error) {
	mm_atomic.AddUint64(&mmTranspileFilter.beforeTranspileFilterCounter, 1)
	defer mm_atomic.AddUint64(&mmTranspileFilter.afterTranspileFilterCounter, 1)

	mmTranspileFilter.t.Helper()

	if mmTranspileFilter.inspectFuncTranspileFilter != nil {
		mmTranspileFilter.inspectFuncTranspileFilter(f1)
	}

	mm_params := RepositoryMockTranspileFilterParams{f1}

	// Record call args
	mmTranspileFilter.TranspileFilterMock.mutex.Lock()
	mmTranspileFilter.TranspileFilterMock.callArgs = append(mmTranspileFilter.TranspileFilterMock.callArgs, &mm_params)
	mmTranspileFilter.TranspileFilterMock.mutex.Unlock()

	for _, e := range mmTranspileFilter.TranspileFilterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmTranspileFilter.TranspileFilterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTranspileFilter.TranspileFilterMock.defaultExpectation.Counter, 1)
		mm_want := mmTranspileFilter.TranspileFilterMock.defaultExpectation.params
		mm_want_ptrs := mmTranspileFilter.TranspileFilterMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockTranspileFilterParams{f1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmTranspileFilter.t.Errorf("RepositoryMock.TranspileFilter got unexpected parameter f1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTranspileFilter.TranspileFilterMock.defaultExpectation.expectationOrigins.originF1, *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTranspileFilter.t.Errorf("RepositoryMock.TranspileFilter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTranspileFilter.TranspileFilterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTranspileFilter.TranspileFilterMock.defaultExpectation.results
		if mm_results == nil {
			mmTranspileFilter.t.Fatal("No results are set for the RepositoryMock.TranspileFilter")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmTranspileFilter.funcTranspileFilter != nil {
		return mmTranspileFilter.funcTranspileFilter(f1)
	}
	mmTranspileFilter.t.Fatalf("Unexpected call to RepositoryMock.TranspileFilter. %v", f1)
	return
}

// TranspileFilterAfterCounter returns a count of finished RepositoryMock.TranspileFilter invocations
func (mmTranspileFilter *RepositoryMock) TranspileFilterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTranspileFilter.afterTranspileFilterCounter)
}

// TranspileFilterBeforeCounter returns a count of RepositoryMock.TranspileFilter invocations
func (mmTranspileFilter *RepositoryMock) TranspileFilterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTranspileFilter.beforeTranspileFilterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.TranspileFilter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Calls() []*RepositoryMockTranspileFilterParams {
	mmTranspileFilter.mutex.RLock()

	argCopy := make([]*RepositoryMockTranspileFilterParams, len(mmTranspileFilter.callArgs))
	copy(argCopy, mmTranspileFilter.callArgs)

	mmTranspileFilter.mutex.RUnlock()

	return argCopy
}

// MinimockTranspileFilterDone returns true if the count of the TranspileFilter invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTranspileFilterDone() bool {
	if m.TranspileFilterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TranspileFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TranspileFilterMock.invocationsDone()
}

// MinimockTranspileFilterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTranspileFilterInspect() {
	for _, e := range m.TranspileFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTranspileFilterCounter := mm_atomic.LoadUint64(&m.afterTranspileFilterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TranspileFilterMock.defaultExpectation != nil && afterTranspileFilterCounter < 1 {
		if m.TranspileFilterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s", m.TranspileFilterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s with params: %#v", m.TranspileFilterMock.defaultExpectation.expectationOrigins.origin, *m.TranspileFilterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTranspileFilter != nil && afterTranspileFilterCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.TranspileFilter at\n%s", m.funcTranspileFilterOrigin)
	}

	if !m.TranspileFilterMock.invocationsDone() && afterTranspileFilterCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.TranspileFilter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TranspileFilterMock.expectedInvocations), m.TranspileFilterMock.expectedInvocationsOrigin, afterTranspileFilterCounter)
	}
}

type mRepositoryMockUpdateComponentRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateComponentRunExpectation
	expectations       []*RepositoryMockUpdateComponentRunExpectation

	callArgs []*RepositoryMockUpdateComponentRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateComponentRunExpectation specifies expectation struct of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateComponentRunParams
	paramPtrs          *RepositoryMockUpdateComponentRunParamPtrs
	expectationOrigins RepositoryMockUpdateComponentRunExpectationOrigins
	results            *RepositoryMockUpdateComponentRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateComponentRunParams contains parameters of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunParams struct {
	ctx                context.Context
	pipelineTriggerUID string
	componentID        string
	componentRun       *datamodel.ComponentRun
}

// RepositoryMockUpdateComponentRunParamPtrs contains pointers to parameters of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunParamPtrs struct {
	ctx                *context.Context
	pipelineTriggerUID *string
	componentID        *string
	componentRun       **datamodel.ComponentRun
}

// RepositoryMockUpdateComponentRunResults contains results of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunResults struct {
	err error
}

// RepositoryMockUpdateComponentRunOrigins contains origins of expectations of the Repository.UpdateComponentRun
type RepositoryMockUpdateComponentRunExpectationOrigins struct {
	origin                   string
	originCtx                string
	originPipelineTriggerUID string
	originComponentID        string
	originComponentRun       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Optional() *mRepositoryMockUpdateComponentRun {
	mmUpdateComponentRun.optional = true
	return mmUpdateComponentRun
}

// Expect sets up expected params for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Expect(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by ExpectParams functions")
	}

	mmUpdateComponentRun.defaultExpectation.params = &RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun}
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateComponentRun.expectations {
		if minimock.Equal(e.params, mmUpdateComponentRun.defaultExpectation.params) {
			mmUpdateComponentRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateComponentRun.defaultExpectation.params)
		}
	}

	return mmUpdateComponentRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// ExpectPipelineTriggerUIDParam2 sets up expected param pipelineTriggerUID for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectPipelineTriggerUIDParam2(pipelineTriggerUID string) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.pipelineTriggerUID = &pipelineTriggerUID
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originPipelineTriggerUID = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// ExpectComponentIDParam3 sets up expected param componentID for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectComponentIDParam3(componentID string) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.componentID = &componentID
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originComponentID = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// ExpectComponentRunParam4 sets up expected param componentRun for Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) ExpectComponentRunParam4(componentRun *datamodel.ComponentRun) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{}
	}

	if mmUpdateComponentRun.defaultExpectation.params != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Expect")
	}

	if mmUpdateComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpdateComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateComponentRunParamPtrs{}
	}
	mmUpdateComponentRun.defaultExpectation.paramPtrs.componentRun = &componentRun
	mmUpdateComponentRun.defaultExpectation.expectationOrigins.originComponentRun = minimock.CallerInfo(1)

	return mmUpdateComponentRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Inspect(f func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun)) *mRepositoryMockUpdateComponentRun {
	if mmUpdateComponentRun.mock.inspectFuncUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateComponentRun")
	}

	mmUpdateComponentRun.mock.inspectFuncUpdateComponentRun = f

	return mmUpdateComponentRun
}

// Return sets up results that will be returned by Repository.UpdateComponentRun
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Return(err error) *RepositoryMock {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	if mmUpdateComponentRun.defaultExpectation == nil {
		mmUpdateComponentRun.defaultExpectation = &RepositoryMockUpdateComponentRunExpectation{mock: mmUpdateComponentRun.mock}
	}
	mmUpdateComponentRun.defaultExpectation.results = &RepositoryMockUpdateComponentRunResults{err}
	mmUpdateComponentRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateComponentRun.mock
}

// Set uses given function f to mock the Repository.UpdateComponentRun method
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Set(f func(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) (err error)) *RepositoryMock {
	if mmUpdateComponentRun.defaultExpectation != nil {
		mmUpdateComponentRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateComponentRun method")
	}

	if len(mmUpdateComponentRun.expectations) > 0 {
		mmUpdateComponentRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateComponentRun method")
	}

	mmUpdateComponentRun.mock.funcUpdateComponentRun = f
	mmUpdateComponentRun.mock.funcUpdateComponentRunOrigin = minimock.CallerInfo(1)
	return mmUpdateComponentRun.mock
}

// When sets expectation for the Repository.UpdateComponentRun which will trigger the result defined by the following
// Then helper
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) When(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) *RepositoryMockUpdateComponentRunExpectation {
	if mmUpdateComponentRun.mock.funcUpdateComponentRun != nil {
		mmUpdateComponentRun.mock.t.Fatalf("RepositoryMock.UpdateComponentRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateComponentRunExpectation{
		mock:               mmUpdateComponentRun.mock,
		params:             &RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun},
		expectationOrigins: RepositoryMockUpdateComponentRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateComponentRun.expectations = append(mmUpdateComponentRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateComponentRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateComponentRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateComponentRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateComponentRun should be invoked
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Times(n uint64) *mRepositoryMockUpdateComponentRun {
	if n == 0 {
		mmUpdateComponentRun.mock.t.Fatalf("Times of RepositoryMock.UpdateComponentRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateComponentRun.expectedInvocations, n)
	mmUpdateComponentRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateComponentRun
}

func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) invocationsDone() bool {
	if len(mmUpdateComponentRun.expectations) == 0 && mmUpdateComponentRun.defaultExpectation == nil && mmUpdateComponentRun.mock.funcUpdateComponentRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateComponentRun.mock.afterUpdateComponentRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateComponentRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateComponentRun implements mm_repository.Repository
func (mmUpdateComponentRun *RepositoryMock) UpdateComponentRun(ctx context.Context, pipelineTriggerUID string, componentID string, componentRun *datamodel.ComponentRun) (err error) {
	mm_atomic.AddUint64(&mmUpdateComponentRun.beforeUpdateComponentRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateComponentRun.afterUpdateComponentRunCounter, 1)

	mmUpdateComponentRun.t.Helper()

	if mmUpdateComponentRun.inspectFuncUpdateComponentRun != nil {
		mmUpdateComponentRun.inspectFuncUpdateComponentRun(ctx, pipelineTriggerUID, componentID, componentRun)
	}

	mm_params := RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun}

	// Record call args
	mmUpdateComponentRun.UpdateComponentRunMock.mutex.Lock()
	mmUpdateComponentRun.UpdateComponentRunMock.callArgs = append(mmUpdateComponentRun.UpdateComponentRunMock.callArgs, &mm_params)
	mmUpdateComponentRun.UpdateComponentRunMock.mutex.Unlock()

	for _, e := range mmUpdateComponentRun.UpdateComponentRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateComponentRunParams{ctx, pipelineTriggerUID, componentID, componentRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineTriggerUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter pipelineTriggerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originPipelineTriggerUID, *mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID, minimock.Diff(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID))
			}

			if mm_want_ptrs.componentID != nil && !minimock.Equal(*mm_want_ptrs.componentID, mm_got.componentID) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter componentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originComponentID, *mm_want_ptrs.componentID, mm_got.componentID, minimock.Diff(*mm_want_ptrs.componentID, mm_got.componentID))
			}

			if mm_want_ptrs.componentRun != nil && !minimock.Equal(*mm_want_ptrs.componentRun, mm_got.componentRun) {
				mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameter componentRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.originComponentRun, *mm_want_ptrs.componentRun, mm_got.componentRun, minimock.Diff(*mm_want_ptrs.componentRun, mm_got.componentRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateComponentRun.t.Errorf("RepositoryMock.UpdateComponentRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateComponentRun.UpdateComponentRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateComponentRun.t.Fatal("No results are set for the RepositoryMock.UpdateComponentRun")
		}
		return (*mm_results).err
	}
	if mmUpdateComponentRun.funcUpdateComponentRun != nil {
		return mmUpdateComponentRun.funcUpdateComponentRun(ctx, pipelineTriggerUID, componentID, componentRun)
	}
	mmUpdateComponentRun.t.Fatalf("Unexpected call to RepositoryMock.UpdateComponentRun. %v %v %v %v", ctx, pipelineTriggerUID, componentID, componentRun)
	return
}

// UpdateComponentRunAfterCounter returns a count of finished RepositoryMock.UpdateComponentRun invocations
func (mmUpdateComponentRun *RepositoryMock) UpdateComponentRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateComponentRun.afterUpdateComponentRunCounter)
}

// UpdateComponentRunBeforeCounter returns a count of RepositoryMock.UpdateComponentRun invocations
func (mmUpdateComponentRun *RepositoryMock) UpdateComponentRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateComponentRun.beforeUpdateComponentRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateComponentRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateComponentRun *mRepositoryMockUpdateComponentRun) Calls() []*RepositoryMockUpdateComponentRunParams {
	mmUpdateComponentRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateComponentRunParams, len(mmUpdateComponentRun.callArgs))
	copy(argCopy, mmUpdateComponentRun.callArgs)

	mmUpdateComponentRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateComponentRunDone returns true if the count of the UpdateComponentRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateComponentRunDone() bool {
	if m.UpdateComponentRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateComponentRunMock.invocationsDone()
}

// MinimockUpdateComponentRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateComponentRunInspect() {
	for _, e := range m.UpdateComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateComponentRunCounter := mm_atomic.LoadUint64(&m.afterUpdateComponentRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateComponentRunMock.defaultExpectation != nil && afterUpdateComponentRunCounter < 1 {
		if m.UpdateComponentRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s", m.UpdateComponentRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s with params: %#v", m.UpdateComponentRunMock.defaultExpectation.expectationOrigins.origin, *m.UpdateComponentRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateComponentRun != nil && afterUpdateComponentRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateComponentRun at\n%s", m.funcUpdateComponentRunOrigin)
	}

	if !m.UpdateComponentRunMock.invocationsDone() && afterUpdateComponentRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateComponentRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateComponentRunMock.expectedInvocations), m.UpdateComponentRunMock.expectedInvocationsOrigin, afterUpdateComponentRunCounter)
	}
}

type mRepositoryMockUpdateNamespaceConnectionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceConnectionByUIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceConnectionByUIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceConnectionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespaceConnectionByUIDExpectation specifies expectation struct of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespaceConnectionByUIDParams
	paramPtrs          *RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespaceConnectionByUIDExpectationOrigins
	results            *RepositoryMockUpdateNamespaceConnectionByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespaceConnectionByUIDParams contains parameters of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
	cp1 *datamodel.Connection
}

// RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
	cp1 **datamodel.Connection
}

// RepositoryMockUpdateNamespaceConnectionByUIDResults contains results of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDResults struct {
	cp2 *datamodel.Connection
	err error
}

// RepositoryMockUpdateNamespaceConnectionByUIDOrigins contains origins of expectations of the Repository.UpdateNamespaceConnectionByUID
type RepositoryMockUpdateNamespaceConnectionByUIDExpectationOrigins struct {
	origin    string
	originCtx string
	originU1  string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Optional() *mRepositoryMockUpdateNamespaceConnectionByUID {
	mmUpdateNamespaceConnectionByUID.optional = true
	return mmUpdateNamespaceConnectionByUID
}

// Expect sets up expected params for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Expect(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceConnectionByUID.defaultExpectation.params = &RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespaceConnectionByUID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceConnectionByUID.defaultExpectation.params) {
			mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceConnectionByUID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceConnectionByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.params != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Expect")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs{}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespaceConnectionByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.params != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Expect")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs{}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs.u1 = &u1
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.originU1 = minimock.CallerInfo(1)

	return mmUpdateNamespaceConnectionByUID
}

// ExpectCp1Param3 sets up expected param cp1 for Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) ExpectCp1Param3(cp1 *datamodel.Connection) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{}
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.params != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Expect")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceConnectionByUIDParamPtrs{}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.paramPtrs.cp1 = &cp1
	mmUpdateNamespaceConnectionByUID.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmUpdateNamespaceConnectionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection)) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if mmUpdateNamespaceConnectionByUID.mock.inspectFuncUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceConnectionByUID")
	}

	mmUpdateNamespaceConnectionByUID.mock.inspectFuncUpdateNamespaceConnectionByUID = f

	return mmUpdateNamespaceConnectionByUID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceConnectionByUID
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Return(cp2 *datamodel.Connection, err error) *RepositoryMock {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	if mmUpdateNamespaceConnectionByUID.defaultExpectation == nil {
		mmUpdateNamespaceConnectionByUID.defaultExpectation = &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{mock: mmUpdateNamespaceConnectionByUID.mock}
	}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.results = &RepositoryMockUpdateNamespaceConnectionByUIDResults{cp2, err}
	mmUpdateNamespaceConnectionByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceConnectionByUID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceConnectionByUID method
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Set(f func(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error)) *RepositoryMock {
	if mmUpdateNamespaceConnectionByUID.defaultExpectation != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceConnectionByUID method")
	}

	if len(mmUpdateNamespaceConnectionByUID.expectations) > 0 {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceConnectionByUID method")
	}

	mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID = f
	mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceConnectionByUID.mock
}

// When sets expectation for the Repository.UpdateNamespaceConnectionByUID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) When(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) *RepositoryMockUpdateNamespaceConnectionByUIDExpectation {
	if mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceConnectionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceConnectionByUIDExpectation{
		mock:               mmUpdateNamespaceConnectionByUID.mock,
		params:             &RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1},
		expectationOrigins: RepositoryMockUpdateNamespaceConnectionByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespaceConnectionByUID.expectations = append(mmUpdateNamespaceConnectionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceConnectionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceConnectionByUIDExpectation) Then(cp2 *datamodel.Connection, err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceConnectionByUIDResults{cp2, err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceConnectionByUID should be invoked
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Times(n uint64) *mRepositoryMockUpdateNamespaceConnectionByUID {
	if n == 0 {
		mmUpdateNamespaceConnectionByUID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceConnectionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceConnectionByUID.expectedInvocations, n)
	mmUpdateNamespaceConnectionByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceConnectionByUID
}

func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) invocationsDone() bool {
	if len(mmUpdateNamespaceConnectionByUID.expectations) == 0 && mmUpdateNamespaceConnectionByUID.defaultExpectation == nil && mmUpdateNamespaceConnectionByUID.mock.funcUpdateNamespaceConnectionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.mock.afterUpdateNamespaceConnectionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceConnectionByUID implements mm_repository.Repository
func (mmUpdateNamespaceConnectionByUID *RepositoryMock) UpdateNamespaceConnectionByUID(ctx context.Context, u1 uuid.UUID, cp1 *datamodel.Connection) (cp2 *datamodel.Connection, err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceConnectionByUID.beforeUpdateNamespaceConnectionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceConnectionByUID.afterUpdateNamespaceConnectionByUIDCounter, 1)

	mmUpdateNamespaceConnectionByUID.t.Helper()

	if mmUpdateNamespaceConnectionByUID.inspectFuncUpdateNamespaceConnectionByUID != nil {
		mmUpdateNamespaceConnectionByUID.inspectFuncUpdateNamespaceConnectionByUID(ctx, u1, cp1)
	}

	mm_params := RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1}

	// Record call args
	mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.mutex.Lock()
	mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.callArgs = append(mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.callArgs, &mm_params)
	mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp2, e.results.err
		}
	}

	if mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceConnectionByUIDParams{ctx, u1, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameter u1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.originU1, *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceConnectionByUID.t.Errorf("RepositoryMock.UpdateNamespaceConnectionByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceConnectionByUID.UpdateNamespaceConnectionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceConnectionByUID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceConnectionByUID")
		}
		return (*mm_results).cp2, (*mm_results).err
	}
	if mmUpdateNamespaceConnectionByUID.funcUpdateNamespaceConnectionByUID != nil {
		return mmUpdateNamespaceConnectionByUID.funcUpdateNamespaceConnectionByUID(ctx, u1, cp1)
	}
	mmUpdateNamespaceConnectionByUID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceConnectionByUID. %v %v %v", ctx, u1, cp1)
	return
}

// UpdateNamespaceConnectionByUIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceConnectionByUID invocations
func (mmUpdateNamespaceConnectionByUID *RepositoryMock) UpdateNamespaceConnectionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.afterUpdateNamespaceConnectionByUIDCounter)
}

// UpdateNamespaceConnectionByUIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceConnectionByUID invocations
func (mmUpdateNamespaceConnectionByUID *RepositoryMock) UpdateNamespaceConnectionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceConnectionByUID.beforeUpdateNamespaceConnectionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceConnectionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceConnectionByUID *mRepositoryMockUpdateNamespaceConnectionByUID) Calls() []*RepositoryMockUpdateNamespaceConnectionByUIDParams {
	mmUpdateNamespaceConnectionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceConnectionByUIDParams, len(mmUpdateNamespaceConnectionByUID.callArgs))
	copy(argCopy, mmUpdateNamespaceConnectionByUID.callArgs)

	mmUpdateNamespaceConnectionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceConnectionByUIDDone returns true if the count of the UpdateNamespaceConnectionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceConnectionByUIDDone() bool {
	if m.UpdateNamespaceConnectionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceConnectionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceConnectionByUIDMock.invocationsDone()
}

// MinimockUpdateNamespaceConnectionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceConnectionByUIDInspect() {
	for _, e := range m.UpdateNamespaceConnectionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespaceConnectionByUIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceConnectionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceConnectionByUIDMock.defaultExpectation != nil && afterUpdateNamespaceConnectionByUIDCounter < 1 {
		if m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s", m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s with params: %#v", m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespaceConnectionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceConnectionByUID != nil && afterUpdateNamespaceConnectionByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s", m.funcUpdateNamespaceConnectionByUIDOrigin)
	}

	if !m.UpdateNamespaceConnectionByUIDMock.invocationsDone() && afterUpdateNamespaceConnectionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceConnectionByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceConnectionByUIDMock.expectedInvocations), m.UpdateNamespaceConnectionByUIDMock.expectedInvocationsOrigin, afterUpdateNamespaceConnectionByUIDCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineByUIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineByUIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespacePipelineByUIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespacePipelineByUIDParams
	paramPtrs          *RepositoryMockUpdateNamespacePipelineByUIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespacePipelineByUIDExpectationOrigins
	results            *RepositoryMockUpdateNamespacePipelineByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespacePipelineByUIDParams contains parameters of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDParams struct {
	ctx      context.Context
	uid      uuid.UUID
	pipeline *datamodel.Pipeline
}

// RepositoryMockUpdateNamespacePipelineByUIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDParamPtrs struct {
	ctx      *context.Context
	uid      *uuid.UUID
	pipeline **datamodel.Pipeline
}

// RepositoryMockUpdateNamespacePipelineByUIDResults contains results of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDResults struct {
	err error
}

// RepositoryMockUpdateNamespacePipelineByUIDOrigins contains origins of expectations of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originUid      string
	originPipeline string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Optional() *mRepositoryMockUpdateNamespacePipelineByUID {
	mmUpdateNamespacePipelineByUID.optional = true
	return mmUpdateNamespacePipelineByUID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Expect(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineByUID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline}
	mmUpdateNamespacePipelineByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespacePipelineByUID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineByUID.defaultExpectation.params) {
			mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineByUID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineByUIDParamPtrs{}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespacePipelineByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineByUIDParamPtrs{}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs.uid = &uid
	mmUpdateNamespacePipelineByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineByUID
}

// ExpectPipelineParam3 sets up expected param pipeline for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) ExpectPipelineParam3(pipeline *datamodel.Pipeline) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineByUIDParamPtrs{}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs.pipeline = &pipeline
	mmUpdateNamespacePipelineByUID.defaultExpectation.expectationOrigins.originPipeline = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline)) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.inspectFuncUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineByUID")
	}

	mmUpdateNamespacePipelineByUID.mock.inspectFuncUpdateNamespacePipelineByUID = f

	return mmUpdateNamespacePipelineByUID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{mock: mmUpdateNamespacePipelineByUID.mock}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineByUIDResults{err}
	mmUpdateNamespacePipelineByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineByUID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineByUID method
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Set(f func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineByUID.defaultExpectation != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineByUID method")
	}

	if len(mmUpdateNamespacePipelineByUID.expectations) > 0 {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineByUID method")
	}

	mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID = f
	mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineByUID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineByUID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) When(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) *RepositoryMockUpdateNamespacePipelineByUIDExpectation {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineByUIDExpectation{
		mock:               mmUpdateNamespacePipelineByUID.mock,
		params:             &RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline},
		expectationOrigins: RepositoryMockUpdateNamespacePipelineByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespacePipelineByUID.expectations = append(mmUpdateNamespacePipelineByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineByUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineByUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineByUID should be invoked
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineByUID {
	if n == 0 {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineByUID.expectedInvocations, n)
	mmUpdateNamespacePipelineByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineByUID
}

func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineByUID.expectations) == 0 && mmUpdateNamespacePipelineByUID.defaultExpectation == nil && mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.mock.afterUpdateNamespacePipelineByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineByUID implements mm_repository.Repository
func (mmUpdateNamespacePipelineByUID *RepositoryMock) UpdateNamespacePipelineByUID(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineByUID.beforeUpdateNamespacePipelineByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineByUID.afterUpdateNamespacePipelineByUIDCounter, 1)

	mmUpdateNamespacePipelineByUID.t.Helper()

	if mmUpdateNamespacePipelineByUID.inspectFuncUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.inspectFuncUpdateNamespacePipelineByUID(ctx, uid, pipeline)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline}

	// Record call args
	mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.mutex.Lock()
	mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.callArgs = append(mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameter pipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.expectationOrigins.originPipeline, *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineByUID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineByUID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineByUID.funcUpdateNamespacePipelineByUID != nil {
		return mmUpdateNamespacePipelineByUID.funcUpdateNamespacePipelineByUID(ctx, uid, pipeline)
	}
	mmUpdateNamespacePipelineByUID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineByUID. %v %v %v", ctx, uid, pipeline)
	return
}

// UpdateNamespacePipelineByUIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineByUID invocations
func (mmUpdateNamespacePipelineByUID *RepositoryMock) UpdateNamespacePipelineByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.afterUpdateNamespacePipelineByUIDCounter)
}

// UpdateNamespacePipelineByUIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineByUID invocations
func (mmUpdateNamespacePipelineByUID *RepositoryMock) UpdateNamespacePipelineByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.beforeUpdateNamespacePipelineByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Calls() []*RepositoryMockUpdateNamespacePipelineByUIDParams {
	mmUpdateNamespacePipelineByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineByUIDParams, len(mmUpdateNamespacePipelineByUID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineByUID.callArgs)

	mmUpdateNamespacePipelineByUID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineByUIDDone returns true if the count of the UpdateNamespacePipelineByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineByUIDDone() bool {
	if m.UpdateNamespacePipelineByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineByUIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineByUIDInspect() {
	for _, e := range m.UpdateNamespacePipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespacePipelineByUIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineByUIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineByUIDCounter < 1 {
		if m.UpdateNamespacePipelineByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineByUID at\n%s", m.UpdateNamespacePipelineByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineByUID at\n%s with params: %#v", m.UpdateNamespacePipelineByUIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespacePipelineByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineByUID != nil && afterUpdateNamespacePipelineByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineByUID at\n%s", m.funcUpdateNamespacePipelineByUIDOrigin)
	}

	if !m.UpdateNamespacePipelineByUIDMock.invocationsDone() && afterUpdateNamespacePipelineByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineByUIDMock.expectedInvocations), m.UpdateNamespacePipelineByUIDMock.expectedInvocationsOrigin, afterUpdateNamespacePipelineByUIDCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineIDByIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineIDByIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespacePipelineIDByIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespacePipelineIDByIDParams
	paramPtrs          *RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespacePipelineIDByIDExpectationOrigins
	results            *RepositoryMockUpdateNamespacePipelineIDByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespacePipelineIDByIDParams contains parameters of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	newID          string
}

// RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	newID          *string
}

// RepositoryMockUpdateNamespacePipelineIDByIDResults contains results of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDResults struct {
	err error
}

// RepositoryMockUpdateNamespacePipelineIDByIDOrigins contains origins of expectations of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originNewID          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Optional() *mRepositoryMockUpdateNamespacePipelineIDByID {
	mmUpdateNamespacePipelineIDByID.optional = true
	return mmUpdateNamespacePipelineIDByID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Expect(ctx context.Context, ownerPermalink string, id string, newID string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineIDByID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespacePipelineIDByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineIDByID.defaultExpectation.params) {
			mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineIDByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespacePipelineIDByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdateNamespacePipelineIDByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineIDByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateNamespacePipelineIDByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineIDByID
}

// ExpectNewIDParam4 sets up expected param newID for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectNewIDParam4(newID string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.newID = &newID
	mmUpdateNamespacePipelineIDByID.defaultExpectation.expectationOrigins.originNewID = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, newID string)) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.inspectFuncUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineIDByID")
	}

	mmUpdateNamespacePipelineIDByID.mock.inspectFuncUpdateNamespacePipelineIDByID = f

	return mmUpdateNamespacePipelineIDByID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{mock: mmUpdateNamespacePipelineIDByID.mock}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineIDByIDResults{err}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineIDByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineIDByID method
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Set(f func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineIDByID.defaultExpectation != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineIDByID method")
	}

	if len(mmUpdateNamespacePipelineIDByID.expectations) > 0 {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineIDByID method")
	}

	mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID = f
	mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineIDByID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) When(ctx context.Context, ownerPermalink string, id string, newID string) *RepositoryMockUpdateNamespacePipelineIDByIDExpectation {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{
		mock:               mmUpdateNamespacePipelineIDByID.mock,
		params:             &RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID},
		expectationOrigins: RepositoryMockUpdateNamespacePipelineIDByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespacePipelineIDByID.expectations = append(mmUpdateNamespacePipelineIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineIDByID should be invoked
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if n == 0 {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineIDByID.expectedInvocations, n)
	mmUpdateNamespacePipelineIDByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineIDByID
}

func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineIDByID.expectations) == 0 && mmUpdateNamespacePipelineIDByID.defaultExpectation == nil && mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.mock.afterUpdateNamespacePipelineIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineIDByID implements mm_repository.Repository
func (mmUpdateNamespacePipelineIDByID *RepositoryMock) UpdateNamespacePipelineIDByID(ctx context.Context, ownerPermalink string, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineIDByID.beforeUpdateNamespacePipelineIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineIDByID.afterUpdateNamespacePipelineIDByIDCounter, 1)

	mmUpdateNamespacePipelineIDByID.t.Helper()

	if mmUpdateNamespacePipelineIDByID.inspectFuncUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.inspectFuncUpdateNamespacePipelineIDByID(ctx, ownerPermalink, id, newID)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID}

	// Record call args
	mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.mutex.Lock()
	mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.callArgs = append(mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter newID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.expectationOrigins.originNewID, *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineIDByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineIDByID.funcUpdateNamespacePipelineIDByID != nil {
		return mmUpdateNamespacePipelineIDByID.funcUpdateNamespacePipelineIDByID(ctx, ownerPermalink, id, newID)
	}
	mmUpdateNamespacePipelineIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineIDByID. %v %v %v %v", ctx, ownerPermalink, id, newID)
	return
}

// UpdateNamespacePipelineIDByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineIDByID invocations
func (mmUpdateNamespacePipelineIDByID *RepositoryMock) UpdateNamespacePipelineIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.afterUpdateNamespacePipelineIDByIDCounter)
}

// UpdateNamespacePipelineIDByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineIDByID invocations
func (mmUpdateNamespacePipelineIDByID *RepositoryMock) UpdateNamespacePipelineIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.beforeUpdateNamespacePipelineIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Calls() []*RepositoryMockUpdateNamespacePipelineIDByIDParams {
	mmUpdateNamespacePipelineIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineIDByIDParams, len(mmUpdateNamespacePipelineIDByID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineIDByID.callArgs)

	mmUpdateNamespacePipelineIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineIDByIDDone returns true if the count of the UpdateNamespacePipelineIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineIDByIDDone() bool {
	if m.UpdateNamespacePipelineIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineIDByIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineIDByIDInspect() {
	for _, e := range m.UpdateNamespacePipelineIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespacePipelineIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineIDByIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineIDByIDCounter < 1 {
		if m.UpdateNamespacePipelineIDByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID at\n%s", m.UpdateNamespacePipelineIDByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID at\n%s with params: %#v", m.UpdateNamespacePipelineIDByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespacePipelineIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineIDByID != nil && afterUpdateNamespacePipelineIDByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID at\n%s", m.funcUpdateNamespacePipelineIDByIDOrigin)
	}

	if !m.UpdateNamespacePipelineIDByIDMock.invocationsDone() && afterUpdateNamespacePipelineIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineIDByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineIDByIDMock.expectedInvocations), m.UpdateNamespacePipelineIDByIDMock.expectedInvocationsOrigin, afterUpdateNamespacePipelineIDByIDCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespacePipelineReleaseByIDParams
	paramPtrs          *RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespacePipelineReleaseByIDExpectationOrigins
	results            *RepositoryMockUpdateNamespacePipelineReleaseByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDParams contains parameters of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDParams struct {
	ctx             context.Context
	ownerPermalink  string
	pipelineUID     uuid.UUID
	id              string
	pipelineRelease *datamodel.PipelineRelease
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs struct {
	ctx             *context.Context
	ownerPermalink  *string
	pipelineUID     *uuid.UUID
	id              *string
	pipelineRelease **datamodel.PipelineRelease
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDResults contains results of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDResults struct {
	err error
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDOrigins contains origins of expectations of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDExpectationOrigins struct {
	origin                string
	originCtx             string
	originOwnerPermalink  string
	originPipelineUID     string
	originId              string
	originPipelineRelease string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Optional() *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	mmUpdateNamespacePipelineReleaseByID.optional = true
	return mmUpdateNamespacePipelineReleaseByID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespacePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params) {
			mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectPipelineReleaseParam5 sets up expected param pipelineRelease for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectPipelineReleaseParam5(pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineRelease = &pipelineRelease
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.expectationOrigins.originPipelineRelease = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease)) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.inspectFuncUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineReleaseByID")
	}

	mmUpdateNamespacePipelineReleaseByID.mock.inspectFuncUpdateNamespacePipelineReleaseByID = f

	return mmUpdateNamespacePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{mock: mmUpdateNamespacePipelineReleaseByID.mock}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineReleaseByIDResults{err}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineReleaseByID method
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineReleaseByID method")
	}

	if len(mmUpdateNamespacePipelineReleaseByID.expectations) > 0 {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineReleaseByID method")
	}

	mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID = f
	mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineReleaseByID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) *RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{
		mock:               mmUpdateNamespacePipelineReleaseByID.mock,
		params:             &RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease},
		expectationOrigins: RepositoryMockUpdateNamespacePipelineReleaseByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespacePipelineReleaseByID.expectations = append(mmUpdateNamespacePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineReleaseByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineReleaseByID should be invoked
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if n == 0 {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineReleaseByID.expectedInvocations, n)
	mmUpdateNamespacePipelineReleaseByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineReleaseByID
}

func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineReleaseByID.expectations) == 0 && mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil && mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.mock.afterUpdateNamespacePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineReleaseByID implements mm_repository.Repository
func (mmUpdateNamespacePipelineReleaseByID *RepositoryMock) UpdateNamespacePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseByID.beforeUpdateNamespacePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseByID.afterUpdateNamespacePipelineReleaseByIDCounter, 1)

	mmUpdateNamespacePipelineReleaseByID.t.Helper()

	if mmUpdateNamespacePipelineReleaseByID.inspectFuncUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.inspectFuncUpdateNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}

	// Record call args
	mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.mutex.Lock()
	mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.callArgs = append(mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.pipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter pipelineRelease, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.originPipelineRelease, *mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease, minimock.Diff(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineReleaseByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineReleaseByID.funcUpdateNamespacePipelineReleaseByID != nil {
		return mmUpdateNamespacePipelineReleaseByID.funcUpdateNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	}
	mmUpdateNamespacePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineReleaseByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	return
}

// UpdateNamespacePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineReleaseByID invocations
func (mmUpdateNamespacePipelineReleaseByID *RepositoryMock) UpdateNamespacePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.afterUpdateNamespacePipelineReleaseByIDCounter)
}

// UpdateNamespacePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineReleaseByID invocations
func (mmUpdateNamespacePipelineReleaseByID *RepositoryMock) UpdateNamespacePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.beforeUpdateNamespacePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Calls() []*RepositoryMockUpdateNamespacePipelineReleaseByIDParams {
	mmUpdateNamespacePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineReleaseByIDParams, len(mmUpdateNamespacePipelineReleaseByID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineReleaseByID.callArgs)

	mmUpdateNamespacePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineReleaseByIDDone returns true if the count of the UpdateNamespacePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseByIDDone() bool {
	if m.UpdateNamespacePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineReleaseByIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseByIDInspect() {
	for _, e := range m.UpdateNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespacePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineReleaseByIDCounter < 1 {
		if m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID at\n%s", m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID at\n%s with params: %#v", m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineReleaseByID != nil && afterUpdateNamespacePipelineReleaseByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID at\n%s", m.funcUpdateNamespacePipelineReleaseByIDOrigin)
	}

	if !m.UpdateNamespacePipelineReleaseByIDMock.invocationsDone() && afterUpdateNamespacePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineReleaseByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineReleaseByIDMock.expectedInvocations), m.UpdateNamespacePipelineReleaseByIDMock.expectedInvocationsOrigin, afterUpdateNamespacePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineReleaseIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams
	paramPtrs          *RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectationOrigins
	results            *RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams contains parameters of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
	newID          string
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
	newID          *string
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults contains results of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults struct {
	err error
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDOrigins contains origins of expectations of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPipelineUID    string
	originId             string
	originNewID          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Optional() *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	mmUpdateNamespacePipelineReleaseIDByID.optional = true
	return mmUpdateNamespacePipelineReleaseIDByID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespacePipelineReleaseIDByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params) {
			mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectIdParam4 sets up expected param id for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectIdParam4(id string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectNewIDParam5 sets up expected param newID for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectNewIDParam5(newID string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.newID = &newID
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.expectationOrigins.originNewID = minimock.CallerInfo(1)

	return mmUpdateNamespacePipelineReleaseIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string)) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.inspectFuncUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineReleaseIDByID")
	}

	mmUpdateNamespacePipelineReleaseIDByID.mock.inspectFuncUpdateNamespacePipelineReleaseIDByID = f

	return mmUpdateNamespacePipelineReleaseIDByID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{mock: mmUpdateNamespacePipelineReleaseIDByID.mock}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults{err}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineReleaseIDByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineReleaseIDByID method
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineReleaseIDByID method")
	}

	if len(mmUpdateNamespacePipelineReleaseIDByID.expectations) > 0 {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineReleaseIDByID method")
	}

	mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID = f
	mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineReleaseIDByID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineReleaseIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) *RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{
		mock:               mmUpdateNamespacePipelineReleaseIDByID.mock,
		params:             &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID},
		expectationOrigins: RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespacePipelineReleaseIDByID.expectations = append(mmUpdateNamespacePipelineReleaseIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineReleaseIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineReleaseIDByID should be invoked
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if n == 0 {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineReleaseIDByID.expectedInvocations, n)
	mmUpdateNamespacePipelineReleaseIDByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespacePipelineReleaseIDByID
}

func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineReleaseIDByID.expectations) == 0 && mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil && mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.mock.afterUpdateNamespacePipelineReleaseIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineReleaseIDByID implements mm_repository.Repository
func (mmUpdateNamespacePipelineReleaseIDByID *RepositoryMock) UpdateNamespacePipelineReleaseIDByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseIDByID.beforeUpdateNamespacePipelineReleaseIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseIDByID.afterUpdateNamespacePipelineReleaseIDByIDCounter, 1)

	mmUpdateNamespacePipelineReleaseIDByID.t.Helper()

	if mmUpdateNamespacePipelineReleaseIDByID.inspectFuncUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.inspectFuncUpdateNamespacePipelineReleaseIDByID(ctx, ownerPermalink, pipelineUID, id, newID)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}

	// Record call args
	mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.mutex.Lock()
	mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.callArgs = append(mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter newID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.originNewID, *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineReleaseIDByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineReleaseIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineReleaseIDByID.funcUpdateNamespacePipelineReleaseIDByID != nil {
		return mmUpdateNamespacePipelineReleaseIDByID.funcUpdateNamespacePipelineReleaseIDByID(ctx, ownerPermalink, pipelineUID, id, newID)
	}
	mmUpdateNamespacePipelineReleaseIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, newID)
	return
}

// UpdateNamespacePipelineReleaseIDByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineReleaseIDByID invocations
func (mmUpdateNamespacePipelineReleaseIDByID *RepositoryMock) UpdateNamespacePipelineReleaseIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.afterUpdateNamespacePipelineReleaseIDByIDCounter)
}

// UpdateNamespacePipelineReleaseIDByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineReleaseIDByID invocations
func (mmUpdateNamespacePipelineReleaseIDByID *RepositoryMock) UpdateNamespacePipelineReleaseIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.beforeUpdateNamespacePipelineReleaseIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Calls() []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams {
	mmUpdateNamespacePipelineReleaseIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams, len(mmUpdateNamespacePipelineReleaseIDByID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineReleaseIDByID.callArgs)

	mmUpdateNamespacePipelineReleaseIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineReleaseIDByIDDone returns true if the count of the UpdateNamespacePipelineReleaseIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseIDByIDDone() bool {
	if m.UpdateNamespacePipelineReleaseIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineReleaseIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineReleaseIDByIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineReleaseIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseIDByIDInspect() {
	for _, e := range m.UpdateNamespacePipelineReleaseIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespacePipelineReleaseIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineReleaseIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineReleaseIDByIDCounter < 1 {
		if m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID at\n%s", m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID at\n%s with params: %#v", m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineReleaseIDByID != nil && afterUpdateNamespacePipelineReleaseIDByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID at\n%s", m.funcUpdateNamespacePipelineReleaseIDByIDOrigin)
	}

	if !m.UpdateNamespacePipelineReleaseIDByIDMock.invocationsDone() && afterUpdateNamespacePipelineReleaseIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineReleaseIDByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineReleaseIDByIDMock.expectedInvocations), m.UpdateNamespacePipelineReleaseIDByIDMock.expectedInvocationsOrigin, afterUpdateNamespacePipelineReleaseIDByIDCounter)
	}
}

type mRepositoryMockUpdateNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespaceSecretByIDExpectation specifies expectation struct of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespaceSecretByIDParams
	paramPtrs          *RepositoryMockUpdateNamespaceSecretByIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespaceSecretByIDExpectationOrigins
	results            *RepositoryMockUpdateNamespaceSecretByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespaceSecretByIDParams contains parameters of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	secret         *datamodel.Secret
}

// RepositoryMockUpdateNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	secret         **datamodel.Secret
}

// RepositoryMockUpdateNamespaceSecretByIDResults contains results of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDResults struct {
	err error
}

// RepositoryMockUpdateNamespaceSecretByIDOrigins contains origins of expectations of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originSecret         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Optional() *mRepositoryMockUpdateNamespaceSecretByID {
	mmUpdateNamespaceSecretByID.optional = true
	return mmUpdateNamespaceSecretByID
}

// Expect sets up expected params for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceSecretByID.defaultExpectation.params = &RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceSecretByID.defaultExpectation.params) {
			mmUpdateNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// ExpectSecretParam4 sets up expected param secret for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectSecretParam4(secret *datamodel.Secret) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.secret = &secret
	mmUpdateNamespaceSecretByID.defaultExpectation.expectationOrigins.originSecret = minimock.CallerInfo(1)

	return mmUpdateNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret)) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.inspectFuncUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceSecretByID")
	}

	mmUpdateNamespaceSecretByID.mock.inspectFuncUpdateNamespaceSecretByID = f

	return mmUpdateNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{mock: mmUpdateNamespaceSecretByID.mock}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.results = &RepositoryMockUpdateNamespaceSecretByIDResults{err}
	mmUpdateNamespaceSecretByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceSecretByID method
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error)) *RepositoryMock {
	if mmUpdateNamespaceSecretByID.defaultExpectation != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceSecretByID method")
	}

	if len(mmUpdateNamespaceSecretByID.expectations) > 0 {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceSecretByID method")
	}

	mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID = f
	mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceSecretByID.mock
}

// When sets expectation for the Repository.UpdateNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) *RepositoryMockUpdateNamespaceSecretByIDExpectation {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceSecretByIDExpectation{
		mock:               mmUpdateNamespaceSecretByID.mock,
		params:             &RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret},
		expectationOrigins: RepositoryMockUpdateNamespaceSecretByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespaceSecretByID.expectations = append(mmUpdateNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceSecretByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceSecretByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceSecretByID should be invoked
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Times(n uint64) *mRepositoryMockUpdateNamespaceSecretByID {
	if n == 0 {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceSecretByID.expectedInvocations, n)
	mmUpdateNamespaceSecretByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceSecretByID
}

func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) invocationsDone() bool {
	if len(mmUpdateNamespaceSecretByID.expectations) == 0 && mmUpdateNamespaceSecretByID.defaultExpectation == nil && mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.mock.afterUpdateNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceSecretByID implements mm_repository.Repository
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.beforeUpdateNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.afterUpdateNamespaceSecretByIDCounter, 1)

	mmUpdateNamespaceSecretByID.t.Helper()

	if mmUpdateNamespaceSecretByID.inspectFuncUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.inspectFuncUpdateNamespaceSecretByID(ctx, ownerPermalink, id, secret)
	}

	mm_params := RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}

	// Record call args
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.mutex.Lock()
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.callArgs = append(mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.callArgs, &mm_params)
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.secret != nil && !minimock.Equal(*mm_want_ptrs.secret, mm_got.secret) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter secret, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.originSecret, *mm_want_ptrs.secret, mm_got.secret, minimock.Diff(*mm_want_ptrs.secret, mm_got.secret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceSecretByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespaceSecretByID.funcUpdateNamespaceSecretByID != nil {
		return mmUpdateNamespaceSecretByID.funcUpdateNamespaceSecretByID(ctx, ownerPermalink, id, secret)
	}
	mmUpdateNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceSecretByID. %v %v %v %v", ctx, ownerPermalink, id, secret)
	return
}

// UpdateNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceSecretByID invocations
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.afterUpdateNamespaceSecretByIDCounter)
}

// UpdateNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceSecretByID invocations
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.beforeUpdateNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Calls() []*RepositoryMockUpdateNamespaceSecretByIDParams {
	mmUpdateNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceSecretByIDParams, len(mmUpdateNamespaceSecretByID.callArgs))
	copy(argCopy, mmUpdateNamespaceSecretByID.callArgs)

	mmUpdateNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceSecretByIDDone returns true if the count of the UpdateNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceSecretByIDDone() bool {
	if m.UpdateNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceSecretByIDMock.invocationsDone()
}

// MinimockUpdateNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceSecretByIDInspect() {
	for _, e := range m.UpdateNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceSecretByIDMock.defaultExpectation != nil && afterUpdateNamespaceSecretByIDCounter < 1 {
		if m.UpdateNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s", m.UpdateNamespaceSecretByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s with params: %#v", m.UpdateNamespaceSecretByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceSecretByID != nil && afterUpdateNamespaceSecretByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID at\n%s", m.funcUpdateNamespaceSecretByIDOrigin)
	}

	if !m.UpdateNamespaceSecretByIDMock.invocationsDone() && afterUpdateNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceSecretByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceSecretByIDMock.expectedInvocations), m.UpdateNamespaceSecretByIDMock.expectedInvocationsOrigin, afterUpdateNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockUpdatePipelineRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdatePipelineRunExpectation
	expectations       []*RepositoryMockUpdatePipelineRunExpectation

	callArgs []*RepositoryMockUpdatePipelineRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdatePipelineRunExpectation specifies expectation struct of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdatePipelineRunParams
	paramPtrs          *RepositoryMockUpdatePipelineRunParamPtrs
	expectationOrigins RepositoryMockUpdatePipelineRunExpectationOrigins
	results            *RepositoryMockUpdatePipelineRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdatePipelineRunParams contains parameters of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunParams struct {
	ctx                context.Context
	pipelineTriggerUID string
	pipelineRun        *datamodel.PipelineRun
}

// RepositoryMockUpdatePipelineRunParamPtrs contains pointers to parameters of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunParamPtrs struct {
	ctx                *context.Context
	pipelineTriggerUID *string
	pipelineRun        **datamodel.PipelineRun
}

// RepositoryMockUpdatePipelineRunResults contains results of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunResults struct {
	err error
}

// RepositoryMockUpdatePipelineRunOrigins contains origins of expectations of the Repository.UpdatePipelineRun
type RepositoryMockUpdatePipelineRunExpectationOrigins struct {
	origin                   string
	originCtx                string
	originPipelineTriggerUID string
	originPipelineRun        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Optional() *mRepositoryMockUpdatePipelineRun {
	mmUpdatePipelineRun.optional = true
	return mmUpdatePipelineRun
}

// Expect sets up expected params for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Expect(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by ExpectParams functions")
	}

	mmUpdatePipelineRun.defaultExpectation.params = &RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun}
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePipelineRun.expectations {
		if minimock.Equal(e.params, mmUpdatePipelineRun.defaultExpectation.params) {
			mmUpdatePipelineRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePipelineRun.defaultExpectation.params)
		}
	}

	return mmUpdatePipelineRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.params != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Expect")
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineRunParamPtrs{}
	}
	mmUpdatePipelineRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePipelineRun
}

// ExpectPipelineTriggerUIDParam2 sets up expected param pipelineTriggerUID for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) ExpectPipelineTriggerUIDParam2(pipelineTriggerUID string) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.params != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Expect")
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineRunParamPtrs{}
	}
	mmUpdatePipelineRun.defaultExpectation.paramPtrs.pipelineTriggerUID = &pipelineTriggerUID
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.originPipelineTriggerUID = minimock.CallerInfo(1)

	return mmUpdatePipelineRun
}

// ExpectPipelineRunParam3 sets up expected param pipelineRun for Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) ExpectPipelineRunParam3(pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{}
	}

	if mmUpdatePipelineRun.defaultExpectation.params != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Expect")
	}

	if mmUpdatePipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpdatePipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpdatePipelineRunParamPtrs{}
	}
	mmUpdatePipelineRun.defaultExpectation.paramPtrs.pipelineRun = &pipelineRun
	mmUpdatePipelineRun.defaultExpectation.expectationOrigins.originPipelineRun = minimock.CallerInfo(1)

	return mmUpdatePipelineRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Inspect(f func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun)) *mRepositoryMockUpdatePipelineRun {
	if mmUpdatePipelineRun.mock.inspectFuncUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdatePipelineRun")
	}

	mmUpdatePipelineRun.mock.inspectFuncUpdatePipelineRun = f

	return mmUpdatePipelineRun
}

// Return sets up results that will be returned by Repository.UpdatePipelineRun
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Return(err error) *RepositoryMock {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	if mmUpdatePipelineRun.defaultExpectation == nil {
		mmUpdatePipelineRun.defaultExpectation = &RepositoryMockUpdatePipelineRunExpectation{mock: mmUpdatePipelineRun.mock}
	}
	mmUpdatePipelineRun.defaultExpectation.results = &RepositoryMockUpdatePipelineRunResults{err}
	mmUpdatePipelineRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineRun.mock
}

// Set uses given function f to mock the Repository.UpdatePipelineRun method
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Set(f func(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) (err error)) *RepositoryMock {
	if mmUpdatePipelineRun.defaultExpectation != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpdatePipelineRun method")
	}

	if len(mmUpdatePipelineRun.expectations) > 0 {
		mmUpdatePipelineRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpdatePipelineRun method")
	}

	mmUpdatePipelineRun.mock.funcUpdatePipelineRun = f
	mmUpdatePipelineRun.mock.funcUpdatePipelineRunOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineRun.mock
}

// When sets expectation for the Repository.UpdatePipelineRun which will trigger the result defined by the following
// Then helper
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) When(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) *RepositoryMockUpdatePipelineRunExpectation {
	if mmUpdatePipelineRun.mock.funcUpdatePipelineRun != nil {
		mmUpdatePipelineRun.mock.t.Fatalf("RepositoryMock.UpdatePipelineRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpdatePipelineRunExpectation{
		mock:               mmUpdatePipelineRun.mock,
		params:             &RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun},
		expectationOrigins: RepositoryMockUpdatePipelineRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePipelineRun.expectations = append(mmUpdatePipelineRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdatePipelineRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdatePipelineRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdatePipelineRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdatePipelineRun should be invoked
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Times(n uint64) *mRepositoryMockUpdatePipelineRun {
	if n == 0 {
		mmUpdatePipelineRun.mock.t.Fatalf("Times of RepositoryMock.UpdatePipelineRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePipelineRun.expectedInvocations, n)
	mmUpdatePipelineRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePipelineRun
}

func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) invocationsDone() bool {
	if len(mmUpdatePipelineRun.expectations) == 0 && mmUpdatePipelineRun.defaultExpectation == nil && mmUpdatePipelineRun.mock.funcUpdatePipelineRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineRun.mock.afterUpdatePipelineRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePipelineRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePipelineRun implements mm_repository.Repository
func (mmUpdatePipelineRun *RepositoryMock) UpdatePipelineRun(ctx context.Context, pipelineTriggerUID string, pipelineRun *datamodel.PipelineRun) (err error) {
	mm_atomic.AddUint64(&mmUpdatePipelineRun.beforeUpdatePipelineRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePipelineRun.afterUpdatePipelineRunCounter, 1)

	mmUpdatePipelineRun.t.Helper()

	if mmUpdatePipelineRun.inspectFuncUpdatePipelineRun != nil {
		mmUpdatePipelineRun.inspectFuncUpdatePipelineRun(ctx, pipelineTriggerUID, pipelineRun)
	}

	mm_params := RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun}

	// Record call args
	mmUpdatePipelineRun.UpdatePipelineRunMock.mutex.Lock()
	mmUpdatePipelineRun.UpdatePipelineRunMock.callArgs = append(mmUpdatePipelineRun.UpdatePipelineRunMock.callArgs, &mm_params)
	mmUpdatePipelineRun.UpdatePipelineRunMock.mutex.Unlock()

	for _, e := range mmUpdatePipelineRun.UpdatePipelineRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdatePipelineRunParams{ctx, pipelineTriggerUID, pipelineRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineTriggerUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID) {
				mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameter pipelineTriggerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.originPipelineTriggerUID, *mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID, minimock.Diff(*mm_want_ptrs.pipelineTriggerUID, mm_got.pipelineTriggerUID))
			}

			if mm_want_ptrs.pipelineRun != nil && !minimock.Equal(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun) {
				mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameter pipelineRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.originPipelineRun, *mm_want_ptrs.pipelineRun, mm_got.pipelineRun, minimock.Diff(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePipelineRun.t.Errorf("RepositoryMock.UpdatePipelineRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePipelineRun.UpdatePipelineRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePipelineRun.t.Fatal("No results are set for the RepositoryMock.UpdatePipelineRun")
		}
		return (*mm_results).err
	}
	if mmUpdatePipelineRun.funcUpdatePipelineRun != nil {
		return mmUpdatePipelineRun.funcUpdatePipelineRun(ctx, pipelineTriggerUID, pipelineRun)
	}
	mmUpdatePipelineRun.t.Fatalf("Unexpected call to RepositoryMock.UpdatePipelineRun. %v %v %v", ctx, pipelineTriggerUID, pipelineRun)
	return
}

// UpdatePipelineRunAfterCounter returns a count of finished RepositoryMock.UpdatePipelineRun invocations
func (mmUpdatePipelineRun *RepositoryMock) UpdatePipelineRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineRun.afterUpdatePipelineRunCounter)
}

// UpdatePipelineRunBeforeCounter returns a count of RepositoryMock.UpdatePipelineRun invocations
func (mmUpdatePipelineRun *RepositoryMock) UpdatePipelineRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineRun.beforeUpdatePipelineRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdatePipelineRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePipelineRun *mRepositoryMockUpdatePipelineRun) Calls() []*RepositoryMockUpdatePipelineRunParams {
	mmUpdatePipelineRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdatePipelineRunParams, len(mmUpdatePipelineRun.callArgs))
	copy(argCopy, mmUpdatePipelineRun.callArgs)

	mmUpdatePipelineRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePipelineRunDone returns true if the count of the UpdatePipelineRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdatePipelineRunDone() bool {
	if m.UpdatePipelineRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePipelineRunMock.invocationsDone()
}

// MinimockUpdatePipelineRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdatePipelineRunInspect() {
	for _, e := range m.UpdatePipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePipelineRunCounter := mm_atomic.LoadUint64(&m.afterUpdatePipelineRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineRunMock.defaultExpectation != nil && afterUpdatePipelineRunCounter < 1 {
		if m.UpdatePipelineRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s", m.UpdatePipelineRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s with params: %#v", m.UpdatePipelineRunMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePipelineRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineRun != nil && afterUpdatePipelineRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRun at\n%s", m.funcUpdatePipelineRunOrigin)
	}

	if !m.UpdatePipelineRunMock.invocationsDone() && afterUpdatePipelineRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdatePipelineRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePipelineRunMock.expectedInvocations), m.UpdatePipelineRunMock.expectedInvocationsOrigin, afterUpdatePipelineRunCounter)
	}
}

type mRepositoryMockUpsertComponentDefinition struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertComponentDefinitionExpectation
	expectations       []*RepositoryMockUpsertComponentDefinitionExpectation

	callArgs []*RepositoryMockUpsertComponentDefinitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertComponentDefinitionExpectation specifies expectation struct of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertComponentDefinitionParams
	paramPtrs          *RepositoryMockUpsertComponentDefinitionParamPtrs
	expectationOrigins RepositoryMockUpsertComponentDefinitionExpectationOrigins
	results            *RepositoryMockUpsertComponentDefinitionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertComponentDefinitionParams contains parameters of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionParams struct {
	ctx context.Context
	cp1 *pb.ComponentDefinition
}

// RepositoryMockUpsertComponentDefinitionParamPtrs contains pointers to parameters of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionParamPtrs struct {
	ctx *context.Context
	cp1 **pb.ComponentDefinition
}

// RepositoryMockUpsertComponentDefinitionResults contains results of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionResults struct {
	err error
}

// RepositoryMockUpsertComponentDefinitionOrigins contains origins of expectations of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionExpectationOrigins struct {
	origin    string
	originCtx string
	originCp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Optional() *mRepositoryMockUpsertComponentDefinition {
	mmUpsertComponentDefinition.optional = true
	return mmUpsertComponentDefinition
}

// Expect sets up expected params for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Expect(ctx context.Context, cp1 *pb.ComponentDefinition) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by ExpectParams functions")
	}

	mmUpsertComponentDefinition.defaultExpectation.params = &RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}
	mmUpsertComponentDefinition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertComponentDefinition.expectations {
		if minimock.Equal(e.params, mmUpsertComponentDefinition.defaultExpectation.params) {
			mmUpsertComponentDefinition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertComponentDefinition.defaultExpectation.params)
		}
	}

	return mmUpsertComponentDefinition
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.params != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Expect")
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentDefinitionParamPtrs{}
	}
	mmUpsertComponentDefinition.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertComponentDefinition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertComponentDefinition
}

// ExpectCp1Param2 sets up expected param cp1 for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) ExpectCp1Param2(cp1 *pb.ComponentDefinition) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.params != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Expect")
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentDefinitionParamPtrs{}
	}
	mmUpsertComponentDefinition.defaultExpectation.paramPtrs.cp1 = &cp1
	mmUpsertComponentDefinition.defaultExpectation.expectationOrigins.originCp1 = minimock.CallerInfo(1)

	return mmUpsertComponentDefinition
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Inspect(f func(ctx context.Context, cp1 *pb.ComponentDefinition)) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.inspectFuncUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertComponentDefinition")
	}

	mmUpsertComponentDefinition.mock.inspectFuncUpsertComponentDefinition = f

	return mmUpsertComponentDefinition
}

// Return sets up results that will be returned by Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Return(err error) *RepositoryMock {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{mock: mmUpsertComponentDefinition.mock}
	}
	mmUpsertComponentDefinition.defaultExpectation.results = &RepositoryMockUpsertComponentDefinitionResults{err}
	mmUpsertComponentDefinition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentDefinition.mock
}

// Set uses given function f to mock the Repository.UpsertComponentDefinition method
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Set(f func(ctx context.Context, cp1 *pb.ComponentDefinition) (err error)) *RepositoryMock {
	if mmUpsertComponentDefinition.defaultExpectation != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertComponentDefinition method")
	}

	if len(mmUpsertComponentDefinition.expectations) > 0 {
		mmUpsertComponentDefinition.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertComponentDefinition method")
	}

	mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition = f
	mmUpsertComponentDefinition.mock.funcUpsertComponentDefinitionOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentDefinition.mock
}

// When sets expectation for the Repository.UpsertComponentDefinition which will trigger the result defined by the following
// Then helper
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) When(ctx context.Context, cp1 *pb.ComponentDefinition) *RepositoryMockUpsertComponentDefinitionExpectation {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertComponentDefinitionExpectation{
		mock:               mmUpsertComponentDefinition.mock,
		params:             &RepositoryMockUpsertComponentDefinitionParams{ctx, cp1},
		expectationOrigins: RepositoryMockUpsertComponentDefinitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertComponentDefinition.expectations = append(mmUpsertComponentDefinition.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertComponentDefinition return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertComponentDefinitionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertComponentDefinitionResults{err}
	return e.mock
}

// Times sets number of times Repository.UpsertComponentDefinition should be invoked
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Times(n uint64) *mRepositoryMockUpsertComponentDefinition {
	if n == 0 {
		mmUpsertComponentDefinition.mock.t.Fatalf("Times of RepositoryMock.UpsertComponentDefinition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertComponentDefinition.expectedInvocations, n)
	mmUpsertComponentDefinition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentDefinition
}

func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) invocationsDone() bool {
	if len(mmUpsertComponentDefinition.expectations) == 0 && mmUpsertComponentDefinition.defaultExpectation == nil && mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertComponentDefinition.mock.afterUpsertComponentDefinitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertComponentDefinition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertComponentDefinition implements mm_repository.Repository
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinition(ctx context.Context, cp1 *pb.ComponentDefinition) (err error) {
	mm_atomic.AddUint64(&mmUpsertComponentDefinition.beforeUpsertComponentDefinitionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertComponentDefinition.afterUpsertComponentDefinitionCounter, 1)

	mmUpsertComponentDefinition.t.Helper()

	if mmUpsertComponentDefinition.inspectFuncUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.inspectFuncUpsertComponentDefinition(ctx, cp1)
	}

	mm_params := RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}

	// Record call args
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.mutex.Lock()
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.callArgs = append(mmUpsertComponentDefinition.UpsertComponentDefinitionMock.callArgs, &mm_params)
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.mutex.Unlock()

	for _, e := range mmUpsertComponentDefinition.UpsertComponentDefinitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameter cp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.originCp1, *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertComponentDefinition.t.Fatal("No results are set for the RepositoryMock.UpsertComponentDefinition")
		}
		return (*mm_results).err
	}
	if mmUpsertComponentDefinition.funcUpsertComponentDefinition != nil {
		return mmUpsertComponentDefinition.funcUpsertComponentDefinition(ctx, cp1)
	}
	mmUpsertComponentDefinition.t.Fatalf("Unexpected call to RepositoryMock.UpsertComponentDefinition. %v %v", ctx, cp1)
	return
}

// UpsertComponentDefinitionAfterCounter returns a count of finished RepositoryMock.UpsertComponentDefinition invocations
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentDefinition.afterUpsertComponentDefinitionCounter)
}

// UpsertComponentDefinitionBeforeCounter returns a count of RepositoryMock.UpsertComponentDefinition invocations
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentDefinition.beforeUpsertComponentDefinitionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertComponentDefinition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Calls() []*RepositoryMockUpsertComponentDefinitionParams {
	mmUpsertComponentDefinition.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertComponentDefinitionParams, len(mmUpsertComponentDefinition.callArgs))
	copy(argCopy, mmUpsertComponentDefinition.callArgs)

	mmUpsertComponentDefinition.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertComponentDefinitionDone returns true if the count of the UpsertComponentDefinition invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertComponentDefinitionDone() bool {
	if m.UpsertComponentDefinitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertComponentDefinitionMock.invocationsDone()
}

// MinimockUpsertComponentDefinitionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertComponentDefinitionInspect() {
	for _, e := range m.UpsertComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertComponentDefinitionCounter := mm_atomic.LoadUint64(&m.afterUpsertComponentDefinitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertComponentDefinitionMock.defaultExpectation != nil && afterUpsertComponentDefinitionCounter < 1 {
		if m.UpsertComponentDefinitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s", m.UpsertComponentDefinitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s with params: %#v", m.UpsertComponentDefinitionMock.defaultExpectation.expectationOrigins.origin, *m.UpsertComponentDefinitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertComponentDefinition != nil && afterUpsertComponentDefinitionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition at\n%s", m.funcUpsertComponentDefinitionOrigin)
	}

	if !m.UpsertComponentDefinitionMock.invocationsDone() && afterUpsertComponentDefinitionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertComponentDefinition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertComponentDefinitionMock.expectedInvocations), m.UpsertComponentDefinitionMock.expectedInvocationsOrigin, afterUpsertComponentDefinitionCounter)
	}
}

type mRepositoryMockUpsertComponentRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertComponentRunExpectation
	expectations       []*RepositoryMockUpsertComponentRunExpectation

	callArgs []*RepositoryMockUpsertComponentRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertComponentRunExpectation specifies expectation struct of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertComponentRunParams
	paramPtrs          *RepositoryMockUpsertComponentRunParamPtrs
	expectationOrigins RepositoryMockUpsertComponentRunExpectationOrigins
	results            *RepositoryMockUpsertComponentRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertComponentRunParams contains parameters of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunParams struct {
	ctx          context.Context
	componentRun *datamodel.ComponentRun
}

// RepositoryMockUpsertComponentRunParamPtrs contains pointers to parameters of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunParamPtrs struct {
	ctx          *context.Context
	componentRun **datamodel.ComponentRun
}

// RepositoryMockUpsertComponentRunResults contains results of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunResults struct {
	err error
}

// RepositoryMockUpsertComponentRunOrigins contains origins of expectations of the Repository.UpsertComponentRun
type RepositoryMockUpsertComponentRunExpectationOrigins struct {
	origin             string
	originCtx          string
	originComponentRun string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Optional() *mRepositoryMockUpsertComponentRun {
	mmUpsertComponentRun.optional = true
	return mmUpsertComponentRun
}

// Expect sets up expected params for Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Expect(ctx context.Context, componentRun *datamodel.ComponentRun) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{}
	}

	if mmUpsertComponentRun.defaultExpectation.paramPtrs != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by ExpectParams functions")
	}

	mmUpsertComponentRun.defaultExpectation.params = &RepositoryMockUpsertComponentRunParams{ctx, componentRun}
	mmUpsertComponentRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertComponentRun.expectations {
		if minimock.Equal(e.params, mmUpsertComponentRun.defaultExpectation.params) {
			mmUpsertComponentRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertComponentRun.defaultExpectation.params)
		}
	}

	return mmUpsertComponentRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{}
	}

	if mmUpsertComponentRun.defaultExpectation.params != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Expect")
	}

	if mmUpsertComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentRunParamPtrs{}
	}
	mmUpsertComponentRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertComponentRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertComponentRun
}

// ExpectComponentRunParam2 sets up expected param componentRun for Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) ExpectComponentRunParam2(componentRun *datamodel.ComponentRun) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{}
	}

	if mmUpsertComponentRun.defaultExpectation.params != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Expect")
	}

	if mmUpsertComponentRun.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentRunParamPtrs{}
	}
	mmUpsertComponentRun.defaultExpectation.paramPtrs.componentRun = &componentRun
	mmUpsertComponentRun.defaultExpectation.expectationOrigins.originComponentRun = minimock.CallerInfo(1)

	return mmUpsertComponentRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Inspect(f func(ctx context.Context, componentRun *datamodel.ComponentRun)) *mRepositoryMockUpsertComponentRun {
	if mmUpsertComponentRun.mock.inspectFuncUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertComponentRun")
	}

	mmUpsertComponentRun.mock.inspectFuncUpsertComponentRun = f

	return mmUpsertComponentRun
}

// Return sets up results that will be returned by Repository.UpsertComponentRun
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Return(err error) *RepositoryMock {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	if mmUpsertComponentRun.defaultExpectation == nil {
		mmUpsertComponentRun.defaultExpectation = &RepositoryMockUpsertComponentRunExpectation{mock: mmUpsertComponentRun.mock}
	}
	mmUpsertComponentRun.defaultExpectation.results = &RepositoryMockUpsertComponentRunResults{err}
	mmUpsertComponentRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentRun.mock
}

// Set uses given function f to mock the Repository.UpsertComponentRun method
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Set(f func(ctx context.Context, componentRun *datamodel.ComponentRun) (err error)) *RepositoryMock {
	if mmUpsertComponentRun.defaultExpectation != nil {
		mmUpsertComponentRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertComponentRun method")
	}

	if len(mmUpsertComponentRun.expectations) > 0 {
		mmUpsertComponentRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertComponentRun method")
	}

	mmUpsertComponentRun.mock.funcUpsertComponentRun = f
	mmUpsertComponentRun.mock.funcUpsertComponentRunOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentRun.mock
}

// When sets expectation for the Repository.UpsertComponentRun which will trigger the result defined by the following
// Then helper
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) When(ctx context.Context, componentRun *datamodel.ComponentRun) *RepositoryMockUpsertComponentRunExpectation {
	if mmUpsertComponentRun.mock.funcUpsertComponentRun != nil {
		mmUpsertComponentRun.mock.t.Fatalf("RepositoryMock.UpsertComponentRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertComponentRunExpectation{
		mock:               mmUpsertComponentRun.mock,
		params:             &RepositoryMockUpsertComponentRunParams{ctx, componentRun},
		expectationOrigins: RepositoryMockUpsertComponentRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertComponentRun.expectations = append(mmUpsertComponentRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertComponentRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertComponentRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertComponentRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpsertComponentRun should be invoked
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Times(n uint64) *mRepositoryMockUpsertComponentRun {
	if n == 0 {
		mmUpsertComponentRun.mock.t.Fatalf("Times of RepositoryMock.UpsertComponentRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertComponentRun.expectedInvocations, n)
	mmUpsertComponentRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertComponentRun
}

func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) invocationsDone() bool {
	if len(mmUpsertComponentRun.expectations) == 0 && mmUpsertComponentRun.defaultExpectation == nil && mmUpsertComponentRun.mock.funcUpsertComponentRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertComponentRun.mock.afterUpsertComponentRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertComponentRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertComponentRun implements mm_repository.Repository
func (mmUpsertComponentRun *RepositoryMock) UpsertComponentRun(ctx context.Context, componentRun *datamodel.ComponentRun) (err error) {
	mm_atomic.AddUint64(&mmUpsertComponentRun.beforeUpsertComponentRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertComponentRun.afterUpsertComponentRunCounter, 1)

	mmUpsertComponentRun.t.Helper()

	if mmUpsertComponentRun.inspectFuncUpsertComponentRun != nil {
		mmUpsertComponentRun.inspectFuncUpsertComponentRun(ctx, componentRun)
	}

	mm_params := RepositoryMockUpsertComponentRunParams{ctx, componentRun}

	// Record call args
	mmUpsertComponentRun.UpsertComponentRunMock.mutex.Lock()
	mmUpsertComponentRun.UpsertComponentRunMock.callArgs = append(mmUpsertComponentRun.UpsertComponentRunMock.callArgs, &mm_params)
	mmUpsertComponentRun.UpsertComponentRunMock.mutex.Unlock()

	for _, e := range mmUpsertComponentRun.UpsertComponentRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertComponentRunParams{ctx, componentRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertComponentRun.t.Errorf("RepositoryMock.UpsertComponentRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.componentRun != nil && !minimock.Equal(*mm_want_ptrs.componentRun, mm_got.componentRun) {
				mmUpsertComponentRun.t.Errorf("RepositoryMock.UpsertComponentRun got unexpected parameter componentRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.expectationOrigins.originComponentRun, *mm_want_ptrs.componentRun, mm_got.componentRun, minimock.Diff(*mm_want_ptrs.componentRun, mm_got.componentRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertComponentRun.t.Errorf("RepositoryMock.UpsertComponentRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertComponentRun.UpsertComponentRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertComponentRun.t.Fatal("No results are set for the RepositoryMock.UpsertComponentRun")
		}
		return (*mm_results).err
	}
	if mmUpsertComponentRun.funcUpsertComponentRun != nil {
		return mmUpsertComponentRun.funcUpsertComponentRun(ctx, componentRun)
	}
	mmUpsertComponentRun.t.Fatalf("Unexpected call to RepositoryMock.UpsertComponentRun. %v %v", ctx, componentRun)
	return
}

// UpsertComponentRunAfterCounter returns a count of finished RepositoryMock.UpsertComponentRun invocations
func (mmUpsertComponentRun *RepositoryMock) UpsertComponentRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentRun.afterUpsertComponentRunCounter)
}

// UpsertComponentRunBeforeCounter returns a count of RepositoryMock.UpsertComponentRun invocations
func (mmUpsertComponentRun *RepositoryMock) UpsertComponentRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentRun.beforeUpsertComponentRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertComponentRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertComponentRun *mRepositoryMockUpsertComponentRun) Calls() []*RepositoryMockUpsertComponentRunParams {
	mmUpsertComponentRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertComponentRunParams, len(mmUpsertComponentRun.callArgs))
	copy(argCopy, mmUpsertComponentRun.callArgs)

	mmUpsertComponentRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertComponentRunDone returns true if the count of the UpsertComponentRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertComponentRunDone() bool {
	if m.UpsertComponentRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertComponentRunMock.invocationsDone()
}

// MinimockUpsertComponentRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertComponentRunInspect() {
	for _, e := range m.UpsertComponentRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertComponentRunCounter := mm_atomic.LoadUint64(&m.afterUpsertComponentRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertComponentRunMock.defaultExpectation != nil && afterUpsertComponentRunCounter < 1 {
		if m.UpsertComponentRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s", m.UpsertComponentRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s with params: %#v", m.UpsertComponentRunMock.defaultExpectation.expectationOrigins.origin, *m.UpsertComponentRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertComponentRun != nil && afterUpsertComponentRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertComponentRun at\n%s", m.funcUpsertComponentRunOrigin)
	}

	if !m.UpsertComponentRunMock.invocationsDone() && afterUpsertComponentRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertComponentRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertComponentRunMock.expectedInvocations), m.UpsertComponentRunMock.expectedInvocationsOrigin, afterUpsertComponentRunCounter)
	}
}

type mRepositoryMockUpsertPipelineRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertPipelineRunExpectation
	expectations       []*RepositoryMockUpsertPipelineRunExpectation

	callArgs []*RepositoryMockUpsertPipelineRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertPipelineRunExpectation specifies expectation struct of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertPipelineRunParams
	paramPtrs          *RepositoryMockUpsertPipelineRunParamPtrs
	expectationOrigins RepositoryMockUpsertPipelineRunExpectationOrigins
	results            *RepositoryMockUpsertPipelineRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertPipelineRunParams contains parameters of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunParams struct {
	ctx         context.Context
	pipelineRun *datamodel.PipelineRun
}

// RepositoryMockUpsertPipelineRunParamPtrs contains pointers to parameters of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunParamPtrs struct {
	ctx         *context.Context
	pipelineRun **datamodel.PipelineRun
}

// RepositoryMockUpsertPipelineRunResults contains results of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunResults struct {
	err error
}

// RepositoryMockUpsertPipelineRunOrigins contains origins of expectations of the Repository.UpsertPipelineRun
type RepositoryMockUpsertPipelineRunExpectationOrigins struct {
	origin            string
	originCtx         string
	originPipelineRun string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Optional() *mRepositoryMockUpsertPipelineRun {
	mmUpsertPipelineRun.optional = true
	return mmUpsertPipelineRun
}

// Expect sets up expected params for Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Expect(ctx context.Context, pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{}
	}

	if mmUpsertPipelineRun.defaultExpectation.paramPtrs != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by ExpectParams functions")
	}

	mmUpsertPipelineRun.defaultExpectation.params = &RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun}
	mmUpsertPipelineRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertPipelineRun.expectations {
		if minimock.Equal(e.params, mmUpsertPipelineRun.defaultExpectation.params) {
			mmUpsertPipelineRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertPipelineRun.defaultExpectation.params)
		}
	}

	return mmUpsertPipelineRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{}
	}

	if mmUpsertPipelineRun.defaultExpectation.params != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Expect")
	}

	if mmUpsertPipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpsertPipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertPipelineRunParamPtrs{}
	}
	mmUpsertPipelineRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertPipelineRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertPipelineRun
}

// ExpectPipelineRunParam2 sets up expected param pipelineRun for Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) ExpectPipelineRunParam2(pipelineRun *datamodel.PipelineRun) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{}
	}

	if mmUpsertPipelineRun.defaultExpectation.params != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Expect")
	}

	if mmUpsertPipelineRun.defaultExpectation.paramPtrs == nil {
		mmUpsertPipelineRun.defaultExpectation.paramPtrs = &RepositoryMockUpsertPipelineRunParamPtrs{}
	}
	mmUpsertPipelineRun.defaultExpectation.paramPtrs.pipelineRun = &pipelineRun
	mmUpsertPipelineRun.defaultExpectation.expectationOrigins.originPipelineRun = minimock.CallerInfo(1)

	return mmUpsertPipelineRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Inspect(f func(ctx context.Context, pipelineRun *datamodel.PipelineRun)) *mRepositoryMockUpsertPipelineRun {
	if mmUpsertPipelineRun.mock.inspectFuncUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertPipelineRun")
	}

	mmUpsertPipelineRun.mock.inspectFuncUpsertPipelineRun = f

	return mmUpsertPipelineRun
}

// Return sets up results that will be returned by Repository.UpsertPipelineRun
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Return(err error) *RepositoryMock {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	if mmUpsertPipelineRun.defaultExpectation == nil {
		mmUpsertPipelineRun.defaultExpectation = &RepositoryMockUpsertPipelineRunExpectation{mock: mmUpsertPipelineRun.mock}
	}
	mmUpsertPipelineRun.defaultExpectation.results = &RepositoryMockUpsertPipelineRunResults{err}
	mmUpsertPipelineRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertPipelineRun.mock
}

// Set uses given function f to mock the Repository.UpsertPipelineRun method
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Set(f func(ctx context.Context, pipelineRun *datamodel.PipelineRun) (err error)) *RepositoryMock {
	if mmUpsertPipelineRun.defaultExpectation != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertPipelineRun method")
	}

	if len(mmUpsertPipelineRun.expectations) > 0 {
		mmUpsertPipelineRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertPipelineRun method")
	}

	mmUpsertPipelineRun.mock.funcUpsertPipelineRun = f
	mmUpsertPipelineRun.mock.funcUpsertPipelineRunOrigin = minimock.CallerInfo(1)
	return mmUpsertPipelineRun.mock
}

// When sets expectation for the Repository.UpsertPipelineRun which will trigger the result defined by the following
// Then helper
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) When(ctx context.Context, pipelineRun *datamodel.PipelineRun) *RepositoryMockUpsertPipelineRunExpectation {
	if mmUpsertPipelineRun.mock.funcUpsertPipelineRun != nil {
		mmUpsertPipelineRun.mock.t.Fatalf("RepositoryMock.UpsertPipelineRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertPipelineRunExpectation{
		mock:               mmUpsertPipelineRun.mock,
		params:             &RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun},
		expectationOrigins: RepositoryMockUpsertPipelineRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertPipelineRun.expectations = append(mmUpsertPipelineRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertPipelineRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertPipelineRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertPipelineRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpsertPipelineRun should be invoked
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Times(n uint64) *mRepositoryMockUpsertPipelineRun {
	if n == 0 {
		mmUpsertPipelineRun.mock.t.Fatalf("Times of RepositoryMock.UpsertPipelineRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertPipelineRun.expectedInvocations, n)
	mmUpsertPipelineRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertPipelineRun
}

func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) invocationsDone() bool {
	if len(mmUpsertPipelineRun.expectations) == 0 && mmUpsertPipelineRun.defaultExpectation == nil && mmUpsertPipelineRun.mock.funcUpsertPipelineRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertPipelineRun.mock.afterUpsertPipelineRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertPipelineRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertPipelineRun implements mm_repository.Repository
func (mmUpsertPipelineRun *RepositoryMock) UpsertPipelineRun(ctx context.Context, pipelineRun *datamodel.PipelineRun) (err error) {
	mm_atomic.AddUint64(&mmUpsertPipelineRun.beforeUpsertPipelineRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertPipelineRun.afterUpsertPipelineRunCounter, 1)

	mmUpsertPipelineRun.t.Helper()

	if mmUpsertPipelineRun.inspectFuncUpsertPipelineRun != nil {
		mmUpsertPipelineRun.inspectFuncUpsertPipelineRun(ctx, pipelineRun)
	}

	mm_params := RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun}

	// Record call args
	mmUpsertPipelineRun.UpsertPipelineRunMock.mutex.Lock()
	mmUpsertPipelineRun.UpsertPipelineRunMock.callArgs = append(mmUpsertPipelineRun.UpsertPipelineRunMock.callArgs, &mm_params)
	mmUpsertPipelineRun.UpsertPipelineRunMock.mutex.Unlock()

	for _, e := range mmUpsertPipelineRun.UpsertPipelineRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertPipelineRunParams{ctx, pipelineRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertPipelineRun.t.Errorf("RepositoryMock.UpsertPipelineRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineRun != nil && !minimock.Equal(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun) {
				mmUpsertPipelineRun.t.Errorf("RepositoryMock.UpsertPipelineRun got unexpected parameter pipelineRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.originPipelineRun, *mm_want_ptrs.pipelineRun, mm_got.pipelineRun, minimock.Diff(*mm_want_ptrs.pipelineRun, mm_got.pipelineRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertPipelineRun.t.Errorf("RepositoryMock.UpsertPipelineRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertPipelineRun.UpsertPipelineRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertPipelineRun.t.Fatal("No results are set for the RepositoryMock.UpsertPipelineRun")
		}
		return (*mm_results).err
	}
	if mmUpsertPipelineRun.funcUpsertPipelineRun != nil {
		return mmUpsertPipelineRun.funcUpsertPipelineRun(ctx, pipelineRun)
	}
	mmUpsertPipelineRun.t.Fatalf("Unexpected call to RepositoryMock.UpsertPipelineRun. %v %v", ctx, pipelineRun)
	return
}

// UpsertPipelineRunAfterCounter returns a count of finished RepositoryMock.UpsertPipelineRun invocations
func (mmUpsertPipelineRun *RepositoryMock) UpsertPipelineRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPipelineRun.afterUpsertPipelineRunCounter)
}

// UpsertPipelineRunBeforeCounter returns a count of RepositoryMock.UpsertPipelineRun invocations
func (mmUpsertPipelineRun *RepositoryMock) UpsertPipelineRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertPipelineRun.beforeUpsertPipelineRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertPipelineRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertPipelineRun *mRepositoryMockUpsertPipelineRun) Calls() []*RepositoryMockUpsertPipelineRunParams {
	mmUpsertPipelineRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertPipelineRunParams, len(mmUpsertPipelineRun.callArgs))
	copy(argCopy, mmUpsertPipelineRun.callArgs)

	mmUpsertPipelineRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertPipelineRunDone returns true if the count of the UpsertPipelineRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertPipelineRunDone() bool {
	if m.UpsertPipelineRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertPipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertPipelineRunMock.invocationsDone()
}

// MinimockUpsertPipelineRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertPipelineRunInspect() {
	for _, e := range m.UpsertPipelineRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertPipelineRunCounter := mm_atomic.LoadUint64(&m.afterUpsertPipelineRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertPipelineRunMock.defaultExpectation != nil && afterUpsertPipelineRunCounter < 1 {
		if m.UpsertPipelineRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s", m.UpsertPipelineRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s with params: %#v", m.UpsertPipelineRunMock.defaultExpectation.expectationOrigins.origin, *m.UpsertPipelineRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertPipelineRun != nil && afterUpsertPipelineRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertPipelineRun at\n%s", m.funcUpsertPipelineRunOrigin)
	}

	if !m.UpsertPipelineRunMock.invocationsDone() && afterUpsertPipelineRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertPipelineRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertPipelineRunMock.expectedInvocations), m.UpsertPipelineRunMock.expectedInvocationsOrigin, afterUpsertPipelineRunCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddPipelineClonesInspect()

			m.MinimockAddPipelineRunsInspect()

			m.MinimockCheckPinnedUserInspect()

			m.MinimockCreateNamespaceConnectionInspect()

			m.MinimockCreateNamespacePipelineInspect()

			m.MinimockCreateNamespacePipelineReleaseInspect()

			m.MinimockCreateNamespaceSecretInspect()

			m.MinimockCreatePipelineTagsInspect()

			m.MinimockDeleteNamespaceConnectionByIDInspect()

			m.MinimockDeleteNamespacePipelineByIDInspect()

			m.MinimockDeleteNamespacePipelineReleaseByIDInspect()

			m.MinimockDeleteNamespaceSecretByIDInspect()

			m.MinimockDeletePipelineTagsInspect()

			m.MinimockGetDefinitionByUIDInspect()

			m.MinimockGetHubStatsInspect()

			m.MinimockGetLatestNamespacePipelineReleaseInspect()

			m.MinimockGetNamespaceConnectionByIDInspect()

			m.MinimockGetNamespacePipelineByIDInspect()

			m.MinimockGetNamespacePipelineReleaseByIDInspect()

			m.MinimockGetNamespaceSecretByIDInspect()

			m.MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsInspect()

			m.MinimockGetPaginatedPipelineRunsByRequesterInspect()

			m.MinimockGetPaginatedPipelineRunsWithPermissionsInspect()

			m.MinimockGetPipelineByIDAdminInspect()

			m.MinimockGetPipelineByUIDInspect()

			m.MinimockGetPipelineByUIDAdminInspect()

			m.MinimockGetPipelineReleaseByUIDAdminInspect()

			m.MinimockGetPipelineRunByUIDInspect()

			m.MinimockListComponentDefinitionUIDsInspect()

			m.MinimockListIntegrationsInspect()

			m.MinimockListNamespaceConnectionsInspect()

			m.MinimockListNamespacePipelineReleasesInspect()

			m.MinimockListNamespacePipelinesInspect()

			m.MinimockListNamespaceSecretsInspect()

			m.MinimockListPipelineIDsByConnectionIDInspect()

			m.MinimockListPipelineTagsInspect()

			m.MinimockListPipelinesInspect()

			m.MinimockListPipelinesAdminInspect()

			m.MinimockPinUserInspect()

			m.MinimockTranspileFilterInspect()

			m.MinimockUpdateComponentRunInspect()

			m.MinimockUpdateNamespaceConnectionByUIDInspect()

			m.MinimockUpdateNamespacePipelineByUIDInspect()

			m.MinimockUpdateNamespacePipelineIDByIDInspect()

			m.MinimockUpdateNamespacePipelineReleaseByIDInspect()

			m.MinimockUpdateNamespacePipelineReleaseIDByIDInspect()

			m.MinimockUpdateNamespaceSecretByIDInspect()

			m.MinimockUpdatePipelineRunInspect()

			m.MinimockUpsertComponentDefinitionInspect()

			m.MinimockUpsertComponentRunInspect()

			m.MinimockUpsertPipelineRunInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddPipelineClonesDone() &&
		m.MinimockAddPipelineRunsDone() &&
		m.MinimockCheckPinnedUserDone() &&
		m.MinimockCreateNamespaceConnectionDone() &&
		m.MinimockCreateNamespacePipelineDone() &&
		m.MinimockCreateNamespacePipelineReleaseDone() &&
		m.MinimockCreateNamespaceSecretDone() &&
		m.MinimockCreatePipelineTagsDone() &&
		m.MinimockDeleteNamespaceConnectionByIDDone() &&
		m.MinimockDeleteNamespacePipelineByIDDone() &&
		m.MinimockDeleteNamespacePipelineReleaseByIDDone() &&
		m.MinimockDeleteNamespaceSecretByIDDone() &&
		m.MinimockDeletePipelineTagsDone() &&
		m.MinimockGetDefinitionByUIDDone() &&
		m.MinimockGetHubStatsDone() &&
		m.MinimockGetLatestNamespacePipelineReleaseDone() &&
		m.MinimockGetNamespaceConnectionByIDDone() &&
		m.MinimockGetNamespacePipelineByIDDone() &&
		m.MinimockGetNamespacePipelineReleaseByIDDone() &&
		m.MinimockGetNamespaceSecretByIDDone() &&
		m.MinimockGetPaginatedComponentRunsByPipelineRunIDWithPermissionsDone() &&
		m.MinimockGetPaginatedPipelineRunsByRequesterDone() &&
		m.MinimockGetPaginatedPipelineRunsWithPermissionsDone() &&
		m.MinimockGetPipelineByIDAdminDone() &&
		m.MinimockGetPipelineByUIDDone() &&
		m.MinimockGetPipelineByUIDAdminDone() &&
		m.MinimockGetPipelineReleaseByUIDAdminDone() &&
		m.MinimockGetPipelineRunByUIDDone() &&
		m.MinimockListComponentDefinitionUIDsDone() &&
		m.MinimockListIntegrationsDone() &&
		m.MinimockListNamespaceConnectionsDone() &&
		m.MinimockListNamespacePipelineReleasesDone() &&
		m.MinimockListNamespacePipelinesDone() &&
		m.MinimockListNamespaceSecretsDone() &&
		m.MinimockListPipelineIDsByConnectionIDDone() &&
		m.MinimockListPipelineTagsDone() &&
		m.MinimockListPipelinesDone() &&
		m.MinimockListPipelinesAdminDone() &&
		m.MinimockPinUserDone() &&
		m.MinimockTranspileFilterDone() &&
		m.MinimockUpdateComponentRunDone() &&
		m.MinimockUpdateNamespaceConnectionByUIDDone() &&
		m.MinimockUpdateNamespacePipelineByUIDDone() &&
		m.MinimockUpdateNamespacePipelineIDByIDDone() &&
		m.MinimockUpdateNamespacePipelineReleaseByIDDone() &&
		m.MinimockUpdateNamespacePipelineReleaseIDByIDDone() &&
		m.MinimockUpdateNamespaceSecretByIDDone() &&
		m.MinimockUpdatePipelineRunDone() &&
		m.MinimockUpsertComponentDefinitionDone() &&
		m.MinimockUpsertComponentRunDone() &&
		m.MinimockUpsertPipelineRunDone()
}
