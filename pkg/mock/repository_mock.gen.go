// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/pipeline-backend/pkg/datamodel"
	mm_repository "github.com/instill-ai/pipeline-backend/pkg/repository"
	pb "github.com/instill-ai/protogen-go/vdp/pipeline/v1beta"
	"go.einride.tech/aip/filtering"
	"go.einride.tech/aip/ordering"
	"gorm.io/gorm/clause"
)

// RepositoryMock implements repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddPipelineClones          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncAddPipelineClones   func(ctx context.Context, uid uuid.UUID)
	afterAddPipelineClonesCounter  uint64
	beforeAddPipelineClonesCounter uint64
	AddPipelineClonesMock          mRepositoryMockAddPipelineClones

	funcAddPipelineRuns          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncAddPipelineRuns   func(ctx context.Context, uid uuid.UUID)
	afterAddPipelineRunsCounter  uint64
	beforeAddPipelineRunsCounter uint64
	AddPipelineRunsMock          mRepositoryMockAddPipelineRuns

	funcCreateNamespacePipeline          func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)
	inspectFuncCreateNamespacePipeline   func(ctx context.Context, pipeline *datamodel.Pipeline)
	afterCreateNamespacePipelineCounter  uint64
	beforeCreateNamespacePipelineCounter uint64
	CreateNamespacePipelineMock          mRepositoryMockCreateNamespacePipeline

	funcCreateNamespacePipelineRelease          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error)
	inspectFuncCreateNamespacePipelineRelease   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease)
	afterCreateNamespacePipelineReleaseCounter  uint64
	beforeCreateNamespacePipelineReleaseCounter uint64
	CreateNamespacePipelineReleaseMock          mRepositoryMockCreateNamespacePipelineRelease

	funcCreateNamespaceSecret          func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error)
	inspectFuncCreateNamespaceSecret   func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret)
	afterCreateNamespaceSecretCounter  uint64
	beforeCreateNamespaceSecretCounter uint64
	CreateNamespaceSecretMock          mRepositoryMockCreateNamespaceSecret

	funcCreatePipelineTags          func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)
	inspectFuncCreatePipelineTags   func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)
	afterCreatePipelineTagsCounter  uint64
	beforeCreatePipelineTagsCounter uint64
	CreatePipelineTagsMock          mRepositoryMockCreatePipelineTags

	funcDeleteNamespacePipelineByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	inspectFuncDeleteNamespacePipelineByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeleteNamespacePipelineByIDCounter  uint64
	beforeDeleteNamespacePipelineByIDCounter uint64
	DeleteNamespacePipelineByIDMock          mRepositoryMockDeleteNamespacePipelineByID

	funcDeleteNamespacePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error)
	inspectFuncDeleteNamespacePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string)
	afterDeleteNamespacePipelineReleaseByIDCounter  uint64
	beforeDeleteNamespacePipelineReleaseByIDCounter uint64
	DeleteNamespacePipelineReleaseByIDMock          mRepositoryMockDeleteNamespacePipelineReleaseByID

	funcDeleteNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	inspectFuncDeleteNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeleteNamespaceSecretByIDCounter  uint64
	beforeDeleteNamespaceSecretByIDCounter uint64
	DeleteNamespaceSecretByIDMock          mRepositoryMockDeleteNamespaceSecretByID

	funcDeletePipelineTags          func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)
	inspectFuncDeletePipelineTags   func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)
	afterDeletePipelineTagsCounter  uint64
	beforeDeletePipelineTagsCounter uint64
	DeletePipelineTagsMock          mRepositoryMockDeletePipelineTags

	funcGetDefinitionByUID          func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error)
	inspectFuncGetDefinitionByUID   func(ctx context.Context, u1 uuid.UUID)
	afterGetDefinitionByUIDCounter  uint64
	beforeGetDefinitionByUIDCounter uint64
	GetDefinitionByUIDMock          mRepositoryMockGetDefinitionByUID

	funcGetHubStats          func(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error)
	inspectFuncGetHubStats   func(uidAllowList []uuid.UUID)
	afterGetHubStatsCounter  uint64
	beforeGetHubStatsCounter uint64
	GetHubStatsMock          mRepositoryMockGetHubStats

	funcGetLatestNamespacePipelineRelease          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	inspectFuncGetLatestNamespacePipelineRelease   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool)
	afterGetLatestNamespacePipelineReleaseCounter  uint64
	beforeGetLatestNamespacePipelineReleaseCounter uint64
	GetLatestNamespacePipelineReleaseMock          mRepositoryMockGetLatestNamespacePipelineRelease

	funcGetNamespacePipelineByID          func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	inspectFuncGetNamespacePipelineByID   func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool)
	afterGetNamespacePipelineByIDCounter  uint64
	beforeGetNamespacePipelineByIDCounter uint64
	GetNamespacePipelineByIDMock          mRepositoryMockGetNamespacePipelineByID

	funcGetNamespacePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)
	inspectFuncGetNamespacePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool)
	afterGetNamespacePipelineReleaseByIDCounter  uint64
	beforeGetNamespacePipelineReleaseByIDCounter uint64
	GetNamespacePipelineReleaseByIDMock          mRepositoryMockGetNamespacePipelineReleaseByID

	funcGetNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error)
	inspectFuncGetNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string)
	afterGetNamespaceSecretByIDCounter  uint64
	beforeGetNamespaceSecretByIDCounter uint64
	GetNamespaceSecretByIDMock          mRepositoryMockGetNamespaceSecretByID

	funcGetPipelineByIDAdmin          func(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	inspectFuncGetPipelineByIDAdmin   func(ctx context.Context, id string, isBasicView bool, embedReleases bool)
	afterGetPipelineByIDAdminCounter  uint64
	beforeGetPipelineByIDAdminCounter uint64
	GetPipelineByIDAdminMock          mRepositoryMockGetPipelineByIDAdmin

	funcGetPipelineByUID          func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	inspectFuncGetPipelineByUID   func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)
	afterGetPipelineByUIDCounter  uint64
	beforeGetPipelineByUIDCounter uint64
	GetPipelineByUIDMock          mRepositoryMockGetPipelineByUID

	funcGetPipelineByUIDAdmin          func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)
	inspectFuncGetPipelineByUIDAdmin   func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)
	afterGetPipelineByUIDAdminCounter  uint64
	beforeGetPipelineByUIDAdminCounter uint64
	GetPipelineByUIDAdminMock          mRepositoryMockGetPipelineByUIDAdmin

	funcListComponentDefinitionUIDs          func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error)
	inspectFuncListComponentDefinitionUIDs   func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams)
	afterListComponentDefinitionUIDsCounter  uint64
	beforeListComponentDefinitionUIDsCounter uint64
	ListComponentDefinitionUIDsMock          mRepositoryMockListComponentDefinitionUIDs

	funcListNamespacePipelineReleases          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error)
	inspectFuncListNamespacePipelineReleases   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool)
	afterListNamespacePipelineReleasesCounter  uint64
	beforeListNamespacePipelineReleasesCounter uint64
	ListNamespacePipelineReleasesMock          mRepositoryMockListNamespacePipelineReleases

	funcListNamespacePipelines          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	inspectFuncListNamespacePipelines   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)
	afterListNamespacePipelinesCounter  uint64
	beforeListNamespacePipelinesCounter uint64
	ListNamespacePipelinesMock          mRepositoryMockListNamespacePipelines

	funcListNamespaceSecrets          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error)
	inspectFuncListNamespaceSecrets   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter)
	afterListNamespaceSecretsCounter  uint64
	beforeListNamespaceSecretsCounter uint64
	ListNamespaceSecretsMock          mRepositoryMockListNamespaceSecrets

	funcListPipelineTags          func(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error)
	inspectFuncListPipelineTags   func(ctx context.Context, pipelineUID uuid.UUID)
	afterListPipelineTagsCounter  uint64
	beforeListPipelineTagsCounter uint64
	ListPipelineTagsMock          mRepositoryMockListPipelineTags

	funcListPipelines          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	inspectFuncListPipelines   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)
	afterListPipelinesCounter  uint64
	beforeListPipelinesCounter uint64
	ListPipelinesMock          mRepositoryMockListPipelines

	funcListPipelinesAdmin          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)
	inspectFuncListPipelinesAdmin   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool)
	afterListPipelinesAdminCounter  uint64
	beforeListPipelinesAdminCounter uint64
	ListPipelinesAdminMock          mRepositoryMockListPipelinesAdmin

	funcTranspileFilter          func(f1 filtering.Filter) (ep1 *clause.Expr, err error)
	inspectFuncTranspileFilter   func(f1 filtering.Filter)
	afterTranspileFilterCounter  uint64
	beforeTranspileFilterCounter uint64
	TranspileFilterMock          mRepositoryMockTranspileFilter

	funcUpdateNamespacePipelineByUID          func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error)
	inspectFuncUpdateNamespacePipelineByUID   func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline)
	afterUpdateNamespacePipelineByUIDCounter  uint64
	beforeUpdateNamespacePipelineByUIDCounter uint64
	UpdateNamespacePipelineByUIDMock          mRepositoryMockUpdateNamespacePipelineByUID

	funcUpdateNamespacePipelineIDByID          func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)
	inspectFuncUpdateNamespacePipelineIDByID   func(ctx context.Context, ownerPermalink string, id string, newID string)
	afterUpdateNamespacePipelineIDByIDCounter  uint64
	beforeUpdateNamespacePipelineIDByIDCounter uint64
	UpdateNamespacePipelineIDByIDMock          mRepositoryMockUpdateNamespacePipelineIDByID

	funcUpdateNamespacePipelineReleaseByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error)
	inspectFuncUpdateNamespacePipelineReleaseByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease)
	afterUpdateNamespacePipelineReleaseByIDCounter  uint64
	beforeUpdateNamespacePipelineReleaseByIDCounter uint64
	UpdateNamespacePipelineReleaseByIDMock          mRepositoryMockUpdateNamespacePipelineReleaseByID

	funcUpdateNamespacePipelineReleaseIDByID          func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error)
	inspectFuncUpdateNamespacePipelineReleaseIDByID   func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string)
	afterUpdateNamespacePipelineReleaseIDByIDCounter  uint64
	beforeUpdateNamespacePipelineReleaseIDByIDCounter uint64
	UpdateNamespacePipelineReleaseIDByIDMock          mRepositoryMockUpdateNamespacePipelineReleaseIDByID

	funcUpdateNamespaceSecretByID          func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error)
	inspectFuncUpdateNamespaceSecretByID   func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret)
	afterUpdateNamespaceSecretByIDCounter  uint64
	beforeUpdateNamespaceSecretByIDCounter uint64
	UpdateNamespaceSecretByIDMock          mRepositoryMockUpdateNamespaceSecretByID

	funcUpdatePipelineRunStats          func(ctx context.Context, uid uuid.UUID) (err error)
	inspectFuncUpdatePipelineRunStats   func(ctx context.Context, uid uuid.UUID)
	afterUpdatePipelineRunStatsCounter  uint64
	beforeUpdatePipelineRunStatsCounter uint64
	UpdatePipelineRunStatsMock          mRepositoryMockUpdatePipelineRunStats

	funcUpsertComponentDefinition          func(ctx context.Context, cp1 *pb.ComponentDefinition) (err error)
	inspectFuncUpsertComponentDefinition   func(ctx context.Context, cp1 *pb.ComponentDefinition)
	afterUpsertComponentDefinitionCounter  uint64
	beforeUpsertComponentDefinitionCounter uint64
	UpsertComponentDefinitionMock          mRepositoryMockUpsertComponentDefinition
}

// NewRepositoryMock returns a mock for repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddPipelineClonesMock = mRepositoryMockAddPipelineClones{mock: m}
	m.AddPipelineClonesMock.callArgs = []*RepositoryMockAddPipelineClonesParams{}

	m.AddPipelineRunsMock = mRepositoryMockAddPipelineRuns{mock: m}
	m.AddPipelineRunsMock.callArgs = []*RepositoryMockAddPipelineRunsParams{}

	m.CreateNamespacePipelineMock = mRepositoryMockCreateNamespacePipeline{mock: m}
	m.CreateNamespacePipelineMock.callArgs = []*RepositoryMockCreateNamespacePipelineParams{}

	m.CreateNamespacePipelineReleaseMock = mRepositoryMockCreateNamespacePipelineRelease{mock: m}
	m.CreateNamespacePipelineReleaseMock.callArgs = []*RepositoryMockCreateNamespacePipelineReleaseParams{}

	m.CreateNamespaceSecretMock = mRepositoryMockCreateNamespaceSecret{mock: m}
	m.CreateNamespaceSecretMock.callArgs = []*RepositoryMockCreateNamespaceSecretParams{}

	m.CreatePipelineTagsMock = mRepositoryMockCreatePipelineTags{mock: m}
	m.CreatePipelineTagsMock.callArgs = []*RepositoryMockCreatePipelineTagsParams{}

	m.DeleteNamespacePipelineByIDMock = mRepositoryMockDeleteNamespacePipelineByID{mock: m}
	m.DeleteNamespacePipelineByIDMock.callArgs = []*RepositoryMockDeleteNamespacePipelineByIDParams{}

	m.DeleteNamespacePipelineReleaseByIDMock = mRepositoryMockDeleteNamespacePipelineReleaseByID{mock: m}
	m.DeleteNamespacePipelineReleaseByIDMock.callArgs = []*RepositoryMockDeleteNamespacePipelineReleaseByIDParams{}

	m.DeleteNamespaceSecretByIDMock = mRepositoryMockDeleteNamespaceSecretByID{mock: m}
	m.DeleteNamespaceSecretByIDMock.callArgs = []*RepositoryMockDeleteNamespaceSecretByIDParams{}

	m.DeletePipelineTagsMock = mRepositoryMockDeletePipelineTags{mock: m}
	m.DeletePipelineTagsMock.callArgs = []*RepositoryMockDeletePipelineTagsParams{}

	m.GetDefinitionByUIDMock = mRepositoryMockGetDefinitionByUID{mock: m}
	m.GetDefinitionByUIDMock.callArgs = []*RepositoryMockGetDefinitionByUIDParams{}

	m.GetHubStatsMock = mRepositoryMockGetHubStats{mock: m}
	m.GetHubStatsMock.callArgs = []*RepositoryMockGetHubStatsParams{}

	m.GetLatestNamespacePipelineReleaseMock = mRepositoryMockGetLatestNamespacePipelineRelease{mock: m}
	m.GetLatestNamespacePipelineReleaseMock.callArgs = []*RepositoryMockGetLatestNamespacePipelineReleaseParams{}

	m.GetNamespacePipelineByIDMock = mRepositoryMockGetNamespacePipelineByID{mock: m}
	m.GetNamespacePipelineByIDMock.callArgs = []*RepositoryMockGetNamespacePipelineByIDParams{}

	m.GetNamespacePipelineReleaseByIDMock = mRepositoryMockGetNamespacePipelineReleaseByID{mock: m}
	m.GetNamespacePipelineReleaseByIDMock.callArgs = []*RepositoryMockGetNamespacePipelineReleaseByIDParams{}

	m.GetNamespaceSecretByIDMock = mRepositoryMockGetNamespaceSecretByID{mock: m}
	m.GetNamespaceSecretByIDMock.callArgs = []*RepositoryMockGetNamespaceSecretByIDParams{}

	m.GetPipelineByIDAdminMock = mRepositoryMockGetPipelineByIDAdmin{mock: m}
	m.GetPipelineByIDAdminMock.callArgs = []*RepositoryMockGetPipelineByIDAdminParams{}

	m.GetPipelineByUIDMock = mRepositoryMockGetPipelineByUID{mock: m}
	m.GetPipelineByUIDMock.callArgs = []*RepositoryMockGetPipelineByUIDParams{}

	m.GetPipelineByUIDAdminMock = mRepositoryMockGetPipelineByUIDAdmin{mock: m}
	m.GetPipelineByUIDAdminMock.callArgs = []*RepositoryMockGetPipelineByUIDAdminParams{}

	m.ListComponentDefinitionUIDsMock = mRepositoryMockListComponentDefinitionUIDs{mock: m}
	m.ListComponentDefinitionUIDsMock.callArgs = []*RepositoryMockListComponentDefinitionUIDsParams{}

	m.ListNamespacePipelineReleasesMock = mRepositoryMockListNamespacePipelineReleases{mock: m}
	m.ListNamespacePipelineReleasesMock.callArgs = []*RepositoryMockListNamespacePipelineReleasesParams{}

	m.ListNamespacePipelinesMock = mRepositoryMockListNamespacePipelines{mock: m}
	m.ListNamespacePipelinesMock.callArgs = []*RepositoryMockListNamespacePipelinesParams{}

	m.ListNamespaceSecretsMock = mRepositoryMockListNamespaceSecrets{mock: m}
	m.ListNamespaceSecretsMock.callArgs = []*RepositoryMockListNamespaceSecretsParams{}

	m.ListPipelineTagsMock = mRepositoryMockListPipelineTags{mock: m}
	m.ListPipelineTagsMock.callArgs = []*RepositoryMockListPipelineTagsParams{}

	m.ListPipelinesMock = mRepositoryMockListPipelines{mock: m}
	m.ListPipelinesMock.callArgs = []*RepositoryMockListPipelinesParams{}

	m.ListPipelinesAdminMock = mRepositoryMockListPipelinesAdmin{mock: m}
	m.ListPipelinesAdminMock.callArgs = []*RepositoryMockListPipelinesAdminParams{}

	m.TranspileFilterMock = mRepositoryMockTranspileFilter{mock: m}
	m.TranspileFilterMock.callArgs = []*RepositoryMockTranspileFilterParams{}

	m.UpdateNamespacePipelineByUIDMock = mRepositoryMockUpdateNamespacePipelineByUID{mock: m}
	m.UpdateNamespacePipelineByUIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineByUIDParams{}

	m.UpdateNamespacePipelineIDByIDMock = mRepositoryMockUpdateNamespacePipelineIDByID{mock: m}
	m.UpdateNamespacePipelineIDByIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineIDByIDParams{}

	m.UpdateNamespacePipelineReleaseByIDMock = mRepositoryMockUpdateNamespacePipelineReleaseByID{mock: m}
	m.UpdateNamespacePipelineReleaseByIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineReleaseByIDParams{}

	m.UpdateNamespacePipelineReleaseIDByIDMock = mRepositoryMockUpdateNamespacePipelineReleaseIDByID{mock: m}
	m.UpdateNamespacePipelineReleaseIDByIDMock.callArgs = []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{}

	m.UpdateNamespaceSecretByIDMock = mRepositoryMockUpdateNamespaceSecretByID{mock: m}
	m.UpdateNamespaceSecretByIDMock.callArgs = []*RepositoryMockUpdateNamespaceSecretByIDParams{}

	m.UpdatePipelineRunStatsMock = mRepositoryMockUpdatePipelineRunStats{mock: m}
	m.UpdatePipelineRunStatsMock.callArgs = []*RepositoryMockUpdatePipelineRunStatsParams{}

	m.UpsertComponentDefinitionMock = mRepositoryMockUpsertComponentDefinition{mock: m}
	m.UpsertComponentDefinitionMock.callArgs = []*RepositoryMockUpsertComponentDefinitionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddPipelineClones struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddPipelineClonesExpectation
	expectations       []*RepositoryMockAddPipelineClonesExpectation

	callArgs []*RepositoryMockAddPipelineClonesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockAddPipelineClonesExpectation specifies expectation struct of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockAddPipelineClonesParams
	paramPtrs *RepositoryMockAddPipelineClonesParamPtrs
	results   *RepositoryMockAddPipelineClonesResults
	Counter   uint64
}

// RepositoryMockAddPipelineClonesParams contains parameters of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockAddPipelineClonesParamPtrs contains pointers to parameters of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryMockAddPipelineClonesResults contains results of the Repository.AddPipelineClones
type RepositoryMockAddPipelineClonesResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Optional() *mRepositoryMockAddPipelineClones {
	mmAddPipelineClones.optional = true
	return mmAddPipelineClones
}

// Expect sets up expected params for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by ExpectParams functions")
	}

	mmAddPipelineClones.defaultExpectation.params = &RepositoryMockAddPipelineClonesParams{ctx, uid}
	for _, e := range mmAddPipelineClones.expectations {
		if minimock.Equal(e.params, mmAddPipelineClones.defaultExpectation.params) {
			mmAddPipelineClones.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPipelineClones.defaultExpectation.params)
		}
	}

	return mmAddPipelineClones
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.params != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Expect")
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs == nil {
		mmAddPipelineClones.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineClonesParamPtrs{}
	}
	mmAddPipelineClones.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddPipelineClones
}

// ExpectUidParam2 sets up expected param uid for Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{}
	}

	if mmAddPipelineClones.defaultExpectation.params != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Expect")
	}

	if mmAddPipelineClones.defaultExpectation.paramPtrs == nil {
		mmAddPipelineClones.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineClonesParamPtrs{}
	}
	mmAddPipelineClones.defaultExpectation.paramPtrs.uid = &uid

	return mmAddPipelineClones
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockAddPipelineClones {
	if mmAddPipelineClones.mock.inspectFuncAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddPipelineClones")
	}

	mmAddPipelineClones.mock.inspectFuncAddPipelineClones = f

	return mmAddPipelineClones
}

// Return sets up results that will be returned by Repository.AddPipelineClones
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Return(err error) *RepositoryMock {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	if mmAddPipelineClones.defaultExpectation == nil {
		mmAddPipelineClones.defaultExpectation = &RepositoryMockAddPipelineClonesExpectation{mock: mmAddPipelineClones.mock}
	}
	mmAddPipelineClones.defaultExpectation.results = &RepositoryMockAddPipelineClonesResults{err}
	return mmAddPipelineClones.mock
}

// Set uses given function f to mock the Repository.AddPipelineClones method
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmAddPipelineClones.defaultExpectation != nil {
		mmAddPipelineClones.mock.t.Fatalf("Default expectation is already set for the Repository.AddPipelineClones method")
	}

	if len(mmAddPipelineClones.expectations) > 0 {
		mmAddPipelineClones.mock.t.Fatalf("Some expectations are already set for the Repository.AddPipelineClones method")
	}

	mmAddPipelineClones.mock.funcAddPipelineClones = f
	return mmAddPipelineClones.mock
}

// When sets expectation for the Repository.AddPipelineClones which will trigger the result defined by the following
// Then helper
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) When(ctx context.Context, uid uuid.UUID) *RepositoryMockAddPipelineClonesExpectation {
	if mmAddPipelineClones.mock.funcAddPipelineClones != nil {
		mmAddPipelineClones.mock.t.Fatalf("RepositoryMock.AddPipelineClones mock is already set by Set")
	}

	expectation := &RepositoryMockAddPipelineClonesExpectation{
		mock:   mmAddPipelineClones.mock,
		params: &RepositoryMockAddPipelineClonesParams{ctx, uid},
	}
	mmAddPipelineClones.expectations = append(mmAddPipelineClones.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddPipelineClones return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddPipelineClonesExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddPipelineClonesResults{err}
	return e.mock
}

// Times sets number of times Repository.AddPipelineClones should be invoked
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Times(n uint64) *mRepositoryMockAddPipelineClones {
	if n == 0 {
		mmAddPipelineClones.mock.t.Fatalf("Times of RepositoryMock.AddPipelineClones mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPipelineClones.expectedInvocations, n)
	return mmAddPipelineClones
}

func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) invocationsDone() bool {
	if len(mmAddPipelineClones.expectations) == 0 && mmAddPipelineClones.defaultExpectation == nil && mmAddPipelineClones.mock.funcAddPipelineClones == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPipelineClones.mock.afterAddPipelineClonesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPipelineClones.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPipelineClones implements repository.Repository
func (mmAddPipelineClones *RepositoryMock) AddPipelineClones(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmAddPipelineClones.beforeAddPipelineClonesCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPipelineClones.afterAddPipelineClonesCounter, 1)

	if mmAddPipelineClones.inspectFuncAddPipelineClones != nil {
		mmAddPipelineClones.inspectFuncAddPipelineClones(ctx, uid)
	}

	mm_params := RepositoryMockAddPipelineClonesParams{ctx, uid}

	// Record call args
	mmAddPipelineClones.AddPipelineClonesMock.mutex.Lock()
	mmAddPipelineClones.AddPipelineClonesMock.callArgs = append(mmAddPipelineClones.AddPipelineClonesMock.callArgs, &mm_params)
	mmAddPipelineClones.AddPipelineClonesMock.mutex.Unlock()

	for _, e := range mmAddPipelineClones.AddPipelineClonesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.params
		mm_want_ptrs := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddPipelineClonesParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPipelineClones.t.Errorf("RepositoryMock.AddPipelineClones got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPipelineClones.AddPipelineClonesMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPipelineClones.t.Fatal("No results are set for the RepositoryMock.AddPipelineClones")
		}
		return (*mm_results).err
	}
	if mmAddPipelineClones.funcAddPipelineClones != nil {
		return mmAddPipelineClones.funcAddPipelineClones(ctx, uid)
	}
	mmAddPipelineClones.t.Fatalf("Unexpected call to RepositoryMock.AddPipelineClones. %v %v", ctx, uid)
	return
}

// AddPipelineClonesAfterCounter returns a count of finished RepositoryMock.AddPipelineClones invocations
func (mmAddPipelineClones *RepositoryMock) AddPipelineClonesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineClones.afterAddPipelineClonesCounter)
}

// AddPipelineClonesBeforeCounter returns a count of RepositoryMock.AddPipelineClones invocations
func (mmAddPipelineClones *RepositoryMock) AddPipelineClonesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineClones.beforeAddPipelineClonesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddPipelineClones.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPipelineClones *mRepositoryMockAddPipelineClones) Calls() []*RepositoryMockAddPipelineClonesParams {
	mmAddPipelineClones.mutex.RLock()

	argCopy := make([]*RepositoryMockAddPipelineClonesParams, len(mmAddPipelineClones.callArgs))
	copy(argCopy, mmAddPipelineClones.callArgs)

	mmAddPipelineClones.mutex.RUnlock()

	return argCopy
}

// MinimockAddPipelineClonesDone returns true if the count of the AddPipelineClones invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddPipelineClonesDone() bool {
	if m.AddPipelineClonesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPipelineClonesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPipelineClonesMock.invocationsDone()
}

// MinimockAddPipelineClonesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddPipelineClonesInspect() {
	for _, e := range m.AddPipelineClonesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones with params: %#v", *e.params)
		}
	}

	afterAddPipelineClonesCounter := mm_atomic.LoadUint64(&m.afterAddPipelineClonesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPipelineClonesMock.defaultExpectation != nil && afterAddPipelineClonesCounter < 1 {
		if m.AddPipelineClonesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddPipelineClones")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineClones with params: %#v", *m.AddPipelineClonesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPipelineClones != nil && afterAddPipelineClonesCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.AddPipelineClones")
	}

	if !m.AddPipelineClonesMock.invocationsDone() && afterAddPipelineClonesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddPipelineClones but found %d calls",
			mm_atomic.LoadUint64(&m.AddPipelineClonesMock.expectedInvocations), afterAddPipelineClonesCounter)
	}
}

type mRepositoryMockAddPipelineRuns struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddPipelineRunsExpectation
	expectations       []*RepositoryMockAddPipelineRunsExpectation

	callArgs []*RepositoryMockAddPipelineRunsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockAddPipelineRunsExpectation specifies expectation struct of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockAddPipelineRunsParams
	paramPtrs *RepositoryMockAddPipelineRunsParamPtrs
	results   *RepositoryMockAddPipelineRunsResults
	Counter   uint64
}

// RepositoryMockAddPipelineRunsParams contains parameters of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockAddPipelineRunsParamPtrs contains pointers to parameters of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsParamPtrs struct {
	ctx *context.Context
	uid *uuid.UUID
}

// RepositoryMockAddPipelineRunsResults contains results of the Repository.AddPipelineRuns
type RepositoryMockAddPipelineRunsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Optional() *mRepositoryMockAddPipelineRuns {
	mmAddPipelineRuns.optional = true
	return mmAddPipelineRuns
}

// Expect sets up expected params for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by ExpectParams functions")
	}

	mmAddPipelineRuns.defaultExpectation.params = &RepositoryMockAddPipelineRunsParams{ctx, uid}
	for _, e := range mmAddPipelineRuns.expectations {
		if minimock.Equal(e.params, mmAddPipelineRuns.defaultExpectation.params) {
			mmAddPipelineRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPipelineRuns.defaultExpectation.params)
		}
	}

	return mmAddPipelineRuns
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.params != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Expect")
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs == nil {
		mmAddPipelineRuns.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineRunsParamPtrs{}
	}
	mmAddPipelineRuns.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddPipelineRuns
}

// ExpectUidParam2 sets up expected param uid for Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{}
	}

	if mmAddPipelineRuns.defaultExpectation.params != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Expect")
	}

	if mmAddPipelineRuns.defaultExpectation.paramPtrs == nil {
		mmAddPipelineRuns.defaultExpectation.paramPtrs = &RepositoryMockAddPipelineRunsParamPtrs{}
	}
	mmAddPipelineRuns.defaultExpectation.paramPtrs.uid = &uid

	return mmAddPipelineRuns
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockAddPipelineRuns {
	if mmAddPipelineRuns.mock.inspectFuncAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddPipelineRuns")
	}

	mmAddPipelineRuns.mock.inspectFuncAddPipelineRuns = f

	return mmAddPipelineRuns
}

// Return sets up results that will be returned by Repository.AddPipelineRuns
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Return(err error) *RepositoryMock {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	if mmAddPipelineRuns.defaultExpectation == nil {
		mmAddPipelineRuns.defaultExpectation = &RepositoryMockAddPipelineRunsExpectation{mock: mmAddPipelineRuns.mock}
	}
	mmAddPipelineRuns.defaultExpectation.results = &RepositoryMockAddPipelineRunsResults{err}
	return mmAddPipelineRuns.mock
}

// Set uses given function f to mock the Repository.AddPipelineRuns method
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmAddPipelineRuns.defaultExpectation != nil {
		mmAddPipelineRuns.mock.t.Fatalf("Default expectation is already set for the Repository.AddPipelineRuns method")
	}

	if len(mmAddPipelineRuns.expectations) > 0 {
		mmAddPipelineRuns.mock.t.Fatalf("Some expectations are already set for the Repository.AddPipelineRuns method")
	}

	mmAddPipelineRuns.mock.funcAddPipelineRuns = f
	return mmAddPipelineRuns.mock
}

// When sets expectation for the Repository.AddPipelineRuns which will trigger the result defined by the following
// Then helper
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) When(ctx context.Context, uid uuid.UUID) *RepositoryMockAddPipelineRunsExpectation {
	if mmAddPipelineRuns.mock.funcAddPipelineRuns != nil {
		mmAddPipelineRuns.mock.t.Fatalf("RepositoryMock.AddPipelineRuns mock is already set by Set")
	}

	expectation := &RepositoryMockAddPipelineRunsExpectation{
		mock:   mmAddPipelineRuns.mock,
		params: &RepositoryMockAddPipelineRunsParams{ctx, uid},
	}
	mmAddPipelineRuns.expectations = append(mmAddPipelineRuns.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddPipelineRuns return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddPipelineRunsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddPipelineRunsResults{err}
	return e.mock
}

// Times sets number of times Repository.AddPipelineRuns should be invoked
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Times(n uint64) *mRepositoryMockAddPipelineRuns {
	if n == 0 {
		mmAddPipelineRuns.mock.t.Fatalf("Times of RepositoryMock.AddPipelineRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPipelineRuns.expectedInvocations, n)
	return mmAddPipelineRuns
}

func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) invocationsDone() bool {
	if len(mmAddPipelineRuns.expectations) == 0 && mmAddPipelineRuns.defaultExpectation == nil && mmAddPipelineRuns.mock.funcAddPipelineRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPipelineRuns.mock.afterAddPipelineRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPipelineRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPipelineRuns implements repository.Repository
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRuns(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmAddPipelineRuns.beforeAddPipelineRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPipelineRuns.afterAddPipelineRunsCounter, 1)

	if mmAddPipelineRuns.inspectFuncAddPipelineRuns != nil {
		mmAddPipelineRuns.inspectFuncAddPipelineRuns(ctx, uid)
	}

	mm_params := RepositoryMockAddPipelineRunsParams{ctx, uid}

	// Record call args
	mmAddPipelineRuns.AddPipelineRunsMock.mutex.Lock()
	mmAddPipelineRuns.AddPipelineRunsMock.callArgs = append(mmAddPipelineRuns.AddPipelineRunsMock.callArgs, &mm_params)
	mmAddPipelineRuns.AddPipelineRunsMock.mutex.Unlock()

	for _, e := range mmAddPipelineRuns.AddPipelineRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.params
		mm_want_ptrs := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddPipelineRunsParams{ctx, uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPipelineRuns.t.Errorf("RepositoryMock.AddPipelineRuns got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPipelineRuns.AddPipelineRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPipelineRuns.t.Fatal("No results are set for the RepositoryMock.AddPipelineRuns")
		}
		return (*mm_results).err
	}
	if mmAddPipelineRuns.funcAddPipelineRuns != nil {
		return mmAddPipelineRuns.funcAddPipelineRuns(ctx, uid)
	}
	mmAddPipelineRuns.t.Fatalf("Unexpected call to RepositoryMock.AddPipelineRuns. %v %v", ctx, uid)
	return
}

// AddPipelineRunsAfterCounter returns a count of finished RepositoryMock.AddPipelineRuns invocations
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineRuns.afterAddPipelineRunsCounter)
}

// AddPipelineRunsBeforeCounter returns a count of RepositoryMock.AddPipelineRuns invocations
func (mmAddPipelineRuns *RepositoryMock) AddPipelineRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPipelineRuns.beforeAddPipelineRunsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddPipelineRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPipelineRuns *mRepositoryMockAddPipelineRuns) Calls() []*RepositoryMockAddPipelineRunsParams {
	mmAddPipelineRuns.mutex.RLock()

	argCopy := make([]*RepositoryMockAddPipelineRunsParams, len(mmAddPipelineRuns.callArgs))
	copy(argCopy, mmAddPipelineRuns.callArgs)

	mmAddPipelineRuns.mutex.RUnlock()

	return argCopy
}

// MinimockAddPipelineRunsDone returns true if the count of the AddPipelineRuns invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddPipelineRunsDone() bool {
	if m.AddPipelineRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPipelineRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPipelineRunsMock.invocationsDone()
}

// MinimockAddPipelineRunsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddPipelineRunsInspect() {
	for _, e := range m.AddPipelineRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns with params: %#v", *e.params)
		}
	}

	afterAddPipelineRunsCounter := mm_atomic.LoadUint64(&m.afterAddPipelineRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPipelineRunsMock.defaultExpectation != nil && afterAddPipelineRunsCounter < 1 {
		if m.AddPipelineRunsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddPipelineRuns")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddPipelineRuns with params: %#v", *m.AddPipelineRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPipelineRuns != nil && afterAddPipelineRunsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.AddPipelineRuns")
	}

	if !m.AddPipelineRunsMock.invocationsDone() && afterAddPipelineRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddPipelineRuns but found %d calls",
			mm_atomic.LoadUint64(&m.AddPipelineRunsMock.expectedInvocations), afterAddPipelineRunsCounter)
	}
}

type mRepositoryMockCreateNamespacePipeline struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespacePipelineExpectation
	expectations       []*RepositoryMockCreateNamespacePipelineExpectation

	callArgs []*RepositoryMockCreateNamespacePipelineParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateNamespacePipelineExpectation specifies expectation struct of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateNamespacePipelineParams
	paramPtrs *RepositoryMockCreateNamespacePipelineParamPtrs
	results   *RepositoryMockCreateNamespacePipelineResults
	Counter   uint64
}

// RepositoryMockCreateNamespacePipelineParams contains parameters of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineParams struct {
	ctx      context.Context
	pipeline *datamodel.Pipeline
}

// RepositoryMockCreateNamespacePipelineParamPtrs contains pointers to parameters of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineParamPtrs struct {
	ctx      *context.Context
	pipeline **datamodel.Pipeline
}

// RepositoryMockCreateNamespacePipelineResults contains results of the Repository.CreateNamespacePipeline
type RepositoryMockCreateNamespacePipelineResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Optional() *mRepositoryMockCreateNamespacePipeline {
	mmCreateNamespacePipeline.optional = true
	return mmCreateNamespacePipeline
}

// Expect sets up expected params for Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Expect(ctx context.Context, pipeline *datamodel.Pipeline) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{}
	}

	if mmCreateNamespacePipeline.defaultExpectation.paramPtrs != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by ExpectParams functions")
	}

	mmCreateNamespacePipeline.defaultExpectation.params = &RepositoryMockCreateNamespacePipelineParams{ctx, pipeline}
	for _, e := range mmCreateNamespacePipeline.expectations {
		if minimock.Equal(e.params, mmCreateNamespacePipeline.defaultExpectation.params) {
			mmCreateNamespacePipeline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespacePipeline.defaultExpectation.params)
		}
	}

	return mmCreateNamespacePipeline
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{}
	}

	if mmCreateNamespacePipeline.defaultExpectation.params != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Expect")
	}

	if mmCreateNamespacePipeline.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipeline.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineParamPtrs{}
	}
	mmCreateNamespacePipeline.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateNamespacePipeline
}

// ExpectPipelineParam2 sets up expected param pipeline for Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) ExpectPipelineParam2(pipeline *datamodel.Pipeline) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{}
	}

	if mmCreateNamespacePipeline.defaultExpectation.params != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Expect")
	}

	if mmCreateNamespacePipeline.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipeline.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineParamPtrs{}
	}
	mmCreateNamespacePipeline.defaultExpectation.paramPtrs.pipeline = &pipeline

	return mmCreateNamespacePipeline
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Inspect(f func(ctx context.Context, pipeline *datamodel.Pipeline)) *mRepositoryMockCreateNamespacePipeline {
	if mmCreateNamespacePipeline.mock.inspectFuncCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespacePipeline")
	}

	mmCreateNamespacePipeline.mock.inspectFuncCreateNamespacePipeline = f

	return mmCreateNamespacePipeline
}

// Return sets up results that will be returned by Repository.CreateNamespacePipeline
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Return(err error) *RepositoryMock {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	if mmCreateNamespacePipeline.defaultExpectation == nil {
		mmCreateNamespacePipeline.defaultExpectation = &RepositoryMockCreateNamespacePipelineExpectation{mock: mmCreateNamespacePipeline.mock}
	}
	mmCreateNamespacePipeline.defaultExpectation.results = &RepositoryMockCreateNamespacePipelineResults{err}
	return mmCreateNamespacePipeline.mock
}

// Set uses given function f to mock the Repository.CreateNamespacePipeline method
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Set(f func(ctx context.Context, pipeline *datamodel.Pipeline) (err error)) *RepositoryMock {
	if mmCreateNamespacePipeline.defaultExpectation != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespacePipeline method")
	}

	if len(mmCreateNamespacePipeline.expectations) > 0 {
		mmCreateNamespacePipeline.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespacePipeline method")
	}

	mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline = f
	return mmCreateNamespacePipeline.mock
}

// When sets expectation for the Repository.CreateNamespacePipeline which will trigger the result defined by the following
// Then helper
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) When(ctx context.Context, pipeline *datamodel.Pipeline) *RepositoryMockCreateNamespacePipelineExpectation {
	if mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.mock.t.Fatalf("RepositoryMock.CreateNamespacePipeline mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespacePipelineExpectation{
		mock:   mmCreateNamespacePipeline.mock,
		params: &RepositoryMockCreateNamespacePipelineParams{ctx, pipeline},
	}
	mmCreateNamespacePipeline.expectations = append(mmCreateNamespacePipeline.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespacePipeline return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespacePipelineExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespacePipelineResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespacePipeline should be invoked
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Times(n uint64) *mRepositoryMockCreateNamespacePipeline {
	if n == 0 {
		mmCreateNamespacePipeline.mock.t.Fatalf("Times of RepositoryMock.CreateNamespacePipeline mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespacePipeline.expectedInvocations, n)
	return mmCreateNamespacePipeline
}

func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) invocationsDone() bool {
	if len(mmCreateNamespacePipeline.expectations) == 0 && mmCreateNamespacePipeline.defaultExpectation == nil && mmCreateNamespacePipeline.mock.funcCreateNamespacePipeline == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipeline.mock.afterCreateNamespacePipelineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipeline.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespacePipeline implements repository.Repository
func (mmCreateNamespacePipeline *RepositoryMock) CreateNamespacePipeline(ctx context.Context, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespacePipeline.beforeCreateNamespacePipelineCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespacePipeline.afterCreateNamespacePipelineCounter, 1)

	if mmCreateNamespacePipeline.inspectFuncCreateNamespacePipeline != nil {
		mmCreateNamespacePipeline.inspectFuncCreateNamespacePipeline(ctx, pipeline)
	}

	mm_params := RepositoryMockCreateNamespacePipelineParams{ctx, pipeline}

	// Record call args
	mmCreateNamespacePipeline.CreateNamespacePipelineMock.mutex.Lock()
	mmCreateNamespacePipeline.CreateNamespacePipelineMock.callArgs = append(mmCreateNamespacePipeline.CreateNamespacePipelineMock.callArgs, &mm_params)
	mmCreateNamespacePipeline.CreateNamespacePipelineMock.mutex.Unlock()

	for _, e := range mmCreateNamespacePipeline.CreateNamespacePipelineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespacePipelineParams{ctx, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespacePipeline.t.Errorf("RepositoryMock.CreateNamespacePipeline got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmCreateNamespacePipeline.t.Errorf("RepositoryMock.CreateNamespacePipeline got unexpected parameter pipeline, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespacePipeline.t.Errorf("RepositoryMock.CreateNamespacePipeline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespacePipeline.CreateNamespacePipelineMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespacePipeline.t.Fatal("No results are set for the RepositoryMock.CreateNamespacePipeline")
		}
		return (*mm_results).err
	}
	if mmCreateNamespacePipeline.funcCreateNamespacePipeline != nil {
		return mmCreateNamespacePipeline.funcCreateNamespacePipeline(ctx, pipeline)
	}
	mmCreateNamespacePipeline.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespacePipeline. %v %v", ctx, pipeline)
	return
}

// CreateNamespacePipelineAfterCounter returns a count of finished RepositoryMock.CreateNamespacePipeline invocations
func (mmCreateNamespacePipeline *RepositoryMock) CreateNamespacePipelineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipeline.afterCreateNamespacePipelineCounter)
}

// CreateNamespacePipelineBeforeCounter returns a count of RepositoryMock.CreateNamespacePipeline invocations
func (mmCreateNamespacePipeline *RepositoryMock) CreateNamespacePipelineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipeline.beforeCreateNamespacePipelineCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespacePipeline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespacePipeline *mRepositoryMockCreateNamespacePipeline) Calls() []*RepositoryMockCreateNamespacePipelineParams {
	mmCreateNamespacePipeline.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespacePipelineParams, len(mmCreateNamespacePipeline.callArgs))
	copy(argCopy, mmCreateNamespacePipeline.callArgs)

	mmCreateNamespacePipeline.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespacePipelineDone returns true if the count of the CreateNamespacePipeline invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespacePipelineDone() bool {
	if m.CreateNamespacePipelineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespacePipelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespacePipelineMock.invocationsDone()
}

// MinimockCreateNamespacePipelineInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespacePipelineInspect() {
	for _, e := range m.CreateNamespacePipelineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipeline with params: %#v", *e.params)
		}
	}

	afterCreateNamespacePipelineCounter := mm_atomic.LoadUint64(&m.afterCreateNamespacePipelineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespacePipelineMock.defaultExpectation != nil && afterCreateNamespacePipelineCounter < 1 {
		if m.CreateNamespacePipelineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateNamespacePipeline")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipeline with params: %#v", *m.CreateNamespacePipelineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespacePipeline != nil && afterCreateNamespacePipelineCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateNamespacePipeline")
	}

	if !m.CreateNamespacePipelineMock.invocationsDone() && afterCreateNamespacePipelineCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespacePipeline but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespacePipelineMock.expectedInvocations), afterCreateNamespacePipelineCounter)
	}
}

type mRepositoryMockCreateNamespacePipelineRelease struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespacePipelineReleaseExpectation
	expectations       []*RepositoryMockCreateNamespacePipelineReleaseExpectation

	callArgs []*RepositoryMockCreateNamespacePipelineReleaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateNamespacePipelineReleaseExpectation specifies expectation struct of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateNamespacePipelineReleaseParams
	paramPtrs *RepositoryMockCreateNamespacePipelineReleaseParamPtrs
	results   *RepositoryMockCreateNamespacePipelineReleaseResults
	Counter   uint64
}

// RepositoryMockCreateNamespacePipelineReleaseParams contains parameters of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseParams struct {
	ctx             context.Context
	ownerPermalink  string
	pipelineUID     uuid.UUID
	pipelineRelease *datamodel.PipelineRelease
}

// RepositoryMockCreateNamespacePipelineReleaseParamPtrs contains pointers to parameters of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseParamPtrs struct {
	ctx             *context.Context
	ownerPermalink  *string
	pipelineUID     *uuid.UUID
	pipelineRelease **datamodel.PipelineRelease
}

// RepositoryMockCreateNamespacePipelineReleaseResults contains results of the Repository.CreateNamespacePipelineRelease
type RepositoryMockCreateNamespacePipelineReleaseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Optional() *mRepositoryMockCreateNamespacePipelineRelease {
	mmCreateNamespacePipelineRelease.optional = true
	return mmCreateNamespacePipelineRelease
}

// Expect sets up expected params for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by ExpectParams functions")
	}

	mmCreateNamespacePipelineRelease.defaultExpectation.params = &RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}
	for _, e := range mmCreateNamespacePipelineRelease.expectations {
		if minimock.Equal(e.params, mmCreateNamespacePipelineRelease.defaultExpectation.params) {
			mmCreateNamespacePipelineRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespacePipelineRelease.defaultExpectation.params)
		}
	}

	return mmCreateNamespacePipelineRelease
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateNamespacePipelineRelease
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmCreateNamespacePipelineRelease
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmCreateNamespacePipelineRelease
}

// ExpectPipelineReleaseParam4 sets up expected param pipelineRelease for Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) ExpectPipelineReleaseParam4(pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{}
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.params != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Expect")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespacePipelineReleaseParamPtrs{}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.paramPtrs.pipelineRelease = &pipelineRelease

	return mmCreateNamespacePipelineRelease
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease)) *mRepositoryMockCreateNamespacePipelineRelease {
	if mmCreateNamespacePipelineRelease.mock.inspectFuncCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespacePipelineRelease")
	}

	mmCreateNamespacePipelineRelease.mock.inspectFuncCreateNamespacePipelineRelease = f

	return mmCreateNamespacePipelineRelease
}

// Return sets up results that will be returned by Repository.CreateNamespacePipelineRelease
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Return(err error) *RepositoryMock {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	if mmCreateNamespacePipelineRelease.defaultExpectation == nil {
		mmCreateNamespacePipelineRelease.defaultExpectation = &RepositoryMockCreateNamespacePipelineReleaseExpectation{mock: mmCreateNamespacePipelineRelease.mock}
	}
	mmCreateNamespacePipelineRelease.defaultExpectation.results = &RepositoryMockCreateNamespacePipelineReleaseResults{err}
	return mmCreateNamespacePipelineRelease.mock
}

// Set uses given function f to mock the Repository.CreateNamespacePipelineRelease method
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error)) *RepositoryMock {
	if mmCreateNamespacePipelineRelease.defaultExpectation != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespacePipelineRelease method")
	}

	if len(mmCreateNamespacePipelineRelease.expectations) > 0 {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespacePipelineRelease method")
	}

	mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease = f
	return mmCreateNamespacePipelineRelease.mock
}

// When sets expectation for the Repository.CreateNamespacePipelineRelease which will trigger the result defined by the following
// Then helper
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) *RepositoryMockCreateNamespacePipelineReleaseExpectation {
	if mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.CreateNamespacePipelineRelease mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespacePipelineReleaseExpectation{
		mock:   mmCreateNamespacePipelineRelease.mock,
		params: &RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease},
	}
	mmCreateNamespacePipelineRelease.expectations = append(mmCreateNamespacePipelineRelease.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespacePipelineRelease return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespacePipelineReleaseExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespacePipelineReleaseResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespacePipelineRelease should be invoked
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Times(n uint64) *mRepositoryMockCreateNamespacePipelineRelease {
	if n == 0 {
		mmCreateNamespacePipelineRelease.mock.t.Fatalf("Times of RepositoryMock.CreateNamespacePipelineRelease mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespacePipelineRelease.expectedInvocations, n)
	return mmCreateNamespacePipelineRelease
}

func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) invocationsDone() bool {
	if len(mmCreateNamespacePipelineRelease.expectations) == 0 && mmCreateNamespacePipelineRelease.defaultExpectation == nil && mmCreateNamespacePipelineRelease.mock.funcCreateNamespacePipelineRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.mock.afterCreateNamespacePipelineReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespacePipelineRelease implements repository.Repository
func (mmCreateNamespacePipelineRelease *RepositoryMock) CreateNamespacePipelineRelease(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pipelineRelease *datamodel.PipelineRelease) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespacePipelineRelease.beforeCreateNamespacePipelineReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespacePipelineRelease.afterCreateNamespacePipelineReleaseCounter, 1)

	if mmCreateNamespacePipelineRelease.inspectFuncCreateNamespacePipelineRelease != nil {
		mmCreateNamespacePipelineRelease.inspectFuncCreateNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, pipelineRelease)
	}

	mm_params := RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}

	// Record call args
	mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.mutex.Lock()
	mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.callArgs = append(mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.callArgs, &mm_params)
	mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.mutex.Unlock()

	for _, e := range mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, pipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease) {
				mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameter pipelineRelease, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease, minimock.Diff(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespacePipelineRelease.t.Errorf("RepositoryMock.CreateNamespacePipelineRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespacePipelineRelease.CreateNamespacePipelineReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespacePipelineRelease.t.Fatal("No results are set for the RepositoryMock.CreateNamespacePipelineRelease")
		}
		return (*mm_results).err
	}
	if mmCreateNamespacePipelineRelease.funcCreateNamespacePipelineRelease != nil {
		return mmCreateNamespacePipelineRelease.funcCreateNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, pipelineRelease)
	}
	mmCreateNamespacePipelineRelease.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespacePipelineRelease. %v %v %v %v", ctx, ownerPermalink, pipelineUID, pipelineRelease)
	return
}

// CreateNamespacePipelineReleaseAfterCounter returns a count of finished RepositoryMock.CreateNamespacePipelineRelease invocations
func (mmCreateNamespacePipelineRelease *RepositoryMock) CreateNamespacePipelineReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.afterCreateNamespacePipelineReleaseCounter)
}

// CreateNamespacePipelineReleaseBeforeCounter returns a count of RepositoryMock.CreateNamespacePipelineRelease invocations
func (mmCreateNamespacePipelineRelease *RepositoryMock) CreateNamespacePipelineReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespacePipelineRelease.beforeCreateNamespacePipelineReleaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespacePipelineRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespacePipelineRelease *mRepositoryMockCreateNamespacePipelineRelease) Calls() []*RepositoryMockCreateNamespacePipelineReleaseParams {
	mmCreateNamespacePipelineRelease.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespacePipelineReleaseParams, len(mmCreateNamespacePipelineRelease.callArgs))
	copy(argCopy, mmCreateNamespacePipelineRelease.callArgs)

	mmCreateNamespacePipelineRelease.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespacePipelineReleaseDone returns true if the count of the CreateNamespacePipelineRelease invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespacePipelineReleaseDone() bool {
	if m.CreateNamespacePipelineReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespacePipelineReleaseMock.invocationsDone()
}

// MinimockCreateNamespacePipelineReleaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespacePipelineReleaseInspect() {
	for _, e := range m.CreateNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipelineRelease with params: %#v", *e.params)
		}
	}

	afterCreateNamespacePipelineReleaseCounter := mm_atomic.LoadUint64(&m.afterCreateNamespacePipelineReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespacePipelineReleaseMock.defaultExpectation != nil && afterCreateNamespacePipelineReleaseCounter < 1 {
		if m.CreateNamespacePipelineReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateNamespacePipelineRelease")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespacePipelineRelease with params: %#v", *m.CreateNamespacePipelineReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespacePipelineRelease != nil && afterCreateNamespacePipelineReleaseCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateNamespacePipelineRelease")
	}

	if !m.CreateNamespacePipelineReleaseMock.invocationsDone() && afterCreateNamespacePipelineReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespacePipelineRelease but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespacePipelineReleaseMock.expectedInvocations), afterCreateNamespacePipelineReleaseCounter)
	}
}

type mRepositoryMockCreateNamespaceSecret struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespaceSecretExpectation
	expectations       []*RepositoryMockCreateNamespaceSecretExpectation

	callArgs []*RepositoryMockCreateNamespaceSecretParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateNamespaceSecretExpectation specifies expectation struct of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateNamespaceSecretParams
	paramPtrs *RepositoryMockCreateNamespaceSecretParamPtrs
	results   *RepositoryMockCreateNamespaceSecretResults
	Counter   uint64
}

// RepositoryMockCreateNamespaceSecretParams contains parameters of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretParams struct {
	ctx            context.Context
	ownerPermalink string
	secret         *datamodel.Secret
}

// RepositoryMockCreateNamespaceSecretParamPtrs contains pointers to parameters of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	secret         **datamodel.Secret
}

// RepositoryMockCreateNamespaceSecretResults contains results of the Repository.CreateNamespaceSecret
type RepositoryMockCreateNamespaceSecretResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Optional() *mRepositoryMockCreateNamespaceSecret {
	mmCreateNamespaceSecret.optional = true
	return mmCreateNamespaceSecret
}

// Expect sets up expected params for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Expect(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceSecret.defaultExpectation.params = &RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}
	for _, e := range mmCreateNamespaceSecret.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceSecret.defaultExpectation.params) {
			mmCreateNamespaceSecret.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceSecret.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceSecret
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateNamespaceSecret
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmCreateNamespaceSecret
}

// ExpectSecretParam3 sets up expected param secret for Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) ExpectSecretParam3(secret *datamodel.Secret) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{}
	}

	if mmCreateNamespaceSecret.defaultExpectation.params != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Expect")
	}

	if mmCreateNamespaceSecret.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceSecret.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceSecretParamPtrs{}
	}
	mmCreateNamespaceSecret.defaultExpectation.paramPtrs.secret = &secret

	return mmCreateNamespaceSecret
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Inspect(f func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret)) *mRepositoryMockCreateNamespaceSecret {
	if mmCreateNamespaceSecret.mock.inspectFuncCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespaceSecret")
	}

	mmCreateNamespaceSecret.mock.inspectFuncCreateNamespaceSecret = f

	return mmCreateNamespaceSecret
}

// Return sets up results that will be returned by Repository.CreateNamespaceSecret
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Return(err error) *RepositoryMock {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	if mmCreateNamespaceSecret.defaultExpectation == nil {
		mmCreateNamespaceSecret.defaultExpectation = &RepositoryMockCreateNamespaceSecretExpectation{mock: mmCreateNamespaceSecret.mock}
	}
	mmCreateNamespaceSecret.defaultExpectation.results = &RepositoryMockCreateNamespaceSecretResults{err}
	return mmCreateNamespaceSecret.mock
}

// Set uses given function f to mock the Repository.CreateNamespaceSecret method
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Set(f func(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error)) *RepositoryMock {
	if mmCreateNamespaceSecret.defaultExpectation != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespaceSecret method")
	}

	if len(mmCreateNamespaceSecret.expectations) > 0 {
		mmCreateNamespaceSecret.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespaceSecret method")
	}

	mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret = f
	return mmCreateNamespaceSecret.mock
}

// When sets expectation for the Repository.CreateNamespaceSecret which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) When(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) *RepositoryMockCreateNamespaceSecretExpectation {
	if mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.mock.t.Fatalf("RepositoryMock.CreateNamespaceSecret mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespaceSecretExpectation{
		mock:   mmCreateNamespaceSecret.mock,
		params: &RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret},
	}
	mmCreateNamespaceSecret.expectations = append(mmCreateNamespaceSecret.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespaceSecret return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespaceSecretExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespaceSecretResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespaceSecret should be invoked
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Times(n uint64) *mRepositoryMockCreateNamespaceSecret {
	if n == 0 {
		mmCreateNamespaceSecret.mock.t.Fatalf("Times of RepositoryMock.CreateNamespaceSecret mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceSecret.expectedInvocations, n)
	return mmCreateNamespaceSecret
}

func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) invocationsDone() bool {
	if len(mmCreateNamespaceSecret.expectations) == 0 && mmCreateNamespaceSecret.defaultExpectation == nil && mmCreateNamespaceSecret.mock.funcCreateNamespaceSecret == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceSecret.mock.afterCreateNamespaceSecretCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceSecret.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceSecret implements repository.Repository
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecret(ctx context.Context, ownerPermalink string, secret *datamodel.Secret) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceSecret.beforeCreateNamespaceSecretCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceSecret.afterCreateNamespaceSecretCounter, 1)

	if mmCreateNamespaceSecret.inspectFuncCreateNamespaceSecret != nil {
		mmCreateNamespaceSecret.inspectFuncCreateNamespaceSecret(ctx, ownerPermalink, secret)
	}

	mm_params := RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}

	// Record call args
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.mutex.Lock()
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.callArgs = append(mmCreateNamespaceSecret.CreateNamespaceSecretMock.callArgs, &mm_params)
	mmCreateNamespaceSecret.CreateNamespaceSecretMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceSecret.CreateNamespaceSecretMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespaceSecretParams{ctx, ownerPermalink, secret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.secret != nil && !minimock.Equal(*mm_want_ptrs.secret, mm_got.secret) {
				mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameter secret, want: %#v, got: %#v%s\n", *mm_want_ptrs.secret, mm_got.secret, minimock.Diff(*mm_want_ptrs.secret, mm_got.secret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceSecret.t.Errorf("RepositoryMock.CreateNamespaceSecret got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceSecret.CreateNamespaceSecretMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceSecret.t.Fatal("No results are set for the RepositoryMock.CreateNamespaceSecret")
		}
		return (*mm_results).err
	}
	if mmCreateNamespaceSecret.funcCreateNamespaceSecret != nil {
		return mmCreateNamespaceSecret.funcCreateNamespaceSecret(ctx, ownerPermalink, secret)
	}
	mmCreateNamespaceSecret.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespaceSecret. %v %v %v", ctx, ownerPermalink, secret)
	return
}

// CreateNamespaceSecretAfterCounter returns a count of finished RepositoryMock.CreateNamespaceSecret invocations
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecretAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceSecret.afterCreateNamespaceSecretCounter)
}

// CreateNamespaceSecretBeforeCounter returns a count of RepositoryMock.CreateNamespaceSecret invocations
func (mmCreateNamespaceSecret *RepositoryMock) CreateNamespaceSecretBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceSecret.beforeCreateNamespaceSecretCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespaceSecret.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceSecret *mRepositoryMockCreateNamespaceSecret) Calls() []*RepositoryMockCreateNamespaceSecretParams {
	mmCreateNamespaceSecret.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespaceSecretParams, len(mmCreateNamespaceSecret.callArgs))
	copy(argCopy, mmCreateNamespaceSecret.callArgs)

	mmCreateNamespaceSecret.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceSecretDone returns true if the count of the CreateNamespaceSecret invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespaceSecretDone() bool {
	if m.CreateNamespaceSecretMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceSecretMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceSecretMock.invocationsDone()
}

// MinimockCreateNamespaceSecretInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespaceSecretInspect() {
	for _, e := range m.CreateNamespaceSecretMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret with params: %#v", *e.params)
		}
	}

	afterCreateNamespaceSecretCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceSecretCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceSecretMock.defaultExpectation != nil && afterCreateNamespaceSecretCounter < 1 {
		if m.CreateNamespaceSecretMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateNamespaceSecret")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceSecret with params: %#v", *m.CreateNamespaceSecretMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceSecret != nil && afterCreateNamespaceSecretCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateNamespaceSecret")
	}

	if !m.CreateNamespaceSecretMock.invocationsDone() && afterCreateNamespaceSecretCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespaceSecret but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceSecretMock.expectedInvocations), afterCreateNamespaceSecretCounter)
	}
}

type mRepositoryMockCreatePipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreatePipelineTagsExpectation
	expectations       []*RepositoryMockCreatePipelineTagsExpectation

	callArgs []*RepositoryMockCreatePipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreatePipelineTagsExpectation specifies expectation struct of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreatePipelineTagsParams
	paramPtrs *RepositoryMockCreatePipelineTagsParamPtrs
	results   *RepositoryMockCreatePipelineTagsResults
	Counter   uint64
}

// RepositoryMockCreatePipelineTagsParams contains parameters of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	tagNames    []string
}

// RepositoryMockCreatePipelineTagsParamPtrs contains pointers to parameters of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	tagNames    *[]string
}

// RepositoryMockCreatePipelineTagsResults contains results of the Repository.CreatePipelineTags
type RepositoryMockCreatePipelineTagsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Optional() *mRepositoryMockCreatePipelineTags {
	mmCreatePipelineTags.optional = true
	return mmCreatePipelineTags
}

// Expect sets up expected params for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by ExpectParams functions")
	}

	mmCreatePipelineTags.defaultExpectation.params = &RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}
	for _, e := range mmCreatePipelineTags.expectations {
		if minimock.Equal(e.params, mmCreatePipelineTags.defaultExpectation.params) {
			mmCreatePipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePipelineTags.defaultExpectation.params)
		}
	}

	return mmCreatePipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreatePipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmCreatePipelineTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{}
	}

	if mmCreatePipelineTags.defaultExpectation.params != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Expect")
	}

	if mmCreatePipelineTags.defaultExpectation.paramPtrs == nil {
		mmCreatePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockCreatePipelineTagsParamPtrs{}
	}
	mmCreatePipelineTags.defaultExpectation.paramPtrs.tagNames = &tagNames

	return mmCreatePipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)) *mRepositoryMockCreatePipelineTags {
	if mmCreatePipelineTags.mock.inspectFuncCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreatePipelineTags")
	}

	mmCreatePipelineTags.mock.inspectFuncCreatePipelineTags = f

	return mmCreatePipelineTags
}

// Return sets up results that will be returned by Repository.CreatePipelineTags
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Return(err error) *RepositoryMock {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	if mmCreatePipelineTags.defaultExpectation == nil {
		mmCreatePipelineTags.defaultExpectation = &RepositoryMockCreatePipelineTagsExpectation{mock: mmCreatePipelineTags.mock}
	}
	mmCreatePipelineTags.defaultExpectation.results = &RepositoryMockCreatePipelineTagsResults{err}
	return mmCreatePipelineTags.mock
}

// Set uses given function f to mock the Repository.CreatePipelineTags method
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmCreatePipelineTags.defaultExpectation != nil {
		mmCreatePipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.CreatePipelineTags method")
	}

	if len(mmCreatePipelineTags.expectations) > 0 {
		mmCreatePipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.CreatePipelineTags method")
	}

	mmCreatePipelineTags.mock.funcCreatePipelineTags = f
	return mmCreatePipelineTags.mock
}

// When sets expectation for the Repository.CreatePipelineTags which will trigger the result defined by the following
// Then helper
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) When(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *RepositoryMockCreatePipelineTagsExpectation {
	if mmCreatePipelineTags.mock.funcCreatePipelineTags != nil {
		mmCreatePipelineTags.mock.t.Fatalf("RepositoryMock.CreatePipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockCreatePipelineTagsExpectation{
		mock:   mmCreatePipelineTags.mock,
		params: &RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames},
	}
	mmCreatePipelineTags.expectations = append(mmCreatePipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreatePipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreatePipelineTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreatePipelineTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.CreatePipelineTags should be invoked
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Times(n uint64) *mRepositoryMockCreatePipelineTags {
	if n == 0 {
		mmCreatePipelineTags.mock.t.Fatalf("Times of RepositoryMock.CreatePipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePipelineTags.expectedInvocations, n)
	return mmCreatePipelineTags
}

func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) invocationsDone() bool {
	if len(mmCreatePipelineTags.expectations) == 0 && mmCreatePipelineTags.defaultExpectation == nil && mmCreatePipelineTags.mock.funcCreatePipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePipelineTags.mock.afterCreatePipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePipelineTags implements repository.Repository
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTags(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmCreatePipelineTags.beforeCreatePipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePipelineTags.afterCreatePipelineTagsCounter, 1)

	if mmCreatePipelineTags.inspectFuncCreatePipelineTags != nil {
		mmCreatePipelineTags.inspectFuncCreatePipelineTags(ctx, pipelineUID, tagNames)
	}

	mm_params := RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}

	// Record call args
	mmCreatePipelineTags.CreatePipelineTagsMock.mutex.Lock()
	mmCreatePipelineTags.CreatePipelineTagsMock.callArgs = append(mmCreatePipelineTags.CreatePipelineTagsMock.callArgs, &mm_params)
	mmCreatePipelineTags.CreatePipelineTagsMock.mutex.Unlock()

	for _, e := range mmCreatePipelineTags.CreatePipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreatePipelineTagsParams{ctx, pipelineUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameter tagNames, want: %#v, got: %#v%s\n", *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePipelineTags.t.Errorf("RepositoryMock.CreatePipelineTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePipelineTags.CreatePipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePipelineTags.t.Fatal("No results are set for the RepositoryMock.CreatePipelineTags")
		}
		return (*mm_results).err
	}
	if mmCreatePipelineTags.funcCreatePipelineTags != nil {
		return mmCreatePipelineTags.funcCreatePipelineTags(ctx, pipelineUID, tagNames)
	}
	mmCreatePipelineTags.t.Fatalf("Unexpected call to RepositoryMock.CreatePipelineTags. %v %v %v", ctx, pipelineUID, tagNames)
	return
}

// CreatePipelineTagsAfterCounter returns a count of finished RepositoryMock.CreatePipelineTags invocations
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineTags.afterCreatePipelineTagsCounter)
}

// CreatePipelineTagsBeforeCounter returns a count of RepositoryMock.CreatePipelineTags invocations
func (mmCreatePipelineTags *RepositoryMock) CreatePipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePipelineTags.beforeCreatePipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreatePipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePipelineTags *mRepositoryMockCreatePipelineTags) Calls() []*RepositoryMockCreatePipelineTagsParams {
	mmCreatePipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockCreatePipelineTagsParams, len(mmCreatePipelineTags.callArgs))
	copy(argCopy, mmCreatePipelineTags.callArgs)

	mmCreatePipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePipelineTagsDone returns true if the count of the CreatePipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreatePipelineTagsDone() bool {
	if m.CreatePipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePipelineTagsMock.invocationsDone()
}

// MinimockCreatePipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreatePipelineTagsInspect() {
	for _, e := range m.CreatePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags with params: %#v", *e.params)
		}
	}

	afterCreatePipelineTagsCounter := mm_atomic.LoadUint64(&m.afterCreatePipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePipelineTagsMock.defaultExpectation != nil && afterCreatePipelineTagsCounter < 1 {
		if m.CreatePipelineTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreatePipelineTags")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreatePipelineTags with params: %#v", *m.CreatePipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePipelineTags != nil && afterCreatePipelineTagsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreatePipelineTags")
	}

	if !m.CreatePipelineTagsMock.invocationsDone() && afterCreatePipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreatePipelineTags but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePipelineTagsMock.expectedInvocations), afterCreatePipelineTagsCounter)
	}
}

type mRepositoryMockDeleteNamespacePipelineByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespacePipelineByIDExpectation
	expectations       []*RepositoryMockDeleteNamespacePipelineByIDExpectation

	callArgs []*RepositoryMockDeleteNamespacePipelineByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteNamespacePipelineByIDExpectation specifies expectation struct of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteNamespacePipelineByIDParams
	paramPtrs *RepositoryMockDeleteNamespacePipelineByIDParamPtrs
	results   *RepositoryMockDeleteNamespacePipelineByIDResults
	Counter   uint64
}

// RepositoryMockDeleteNamespacePipelineByIDParams contains parameters of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeleteNamespacePipelineByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeleteNamespacePipelineByIDResults contains results of the Repository.DeleteNamespacePipelineByID
type RepositoryMockDeleteNamespacePipelineByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Optional() *mRepositoryMockDeleteNamespacePipelineByID {
	mmDeleteNamespacePipelineByID.optional = true
	return mmDeleteNamespacePipelineByID
}

// Expect sets up expected params for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespacePipelineByID.defaultExpectation.params = &RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id}
	for _, e := range mmDeleteNamespacePipelineByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespacePipelineByID.defaultExpectation.params) {
			mmDeleteNamespacePipelineByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespacePipelineByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespacePipelineByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteNamespacePipelineByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmDeleteNamespacePipelineByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{}
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.paramPtrs.id = &id

	return mmDeleteNamespacePipelineByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeleteNamespacePipelineByID {
	if mmDeleteNamespacePipelineByID.mock.inspectFuncDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespacePipelineByID")
	}

	mmDeleteNamespacePipelineByID.mock.inspectFuncDeleteNamespacePipelineByID = f

	return mmDeleteNamespacePipelineByID
}

// Return sets up results that will be returned by Repository.DeleteNamespacePipelineByID
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineByIDExpectation{mock: mmDeleteNamespacePipelineByID.mock}
	}
	mmDeleteNamespacePipelineByID.defaultExpectation.results = &RepositoryMockDeleteNamespacePipelineByIDResults{err}
	return mmDeleteNamespacePipelineByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespacePipelineByID method
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespacePipelineByID.defaultExpectation != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespacePipelineByID method")
	}

	if len(mmDeleteNamespacePipelineByID.expectations) > 0 {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespacePipelineByID method")
	}

	mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID = f
	return mmDeleteNamespacePipelineByID.mock
}

// When sets expectation for the Repository.DeleteNamespacePipelineByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeleteNamespacePipelineByIDExpectation {
	if mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespacePipelineByIDExpectation{
		mock:   mmDeleteNamespacePipelineByID.mock,
		params: &RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id},
	}
	mmDeleteNamespacePipelineByID.expectations = append(mmDeleteNamespacePipelineByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespacePipelineByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespacePipelineByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespacePipelineByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespacePipelineByID should be invoked
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Times(n uint64) *mRepositoryMockDeleteNamespacePipelineByID {
	if n == 0 {
		mmDeleteNamespacePipelineByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespacePipelineByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespacePipelineByID.expectedInvocations, n)
	return mmDeleteNamespacePipelineByID
}

func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) invocationsDone() bool {
	if len(mmDeleteNamespacePipelineByID.expectations) == 0 && mmDeleteNamespacePipelineByID.defaultExpectation == nil && mmDeleteNamespacePipelineByID.mock.funcDeleteNamespacePipelineByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.mock.afterDeleteNamespacePipelineByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespacePipelineByID implements repository.Repository
func (mmDeleteNamespacePipelineByID *RepositoryMock) DeleteNamespacePipelineByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespacePipelineByID.beforeDeleteNamespacePipelineByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespacePipelineByID.afterDeleteNamespacePipelineByIDCounter, 1)

	if mmDeleteNamespacePipelineByID.inspectFuncDeleteNamespacePipelineByID != nil {
		mmDeleteNamespacePipelineByID.inspectFuncDeleteNamespacePipelineByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.mutex.Lock()
	mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.callArgs = append(mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.callArgs, &mm_params)
	mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespacePipelineByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespacePipelineByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespacePipelineByID.DeleteNamespacePipelineByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespacePipelineByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespacePipelineByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespacePipelineByID.funcDeleteNamespacePipelineByID != nil {
		return mmDeleteNamespacePipelineByID.funcDeleteNamespacePipelineByID(ctx, ownerPermalink, id)
	}
	mmDeleteNamespacePipelineByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespacePipelineByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeleteNamespacePipelineByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespacePipelineByID invocations
func (mmDeleteNamespacePipelineByID *RepositoryMock) DeleteNamespacePipelineByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.afterDeleteNamespacePipelineByIDCounter)
}

// DeleteNamespacePipelineByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespacePipelineByID invocations
func (mmDeleteNamespacePipelineByID *RepositoryMock) DeleteNamespacePipelineByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineByID.beforeDeleteNamespacePipelineByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespacePipelineByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespacePipelineByID *mRepositoryMockDeleteNamespacePipelineByID) Calls() []*RepositoryMockDeleteNamespacePipelineByIDParams {
	mmDeleteNamespacePipelineByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespacePipelineByIDParams, len(mmDeleteNamespacePipelineByID.callArgs))
	copy(argCopy, mmDeleteNamespacePipelineByID.callArgs)

	mmDeleteNamespacePipelineByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespacePipelineByIDDone returns true if the count of the DeleteNamespacePipelineByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespacePipelineByIDDone() bool {
	if m.DeleteNamespacePipelineByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespacePipelineByIDMock.invocationsDone()
}

// MinimockDeleteNamespacePipelineByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespacePipelineByIDInspect() {
	for _, e := range m.DeleteNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineByID with params: %#v", *e.params)
		}
	}

	afterDeleteNamespacePipelineByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespacePipelineByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespacePipelineByIDMock.defaultExpectation != nil && afterDeleteNamespacePipelineByIDCounter < 1 {
		if m.DeleteNamespacePipelineByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteNamespacePipelineByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineByID with params: %#v", *m.DeleteNamespacePipelineByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespacePipelineByID != nil && afterDeleteNamespacePipelineByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteNamespacePipelineByID")
	}

	if !m.DeleteNamespacePipelineByIDMock.invocationsDone() && afterDeleteNamespacePipelineByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespacePipelineByID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespacePipelineByIDMock.expectedInvocations), afterDeleteNamespacePipelineByIDCounter)
	}
}

type mRepositoryMockDeleteNamespacePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockDeleteNamespacePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation specifies expectation struct of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteNamespacePipelineReleaseByIDParams
	paramPtrs *RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs
	results   *RepositoryMockDeleteNamespacePipelineReleaseByIDResults
	Counter   uint64
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDParams contains parameters of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
}

// RepositoryMockDeleteNamespacePipelineReleaseByIDResults contains results of the Repository.DeleteNamespacePipelineReleaseByID
type RepositoryMockDeleteNamespacePipelineReleaseByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Optional() *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	mmDeleteNamespacePipelineReleaseByID.optional = true
	return mmDeleteNamespacePipelineReleaseByID
}

// Expect sets up expected params for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params = &RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}
	for _, e := range mmDeleteNamespacePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params) {
			mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmDeleteNamespacePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{}
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id

	return mmDeleteNamespacePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string)) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if mmDeleteNamespacePipelineReleaseByID.mock.inspectFuncDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespacePipelineReleaseByID")
	}

	mmDeleteNamespacePipelineReleaseByID.mock.inspectFuncDeleteNamespacePipelineReleaseByID = f

	return mmDeleteNamespacePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.DeleteNamespacePipelineReleaseByID
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmDeleteNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{mock: mmDeleteNamespacePipelineReleaseByID.mock}
	}
	mmDeleteNamespacePipelineReleaseByID.defaultExpectation.results = &RepositoryMockDeleteNamespacePipelineReleaseByIDResults{err}
	return mmDeleteNamespacePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespacePipelineReleaseByID method
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespacePipelineReleaseByID.defaultExpectation != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespacePipelineReleaseByID method")
	}

	if len(mmDeleteNamespacePipelineReleaseByID.expectations) > 0 {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespacePipelineReleaseByID method")
	}

	mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID = f
	return mmDeleteNamespacePipelineReleaseByID.mock
}

// When sets expectation for the Repository.DeleteNamespacePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) *RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation {
	if mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.DeleteNamespacePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation{
		mock:   mmDeleteNamespacePipelineReleaseByID.mock,
		params: &RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id},
	}
	mmDeleteNamespacePipelineReleaseByID.expectations = append(mmDeleteNamespacePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespacePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespacePipelineReleaseByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespacePipelineReleaseByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespacePipelineReleaseByID should be invoked
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Times(n uint64) *mRepositoryMockDeleteNamespacePipelineReleaseByID {
	if n == 0 {
		mmDeleteNamespacePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespacePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespacePipelineReleaseByID.expectedInvocations, n)
	return mmDeleteNamespacePipelineReleaseByID
}

func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) invocationsDone() bool {
	if len(mmDeleteNamespacePipelineReleaseByID.expectations) == 0 && mmDeleteNamespacePipelineReleaseByID.defaultExpectation == nil && mmDeleteNamespacePipelineReleaseByID.mock.funcDeleteNamespacePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.mock.afterDeleteNamespacePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespacePipelineReleaseByID implements repository.Repository
func (mmDeleteNamespacePipelineReleaseByID *RepositoryMock) DeleteNamespacePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespacePipelineReleaseByID.beforeDeleteNamespacePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespacePipelineReleaseByID.afterDeleteNamespacePipelineReleaseByIDCounter, 1)

	if mmDeleteNamespacePipelineReleaseByID.inspectFuncDeleteNamespacePipelineReleaseByID != nil {
		mmDeleteNamespacePipelineReleaseByID.inspectFuncDeleteNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id)
	}

	mm_params := RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}

	// Record call args
	mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.mutex.Lock()
	mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.callArgs = append(mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.callArgs, &mm_params)
	mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.DeleteNamespacePipelineReleaseByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespacePipelineReleaseByID.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespacePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespacePipelineReleaseByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespacePipelineReleaseByID.funcDeleteNamespacePipelineReleaseByID != nil {
		return mmDeleteNamespacePipelineReleaseByID.funcDeleteNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id)
	}
	mmDeleteNamespacePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespacePipelineReleaseByID. %v %v %v %v", ctx, ownerPermalink, pipelineUID, id)
	return
}

// DeleteNamespacePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespacePipelineReleaseByID invocations
func (mmDeleteNamespacePipelineReleaseByID *RepositoryMock) DeleteNamespacePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.afterDeleteNamespacePipelineReleaseByIDCounter)
}

// DeleteNamespacePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespacePipelineReleaseByID invocations
func (mmDeleteNamespacePipelineReleaseByID *RepositoryMock) DeleteNamespacePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespacePipelineReleaseByID.beforeDeleteNamespacePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespacePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespacePipelineReleaseByID *mRepositoryMockDeleteNamespacePipelineReleaseByID) Calls() []*RepositoryMockDeleteNamespacePipelineReleaseByIDParams {
	mmDeleteNamespacePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespacePipelineReleaseByIDParams, len(mmDeleteNamespacePipelineReleaseByID.callArgs))
	copy(argCopy, mmDeleteNamespacePipelineReleaseByID.callArgs)

	mmDeleteNamespacePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespacePipelineReleaseByIDDone returns true if the count of the DeleteNamespacePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespacePipelineReleaseByIDDone() bool {
	if m.DeleteNamespacePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespacePipelineReleaseByIDMock.invocationsDone()
}

// MinimockDeleteNamespacePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespacePipelineReleaseByIDInspect() {
	for _, e := range m.DeleteNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID with params: %#v", *e.params)
		}
	}

	afterDeleteNamespacePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespacePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation != nil && afterDeleteNamespacePipelineReleaseByIDCounter < 1 {
		if m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID with params: %#v", *m.DeleteNamespacePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespacePipelineReleaseByID != nil && afterDeleteNamespacePipelineReleaseByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteNamespacePipelineReleaseByID")
	}

	if !m.DeleteNamespacePipelineReleaseByIDMock.invocationsDone() && afterDeleteNamespacePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespacePipelineReleaseByID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespacePipelineReleaseByIDMock.expectedInvocations), afterDeleteNamespacePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockDeleteNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockDeleteNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockDeleteNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteNamespaceSecretByIDExpectation specifies expectation struct of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteNamespaceSecretByIDParams
	paramPtrs *RepositoryMockDeleteNamespaceSecretByIDParamPtrs
	results   *RepositoryMockDeleteNamespaceSecretByIDResults
	Counter   uint64
}

// RepositoryMockDeleteNamespaceSecretByIDParams contains parameters of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeleteNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeleteNamespaceSecretByIDResults contains results of the Repository.DeleteNamespaceSecretByID
type RepositoryMockDeleteNamespaceSecretByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Optional() *mRepositoryMockDeleteNamespaceSecretByID {
	mmDeleteNamespaceSecretByID.optional = true
	return mmDeleteNamespaceSecretByID
}

// Expect sets up expected params for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceSecretByID.defaultExpectation.params = &RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}
	for _, e := range mmDeleteNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceSecretByID.defaultExpectation.params) {
			mmDeleteNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmDeleteNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{}
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.params != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Expect")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceSecretByIDParamPtrs{}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id

	return mmDeleteNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeleteNamespaceSecretByID {
	if mmDeleteNamespaceSecretByID.mock.inspectFuncDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespaceSecretByID")
	}

	mmDeleteNamespaceSecretByID.mock.inspectFuncDeleteNamespaceSecretByID = f

	return mmDeleteNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.DeleteNamespaceSecretByID
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	if mmDeleteNamespaceSecretByID.defaultExpectation == nil {
		mmDeleteNamespaceSecretByID.defaultExpectation = &RepositoryMockDeleteNamespaceSecretByIDExpectation{mock: mmDeleteNamespaceSecretByID.mock}
	}
	mmDeleteNamespaceSecretByID.defaultExpectation.results = &RepositoryMockDeleteNamespaceSecretByIDResults{err}
	return mmDeleteNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespaceSecretByID method
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespaceSecretByID.defaultExpectation != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespaceSecretByID method")
	}

	if len(mmDeleteNamespaceSecretByID.expectations) > 0 {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespaceSecretByID method")
	}

	mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID = f
	return mmDeleteNamespaceSecretByID.mock
}

// When sets expectation for the Repository.DeleteNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeleteNamespaceSecretByIDExpectation {
	if mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespaceSecretByIDExpectation{
		mock:   mmDeleteNamespaceSecretByID.mock,
		params: &RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id},
	}
	mmDeleteNamespaceSecretByID.expectations = append(mmDeleteNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespaceSecretByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespaceSecretByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespaceSecretByID should be invoked
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Times(n uint64) *mRepositoryMockDeleteNamespaceSecretByID {
	if n == 0 {
		mmDeleteNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceSecretByID.expectedInvocations, n)
	return mmDeleteNamespaceSecretByID
}

func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) invocationsDone() bool {
	if len(mmDeleteNamespaceSecretByID.expectations) == 0 && mmDeleteNamespaceSecretByID.defaultExpectation == nil && mmDeleteNamespaceSecretByID.mock.funcDeleteNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.mock.afterDeleteNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceSecretByID implements repository.Repository
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.beforeDeleteNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.afterDeleteNamespaceSecretByIDCounter, 1)

	if mmDeleteNamespaceSecretByID.inspectFuncDeleteNamespaceSecretByID != nil {
		mmDeleteNamespaceSecretByID.inspectFuncDeleteNamespaceSecretByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.mutex.Lock()
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.callArgs = append(mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.callArgs, &mm_params)
	mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespaceSecretByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceSecretByID.t.Errorf("RepositoryMock.DeleteNamespaceSecretByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceSecretByID.DeleteNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespaceSecretByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespaceSecretByID.funcDeleteNamespaceSecretByID != nil {
		return mmDeleteNamespaceSecretByID.funcDeleteNamespaceSecretByID(ctx, ownerPermalink, id)
	}
	mmDeleteNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespaceSecretByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeleteNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespaceSecretByID invocations
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.afterDeleteNamespaceSecretByIDCounter)
}

// DeleteNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespaceSecretByID invocations
func (mmDeleteNamespaceSecretByID *RepositoryMock) DeleteNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceSecretByID.beforeDeleteNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceSecretByID *mRepositoryMockDeleteNamespaceSecretByID) Calls() []*RepositoryMockDeleteNamespaceSecretByIDParams {
	mmDeleteNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespaceSecretByIDParams, len(mmDeleteNamespaceSecretByID.callArgs))
	copy(argCopy, mmDeleteNamespaceSecretByID.callArgs)

	mmDeleteNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceSecretByIDDone returns true if the count of the DeleteNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespaceSecretByIDDone() bool {
	if m.DeleteNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceSecretByIDMock.invocationsDone()
}

// MinimockDeleteNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespaceSecretByIDInspect() {
	for _, e := range m.DeleteNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID with params: %#v", *e.params)
		}
	}

	afterDeleteNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceSecretByIDMock.defaultExpectation != nil && afterDeleteNamespaceSecretByIDCounter < 1 {
		if m.DeleteNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteNamespaceSecretByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceSecretByID with params: %#v", *m.DeleteNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceSecretByID != nil && afterDeleteNamespaceSecretByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteNamespaceSecretByID")
	}

	if !m.DeleteNamespaceSecretByIDMock.invocationsDone() && afterDeleteNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespaceSecretByID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceSecretByIDMock.expectedInvocations), afterDeleteNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockDeletePipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeletePipelineTagsExpectation
	expectations       []*RepositoryMockDeletePipelineTagsExpectation

	callArgs []*RepositoryMockDeletePipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeletePipelineTagsExpectation specifies expectation struct of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeletePipelineTagsParams
	paramPtrs *RepositoryMockDeletePipelineTagsParamPtrs
	results   *RepositoryMockDeletePipelineTagsResults
	Counter   uint64
}

// RepositoryMockDeletePipelineTagsParams contains parameters of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
	tagNames    []string
}

// RepositoryMockDeletePipelineTagsParamPtrs contains pointers to parameters of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
	tagNames    *[]string
}

// RepositoryMockDeletePipelineTagsResults contains results of the Repository.DeletePipelineTags
type RepositoryMockDeletePipelineTagsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Optional() *mRepositoryMockDeletePipelineTags {
	mmDeletePipelineTags.optional = true
	return mmDeletePipelineTags
}

// Expect sets up expected params for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by ExpectParams functions")
	}

	mmDeletePipelineTags.defaultExpectation.params = &RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}
	for _, e := range mmDeletePipelineTags.expectations {
		if minimock.Equal(e.params, mmDeletePipelineTags.defaultExpectation.params) {
			mmDeletePipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePipelineTags.defaultExpectation.params)
		}
	}

	return mmDeletePipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeletePipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmDeletePipelineTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{}
	}

	if mmDeletePipelineTags.defaultExpectation.params != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Expect")
	}

	if mmDeletePipelineTags.defaultExpectation.paramPtrs == nil {
		mmDeletePipelineTags.defaultExpectation.paramPtrs = &RepositoryMockDeletePipelineTagsParamPtrs{}
	}
	mmDeletePipelineTags.defaultExpectation.paramPtrs.tagNames = &tagNames

	return mmDeletePipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string)) *mRepositoryMockDeletePipelineTags {
	if mmDeletePipelineTags.mock.inspectFuncDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeletePipelineTags")
	}

	mmDeletePipelineTags.mock.inspectFuncDeletePipelineTags = f

	return mmDeletePipelineTags
}

// Return sets up results that will be returned by Repository.DeletePipelineTags
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Return(err error) *RepositoryMock {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	if mmDeletePipelineTags.defaultExpectation == nil {
		mmDeletePipelineTags.defaultExpectation = &RepositoryMockDeletePipelineTagsExpectation{mock: mmDeletePipelineTags.mock}
	}
	mmDeletePipelineTags.defaultExpectation.results = &RepositoryMockDeletePipelineTagsResults{err}
	return mmDeletePipelineTags.mock
}

// Set uses given function f to mock the Repository.DeletePipelineTags method
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmDeletePipelineTags.defaultExpectation != nil {
		mmDeletePipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.DeletePipelineTags method")
	}

	if len(mmDeletePipelineTags.expectations) > 0 {
		mmDeletePipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.DeletePipelineTags method")
	}

	mmDeletePipelineTags.mock.funcDeletePipelineTags = f
	return mmDeletePipelineTags.mock
}

// When sets expectation for the Repository.DeletePipelineTags which will trigger the result defined by the following
// Then helper
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) When(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) *RepositoryMockDeletePipelineTagsExpectation {
	if mmDeletePipelineTags.mock.funcDeletePipelineTags != nil {
		mmDeletePipelineTags.mock.t.Fatalf("RepositoryMock.DeletePipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockDeletePipelineTagsExpectation{
		mock:   mmDeletePipelineTags.mock,
		params: &RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames},
	}
	mmDeletePipelineTags.expectations = append(mmDeletePipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeletePipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeletePipelineTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeletePipelineTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.DeletePipelineTags should be invoked
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Times(n uint64) *mRepositoryMockDeletePipelineTags {
	if n == 0 {
		mmDeletePipelineTags.mock.t.Fatalf("Times of RepositoryMock.DeletePipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePipelineTags.expectedInvocations, n)
	return mmDeletePipelineTags
}

func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) invocationsDone() bool {
	if len(mmDeletePipelineTags.expectations) == 0 && mmDeletePipelineTags.defaultExpectation == nil && mmDeletePipelineTags.mock.funcDeletePipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePipelineTags.mock.afterDeletePipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePipelineTags implements repository.Repository
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTags(ctx context.Context, pipelineUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmDeletePipelineTags.beforeDeletePipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePipelineTags.afterDeletePipelineTagsCounter, 1)

	if mmDeletePipelineTags.inspectFuncDeletePipelineTags != nil {
		mmDeletePipelineTags.inspectFuncDeletePipelineTags(ctx, pipelineUID, tagNames)
	}

	mm_params := RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}

	// Record call args
	mmDeletePipelineTags.DeletePipelineTagsMock.mutex.Lock()
	mmDeletePipelineTags.DeletePipelineTagsMock.callArgs = append(mmDeletePipelineTags.DeletePipelineTagsMock.callArgs, &mm_params)
	mmDeletePipelineTags.DeletePipelineTagsMock.mutex.Unlock()

	for _, e := range mmDeletePipelineTags.DeletePipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeletePipelineTagsParams{ctx, pipelineUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameter tagNames, want: %#v, got: %#v%s\n", *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePipelineTags.t.Errorf("RepositoryMock.DeletePipelineTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePipelineTags.DeletePipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePipelineTags.t.Fatal("No results are set for the RepositoryMock.DeletePipelineTags")
		}
		return (*mm_results).err
	}
	if mmDeletePipelineTags.funcDeletePipelineTags != nil {
		return mmDeletePipelineTags.funcDeletePipelineTags(ctx, pipelineUID, tagNames)
	}
	mmDeletePipelineTags.t.Fatalf("Unexpected call to RepositoryMock.DeletePipelineTags. %v %v %v", ctx, pipelineUID, tagNames)
	return
}

// DeletePipelineTagsAfterCounter returns a count of finished RepositoryMock.DeletePipelineTags invocations
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineTags.afterDeletePipelineTagsCounter)
}

// DeletePipelineTagsBeforeCounter returns a count of RepositoryMock.DeletePipelineTags invocations
func (mmDeletePipelineTags *RepositoryMock) DeletePipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePipelineTags.beforeDeletePipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeletePipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePipelineTags *mRepositoryMockDeletePipelineTags) Calls() []*RepositoryMockDeletePipelineTagsParams {
	mmDeletePipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockDeletePipelineTagsParams, len(mmDeletePipelineTags.callArgs))
	copy(argCopy, mmDeletePipelineTags.callArgs)

	mmDeletePipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePipelineTagsDone returns true if the count of the DeletePipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeletePipelineTagsDone() bool {
	if m.DeletePipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePipelineTagsMock.invocationsDone()
}

// MinimockDeletePipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeletePipelineTagsInspect() {
	for _, e := range m.DeletePipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags with params: %#v", *e.params)
		}
	}

	afterDeletePipelineTagsCounter := mm_atomic.LoadUint64(&m.afterDeletePipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePipelineTagsMock.defaultExpectation != nil && afterDeletePipelineTagsCounter < 1 {
		if m.DeletePipelineTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeletePipelineTags")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeletePipelineTags with params: %#v", *m.DeletePipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePipelineTags != nil && afterDeletePipelineTagsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeletePipelineTags")
	}

	if !m.DeletePipelineTagsMock.invocationsDone() && afterDeletePipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeletePipelineTags but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePipelineTagsMock.expectedInvocations), afterDeletePipelineTagsCounter)
	}
}

type mRepositoryMockGetDefinitionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetDefinitionByUIDExpectation
	expectations       []*RepositoryMockGetDefinitionByUIDExpectation

	callArgs []*RepositoryMockGetDefinitionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetDefinitionByUIDExpectation specifies expectation struct of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetDefinitionByUIDParams
	paramPtrs *RepositoryMockGetDefinitionByUIDParamPtrs
	results   *RepositoryMockGetDefinitionByUIDResults
	Counter   uint64
}

// RepositoryMockGetDefinitionByUIDParams contains parameters of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDParams struct {
	ctx context.Context
	u1  uuid.UUID
}

// RepositoryMockGetDefinitionByUIDParamPtrs contains pointers to parameters of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDParamPtrs struct {
	ctx *context.Context
	u1  *uuid.UUID
}

// RepositoryMockGetDefinitionByUIDResults contains results of the Repository.GetDefinitionByUID
type RepositoryMockGetDefinitionByUIDResults struct {
	cp1 *datamodel.ComponentDefinition
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Optional() *mRepositoryMockGetDefinitionByUID {
	mmGetDefinitionByUID.optional = true
	return mmGetDefinitionByUID
}

// Expect sets up expected params for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Expect(ctx context.Context, u1 uuid.UUID) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by ExpectParams functions")
	}

	mmGetDefinitionByUID.defaultExpectation.params = &RepositoryMockGetDefinitionByUIDParams{ctx, u1}
	for _, e := range mmGetDefinitionByUID.expectations {
		if minimock.Equal(e.params, mmGetDefinitionByUID.defaultExpectation.params) {
			mmGetDefinitionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDefinitionByUID.defaultExpectation.params)
		}
	}

	return mmGetDefinitionByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.params != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Expect")
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetDefinitionByUIDParamPtrs{}
	}
	mmGetDefinitionByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetDefinitionByUID
}

// ExpectU1Param2 sets up expected param u1 for Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) ExpectU1Param2(u1 uuid.UUID) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{}
	}

	if mmGetDefinitionByUID.defaultExpectation.params != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Expect")
	}

	if mmGetDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetDefinitionByUIDParamPtrs{}
	}
	mmGetDefinitionByUID.defaultExpectation.paramPtrs.u1 = &u1

	return mmGetDefinitionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Inspect(f func(ctx context.Context, u1 uuid.UUID)) *mRepositoryMockGetDefinitionByUID {
	if mmGetDefinitionByUID.mock.inspectFuncGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetDefinitionByUID")
	}

	mmGetDefinitionByUID.mock.inspectFuncGetDefinitionByUID = f

	return mmGetDefinitionByUID
}

// Return sets up results that will be returned by Repository.GetDefinitionByUID
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Return(cp1 *datamodel.ComponentDefinition, err error) *RepositoryMock {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	if mmGetDefinitionByUID.defaultExpectation == nil {
		mmGetDefinitionByUID.defaultExpectation = &RepositoryMockGetDefinitionByUIDExpectation{mock: mmGetDefinitionByUID.mock}
	}
	mmGetDefinitionByUID.defaultExpectation.results = &RepositoryMockGetDefinitionByUIDResults{cp1, err}
	return mmGetDefinitionByUID.mock
}

// Set uses given function f to mock the Repository.GetDefinitionByUID method
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Set(f func(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error)) *RepositoryMock {
	if mmGetDefinitionByUID.defaultExpectation != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetDefinitionByUID method")
	}

	if len(mmGetDefinitionByUID.expectations) > 0 {
		mmGetDefinitionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetDefinitionByUID method")
	}

	mmGetDefinitionByUID.mock.funcGetDefinitionByUID = f
	return mmGetDefinitionByUID.mock
}

// When sets expectation for the Repository.GetDefinitionByUID which will trigger the result defined by the following
// Then helper
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) When(ctx context.Context, u1 uuid.UUID) *RepositoryMockGetDefinitionByUIDExpectation {
	if mmGetDefinitionByUID.mock.funcGetDefinitionByUID != nil {
		mmGetDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetDefinitionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetDefinitionByUIDExpectation{
		mock:   mmGetDefinitionByUID.mock,
		params: &RepositoryMockGetDefinitionByUIDParams{ctx, u1},
	}
	mmGetDefinitionByUID.expectations = append(mmGetDefinitionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetDefinitionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetDefinitionByUIDExpectation) Then(cp1 *datamodel.ComponentDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockGetDefinitionByUIDResults{cp1, err}
	return e.mock
}

// Times sets number of times Repository.GetDefinitionByUID should be invoked
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Times(n uint64) *mRepositoryMockGetDefinitionByUID {
	if n == 0 {
		mmGetDefinitionByUID.mock.t.Fatalf("Times of RepositoryMock.GetDefinitionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetDefinitionByUID.expectedInvocations, n)
	return mmGetDefinitionByUID
}

func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) invocationsDone() bool {
	if len(mmGetDefinitionByUID.expectations) == 0 && mmGetDefinitionByUID.defaultExpectation == nil && mmGetDefinitionByUID.mock.funcGetDefinitionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetDefinitionByUID.mock.afterGetDefinitionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetDefinitionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetDefinitionByUID implements repository.Repository
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUID(ctx context.Context, u1 uuid.UUID) (cp1 *datamodel.ComponentDefinition, err error) {
	mm_atomic.AddUint64(&mmGetDefinitionByUID.beforeGetDefinitionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefinitionByUID.afterGetDefinitionByUIDCounter, 1)

	if mmGetDefinitionByUID.inspectFuncGetDefinitionByUID != nil {
		mmGetDefinitionByUID.inspectFuncGetDefinitionByUID(ctx, u1)
	}

	mm_params := RepositoryMockGetDefinitionByUIDParams{ctx, u1}

	// Record call args
	mmGetDefinitionByUID.GetDefinitionByUIDMock.mutex.Lock()
	mmGetDefinitionByUID.GetDefinitionByUIDMock.callArgs = append(mmGetDefinitionByUID.GetDefinitionByUIDMock.callArgs, &mm_params)
	mmGetDefinitionByUID.GetDefinitionByUIDMock.mutex.Unlock()

	for _, e := range mmGetDefinitionByUID.GetDefinitionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetDefinitionByUIDParams{ctx, u1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.u1 != nil && !minimock.Equal(*mm_want_ptrs.u1, mm_got.u1) {
				mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameter u1, want: %#v, got: %#v%s\n", *mm_want_ptrs.u1, mm_got.u1, minimock.Diff(*mm_want_ptrs.u1, mm_got.u1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDefinitionByUID.t.Errorf("RepositoryMock.GetDefinitionByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDefinitionByUID.GetDefinitionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefinitionByUID.t.Fatal("No results are set for the RepositoryMock.GetDefinitionByUID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetDefinitionByUID.funcGetDefinitionByUID != nil {
		return mmGetDefinitionByUID.funcGetDefinitionByUID(ctx, u1)
	}
	mmGetDefinitionByUID.t.Fatalf("Unexpected call to RepositoryMock.GetDefinitionByUID. %v %v", ctx, u1)
	return
}

// GetDefinitionByUIDAfterCounter returns a count of finished RepositoryMock.GetDefinitionByUID invocations
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefinitionByUID.afterGetDefinitionByUIDCounter)
}

// GetDefinitionByUIDBeforeCounter returns a count of RepositoryMock.GetDefinitionByUID invocations
func (mmGetDefinitionByUID *RepositoryMock) GetDefinitionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefinitionByUID.beforeGetDefinitionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetDefinitionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDefinitionByUID *mRepositoryMockGetDefinitionByUID) Calls() []*RepositoryMockGetDefinitionByUIDParams {
	mmGetDefinitionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetDefinitionByUIDParams, len(mmGetDefinitionByUID.callArgs))
	copy(argCopy, mmGetDefinitionByUID.callArgs)

	mmGetDefinitionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetDefinitionByUIDDone returns true if the count of the GetDefinitionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDefinitionByUIDDone() bool {
	if m.GetDefinitionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetDefinitionByUIDMock.invocationsDone()
}

// MinimockGetDefinitionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetDefinitionByUIDInspect() {
	for _, e := range m.GetDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID with params: %#v", *e.params)
		}
	}

	afterGetDefinitionByUIDCounter := mm_atomic.LoadUint64(&m.afterGetDefinitionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefinitionByUIDMock.defaultExpectation != nil && afterGetDefinitionByUIDCounter < 1 {
		if m.GetDefinitionByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetDefinitionByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetDefinitionByUID with params: %#v", *m.GetDefinitionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefinitionByUID != nil && afterGetDefinitionByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetDefinitionByUID")
	}

	if !m.GetDefinitionByUIDMock.invocationsDone() && afterGetDefinitionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetDefinitionByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetDefinitionByUIDMock.expectedInvocations), afterGetDefinitionByUIDCounter)
	}
}

type mRepositoryMockGetHubStats struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetHubStatsExpectation
	expectations       []*RepositoryMockGetHubStatsExpectation

	callArgs []*RepositoryMockGetHubStatsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetHubStatsExpectation specifies expectation struct of the Repository.GetHubStats
type RepositoryMockGetHubStatsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetHubStatsParams
	paramPtrs *RepositoryMockGetHubStatsParamPtrs
	results   *RepositoryMockGetHubStatsResults
	Counter   uint64
}

// RepositoryMockGetHubStatsParams contains parameters of the Repository.GetHubStats
type RepositoryMockGetHubStatsParams struct {
	uidAllowList []uuid.UUID
}

// RepositoryMockGetHubStatsParamPtrs contains pointers to parameters of the Repository.GetHubStats
type RepositoryMockGetHubStatsParamPtrs struct {
	uidAllowList *[]uuid.UUID
}

// RepositoryMockGetHubStatsResults contains results of the Repository.GetHubStats
type RepositoryMockGetHubStatsResults struct {
	hp1 *datamodel.HubStats
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHubStats *mRepositoryMockGetHubStats) Optional() *mRepositoryMockGetHubStats {
	mmGetHubStats.optional = true
	return mmGetHubStats
}

// Expect sets up expected params for Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Expect(uidAllowList []uuid.UUID) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{}
	}

	if mmGetHubStats.defaultExpectation.paramPtrs != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by ExpectParams functions")
	}

	mmGetHubStats.defaultExpectation.params = &RepositoryMockGetHubStatsParams{uidAllowList}
	for _, e := range mmGetHubStats.expectations {
		if minimock.Equal(e.params, mmGetHubStats.defaultExpectation.params) {
			mmGetHubStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHubStats.defaultExpectation.params)
		}
	}

	return mmGetHubStats
}

// ExpectUidAllowListParam1 sets up expected param uidAllowList for Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) ExpectUidAllowListParam1(uidAllowList []uuid.UUID) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{}
	}

	if mmGetHubStats.defaultExpectation.params != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Expect")
	}

	if mmGetHubStats.defaultExpectation.paramPtrs == nil {
		mmGetHubStats.defaultExpectation.paramPtrs = &RepositoryMockGetHubStatsParamPtrs{}
	}
	mmGetHubStats.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList

	return mmGetHubStats
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Inspect(f func(uidAllowList []uuid.UUID)) *mRepositoryMockGetHubStats {
	if mmGetHubStats.mock.inspectFuncGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetHubStats")
	}

	mmGetHubStats.mock.inspectFuncGetHubStats = f

	return mmGetHubStats
}

// Return sets up results that will be returned by Repository.GetHubStats
func (mmGetHubStats *mRepositoryMockGetHubStats) Return(hp1 *datamodel.HubStats, err error) *RepositoryMock {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	if mmGetHubStats.defaultExpectation == nil {
		mmGetHubStats.defaultExpectation = &RepositoryMockGetHubStatsExpectation{mock: mmGetHubStats.mock}
	}
	mmGetHubStats.defaultExpectation.results = &RepositoryMockGetHubStatsResults{hp1, err}
	return mmGetHubStats.mock
}

// Set uses given function f to mock the Repository.GetHubStats method
func (mmGetHubStats *mRepositoryMockGetHubStats) Set(f func(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error)) *RepositoryMock {
	if mmGetHubStats.defaultExpectation != nil {
		mmGetHubStats.mock.t.Fatalf("Default expectation is already set for the Repository.GetHubStats method")
	}

	if len(mmGetHubStats.expectations) > 0 {
		mmGetHubStats.mock.t.Fatalf("Some expectations are already set for the Repository.GetHubStats method")
	}

	mmGetHubStats.mock.funcGetHubStats = f
	return mmGetHubStats.mock
}

// When sets expectation for the Repository.GetHubStats which will trigger the result defined by the following
// Then helper
func (mmGetHubStats *mRepositoryMockGetHubStats) When(uidAllowList []uuid.UUID) *RepositoryMockGetHubStatsExpectation {
	if mmGetHubStats.mock.funcGetHubStats != nil {
		mmGetHubStats.mock.t.Fatalf("RepositoryMock.GetHubStats mock is already set by Set")
	}

	expectation := &RepositoryMockGetHubStatsExpectation{
		mock:   mmGetHubStats.mock,
		params: &RepositoryMockGetHubStatsParams{uidAllowList},
	}
	mmGetHubStats.expectations = append(mmGetHubStats.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetHubStats return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetHubStatsExpectation) Then(hp1 *datamodel.HubStats, err error) *RepositoryMock {
	e.results = &RepositoryMockGetHubStatsResults{hp1, err}
	return e.mock
}

// Times sets number of times Repository.GetHubStats should be invoked
func (mmGetHubStats *mRepositoryMockGetHubStats) Times(n uint64) *mRepositoryMockGetHubStats {
	if n == 0 {
		mmGetHubStats.mock.t.Fatalf("Times of RepositoryMock.GetHubStats mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHubStats.expectedInvocations, n)
	return mmGetHubStats
}

func (mmGetHubStats *mRepositoryMockGetHubStats) invocationsDone() bool {
	if len(mmGetHubStats.expectations) == 0 && mmGetHubStats.defaultExpectation == nil && mmGetHubStats.mock.funcGetHubStats == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHubStats.mock.afterGetHubStatsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHubStats.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHubStats implements repository.Repository
func (mmGetHubStats *RepositoryMock) GetHubStats(uidAllowList []uuid.UUID) (hp1 *datamodel.HubStats, err error) {
	mm_atomic.AddUint64(&mmGetHubStats.beforeGetHubStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHubStats.afterGetHubStatsCounter, 1)

	if mmGetHubStats.inspectFuncGetHubStats != nil {
		mmGetHubStats.inspectFuncGetHubStats(uidAllowList)
	}

	mm_params := RepositoryMockGetHubStatsParams{uidAllowList}

	// Record call args
	mmGetHubStats.GetHubStatsMock.mutex.Lock()
	mmGetHubStats.GetHubStatsMock.callArgs = append(mmGetHubStats.GetHubStatsMock.callArgs, &mm_params)
	mmGetHubStats.GetHubStatsMock.mutex.Unlock()

	for _, e := range mmGetHubStats.GetHubStatsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmGetHubStats.GetHubStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHubStats.GetHubStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHubStats.GetHubStatsMock.defaultExpectation.params
		mm_want_ptrs := mmGetHubStats.GetHubStatsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetHubStatsParams{uidAllowList}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmGetHubStats.t.Errorf("RepositoryMock.GetHubStats got unexpected parameter uidAllowList, want: %#v, got: %#v%s\n", *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHubStats.t.Errorf("RepositoryMock.GetHubStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHubStats.GetHubStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHubStats.t.Fatal("No results are set for the RepositoryMock.GetHubStats")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmGetHubStats.funcGetHubStats != nil {
		return mmGetHubStats.funcGetHubStats(uidAllowList)
	}
	mmGetHubStats.t.Fatalf("Unexpected call to RepositoryMock.GetHubStats. %v", uidAllowList)
	return
}

// GetHubStatsAfterCounter returns a count of finished RepositoryMock.GetHubStats invocations
func (mmGetHubStats *RepositoryMock) GetHubStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHubStats.afterGetHubStatsCounter)
}

// GetHubStatsBeforeCounter returns a count of RepositoryMock.GetHubStats invocations
func (mmGetHubStats *RepositoryMock) GetHubStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHubStats.beforeGetHubStatsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetHubStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHubStats *mRepositoryMockGetHubStats) Calls() []*RepositoryMockGetHubStatsParams {
	mmGetHubStats.mutex.RLock()

	argCopy := make([]*RepositoryMockGetHubStatsParams, len(mmGetHubStats.callArgs))
	copy(argCopy, mmGetHubStats.callArgs)

	mmGetHubStats.mutex.RUnlock()

	return argCopy
}

// MinimockGetHubStatsDone returns true if the count of the GetHubStats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetHubStatsDone() bool {
	if m.GetHubStatsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHubStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHubStatsMock.invocationsDone()
}

// MinimockGetHubStatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetHubStatsInspect() {
	for _, e := range m.GetHubStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats with params: %#v", *e.params)
		}
	}

	afterGetHubStatsCounter := mm_atomic.LoadUint64(&m.afterGetHubStatsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHubStatsMock.defaultExpectation != nil && afterGetHubStatsCounter < 1 {
		if m.GetHubStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetHubStats")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetHubStats with params: %#v", *m.GetHubStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHubStats != nil && afterGetHubStatsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetHubStats")
	}

	if !m.GetHubStatsMock.invocationsDone() && afterGetHubStatsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetHubStats but found %d calls",
			mm_atomic.LoadUint64(&m.GetHubStatsMock.expectedInvocations), afterGetHubStatsCounter)
	}
}

type mRepositoryMockGetLatestNamespacePipelineRelease struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestNamespacePipelineReleaseExpectation
	expectations       []*RepositoryMockGetLatestNamespacePipelineReleaseExpectation

	callArgs []*RepositoryMockGetLatestNamespacePipelineReleaseParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetLatestNamespacePipelineReleaseExpectation specifies expectation struct of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetLatestNamespacePipelineReleaseParams
	paramPtrs *RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs
	results   *RepositoryMockGetLatestNamespacePipelineReleaseResults
	Counter   uint64
}

// RepositoryMockGetLatestNamespacePipelineReleaseParams contains parameters of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	isBasicView    bool
}

// RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs contains pointers to parameters of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	isBasicView    *bool
}

// RepositoryMockGetLatestNamespacePipelineReleaseResults contains results of the Repository.GetLatestNamespacePipelineRelease
type RepositoryMockGetLatestNamespacePipelineReleaseResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Optional() *mRepositoryMockGetLatestNamespacePipelineRelease {
	mmGetLatestNamespacePipelineRelease.optional = true
	return mmGetLatestNamespacePipelineRelease
}

// Expect sets up expected params for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by ExpectParams functions")
	}

	mmGetLatestNamespacePipelineRelease.defaultExpectation.params = &RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}
	for _, e := range mmGetLatestNamespacePipelineRelease.expectations {
		if minimock.Equal(e.params, mmGetLatestNamespacePipelineRelease.defaultExpectation.params) {
			mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestNamespacePipelineRelease.defaultExpectation.params)
		}
	}

	return mmGetLatestNamespacePipelineRelease
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetLatestNamespacePipelineRelease
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmGetLatestNamespacePipelineRelease
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmGetLatestNamespacePipelineRelease
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{}
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.params != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Expect")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs = &RepositoryMockGetLatestNamespacePipelineReleaseParamPtrs{}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetLatestNamespacePipelineRelease
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool)) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if mmGetLatestNamespacePipelineRelease.mock.inspectFuncGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestNamespacePipelineRelease")
	}

	mmGetLatestNamespacePipelineRelease.mock.inspectFuncGetLatestNamespacePipelineRelease = f

	return mmGetLatestNamespacePipelineRelease
}

// Return sets up results that will be returned by Repository.GetLatestNamespacePipelineRelease
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	if mmGetLatestNamespacePipelineRelease.defaultExpectation == nil {
		mmGetLatestNamespacePipelineRelease.defaultExpectation = &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{mock: mmGetLatestNamespacePipelineRelease.mock}
	}
	mmGetLatestNamespacePipelineRelease.defaultExpectation.results = &RepositoryMockGetLatestNamespacePipelineReleaseResults{pp1, err}
	return mmGetLatestNamespacePipelineRelease.mock
}

// Set uses given function f to mock the Repository.GetLatestNamespacePipelineRelease method
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetLatestNamespacePipelineRelease.defaultExpectation != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestNamespacePipelineRelease method")
	}

	if len(mmGetLatestNamespacePipelineRelease.expectations) > 0 {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestNamespacePipelineRelease method")
	}

	mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease = f
	return mmGetLatestNamespacePipelineRelease.mock
}

// When sets expectation for the Repository.GetLatestNamespacePipelineRelease which will trigger the result defined by the following
// Then helper
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) *RepositoryMockGetLatestNamespacePipelineReleaseExpectation {
	if mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("RepositoryMock.GetLatestNamespacePipelineRelease mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestNamespacePipelineReleaseExpectation{
		mock:   mmGetLatestNamespacePipelineRelease.mock,
		params: &RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView},
	}
	mmGetLatestNamespacePipelineRelease.expectations = append(mmGetLatestNamespacePipelineRelease.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestNamespacePipelineRelease return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestNamespacePipelineReleaseExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestNamespacePipelineReleaseResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestNamespacePipelineRelease should be invoked
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Times(n uint64) *mRepositoryMockGetLatestNamespacePipelineRelease {
	if n == 0 {
		mmGetLatestNamespacePipelineRelease.mock.t.Fatalf("Times of RepositoryMock.GetLatestNamespacePipelineRelease mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestNamespacePipelineRelease.expectedInvocations, n)
	return mmGetLatestNamespacePipelineRelease
}

func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) invocationsDone() bool {
	if len(mmGetLatestNamespacePipelineRelease.expectations) == 0 && mmGetLatestNamespacePipelineRelease.defaultExpectation == nil && mmGetLatestNamespacePipelineRelease.mock.funcGetLatestNamespacePipelineRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.mock.afterGetLatestNamespacePipelineReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestNamespacePipelineRelease implements repository.Repository
func (mmGetLatestNamespacePipelineRelease *RepositoryMock) GetLatestNamespacePipelineRelease(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetLatestNamespacePipelineRelease.beforeGetLatestNamespacePipelineReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestNamespacePipelineRelease.afterGetLatestNamespacePipelineReleaseCounter, 1)

	if mmGetLatestNamespacePipelineRelease.inspectFuncGetLatestNamespacePipelineRelease != nil {
		mmGetLatestNamespacePipelineRelease.inspectFuncGetLatestNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, isBasicView)
	}

	mm_params := RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}

	// Record call args
	mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.mutex.Lock()
	mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.callArgs = append(mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.callArgs, &mm_params)
	mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.mutex.Unlock()

	for _, e := range mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestNamespacePipelineReleaseParams{ctx, ownerPermalink, pipelineUID, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestNamespacePipelineRelease.t.Errorf("RepositoryMock.GetLatestNamespacePipelineRelease got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestNamespacePipelineRelease.GetLatestNamespacePipelineReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestNamespacePipelineRelease.t.Fatal("No results are set for the RepositoryMock.GetLatestNamespacePipelineRelease")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetLatestNamespacePipelineRelease.funcGetLatestNamespacePipelineRelease != nil {
		return mmGetLatestNamespacePipelineRelease.funcGetLatestNamespacePipelineRelease(ctx, ownerPermalink, pipelineUID, isBasicView)
	}
	mmGetLatestNamespacePipelineRelease.t.Fatalf("Unexpected call to RepositoryMock.GetLatestNamespacePipelineRelease. %v %v %v %v", ctx, ownerPermalink, pipelineUID, isBasicView)
	return
}

// GetLatestNamespacePipelineReleaseAfterCounter returns a count of finished RepositoryMock.GetLatestNamespacePipelineRelease invocations
func (mmGetLatestNamespacePipelineRelease *RepositoryMock) GetLatestNamespacePipelineReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.afterGetLatestNamespacePipelineReleaseCounter)
}

// GetLatestNamespacePipelineReleaseBeforeCounter returns a count of RepositoryMock.GetLatestNamespacePipelineRelease invocations
func (mmGetLatestNamespacePipelineRelease *RepositoryMock) GetLatestNamespacePipelineReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestNamespacePipelineRelease.beforeGetLatestNamespacePipelineReleaseCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestNamespacePipelineRelease.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestNamespacePipelineRelease *mRepositoryMockGetLatestNamespacePipelineRelease) Calls() []*RepositoryMockGetLatestNamespacePipelineReleaseParams {
	mmGetLatestNamespacePipelineRelease.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestNamespacePipelineReleaseParams, len(mmGetLatestNamespacePipelineRelease.callArgs))
	copy(argCopy, mmGetLatestNamespacePipelineRelease.callArgs)

	mmGetLatestNamespacePipelineRelease.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestNamespacePipelineReleaseDone returns true if the count of the GetLatestNamespacePipelineRelease invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestNamespacePipelineReleaseDone() bool {
	if m.GetLatestNamespacePipelineReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestNamespacePipelineReleaseMock.invocationsDone()
}

// MinimockGetLatestNamespacePipelineReleaseInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestNamespacePipelineReleaseInspect() {
	for _, e := range m.GetLatestNamespacePipelineReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease with params: %#v", *e.params)
		}
	}

	afterGetLatestNamespacePipelineReleaseCounter := mm_atomic.LoadUint64(&m.afterGetLatestNamespacePipelineReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestNamespacePipelineReleaseMock.defaultExpectation != nil && afterGetLatestNamespacePipelineReleaseCounter < 1 {
		if m.GetLatestNamespacePipelineReleaseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease with params: %#v", *m.GetLatestNamespacePipelineReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestNamespacePipelineRelease != nil && afterGetLatestNamespacePipelineReleaseCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLatestNamespacePipelineRelease")
	}

	if !m.GetLatestNamespacePipelineReleaseMock.invocationsDone() && afterGetLatestNamespacePipelineReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestNamespacePipelineRelease but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestNamespacePipelineReleaseMock.expectedInvocations), afterGetLatestNamespacePipelineReleaseCounter)
	}
}

type mRepositoryMockGetNamespacePipelineByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespacePipelineByIDExpectation
	expectations       []*RepositoryMockGetNamespacePipelineByIDExpectation

	callArgs []*RepositoryMockGetNamespacePipelineByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetNamespacePipelineByIDExpectation specifies expectation struct of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetNamespacePipelineByIDParams
	paramPtrs *RepositoryMockGetNamespacePipelineByIDParamPtrs
	results   *RepositoryMockGetNamespacePipelineByIDResults
	Counter   uint64
}

// RepositoryMockGetNamespacePipelineByIDParams contains parameters of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	isBasicView    bool
	embedReleases  bool
}

// RepositoryMockGetNamespacePipelineByIDParamPtrs contains pointers to parameters of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	isBasicView    *bool
	embedReleases  *bool
}

// RepositoryMockGetNamespacePipelineByIDResults contains results of the Repository.GetNamespacePipelineByID
type RepositoryMockGetNamespacePipelineByIDResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Optional() *mRepositoryMockGetNamespacePipelineByID {
	mmGetNamespacePipelineByID.optional = true
	return mmGetNamespacePipelineByID
}

// Expect sets up expected params for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Expect(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by ExpectParams functions")
	}

	mmGetNamespacePipelineByID.defaultExpectation.params = &RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}
	for _, e := range mmGetNamespacePipelineByID.expectations {
		if minimock.Equal(e.params, mmGetNamespacePipelineByID.defaultExpectation.params) {
			mmGetNamespacePipelineByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespacePipelineByID.defaultExpectation.params)
		}
	}

	return mmGetNamespacePipelineByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetNamespacePipelineByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmGetNamespacePipelineByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.id = &id

	return mmGetNamespacePipelineByID
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetNamespacePipelineByID
}

// ExpectEmbedReleasesParam5 sets up expected param embedReleases for Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) ExpectEmbedReleasesParam5(embedReleases bool) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{}
	}

	if mmGetNamespacePipelineByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineByIDParamPtrs{}
	}
	mmGetNamespacePipelineByID.defaultExpectation.paramPtrs.embedReleases = &embedReleases

	return mmGetNamespacePipelineByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool)) *mRepositoryMockGetNamespacePipelineByID {
	if mmGetNamespacePipelineByID.mock.inspectFuncGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespacePipelineByID")
	}

	mmGetNamespacePipelineByID.mock.inspectFuncGetNamespacePipelineByID = f

	return mmGetNamespacePipelineByID
}

// Return sets up results that will be returned by Repository.GetNamespacePipelineByID
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	if mmGetNamespacePipelineByID.defaultExpectation == nil {
		mmGetNamespacePipelineByID.defaultExpectation = &RepositoryMockGetNamespacePipelineByIDExpectation{mock: mmGetNamespacePipelineByID.mock}
	}
	mmGetNamespacePipelineByID.defaultExpectation.results = &RepositoryMockGetNamespacePipelineByIDResults{pp1, err}
	return mmGetNamespacePipelineByID.mock
}

// Set uses given function f to mock the Repository.GetNamespacePipelineByID method
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Set(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetNamespacePipelineByID.defaultExpectation != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespacePipelineByID method")
	}

	if len(mmGetNamespacePipelineByID.expectations) > 0 {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespacePipelineByID method")
	}

	mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID = f
	return mmGetNamespacePipelineByID.mock
}

// When sets expectation for the Repository.GetNamespacePipelineByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) When(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) *RepositoryMockGetNamespacePipelineByIDExpectation {
	if mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespacePipelineByIDExpectation{
		mock:   mmGetNamespacePipelineByID.mock,
		params: &RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases},
	}
	mmGetNamespacePipelineByID.expectations = append(mmGetNamespacePipelineByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespacePipelineByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespacePipelineByIDExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespacePipelineByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespacePipelineByID should be invoked
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Times(n uint64) *mRepositoryMockGetNamespacePipelineByID {
	if n == 0 {
		mmGetNamespacePipelineByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespacePipelineByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespacePipelineByID.expectedInvocations, n)
	return mmGetNamespacePipelineByID
}

func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) invocationsDone() bool {
	if len(mmGetNamespacePipelineByID.expectations) == 0 && mmGetNamespacePipelineByID.defaultExpectation == nil && mmGetNamespacePipelineByID.mock.funcGetNamespacePipelineByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.mock.afterGetNamespacePipelineByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespacePipelineByID implements repository.Repository
func (mmGetNamespacePipelineByID *RepositoryMock) GetNamespacePipelineByID(ctx context.Context, ownerPermalink string, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetNamespacePipelineByID.beforeGetNamespacePipelineByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespacePipelineByID.afterGetNamespacePipelineByIDCounter, 1)

	if mmGetNamespacePipelineByID.inspectFuncGetNamespacePipelineByID != nil {
		mmGetNamespacePipelineByID.inspectFuncGetNamespacePipelineByID(ctx, ownerPermalink, id, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}

	// Record call args
	mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.mutex.Lock()
	mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.callArgs = append(mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.callArgs, &mm_params)
	mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespacePipelineByIDParams{ctx, ownerPermalink, id, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameter embedReleases, want: %#v, got: %#v%s\n", *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespacePipelineByID.t.Errorf("RepositoryMock.GetNamespacePipelineByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespacePipelineByID.GetNamespacePipelineByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespacePipelineByID.t.Fatal("No results are set for the RepositoryMock.GetNamespacePipelineByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetNamespacePipelineByID.funcGetNamespacePipelineByID != nil {
		return mmGetNamespacePipelineByID.funcGetNamespacePipelineByID(ctx, ownerPermalink, id, isBasicView, embedReleases)
	}
	mmGetNamespacePipelineByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespacePipelineByID. %v %v %v %v %v", ctx, ownerPermalink, id, isBasicView, embedReleases)
	return
}

// GetNamespacePipelineByIDAfterCounter returns a count of finished RepositoryMock.GetNamespacePipelineByID invocations
func (mmGetNamespacePipelineByID *RepositoryMock) GetNamespacePipelineByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.afterGetNamespacePipelineByIDCounter)
}

// GetNamespacePipelineByIDBeforeCounter returns a count of RepositoryMock.GetNamespacePipelineByID invocations
func (mmGetNamespacePipelineByID *RepositoryMock) GetNamespacePipelineByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineByID.beforeGetNamespacePipelineByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespacePipelineByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespacePipelineByID *mRepositoryMockGetNamespacePipelineByID) Calls() []*RepositoryMockGetNamespacePipelineByIDParams {
	mmGetNamespacePipelineByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespacePipelineByIDParams, len(mmGetNamespacePipelineByID.callArgs))
	copy(argCopy, mmGetNamespacePipelineByID.callArgs)

	mmGetNamespacePipelineByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespacePipelineByIDDone returns true if the count of the GetNamespacePipelineByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespacePipelineByIDDone() bool {
	if m.GetNamespacePipelineByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespacePipelineByIDMock.invocationsDone()
}

// MinimockGetNamespacePipelineByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespacePipelineByIDInspect() {
	for _, e := range m.GetNamespacePipelineByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineByID with params: %#v", *e.params)
		}
	}

	afterGetNamespacePipelineByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespacePipelineByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespacePipelineByIDMock.defaultExpectation != nil && afterGetNamespacePipelineByIDCounter < 1 {
		if m.GetNamespacePipelineByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetNamespacePipelineByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineByID with params: %#v", *m.GetNamespacePipelineByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespacePipelineByID != nil && afterGetNamespacePipelineByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetNamespacePipelineByID")
	}

	if !m.GetNamespacePipelineByIDMock.invocationsDone() && afterGetNamespacePipelineByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespacePipelineByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespacePipelineByIDMock.expectedInvocations), afterGetNamespacePipelineByIDCounter)
	}
}

type mRepositoryMockGetNamespacePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespacePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockGetNamespacePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockGetNamespacePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetNamespacePipelineReleaseByIDExpectation specifies expectation struct of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetNamespacePipelineReleaseByIDParams
	paramPtrs *RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs
	results   *RepositoryMockGetNamespacePipelineReleaseByIDResults
	Counter   uint64
}

// RepositoryMockGetNamespacePipelineReleaseByIDParams contains parameters of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
	isBasicView    bool
}

// RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
	isBasicView    *bool
}

// RepositoryMockGetNamespacePipelineReleaseByIDResults contains results of the Repository.GetNamespacePipelineReleaseByID
type RepositoryMockGetNamespacePipelineReleaseByIDResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Optional() *mRepositoryMockGetNamespacePipelineReleaseByID {
	mmGetNamespacePipelineReleaseByID.optional = true
	return mmGetNamespacePipelineReleaseByID
}

// Expect sets up expected params for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmGetNamespacePipelineReleaseByID.defaultExpectation.params = &RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}
	for _, e := range mmGetNamespacePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmGetNamespacePipelineReleaseByID.defaultExpectation.params) {
			mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespacePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmGetNamespacePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetNamespacePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmGetNamespacePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmGetNamespacePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id

	return mmGetNamespacePipelineReleaseByID
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{}
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetNamespacePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool)) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if mmGetNamespacePipelineReleaseByID.mock.inspectFuncGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespacePipelineReleaseByID")
	}

	mmGetNamespacePipelineReleaseByID.mock.inspectFuncGetNamespacePipelineReleaseByID = f

	return mmGetNamespacePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.GetNamespacePipelineReleaseByID
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Return(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmGetNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmGetNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{mock: mmGetNamespacePipelineReleaseByID.mock}
	}
	mmGetNamespacePipelineReleaseByID.defaultExpectation.results = &RepositoryMockGetNamespacePipelineReleaseByIDResults{pp1, err}
	return mmGetNamespacePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.GetNamespacePipelineReleaseByID method
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error)) *RepositoryMock {
	if mmGetNamespacePipelineReleaseByID.defaultExpectation != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespacePipelineReleaseByID method")
	}

	if len(mmGetNamespacePipelineReleaseByID.expectations) > 0 {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespacePipelineReleaseByID method")
	}

	mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID = f
	return mmGetNamespacePipelineReleaseByID.mock
}

// When sets expectation for the Repository.GetNamespacePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) *RepositoryMockGetNamespacePipelineReleaseByIDExpectation {
	if mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.GetNamespacePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespacePipelineReleaseByIDExpectation{
		mock:   mmGetNamespacePipelineReleaseByID.mock,
		params: &RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView},
	}
	mmGetNamespacePipelineReleaseByID.expectations = append(mmGetNamespacePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespacePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespacePipelineReleaseByIDExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespacePipelineReleaseByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespacePipelineReleaseByID should be invoked
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Times(n uint64) *mRepositoryMockGetNamespacePipelineReleaseByID {
	if n == 0 {
		mmGetNamespacePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespacePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespacePipelineReleaseByID.expectedInvocations, n)
	return mmGetNamespacePipelineReleaseByID
}

func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) invocationsDone() bool {
	if len(mmGetNamespacePipelineReleaseByID.expectations) == 0 && mmGetNamespacePipelineReleaseByID.defaultExpectation == nil && mmGetNamespacePipelineReleaseByID.mock.funcGetNamespacePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.mock.afterGetNamespacePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespacePipelineReleaseByID implements repository.Repository
func (mmGetNamespacePipelineReleaseByID *RepositoryMock) GetNamespacePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, isBasicView bool) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmGetNamespacePipelineReleaseByID.beforeGetNamespacePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespacePipelineReleaseByID.afterGetNamespacePipelineReleaseByIDCounter, 1)

	if mmGetNamespacePipelineReleaseByID.inspectFuncGetNamespacePipelineReleaseByID != nil {
		mmGetNamespacePipelineReleaseByID.inspectFuncGetNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, isBasicView)
	}

	mm_params := RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}

	// Record call args
	mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.mutex.Lock()
	mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.callArgs = append(mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.callArgs, &mm_params)
	mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, isBasicView}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.GetNamespacePipelineReleaseByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespacePipelineReleaseByID.GetNamespacePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespacePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.GetNamespacePipelineReleaseByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetNamespacePipelineReleaseByID.funcGetNamespacePipelineReleaseByID != nil {
		return mmGetNamespacePipelineReleaseByID.funcGetNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, isBasicView)
	}
	mmGetNamespacePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespacePipelineReleaseByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, isBasicView)
	return
}

// GetNamespacePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.GetNamespacePipelineReleaseByID invocations
func (mmGetNamespacePipelineReleaseByID *RepositoryMock) GetNamespacePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.afterGetNamespacePipelineReleaseByIDCounter)
}

// GetNamespacePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.GetNamespacePipelineReleaseByID invocations
func (mmGetNamespacePipelineReleaseByID *RepositoryMock) GetNamespacePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespacePipelineReleaseByID.beforeGetNamespacePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespacePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespacePipelineReleaseByID *mRepositoryMockGetNamespacePipelineReleaseByID) Calls() []*RepositoryMockGetNamespacePipelineReleaseByIDParams {
	mmGetNamespacePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespacePipelineReleaseByIDParams, len(mmGetNamespacePipelineReleaseByID.callArgs))
	copy(argCopy, mmGetNamespacePipelineReleaseByID.callArgs)

	mmGetNamespacePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespacePipelineReleaseByIDDone returns true if the count of the GetNamespacePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespacePipelineReleaseByIDDone() bool {
	if m.GetNamespacePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespacePipelineReleaseByIDMock.invocationsDone()
}

// MinimockGetNamespacePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespacePipelineReleaseByIDInspect() {
	for _, e := range m.GetNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID with params: %#v", *e.params)
		}
	}

	afterGetNamespacePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespacePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespacePipelineReleaseByIDMock.defaultExpectation != nil && afterGetNamespacePipelineReleaseByIDCounter < 1 {
		if m.GetNamespacePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID with params: %#v", *m.GetNamespacePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespacePipelineReleaseByID != nil && afterGetNamespacePipelineReleaseByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetNamespacePipelineReleaseByID")
	}

	if !m.GetNamespacePipelineReleaseByIDMock.invocationsDone() && afterGetNamespacePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespacePipelineReleaseByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespacePipelineReleaseByIDMock.expectedInvocations), afterGetNamespacePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockGetNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockGetNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockGetNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetNamespaceSecretByIDExpectation specifies expectation struct of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetNamespaceSecretByIDParams
	paramPtrs *RepositoryMockGetNamespaceSecretByIDParamPtrs
	results   *RepositoryMockGetNamespaceSecretByIDResults
	Counter   uint64
}

// RepositoryMockGetNamespaceSecretByIDParams contains parameters of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockGetNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockGetNamespaceSecretByIDResults contains results of the Repository.GetNamespaceSecretByID
type RepositoryMockGetNamespaceSecretByIDResults struct {
	sp1 *datamodel.Secret
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Optional() *mRepositoryMockGetNamespaceSecretByID {
	mmGetNamespaceSecretByID.optional = true
	return mmGetNamespaceSecretByID
}

// Expect sets up expected params for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceSecretByID.defaultExpectation.params = &RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}
	for _, e := range mmGetNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceSecretByID.defaultExpectation.params) {
			mmGetNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmGetNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{}
	}

	if mmGetNamespaceSecretByID.defaultExpectation.params != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Expect")
	}

	if mmGetNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceSecretByIDParamPtrs{}
	}
	mmGetNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id

	return mmGetNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockGetNamespaceSecretByID {
	if mmGetNamespaceSecretByID.mock.inspectFuncGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespaceSecretByID")
	}

	mmGetNamespaceSecretByID.mock.inspectFuncGetNamespaceSecretByID = f

	return mmGetNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.GetNamespaceSecretByID
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Return(sp1 *datamodel.Secret, err error) *RepositoryMock {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	if mmGetNamespaceSecretByID.defaultExpectation == nil {
		mmGetNamespaceSecretByID.defaultExpectation = &RepositoryMockGetNamespaceSecretByIDExpectation{mock: mmGetNamespaceSecretByID.mock}
	}
	mmGetNamespaceSecretByID.defaultExpectation.results = &RepositoryMockGetNamespaceSecretByIDResults{sp1, err}
	return mmGetNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.GetNamespaceSecretByID method
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error)) *RepositoryMock {
	if mmGetNamespaceSecretByID.defaultExpectation != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespaceSecretByID method")
	}

	if len(mmGetNamespaceSecretByID.expectations) > 0 {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespaceSecretByID method")
	}

	mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID = f
	return mmGetNamespaceSecretByID.mock
}

// When sets expectation for the Repository.GetNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockGetNamespaceSecretByIDExpectation {
	if mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.GetNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespaceSecretByIDExpectation{
		mock:   mmGetNamespaceSecretByID.mock,
		params: &RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id},
	}
	mmGetNamespaceSecretByID.expectations = append(mmGetNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespaceSecretByIDExpectation) Then(sp1 *datamodel.Secret, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespaceSecretByIDResults{sp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespaceSecretByID should be invoked
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Times(n uint64) *mRepositoryMockGetNamespaceSecretByID {
	if n == 0 {
		mmGetNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceSecretByID.expectedInvocations, n)
	return mmGetNamespaceSecretByID
}

func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) invocationsDone() bool {
	if len(mmGetNamespaceSecretByID.expectations) == 0 && mmGetNamespaceSecretByID.defaultExpectation == nil && mmGetNamespaceSecretByID.mock.funcGetNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.mock.afterGetNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceSecretByID implements repository.Repository
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string) (sp1 *datamodel.Secret, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceSecretByID.beforeGetNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceSecretByID.afterGetNamespaceSecretByIDCounter, 1)

	if mmGetNamespaceSecretByID.inspectFuncGetNamespaceSecretByID != nil {
		mmGetNamespaceSecretByID.inspectFuncGetNamespaceSecretByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.mutex.Lock()
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.callArgs = append(mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.callArgs, &mm_params)
	mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespaceSecretByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceSecretByID.t.Errorf("RepositoryMock.GetNamespaceSecretByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceSecretByID.GetNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.GetNamespaceSecretByID")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetNamespaceSecretByID.funcGetNamespaceSecretByID != nil {
		return mmGetNamespaceSecretByID.funcGetNamespaceSecretByID(ctx, ownerPermalink, id)
	}
	mmGetNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespaceSecretByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// GetNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.GetNamespaceSecretByID invocations
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.afterGetNamespaceSecretByIDCounter)
}

// GetNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.GetNamespaceSecretByID invocations
func (mmGetNamespaceSecretByID *RepositoryMock) GetNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceSecretByID.beforeGetNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceSecretByID *mRepositoryMockGetNamespaceSecretByID) Calls() []*RepositoryMockGetNamespaceSecretByIDParams {
	mmGetNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespaceSecretByIDParams, len(mmGetNamespaceSecretByID.callArgs))
	copy(argCopy, mmGetNamespaceSecretByID.callArgs)

	mmGetNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceSecretByIDDone returns true if the count of the GetNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespaceSecretByIDDone() bool {
	if m.GetNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceSecretByIDMock.invocationsDone()
}

// MinimockGetNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespaceSecretByIDInspect() {
	for _, e := range m.GetNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID with params: %#v", *e.params)
		}
	}

	afterGetNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceSecretByIDMock.defaultExpectation != nil && afterGetNamespaceSecretByIDCounter < 1 {
		if m.GetNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetNamespaceSecretByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceSecretByID with params: %#v", *m.GetNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceSecretByID != nil && afterGetNamespaceSecretByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetNamespaceSecretByID")
	}

	if !m.GetNamespaceSecretByIDMock.invocationsDone() && afterGetNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespaceSecretByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceSecretByIDMock.expectedInvocations), afterGetNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockGetPipelineByIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByIDAdminExpectation
	expectations       []*RepositoryMockGetPipelineByIDAdminExpectation

	callArgs []*RepositoryMockGetPipelineByIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetPipelineByIDAdminExpectation specifies expectation struct of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetPipelineByIDAdminParams
	paramPtrs *RepositoryMockGetPipelineByIDAdminParamPtrs
	results   *RepositoryMockGetPipelineByIDAdminResults
	Counter   uint64
}

// RepositoryMockGetPipelineByIDAdminParams contains parameters of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminParams struct {
	ctx           context.Context
	id            string
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByIDAdminParamPtrs contains pointers to parameters of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminParamPtrs struct {
	ctx           *context.Context
	id            *string
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByIDAdminResults contains results of the Repository.GetPipelineByIDAdmin
type RepositoryMockGetPipelineByIDAdminResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Optional() *mRepositoryMockGetPipelineByIDAdmin {
	mmGetPipelineByIDAdmin.optional = true
	return mmGetPipelineByIDAdmin
}

// Expect sets up expected params for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Expect(ctx context.Context, id string, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetPipelineByIDAdmin.defaultExpectation.params = &RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}
	for _, e := range mmGetPipelineByIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetPipelineByIDAdmin.defaultExpectation.params) {
			mmGetPipelineByIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetPipelineByIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPipelineByIDAdmin
}

// ExpectIdParam2 sets up expected param id for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectIdParam2(id string) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.id = &id

	return mmGetPipelineByIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetPipelineByIDAdmin
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{}
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByIDAdminParamPtrs{}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases

	return mmGetPipelineByIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Inspect(f func(ctx context.Context, id string, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByIDAdmin {
	if mmGetPipelineByIDAdmin.mock.inspectFuncGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByIDAdmin")
	}

	mmGetPipelineByIDAdmin.mock.inspectFuncGetPipelineByIDAdmin = f

	return mmGetPipelineByIDAdmin
}

// Return sets up results that will be returned by Repository.GetPipelineByIDAdmin
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByIDAdmin.defaultExpectation == nil {
		mmGetPipelineByIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByIDAdminExpectation{mock: mmGetPipelineByIDAdmin.mock}
	}
	mmGetPipelineByIDAdmin.defaultExpectation.results = &RepositoryMockGetPipelineByIDAdminResults{pp1, err}
	return mmGetPipelineByIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetPipelineByIDAdmin method
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Set(f func(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByIDAdmin.defaultExpectation != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByIDAdmin method")
	}

	if len(mmGetPipelineByIDAdmin.expectations) > 0 {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByIDAdmin method")
	}

	mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin = f
	return mmGetPipelineByIDAdmin.mock
}

// When sets expectation for the Repository.GetPipelineByIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) When(ctx context.Context, id string, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByIDAdminExpectation {
	if mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByIDAdminExpectation{
		mock:   mmGetPipelineByIDAdmin.mock,
		params: &RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases},
	}
	mmGetPipelineByIDAdmin.expectations = append(mmGetPipelineByIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByIDAdminExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByIDAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByIDAdmin should be invoked
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Times(n uint64) *mRepositoryMockGetPipelineByIDAdmin {
	if n == 0 {
		mmGetPipelineByIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByIDAdmin.expectedInvocations, n)
	return mmGetPipelineByIDAdmin
}

func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) invocationsDone() bool {
	if len(mmGetPipelineByIDAdmin.expectations) == 0 && mmGetPipelineByIDAdmin.defaultExpectation == nil && mmGetPipelineByIDAdmin.mock.funcGetPipelineByIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.mock.afterGetPipelineByIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByIDAdmin implements repository.Repository
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdmin(ctx context.Context, id string, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.beforeGetPipelineByIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.afterGetPipelineByIDAdminCounter, 1)

	if mmGetPipelineByIDAdmin.inspectFuncGetPipelineByIDAdmin != nil {
		mmGetPipelineByIDAdmin.inspectFuncGetPipelineByIDAdmin(ctx, id, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.mutex.Lock()
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.callArgs = append(mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.callArgs, &mm_params)
	mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.mutex.Unlock()

	for _, e := range mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByIDAdminParams{ctx, id, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameter embedReleases, want: %#v, got: %#v%s\n", *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByIDAdmin.t.Errorf("RepositoryMock.GetPipelineByIDAdmin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByIDAdmin.GetPipelineByIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetPipelineByIDAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByIDAdmin.funcGetPipelineByIDAdmin != nil {
		return mmGetPipelineByIDAdmin.funcGetPipelineByIDAdmin(ctx, id, isBasicView, embedReleases)
	}
	mmGetPipelineByIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByIDAdmin. %v %v %v %v", ctx, id, isBasicView, embedReleases)
	return
}

// GetPipelineByIDAdminAfterCounter returns a count of finished RepositoryMock.GetPipelineByIDAdmin invocations
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.afterGetPipelineByIDAdminCounter)
}

// GetPipelineByIDAdminBeforeCounter returns a count of RepositoryMock.GetPipelineByIDAdmin invocations
func (mmGetPipelineByIDAdmin *RepositoryMock) GetPipelineByIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByIDAdmin.beforeGetPipelineByIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByIDAdmin *mRepositoryMockGetPipelineByIDAdmin) Calls() []*RepositoryMockGetPipelineByIDAdminParams {
	mmGetPipelineByIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByIDAdminParams, len(mmGetPipelineByIDAdmin.callArgs))
	copy(argCopy, mmGetPipelineByIDAdmin.callArgs)

	mmGetPipelineByIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByIDAdminDone returns true if the count of the GetPipelineByIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByIDAdminDone() bool {
	if m.GetPipelineByIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByIDAdminMock.invocationsDone()
}

// MinimockGetPipelineByIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByIDAdminInspect() {
	for _, e := range m.GetPipelineByIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin with params: %#v", *e.params)
		}
	}

	afterGetPipelineByIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByIDAdminMock.defaultExpectation != nil && afterGetPipelineByIDAdminCounter < 1 {
		if m.GetPipelineByIDAdminMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetPipelineByIDAdmin")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByIDAdmin with params: %#v", *m.GetPipelineByIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByIDAdmin != nil && afterGetPipelineByIDAdminCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetPipelineByIDAdmin")
	}

	if !m.GetPipelineByIDAdminMock.invocationsDone() && afterGetPipelineByIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByIDAdmin but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByIDAdminMock.expectedInvocations), afterGetPipelineByIDAdminCounter)
	}
}

type mRepositoryMockGetPipelineByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByUIDExpectation
	expectations       []*RepositoryMockGetPipelineByUIDExpectation

	callArgs []*RepositoryMockGetPipelineByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetPipelineByUIDExpectation specifies expectation struct of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetPipelineByUIDParams
	paramPtrs *RepositoryMockGetPipelineByUIDParamPtrs
	results   *RepositoryMockGetPipelineByUIDResults
	Counter   uint64
}

// RepositoryMockGetPipelineByUIDParams contains parameters of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByUIDParamPtrs contains pointers to parameters of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByUIDResults contains results of the Repository.GetPipelineByUID
type RepositoryMockGetPipelineByUIDResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Optional() *mRepositoryMockGetPipelineByUID {
	mmGetPipelineByUID.optional = true
	return mmGetPipelineByUID
}

// Expect sets up expected params for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by ExpectParams functions")
	}

	mmGetPipelineByUID.defaultExpectation.params = &RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}
	for _, e := range mmGetPipelineByUID.expectations {
		if minimock.Equal(e.params, mmGetPipelineByUID.defaultExpectation.params) {
			mmGetPipelineByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByUID.defaultExpectation.params)
		}
	}

	return mmGetPipelineByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPipelineByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.uid = &uid

	return mmGetPipelineByUID
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetPipelineByUID
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{}
	}

	if mmGetPipelineByUID.defaultExpectation.params != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Expect")
	}

	if mmGetPipelineByUID.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDParamPtrs{}
	}
	mmGetPipelineByUID.defaultExpectation.paramPtrs.embedReleases = &embedReleases

	return mmGetPipelineByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByUID {
	if mmGetPipelineByUID.mock.inspectFuncGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByUID")
	}

	mmGetPipelineByUID.mock.inspectFuncGetPipelineByUID = f

	return mmGetPipelineByUID
}

// Return sets up results that will be returned by Repository.GetPipelineByUID
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	if mmGetPipelineByUID.defaultExpectation == nil {
		mmGetPipelineByUID.defaultExpectation = &RepositoryMockGetPipelineByUIDExpectation{mock: mmGetPipelineByUID.mock}
	}
	mmGetPipelineByUID.defaultExpectation.results = &RepositoryMockGetPipelineByUIDResults{pp1, err}
	return mmGetPipelineByUID.mock
}

// Set uses given function f to mock the Repository.GetPipelineByUID method
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByUID.defaultExpectation != nil {
		mmGetPipelineByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByUID method")
	}

	if len(mmGetPipelineByUID.expectations) > 0 {
		mmGetPipelineByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByUID method")
	}

	mmGetPipelineByUID.mock.funcGetPipelineByUID = f
	return mmGetPipelineByUID.mock
}

// When sets expectation for the Repository.GetPipelineByUID which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) When(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByUIDExpectation {
	if mmGetPipelineByUID.mock.funcGetPipelineByUID != nil {
		mmGetPipelineByUID.mock.t.Fatalf("RepositoryMock.GetPipelineByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByUIDExpectation{
		mock:   mmGetPipelineByUID.mock,
		params: &RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases},
	}
	mmGetPipelineByUID.expectations = append(mmGetPipelineByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByUIDExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByUIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByUID should be invoked
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Times(n uint64) *mRepositoryMockGetPipelineByUID {
	if n == 0 {
		mmGetPipelineByUID.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByUID.expectedInvocations, n)
	return mmGetPipelineByUID
}

func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) invocationsDone() bool {
	if len(mmGetPipelineByUID.expectations) == 0 && mmGetPipelineByUID.defaultExpectation == nil && mmGetPipelineByUID.mock.funcGetPipelineByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUID.mock.afterGetPipelineByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByUID implements repository.Repository
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUID(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByUID.beforeGetPipelineByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByUID.afterGetPipelineByUIDCounter, 1)

	if mmGetPipelineByUID.inspectFuncGetPipelineByUID != nil {
		mmGetPipelineByUID.inspectFuncGetPipelineByUID(ctx, uid, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByUID.GetPipelineByUIDMock.mutex.Lock()
	mmGetPipelineByUID.GetPipelineByUIDMock.callArgs = append(mmGetPipelineByUID.GetPipelineByUIDMock.callArgs, &mm_params)
	mmGetPipelineByUID.GetPipelineByUIDMock.mutex.Unlock()

	for _, e := range mmGetPipelineByUID.GetPipelineByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByUIDParams{ctx, uid, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameter embedReleases, want: %#v, got: %#v%s\n", *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByUID.t.Errorf("RepositoryMock.GetPipelineByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByUID.GetPipelineByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByUID.t.Fatal("No results are set for the RepositoryMock.GetPipelineByUID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByUID.funcGetPipelineByUID != nil {
		return mmGetPipelineByUID.funcGetPipelineByUID(ctx, uid, isBasicView, embedReleases)
	}
	mmGetPipelineByUID.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByUID. %v %v %v %v", ctx, uid, isBasicView, embedReleases)
	return
}

// GetPipelineByUIDAfterCounter returns a count of finished RepositoryMock.GetPipelineByUID invocations
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUID.afterGetPipelineByUIDCounter)
}

// GetPipelineByUIDBeforeCounter returns a count of RepositoryMock.GetPipelineByUID invocations
func (mmGetPipelineByUID *RepositoryMock) GetPipelineByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUID.beforeGetPipelineByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByUID *mRepositoryMockGetPipelineByUID) Calls() []*RepositoryMockGetPipelineByUIDParams {
	mmGetPipelineByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByUIDParams, len(mmGetPipelineByUID.callArgs))
	copy(argCopy, mmGetPipelineByUID.callArgs)

	mmGetPipelineByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByUIDDone returns true if the count of the GetPipelineByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByUIDDone() bool {
	if m.GetPipelineByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByUIDMock.invocationsDone()
}

// MinimockGetPipelineByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByUIDInspect() {
	for _, e := range m.GetPipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID with params: %#v", *e.params)
		}
	}

	afterGetPipelineByUIDCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByUIDMock.defaultExpectation != nil && afterGetPipelineByUIDCounter < 1 {
		if m.GetPipelineByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetPipelineByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUID with params: %#v", *m.GetPipelineByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByUID != nil && afterGetPipelineByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetPipelineByUID")
	}

	if !m.GetPipelineByUIDMock.invocationsDone() && afterGetPipelineByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByUIDMock.expectedInvocations), afterGetPipelineByUIDCounter)
	}
}

type mRepositoryMockGetPipelineByUIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetPipelineByUIDAdminExpectation
	expectations       []*RepositoryMockGetPipelineByUIDAdminExpectation

	callArgs []*RepositoryMockGetPipelineByUIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetPipelineByUIDAdminExpectation specifies expectation struct of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetPipelineByUIDAdminParams
	paramPtrs *RepositoryMockGetPipelineByUIDAdminParamPtrs
	results   *RepositoryMockGetPipelineByUIDAdminResults
	Counter   uint64
}

// RepositoryMockGetPipelineByUIDAdminParams contains parameters of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	embedReleases bool
}

// RepositoryMockGetPipelineByUIDAdminParamPtrs contains pointers to parameters of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	embedReleases *bool
}

// RepositoryMockGetPipelineByUIDAdminResults contains results of the Repository.GetPipelineByUIDAdmin
type RepositoryMockGetPipelineByUIDAdminResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Optional() *mRepositoryMockGetPipelineByUIDAdmin {
	mmGetPipelineByUIDAdmin.optional = true
	return mmGetPipelineByUIDAdmin
}

// Expect sets up expected params for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetPipelineByUIDAdmin.defaultExpectation.params = &RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases}
	for _, e := range mmGetPipelineByUIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetPipelineByUIDAdmin.defaultExpectation.params) {
			mmGetPipelineByUIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPipelineByUIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetPipelineByUIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetPipelineByUIDAdmin
}

// ExpectUidParam2 sets up expected param uid for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.uid = &uid

	return mmGetPipelineByUIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetPipelineByUIDAdmin
}

// ExpectEmbedReleasesParam4 sets up expected param embedReleases for Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) ExpectEmbedReleasesParam4(embedReleases bool) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{}
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.params != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Expect")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetPipelineByUIDAdminParamPtrs{}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases

	return mmGetPipelineByUIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool)) *mRepositoryMockGetPipelineByUIDAdmin {
	if mmGetPipelineByUIDAdmin.mock.inspectFuncGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetPipelineByUIDAdmin")
	}

	mmGetPipelineByUIDAdmin.mock.inspectFuncGetPipelineByUIDAdmin = f

	return mmGetPipelineByUIDAdmin
}

// Return sets up results that will be returned by Repository.GetPipelineByUIDAdmin
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Return(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	if mmGetPipelineByUIDAdmin.defaultExpectation == nil {
		mmGetPipelineByUIDAdmin.defaultExpectation = &RepositoryMockGetPipelineByUIDAdminExpectation{mock: mmGetPipelineByUIDAdmin.mock}
	}
	mmGetPipelineByUIDAdmin.defaultExpectation.results = &RepositoryMockGetPipelineByUIDAdminResults{pp1, err}
	return mmGetPipelineByUIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetPipelineByUIDAdmin method
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error)) *RepositoryMock {
	if mmGetPipelineByUIDAdmin.defaultExpectation != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetPipelineByUIDAdmin method")
	}

	if len(mmGetPipelineByUIDAdmin.expectations) > 0 {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetPipelineByUIDAdmin method")
	}

	mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin = f
	return mmGetPipelineByUIDAdmin.mock
}

// When sets expectation for the Repository.GetPipelineByUIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) When(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) *RepositoryMockGetPipelineByUIDAdminExpectation {
	if mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetPipelineByUIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetPipelineByUIDAdminExpectation{
		mock:   mmGetPipelineByUIDAdmin.mock,
		params: &RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases},
	}
	mmGetPipelineByUIDAdmin.expectations = append(mmGetPipelineByUIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetPipelineByUIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetPipelineByUIDAdminExpectation) Then(pp1 *datamodel.Pipeline, err error) *RepositoryMock {
	e.results = &RepositoryMockGetPipelineByUIDAdminResults{pp1, err}
	return e.mock
}

// Times sets number of times Repository.GetPipelineByUIDAdmin should be invoked
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Times(n uint64) *mRepositoryMockGetPipelineByUIDAdmin {
	if n == 0 {
		mmGetPipelineByUIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetPipelineByUIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPipelineByUIDAdmin.expectedInvocations, n)
	return mmGetPipelineByUIDAdmin
}

func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) invocationsDone() bool {
	if len(mmGetPipelineByUIDAdmin.expectations) == 0 && mmGetPipelineByUIDAdmin.defaultExpectation == nil && mmGetPipelineByUIDAdmin.mock.funcGetPipelineByUIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.mock.afterGetPipelineByUIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPipelineByUIDAdmin implements repository.Repository
func (mmGetPipelineByUIDAdmin *RepositoryMock) GetPipelineByUIDAdmin(ctx context.Context, uid uuid.UUID, isBasicView bool, embedReleases bool) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmGetPipelineByUIDAdmin.beforeGetPipelineByUIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPipelineByUIDAdmin.afterGetPipelineByUIDAdminCounter, 1)

	if mmGetPipelineByUIDAdmin.inspectFuncGetPipelineByUIDAdmin != nil {
		mmGetPipelineByUIDAdmin.inspectFuncGetPipelineByUIDAdmin(ctx, uid, isBasicView, embedReleases)
	}

	mm_params := RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases}

	// Record call args
	mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.mutex.Lock()
	mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.callArgs = append(mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.callArgs, &mm_params)
	mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.mutex.Unlock()

	for _, e := range mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetPipelineByUIDAdminParams{ctx, uid, isBasicView, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameter embedReleases, want: %#v, got: %#v%s\n", *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPipelineByUIDAdmin.t.Errorf("RepositoryMock.GetPipelineByUIDAdmin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPipelineByUIDAdmin.GetPipelineByUIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPipelineByUIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetPipelineByUIDAdmin")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPipelineByUIDAdmin.funcGetPipelineByUIDAdmin != nil {
		return mmGetPipelineByUIDAdmin.funcGetPipelineByUIDAdmin(ctx, uid, isBasicView, embedReleases)
	}
	mmGetPipelineByUIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetPipelineByUIDAdmin. %v %v %v %v", ctx, uid, isBasicView, embedReleases)
	return
}

// GetPipelineByUIDAdminAfterCounter returns a count of finished RepositoryMock.GetPipelineByUIDAdmin invocations
func (mmGetPipelineByUIDAdmin *RepositoryMock) GetPipelineByUIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.afterGetPipelineByUIDAdminCounter)
}

// GetPipelineByUIDAdminBeforeCounter returns a count of RepositoryMock.GetPipelineByUIDAdmin invocations
func (mmGetPipelineByUIDAdmin *RepositoryMock) GetPipelineByUIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPipelineByUIDAdmin.beforeGetPipelineByUIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetPipelineByUIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPipelineByUIDAdmin *mRepositoryMockGetPipelineByUIDAdmin) Calls() []*RepositoryMockGetPipelineByUIDAdminParams {
	mmGetPipelineByUIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetPipelineByUIDAdminParams, len(mmGetPipelineByUIDAdmin.callArgs))
	copy(argCopy, mmGetPipelineByUIDAdmin.callArgs)

	mmGetPipelineByUIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetPipelineByUIDAdminDone returns true if the count of the GetPipelineByUIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetPipelineByUIDAdminDone() bool {
	if m.GetPipelineByUIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPipelineByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPipelineByUIDAdminMock.invocationsDone()
}

// MinimockGetPipelineByUIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetPipelineByUIDAdminInspect() {
	for _, e := range m.GetPipelineByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUIDAdmin with params: %#v", *e.params)
		}
	}

	afterGetPipelineByUIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetPipelineByUIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPipelineByUIDAdminMock.defaultExpectation != nil && afterGetPipelineByUIDAdminCounter < 1 {
		if m.GetPipelineByUIDAdminMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetPipelineByUIDAdmin")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetPipelineByUIDAdmin with params: %#v", *m.GetPipelineByUIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPipelineByUIDAdmin != nil && afterGetPipelineByUIDAdminCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetPipelineByUIDAdmin")
	}

	if !m.GetPipelineByUIDAdminMock.invocationsDone() && afterGetPipelineByUIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetPipelineByUIDAdmin but found %d calls",
			mm_atomic.LoadUint64(&m.GetPipelineByUIDAdminMock.expectedInvocations), afterGetPipelineByUIDAdminCounter)
	}
}

type mRepositoryMockListComponentDefinitionUIDs struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListComponentDefinitionUIDsExpectation
	expectations       []*RepositoryMockListComponentDefinitionUIDsExpectation

	callArgs []*RepositoryMockListComponentDefinitionUIDsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListComponentDefinitionUIDsExpectation specifies expectation struct of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListComponentDefinitionUIDsParams
	paramPtrs *RepositoryMockListComponentDefinitionUIDsParamPtrs
	results   *RepositoryMockListComponentDefinitionUIDsResults
	Counter   uint64
}

// RepositoryMockListComponentDefinitionUIDsParams contains parameters of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsParams struct {
	ctx context.Context
	l1  mm_repository.ListComponentDefinitionsParams
}

// RepositoryMockListComponentDefinitionUIDsParamPtrs contains pointers to parameters of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsParamPtrs struct {
	ctx *context.Context
	l1  *mm_repository.ListComponentDefinitionsParams
}

// RepositoryMockListComponentDefinitionUIDsResults contains results of the Repository.ListComponentDefinitionUIDs
type RepositoryMockListComponentDefinitionUIDsResults struct {
	uids      []*datamodel.ComponentDefinition
	totalSize int64
	err       error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Optional() *mRepositoryMockListComponentDefinitionUIDs {
	mmListComponentDefinitionUIDs.optional = true
	return mmListComponentDefinitionUIDs
}

// Expect sets up expected params for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Expect(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by ExpectParams functions")
	}

	mmListComponentDefinitionUIDs.defaultExpectation.params = &RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}
	for _, e := range mmListComponentDefinitionUIDs.expectations {
		if minimock.Equal(e.params, mmListComponentDefinitionUIDs.defaultExpectation.params) {
			mmListComponentDefinitionUIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListComponentDefinitionUIDs.defaultExpectation.params)
		}
	}

	return mmListComponentDefinitionUIDs
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.params != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Expect")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs == nil {
		mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs = &RepositoryMockListComponentDefinitionUIDsParamPtrs{}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListComponentDefinitionUIDs
}

// ExpectL1Param2 sets up expected param l1 for Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) ExpectL1Param2(l1 mm_repository.ListComponentDefinitionsParams) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{}
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.params != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Expect")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs == nil {
		mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs = &RepositoryMockListComponentDefinitionUIDsParamPtrs{}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.paramPtrs.l1 = &l1

	return mmListComponentDefinitionUIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Inspect(f func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams)) *mRepositoryMockListComponentDefinitionUIDs {
	if mmListComponentDefinitionUIDs.mock.inspectFuncListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListComponentDefinitionUIDs")
	}

	mmListComponentDefinitionUIDs.mock.inspectFuncListComponentDefinitionUIDs = f

	return mmListComponentDefinitionUIDs
}

// Return sets up results that will be returned by Repository.ListComponentDefinitionUIDs
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Return(uids []*datamodel.ComponentDefinition, totalSize int64, err error) *RepositoryMock {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	if mmListComponentDefinitionUIDs.defaultExpectation == nil {
		mmListComponentDefinitionUIDs.defaultExpectation = &RepositoryMockListComponentDefinitionUIDsExpectation{mock: mmListComponentDefinitionUIDs.mock}
	}
	mmListComponentDefinitionUIDs.defaultExpectation.results = &RepositoryMockListComponentDefinitionUIDsResults{uids, totalSize, err}
	return mmListComponentDefinitionUIDs.mock
}

// Set uses given function f to mock the Repository.ListComponentDefinitionUIDs method
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Set(f func(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error)) *RepositoryMock {
	if mmListComponentDefinitionUIDs.defaultExpectation != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Default expectation is already set for the Repository.ListComponentDefinitionUIDs method")
	}

	if len(mmListComponentDefinitionUIDs.expectations) > 0 {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Some expectations are already set for the Repository.ListComponentDefinitionUIDs method")
	}

	mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs = f
	return mmListComponentDefinitionUIDs.mock
}

// When sets expectation for the Repository.ListComponentDefinitionUIDs which will trigger the result defined by the following
// Then helper
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) When(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) *RepositoryMockListComponentDefinitionUIDsExpectation {
	if mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("RepositoryMock.ListComponentDefinitionUIDs mock is already set by Set")
	}

	expectation := &RepositoryMockListComponentDefinitionUIDsExpectation{
		mock:   mmListComponentDefinitionUIDs.mock,
		params: &RepositoryMockListComponentDefinitionUIDsParams{ctx, l1},
	}
	mmListComponentDefinitionUIDs.expectations = append(mmListComponentDefinitionUIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListComponentDefinitionUIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListComponentDefinitionUIDsExpectation) Then(uids []*datamodel.ComponentDefinition, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListComponentDefinitionUIDsResults{uids, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListComponentDefinitionUIDs should be invoked
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Times(n uint64) *mRepositoryMockListComponentDefinitionUIDs {
	if n == 0 {
		mmListComponentDefinitionUIDs.mock.t.Fatalf("Times of RepositoryMock.ListComponentDefinitionUIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListComponentDefinitionUIDs.expectedInvocations, n)
	return mmListComponentDefinitionUIDs
}

func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) invocationsDone() bool {
	if len(mmListComponentDefinitionUIDs.expectations) == 0 && mmListComponentDefinitionUIDs.defaultExpectation == nil && mmListComponentDefinitionUIDs.mock.funcListComponentDefinitionUIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.mock.afterListComponentDefinitionUIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListComponentDefinitionUIDs implements repository.Repository
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDs(ctx context.Context, l1 mm_repository.ListComponentDefinitionsParams) (uids []*datamodel.ComponentDefinition, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.beforeListComponentDefinitionUIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.afterListComponentDefinitionUIDsCounter, 1)

	if mmListComponentDefinitionUIDs.inspectFuncListComponentDefinitionUIDs != nil {
		mmListComponentDefinitionUIDs.inspectFuncListComponentDefinitionUIDs(ctx, l1)
	}

	mm_params := RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}

	// Record call args
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.mutex.Lock()
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.callArgs = append(mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.callArgs, &mm_params)
	mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.mutex.Unlock()

	for _, e := range mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.uids, e.results.totalSize, e.results.err
		}
	}

	if mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.params
		mm_want_ptrs := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListComponentDefinitionUIDsParams{ctx, l1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.l1 != nil && !minimock.Equal(*mm_want_ptrs.l1, mm_got.l1) {
				mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameter l1, want: %#v, got: %#v%s\n", *mm_want_ptrs.l1, mm_got.l1, minimock.Diff(*mm_want_ptrs.l1, mm_got.l1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListComponentDefinitionUIDs.t.Errorf("RepositoryMock.ListComponentDefinitionUIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListComponentDefinitionUIDs.ListComponentDefinitionUIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmListComponentDefinitionUIDs.t.Fatal("No results are set for the RepositoryMock.ListComponentDefinitionUIDs")
		}
		return (*mm_results).uids, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListComponentDefinitionUIDs.funcListComponentDefinitionUIDs != nil {
		return mmListComponentDefinitionUIDs.funcListComponentDefinitionUIDs(ctx, l1)
	}
	mmListComponentDefinitionUIDs.t.Fatalf("Unexpected call to RepositoryMock.ListComponentDefinitionUIDs. %v %v", ctx, l1)
	return
}

// ListComponentDefinitionUIDsAfterCounter returns a count of finished RepositoryMock.ListComponentDefinitionUIDs invocations
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.afterListComponentDefinitionUIDsCounter)
}

// ListComponentDefinitionUIDsBeforeCounter returns a count of RepositoryMock.ListComponentDefinitionUIDs invocations
func (mmListComponentDefinitionUIDs *RepositoryMock) ListComponentDefinitionUIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListComponentDefinitionUIDs.beforeListComponentDefinitionUIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListComponentDefinitionUIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListComponentDefinitionUIDs *mRepositoryMockListComponentDefinitionUIDs) Calls() []*RepositoryMockListComponentDefinitionUIDsParams {
	mmListComponentDefinitionUIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockListComponentDefinitionUIDsParams, len(mmListComponentDefinitionUIDs.callArgs))
	copy(argCopy, mmListComponentDefinitionUIDs.callArgs)

	mmListComponentDefinitionUIDs.mutex.RUnlock()

	return argCopy
}

// MinimockListComponentDefinitionUIDsDone returns true if the count of the ListComponentDefinitionUIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListComponentDefinitionUIDsDone() bool {
	if m.ListComponentDefinitionUIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListComponentDefinitionUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListComponentDefinitionUIDsMock.invocationsDone()
}

// MinimockListComponentDefinitionUIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListComponentDefinitionUIDsInspect() {
	for _, e := range m.ListComponentDefinitionUIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs with params: %#v", *e.params)
		}
	}

	afterListComponentDefinitionUIDsCounter := mm_atomic.LoadUint64(&m.afterListComponentDefinitionUIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListComponentDefinitionUIDsMock.defaultExpectation != nil && afterListComponentDefinitionUIDsCounter < 1 {
		if m.ListComponentDefinitionUIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListComponentDefinitionUIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListComponentDefinitionUIDs with params: %#v", *m.ListComponentDefinitionUIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListComponentDefinitionUIDs != nil && afterListComponentDefinitionUIDsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListComponentDefinitionUIDs")
	}

	if !m.ListComponentDefinitionUIDsMock.invocationsDone() && afterListComponentDefinitionUIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListComponentDefinitionUIDs but found %d calls",
			mm_atomic.LoadUint64(&m.ListComponentDefinitionUIDsMock.expectedInvocations), afterListComponentDefinitionUIDsCounter)
	}
}

type mRepositoryMockListNamespacePipelineReleases struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespacePipelineReleasesExpectation
	expectations       []*RepositoryMockListNamespacePipelineReleasesExpectation

	callArgs []*RepositoryMockListNamespacePipelineReleasesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListNamespacePipelineReleasesExpectation specifies expectation struct of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListNamespacePipelineReleasesParams
	paramPtrs *RepositoryMockListNamespacePipelineReleasesParamPtrs
	results   *RepositoryMockListNamespacePipelineReleasesResults
	Counter   uint64
}

// RepositoryMockListNamespacePipelineReleasesParams contains parameters of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	showDeleted    bool
	returnCount    bool
}

// RepositoryMockListNamespacePipelineReleasesParamPtrs contains pointers to parameters of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	showDeleted    *bool
	returnCount    *bool
}

// RepositoryMockListNamespacePipelineReleasesResults contains results of the Repository.ListNamespacePipelineReleases
type RepositoryMockListNamespacePipelineReleasesResults struct {
	ppa1 []*datamodel.PipelineRelease
	i1   int64
	s1   string
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Optional() *mRepositoryMockListNamespacePipelineReleases {
	mmListNamespacePipelineReleases.optional = true
	return mmListNamespacePipelineReleases
}

// Expect sets up expected params for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by ExpectParams functions")
	}

	mmListNamespacePipelineReleases.defaultExpectation.params = &RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}
	for _, e := range mmListNamespacePipelineReleases.expectations {
		if minimock.Equal(e.params, mmListNamespacePipelineReleases.defaultExpectation.params) {
			mmListNamespacePipelineReleases.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespacePipelineReleases.defaultExpectation.params)
		}
	}

	return mmListNamespacePipelineReleases
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListNamespacePipelineReleases
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmListNamespacePipelineReleases
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmListNamespacePipelineReleases
}

// ExpectPageSizeParam4 sets up expected param pageSize for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectPageSizeParam4(pageSize int64) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListNamespacePipelineReleases
}

// ExpectPageTokenParam5 sets up expected param pageToken for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectPageTokenParam5(pageToken string) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListNamespacePipelineReleases
}

// ExpectIsBasicViewParam6 sets up expected param isBasicView for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectIsBasicViewParam6(isBasicView bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmListNamespacePipelineReleases
}

// ExpectFilterParam7 sets up expected param filter for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectFilterParam7(filter filtering.Filter) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.filter = &filter

	return mmListNamespacePipelineReleases
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.showDeleted = &showDeleted

	return mmListNamespacePipelineReleases
}

// ExpectReturnCountParam9 sets up expected param returnCount for Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) ExpectReturnCountParam9(returnCount bool) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{}
	}

	if mmListNamespacePipelineReleases.defaultExpectation.params != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Expect")
	}

	if mmListNamespacePipelineReleases.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelineReleases.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelineReleasesParamPtrs{}
	}
	mmListNamespacePipelineReleases.defaultExpectation.paramPtrs.returnCount = &returnCount

	return mmListNamespacePipelineReleases
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool)) *mRepositoryMockListNamespacePipelineReleases {
	if mmListNamespacePipelineReleases.mock.inspectFuncListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespacePipelineReleases")
	}

	mmListNamespacePipelineReleases.mock.inspectFuncListNamespacePipelineReleases = f

	return mmListNamespacePipelineReleases
}

// Return sets up results that will be returned by Repository.ListNamespacePipelineReleases
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Return(ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	if mmListNamespacePipelineReleases.defaultExpectation == nil {
		mmListNamespacePipelineReleases.defaultExpectation = &RepositoryMockListNamespacePipelineReleasesExpectation{mock: mmListNamespacePipelineReleases.mock}
	}
	mmListNamespacePipelineReleases.defaultExpectation.results = &RepositoryMockListNamespacePipelineReleasesResults{ppa1, i1, s1, err}
	return mmListNamespacePipelineReleases.mock
}

// Set uses given function f to mock the Repository.ListNamespacePipelineReleases method
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListNamespacePipelineReleases.defaultExpectation != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespacePipelineReleases method")
	}

	if len(mmListNamespacePipelineReleases.expectations) > 0 {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespacePipelineReleases method")
	}

	mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases = f
	return mmListNamespacePipelineReleases.mock
}

// When sets expectation for the Repository.ListNamespacePipelineReleases which will trigger the result defined by the following
// Then helper
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) *RepositoryMockListNamespacePipelineReleasesExpectation {
	if mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.mock.t.Fatalf("RepositoryMock.ListNamespacePipelineReleases mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespacePipelineReleasesExpectation{
		mock:   mmListNamespacePipelineReleases.mock,
		params: &RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount},
	}
	mmListNamespacePipelineReleases.expectations = append(mmListNamespacePipelineReleases.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespacePipelineReleases return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespacePipelineReleasesExpectation) Then(ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespacePipelineReleasesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespacePipelineReleases should be invoked
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Times(n uint64) *mRepositoryMockListNamespacePipelineReleases {
	if n == 0 {
		mmListNamespacePipelineReleases.mock.t.Fatalf("Times of RepositoryMock.ListNamespacePipelineReleases mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespacePipelineReleases.expectedInvocations, n)
	return mmListNamespacePipelineReleases
}

func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) invocationsDone() bool {
	if len(mmListNamespacePipelineReleases.expectations) == 0 && mmListNamespacePipelineReleases.defaultExpectation == nil && mmListNamespacePipelineReleases.mock.funcListNamespacePipelineReleases == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.mock.afterListNamespacePipelineReleasesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespacePipelineReleases implements repository.Repository
func (mmListNamespacePipelineReleases *RepositoryMock) ListNamespacePipelineReleases(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, returnCount bool) (ppa1 []*datamodel.PipelineRelease, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListNamespacePipelineReleases.beforeListNamespacePipelineReleasesCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespacePipelineReleases.afterListNamespacePipelineReleasesCounter, 1)

	if mmListNamespacePipelineReleases.inspectFuncListNamespacePipelineReleases != nil {
		mmListNamespacePipelineReleases.inspectFuncListNamespacePipelineReleases(ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	}

	mm_params := RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}

	// Record call args
	mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.mutex.Lock()
	mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.callArgs = append(mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.callArgs, &mm_params)
	mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.mutex.Unlock()

	for _, e := range mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespacePipelineReleasesParams{ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter showDeleted, want: %#v, got: %#v%s\n", *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.returnCount != nil && !minimock.Equal(*mm_want_ptrs.returnCount, mm_got.returnCount) {
				mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameter returnCount, want: %#v, got: %#v%s\n", *mm_want_ptrs.returnCount, mm_got.returnCount, minimock.Diff(*mm_want_ptrs.returnCount, mm_got.returnCount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespacePipelineReleases.t.Errorf("RepositoryMock.ListNamespacePipelineReleases got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespacePipelineReleases.ListNamespacePipelineReleasesMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespacePipelineReleases.t.Fatal("No results are set for the RepositoryMock.ListNamespacePipelineReleases")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListNamespacePipelineReleases.funcListNamespacePipelineReleases != nil {
		return mmListNamespacePipelineReleases.funcListNamespacePipelineReleases(ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	}
	mmListNamespacePipelineReleases.t.Fatalf("Unexpected call to RepositoryMock.ListNamespacePipelineReleases. %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, pageSize, pageToken, isBasicView, filter, showDeleted, returnCount)
	return
}

// ListNamespacePipelineReleasesAfterCounter returns a count of finished RepositoryMock.ListNamespacePipelineReleases invocations
func (mmListNamespacePipelineReleases *RepositoryMock) ListNamespacePipelineReleasesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.afterListNamespacePipelineReleasesCounter)
}

// ListNamespacePipelineReleasesBeforeCounter returns a count of RepositoryMock.ListNamespacePipelineReleases invocations
func (mmListNamespacePipelineReleases *RepositoryMock) ListNamespacePipelineReleasesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelineReleases.beforeListNamespacePipelineReleasesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespacePipelineReleases.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespacePipelineReleases *mRepositoryMockListNamespacePipelineReleases) Calls() []*RepositoryMockListNamespacePipelineReleasesParams {
	mmListNamespacePipelineReleases.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespacePipelineReleasesParams, len(mmListNamespacePipelineReleases.callArgs))
	copy(argCopy, mmListNamespacePipelineReleases.callArgs)

	mmListNamespacePipelineReleases.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespacePipelineReleasesDone returns true if the count of the ListNamespacePipelineReleases invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespacePipelineReleasesDone() bool {
	if m.ListNamespacePipelineReleasesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespacePipelineReleasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespacePipelineReleasesMock.invocationsDone()
}

// MinimockListNamespacePipelineReleasesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespacePipelineReleasesInspect() {
	for _, e := range m.ListNamespacePipelineReleasesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelineReleases with params: %#v", *e.params)
		}
	}

	afterListNamespacePipelineReleasesCounter := mm_atomic.LoadUint64(&m.afterListNamespacePipelineReleasesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespacePipelineReleasesMock.defaultExpectation != nil && afterListNamespacePipelineReleasesCounter < 1 {
		if m.ListNamespacePipelineReleasesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListNamespacePipelineReleases")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelineReleases with params: %#v", *m.ListNamespacePipelineReleasesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespacePipelineReleases != nil && afterListNamespacePipelineReleasesCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListNamespacePipelineReleases")
	}

	if !m.ListNamespacePipelineReleasesMock.invocationsDone() && afterListNamespacePipelineReleasesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespacePipelineReleases but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespacePipelineReleasesMock.expectedInvocations), afterListNamespacePipelineReleasesCounter)
	}
}

type mRepositoryMockListNamespacePipelines struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespacePipelinesExpectation
	expectations       []*RepositoryMockListNamespacePipelinesExpectation

	callArgs []*RepositoryMockListNamespacePipelinesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListNamespacePipelinesExpectation specifies expectation struct of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListNamespacePipelinesParams
	paramPtrs *RepositoryMockListNamespacePipelinesParamPtrs
	results   *RepositoryMockListNamespacePipelinesResults
	Counter   uint64
}

// RepositoryMockListNamespacePipelinesParams contains parameters of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	uidAllowList   []uuid.UUID
	showDeleted    bool
	embedReleases  bool
	order          ordering.OrderBy
}

// RepositoryMockListNamespacePipelinesParamPtrs contains pointers to parameters of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	uidAllowList   *[]uuid.UUID
	showDeleted    *bool
	embedReleases  *bool
	order          *ordering.OrderBy
}

// RepositoryMockListNamespacePipelinesResults contains results of the Repository.ListNamespacePipelines
type RepositoryMockListNamespacePipelinesResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Optional() *mRepositoryMockListNamespacePipelines {
	mmListNamespacePipelines.optional = true
	return mmListNamespacePipelines
}

// Expect sets up expected params for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by ExpectParams functions")
	}

	mmListNamespacePipelines.defaultExpectation.params = &RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}
	for _, e := range mmListNamespacePipelines.expectations {
		if minimock.Equal(e.params, mmListNamespacePipelines.defaultExpectation.params) {
			mmListNamespacePipelines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespacePipelines.defaultExpectation.params)
		}
	}

	return mmListNamespacePipelines
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListNamespacePipelines
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmListNamespacePipelines
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListNamespacePipelines
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListNamespacePipelines
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmListNamespacePipelines
}

// ExpectFilterParam6 sets up expected param filter for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectFilterParam6(filter filtering.Filter) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.filter = &filter

	return mmListNamespacePipelines
}

// ExpectUidAllowListParam7 sets up expected param uidAllowList for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectUidAllowListParam7(uidAllowList []uuid.UUID) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList

	return mmListNamespacePipelines
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.showDeleted = &showDeleted

	return mmListNamespacePipelines
}

// ExpectEmbedReleasesParam9 sets up expected param embedReleases for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectEmbedReleasesParam9(embedReleases bool) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.embedReleases = &embedReleases

	return mmListNamespacePipelines
}

// ExpectOrderParam10 sets up expected param order for Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) ExpectOrderParam10(order ordering.OrderBy) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{}
	}

	if mmListNamespacePipelines.defaultExpectation.params != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Expect")
	}

	if mmListNamespacePipelines.defaultExpectation.paramPtrs == nil {
		mmListNamespacePipelines.defaultExpectation.paramPtrs = &RepositoryMockListNamespacePipelinesParamPtrs{}
	}
	mmListNamespacePipelines.defaultExpectation.paramPtrs.order = &order

	return mmListNamespacePipelines
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)) *mRepositoryMockListNamespacePipelines {
	if mmListNamespacePipelines.mock.inspectFuncListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespacePipelines")
	}

	mmListNamespacePipelines.mock.inspectFuncListNamespacePipelines = f

	return mmListNamespacePipelines
}

// Return sets up results that will be returned by Repository.ListNamespacePipelines
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	if mmListNamespacePipelines.defaultExpectation == nil {
		mmListNamespacePipelines.defaultExpectation = &RepositoryMockListNamespacePipelinesExpectation{mock: mmListNamespacePipelines.mock}
	}
	mmListNamespacePipelines.defaultExpectation.results = &RepositoryMockListNamespacePipelinesResults{ppa1, i1, s1, err}
	return mmListNamespacePipelines.mock
}

// Set uses given function f to mock the Repository.ListNamespacePipelines method
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListNamespacePipelines.defaultExpectation != nil {
		mmListNamespacePipelines.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespacePipelines method")
	}

	if len(mmListNamespacePipelines.expectations) > 0 {
		mmListNamespacePipelines.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespacePipelines method")
	}

	mmListNamespacePipelines.mock.funcListNamespacePipelines = f
	return mmListNamespacePipelines.mock
}

// When sets expectation for the Repository.ListNamespacePipelines which will trigger the result defined by the following
// Then helper
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *RepositoryMockListNamespacePipelinesExpectation {
	if mmListNamespacePipelines.mock.funcListNamespacePipelines != nil {
		mmListNamespacePipelines.mock.t.Fatalf("RepositoryMock.ListNamespacePipelines mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespacePipelinesExpectation{
		mock:   mmListNamespacePipelines.mock,
		params: &RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order},
	}
	mmListNamespacePipelines.expectations = append(mmListNamespacePipelines.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespacePipelines return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespacePipelinesExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespacePipelinesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespacePipelines should be invoked
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Times(n uint64) *mRepositoryMockListNamespacePipelines {
	if n == 0 {
		mmListNamespacePipelines.mock.t.Fatalf("Times of RepositoryMock.ListNamespacePipelines mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespacePipelines.expectedInvocations, n)
	return mmListNamespacePipelines
}

func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) invocationsDone() bool {
	if len(mmListNamespacePipelines.expectations) == 0 && mmListNamespacePipelines.defaultExpectation == nil && mmListNamespacePipelines.mock.funcListNamespacePipelines == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelines.mock.afterListNamespacePipelinesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespacePipelines.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespacePipelines implements repository.Repository
func (mmListNamespacePipelines *RepositoryMock) ListNamespacePipelines(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListNamespacePipelines.beforeListNamespacePipelinesCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespacePipelines.afterListNamespacePipelinesCounter, 1)

	if mmListNamespacePipelines.inspectFuncListNamespacePipelines != nil {
		mmListNamespacePipelines.inspectFuncListNamespacePipelines(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}

	mm_params := RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

	// Record call args
	mmListNamespacePipelines.ListNamespacePipelinesMock.mutex.Lock()
	mmListNamespacePipelines.ListNamespacePipelinesMock.callArgs = append(mmListNamespacePipelines.ListNamespacePipelinesMock.callArgs, &mm_params)
	mmListNamespacePipelines.ListNamespacePipelinesMock.mutex.Unlock()

	for _, e := range mmListNamespacePipelines.ListNamespacePipelinesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespacePipelinesParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter uidAllowList, want: %#v, got: %#v%s\n", *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter showDeleted, want: %#v, got: %#v%s\n", *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter embedReleases, want: %#v, got: %#v%s\n", *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespacePipelines.t.Errorf("RepositoryMock.ListNamespacePipelines got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespacePipelines.ListNamespacePipelinesMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespacePipelines.t.Fatal("No results are set for the RepositoryMock.ListNamespacePipelines")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListNamespacePipelines.funcListNamespacePipelines != nil {
		return mmListNamespacePipelines.funcListNamespacePipelines(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}
	mmListNamespacePipelines.t.Fatalf("Unexpected call to RepositoryMock.ListNamespacePipelines. %v %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	return
}

// ListNamespacePipelinesAfterCounter returns a count of finished RepositoryMock.ListNamespacePipelines invocations
func (mmListNamespacePipelines *RepositoryMock) ListNamespacePipelinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelines.afterListNamespacePipelinesCounter)
}

// ListNamespacePipelinesBeforeCounter returns a count of RepositoryMock.ListNamespacePipelines invocations
func (mmListNamespacePipelines *RepositoryMock) ListNamespacePipelinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespacePipelines.beforeListNamespacePipelinesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespacePipelines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespacePipelines *mRepositoryMockListNamespacePipelines) Calls() []*RepositoryMockListNamespacePipelinesParams {
	mmListNamespacePipelines.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespacePipelinesParams, len(mmListNamespacePipelines.callArgs))
	copy(argCopy, mmListNamespacePipelines.callArgs)

	mmListNamespacePipelines.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespacePipelinesDone returns true if the count of the ListNamespacePipelines invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespacePipelinesDone() bool {
	if m.ListNamespacePipelinesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespacePipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespacePipelinesMock.invocationsDone()
}

// MinimockListNamespacePipelinesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespacePipelinesInspect() {
	for _, e := range m.ListNamespacePipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelines with params: %#v", *e.params)
		}
	}

	afterListNamespacePipelinesCounter := mm_atomic.LoadUint64(&m.afterListNamespacePipelinesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespacePipelinesMock.defaultExpectation != nil && afterListNamespacePipelinesCounter < 1 {
		if m.ListNamespacePipelinesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListNamespacePipelines")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespacePipelines with params: %#v", *m.ListNamespacePipelinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespacePipelines != nil && afterListNamespacePipelinesCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListNamespacePipelines")
	}

	if !m.ListNamespacePipelinesMock.invocationsDone() && afterListNamespacePipelinesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespacePipelines but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespacePipelinesMock.expectedInvocations), afterListNamespacePipelinesCounter)
	}
}

type mRepositoryMockListNamespaceSecrets struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespaceSecretsExpectation
	expectations       []*RepositoryMockListNamespaceSecretsExpectation

	callArgs []*RepositoryMockListNamespaceSecretsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListNamespaceSecretsExpectation specifies expectation struct of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListNamespaceSecretsParams
	paramPtrs *RepositoryMockListNamespaceSecretsParamPtrs
	results   *RepositoryMockListNamespaceSecretsResults
	Counter   uint64
}

// RepositoryMockListNamespaceSecretsParams contains parameters of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	filter         filtering.Filter
}

// RepositoryMockListNamespaceSecretsParamPtrs contains pointers to parameters of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	filter         *filtering.Filter
}

// RepositoryMockListNamespaceSecretsResults contains results of the Repository.ListNamespaceSecrets
type RepositoryMockListNamespaceSecretsResults struct {
	spa1 []*datamodel.Secret
	i1   int64
	s1   string
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Optional() *mRepositoryMockListNamespaceSecrets {
	mmListNamespaceSecrets.optional = true
	return mmListNamespaceSecrets
}

// Expect sets up expected params for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by ExpectParams functions")
	}

	mmListNamespaceSecrets.defaultExpectation.params = &RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}
	for _, e := range mmListNamespaceSecrets.expectations {
		if minimock.Equal(e.params, mmListNamespaceSecrets.defaultExpectation.params) {
			mmListNamespaceSecrets.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceSecrets.defaultExpectation.params)
		}
	}

	return mmListNamespaceSecrets
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListNamespaceSecrets
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmListNamespaceSecrets
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListNamespaceSecrets
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListNamespaceSecrets
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{}
	}

	if mmListNamespaceSecrets.defaultExpectation.params != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Expect")
	}

	if mmListNamespaceSecrets.defaultExpectation.paramPtrs == nil {
		mmListNamespaceSecrets.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceSecretsParamPtrs{}
	}
	mmListNamespaceSecrets.defaultExpectation.paramPtrs.filter = &filter

	return mmListNamespaceSecrets
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter)) *mRepositoryMockListNamespaceSecrets {
	if mmListNamespaceSecrets.mock.inspectFuncListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespaceSecrets")
	}

	mmListNamespaceSecrets.mock.inspectFuncListNamespaceSecrets = f

	return mmListNamespaceSecrets
}

// Return sets up results that will be returned by Repository.ListNamespaceSecrets
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Return(spa1 []*datamodel.Secret, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	if mmListNamespaceSecrets.defaultExpectation == nil {
		mmListNamespaceSecrets.defaultExpectation = &RepositoryMockListNamespaceSecretsExpectation{mock: mmListNamespaceSecrets.mock}
	}
	mmListNamespaceSecrets.defaultExpectation.results = &RepositoryMockListNamespaceSecretsResults{spa1, i1, s1, err}
	return mmListNamespaceSecrets.mock
}

// Set uses given function f to mock the Repository.ListNamespaceSecrets method
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListNamespaceSecrets.defaultExpectation != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespaceSecrets method")
	}

	if len(mmListNamespaceSecrets.expectations) > 0 {
		mmListNamespaceSecrets.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespaceSecrets method")
	}

	mmListNamespaceSecrets.mock.funcListNamespaceSecrets = f
	return mmListNamespaceSecrets.mock
}

// When sets expectation for the Repository.ListNamespaceSecrets which will trigger the result defined by the following
// Then helper
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) *RepositoryMockListNamespaceSecretsExpectation {
	if mmListNamespaceSecrets.mock.funcListNamespaceSecrets != nil {
		mmListNamespaceSecrets.mock.t.Fatalf("RepositoryMock.ListNamespaceSecrets mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespaceSecretsExpectation{
		mock:   mmListNamespaceSecrets.mock,
		params: &RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter},
	}
	mmListNamespaceSecrets.expectations = append(mmListNamespaceSecrets.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespaceSecrets return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespaceSecretsExpectation) Then(spa1 []*datamodel.Secret, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespaceSecretsResults{spa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespaceSecrets should be invoked
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Times(n uint64) *mRepositoryMockListNamespaceSecrets {
	if n == 0 {
		mmListNamespaceSecrets.mock.t.Fatalf("Times of RepositoryMock.ListNamespaceSecrets mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceSecrets.expectedInvocations, n)
	return mmListNamespaceSecrets
}

func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) invocationsDone() bool {
	if len(mmListNamespaceSecrets.expectations) == 0 && mmListNamespaceSecrets.defaultExpectation == nil && mmListNamespaceSecrets.mock.funcListNamespaceSecrets == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceSecrets.mock.afterListNamespaceSecretsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceSecrets.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceSecrets implements repository.Repository
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecrets(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, filter filtering.Filter) (spa1 []*datamodel.Secret, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListNamespaceSecrets.beforeListNamespaceSecretsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceSecrets.afterListNamespaceSecretsCounter, 1)

	if mmListNamespaceSecrets.inspectFuncListNamespaceSecrets != nil {
		mmListNamespaceSecrets.inspectFuncListNamespaceSecrets(ctx, ownerPermalink, pageSize, pageToken, filter)
	}

	mm_params := RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}

	// Record call args
	mmListNamespaceSecrets.ListNamespaceSecretsMock.mutex.Lock()
	mmListNamespaceSecrets.ListNamespaceSecretsMock.callArgs = append(mmListNamespaceSecrets.ListNamespaceSecretsMock.callArgs, &mm_params)
	mmListNamespaceSecrets.ListNamespaceSecretsMock.mutex.Unlock()

	for _, e := range mmListNamespaceSecrets.ListNamespaceSecretsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespaceSecretsParams{ctx, ownerPermalink, pageSize, pageToken, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceSecrets.t.Errorf("RepositoryMock.ListNamespaceSecrets got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceSecrets.ListNamespaceSecretsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceSecrets.t.Fatal("No results are set for the RepositoryMock.ListNamespaceSecrets")
		}
		return (*mm_results).spa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListNamespaceSecrets.funcListNamespaceSecrets != nil {
		return mmListNamespaceSecrets.funcListNamespaceSecrets(ctx, ownerPermalink, pageSize, pageToken, filter)
	}
	mmListNamespaceSecrets.t.Fatalf("Unexpected call to RepositoryMock.ListNamespaceSecrets. %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, filter)
	return
}

// ListNamespaceSecretsAfterCounter returns a count of finished RepositoryMock.ListNamespaceSecrets invocations
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecretsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceSecrets.afterListNamespaceSecretsCounter)
}

// ListNamespaceSecretsBeforeCounter returns a count of RepositoryMock.ListNamespaceSecrets invocations
func (mmListNamespaceSecrets *RepositoryMock) ListNamespaceSecretsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceSecrets.beforeListNamespaceSecretsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespaceSecrets.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceSecrets *mRepositoryMockListNamespaceSecrets) Calls() []*RepositoryMockListNamespaceSecretsParams {
	mmListNamespaceSecrets.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespaceSecretsParams, len(mmListNamespaceSecrets.callArgs))
	copy(argCopy, mmListNamespaceSecrets.callArgs)

	mmListNamespaceSecrets.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceSecretsDone returns true if the count of the ListNamespaceSecrets invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespaceSecretsDone() bool {
	if m.ListNamespaceSecretsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceSecretsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceSecretsMock.invocationsDone()
}

// MinimockListNamespaceSecretsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespaceSecretsInspect() {
	for _, e := range m.ListNamespaceSecretsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets with params: %#v", *e.params)
		}
	}

	afterListNamespaceSecretsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceSecretsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceSecretsMock.defaultExpectation != nil && afterListNamespaceSecretsCounter < 1 {
		if m.ListNamespaceSecretsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListNamespaceSecrets")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceSecrets with params: %#v", *m.ListNamespaceSecretsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceSecrets != nil && afterListNamespaceSecretsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListNamespaceSecrets")
	}

	if !m.ListNamespaceSecretsMock.invocationsDone() && afterListNamespaceSecretsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespaceSecrets but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceSecretsMock.expectedInvocations), afterListNamespaceSecretsCounter)
	}
}

type mRepositoryMockListPipelineTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelineTagsExpectation
	expectations       []*RepositoryMockListPipelineTagsExpectation

	callArgs []*RepositoryMockListPipelineTagsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListPipelineTagsExpectation specifies expectation struct of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListPipelineTagsParams
	paramPtrs *RepositoryMockListPipelineTagsParamPtrs
	results   *RepositoryMockListPipelineTagsResults
	Counter   uint64
}

// RepositoryMockListPipelineTagsParams contains parameters of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsParams struct {
	ctx         context.Context
	pipelineUID uuid.UUID
}

// RepositoryMockListPipelineTagsParamPtrs contains pointers to parameters of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsParamPtrs struct {
	ctx         *context.Context
	pipelineUID *uuid.UUID
}

// RepositoryMockListPipelineTagsResults contains results of the Repository.ListPipelineTags
type RepositoryMockListPipelineTagsResults struct {
	ta1 []datamodel.Tag
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Optional() *mRepositoryMockListPipelineTags {
	mmListPipelineTags.optional = true
	return mmListPipelineTags
}

// Expect sets up expected params for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Expect(ctx context.Context, pipelineUID uuid.UUID) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by ExpectParams functions")
	}

	mmListPipelineTags.defaultExpectation.params = &RepositoryMockListPipelineTagsParams{ctx, pipelineUID}
	for _, e := range mmListPipelineTags.expectations {
		if minimock.Equal(e.params, mmListPipelineTags.defaultExpectation.params) {
			mmListPipelineTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelineTags.defaultExpectation.params)
		}
	}

	return mmListPipelineTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.params != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Expect")
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs == nil {
		mmListPipelineTags.defaultExpectation.paramPtrs = &RepositoryMockListPipelineTagsParamPtrs{}
	}
	mmListPipelineTags.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListPipelineTags
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{}
	}

	if mmListPipelineTags.defaultExpectation.params != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Expect")
	}

	if mmListPipelineTags.defaultExpectation.paramPtrs == nil {
		mmListPipelineTags.defaultExpectation.paramPtrs = &RepositoryMockListPipelineTagsParamPtrs{}
	}
	mmListPipelineTags.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmListPipelineTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID)) *mRepositoryMockListPipelineTags {
	if mmListPipelineTags.mock.inspectFuncListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelineTags")
	}

	mmListPipelineTags.mock.inspectFuncListPipelineTags = f

	return mmListPipelineTags
}

// Return sets up results that will be returned by Repository.ListPipelineTags
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Return(ta1 []datamodel.Tag, err error) *RepositoryMock {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	if mmListPipelineTags.defaultExpectation == nil {
		mmListPipelineTags.defaultExpectation = &RepositoryMockListPipelineTagsExpectation{mock: mmListPipelineTags.mock}
	}
	mmListPipelineTags.defaultExpectation.results = &RepositoryMockListPipelineTagsResults{ta1, err}
	return mmListPipelineTags.mock
}

// Set uses given function f to mock the Repository.ListPipelineTags method
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Set(f func(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error)) *RepositoryMock {
	if mmListPipelineTags.defaultExpectation != nil {
		mmListPipelineTags.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelineTags method")
	}

	if len(mmListPipelineTags.expectations) > 0 {
		mmListPipelineTags.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelineTags method")
	}

	mmListPipelineTags.mock.funcListPipelineTags = f
	return mmListPipelineTags.mock
}

// When sets expectation for the Repository.ListPipelineTags which will trigger the result defined by the following
// Then helper
func (mmListPipelineTags *mRepositoryMockListPipelineTags) When(ctx context.Context, pipelineUID uuid.UUID) *RepositoryMockListPipelineTagsExpectation {
	if mmListPipelineTags.mock.funcListPipelineTags != nil {
		mmListPipelineTags.mock.t.Fatalf("RepositoryMock.ListPipelineTags mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelineTagsExpectation{
		mock:   mmListPipelineTags.mock,
		params: &RepositoryMockListPipelineTagsParams{ctx, pipelineUID},
	}
	mmListPipelineTags.expectations = append(mmListPipelineTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelineTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelineTagsExpectation) Then(ta1 []datamodel.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelineTagsResults{ta1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelineTags should be invoked
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Times(n uint64) *mRepositoryMockListPipelineTags {
	if n == 0 {
		mmListPipelineTags.mock.t.Fatalf("Times of RepositoryMock.ListPipelineTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelineTags.expectedInvocations, n)
	return mmListPipelineTags
}

func (mmListPipelineTags *mRepositoryMockListPipelineTags) invocationsDone() bool {
	if len(mmListPipelineTags.expectations) == 0 && mmListPipelineTags.defaultExpectation == nil && mmListPipelineTags.mock.funcListPipelineTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelineTags.mock.afterListPipelineTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelineTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelineTags implements repository.Repository
func (mmListPipelineTags *RepositoryMock) ListPipelineTags(ctx context.Context, pipelineUID uuid.UUID) (ta1 []datamodel.Tag, err error) {
	mm_atomic.AddUint64(&mmListPipelineTags.beforeListPipelineTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelineTags.afterListPipelineTagsCounter, 1)

	if mmListPipelineTags.inspectFuncListPipelineTags != nil {
		mmListPipelineTags.inspectFuncListPipelineTags(ctx, pipelineUID)
	}

	mm_params := RepositoryMockListPipelineTagsParams{ctx, pipelineUID}

	// Record call args
	mmListPipelineTags.ListPipelineTagsMock.mutex.Lock()
	mmListPipelineTags.ListPipelineTagsMock.callArgs = append(mmListPipelineTags.ListPipelineTagsMock.callArgs, &mm_params)
	mmListPipelineTags.ListPipelineTagsMock.mutex.Unlock()

	for _, e := range mmListPipelineTags.ListPipelineTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ta1, e.results.err
		}
	}

	if mmListPipelineTags.ListPipelineTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelineTagsParams{ctx, pipelineUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelineTags.t.Errorf("RepositoryMock.ListPipelineTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelineTags.ListPipelineTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelineTags.t.Fatal("No results are set for the RepositoryMock.ListPipelineTags")
		}
		return (*mm_results).ta1, (*mm_results).err
	}
	if mmListPipelineTags.funcListPipelineTags != nil {
		return mmListPipelineTags.funcListPipelineTags(ctx, pipelineUID)
	}
	mmListPipelineTags.t.Fatalf("Unexpected call to RepositoryMock.ListPipelineTags. %v %v", ctx, pipelineUID)
	return
}

// ListPipelineTagsAfterCounter returns a count of finished RepositoryMock.ListPipelineTags invocations
func (mmListPipelineTags *RepositoryMock) ListPipelineTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineTags.afterListPipelineTagsCounter)
}

// ListPipelineTagsBeforeCounter returns a count of RepositoryMock.ListPipelineTags invocations
func (mmListPipelineTags *RepositoryMock) ListPipelineTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelineTags.beforeListPipelineTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelineTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelineTags *mRepositoryMockListPipelineTags) Calls() []*RepositoryMockListPipelineTagsParams {
	mmListPipelineTags.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelineTagsParams, len(mmListPipelineTags.callArgs))
	copy(argCopy, mmListPipelineTags.callArgs)

	mmListPipelineTags.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelineTagsDone returns true if the count of the ListPipelineTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelineTagsDone() bool {
	if m.ListPipelineTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelineTagsMock.invocationsDone()
}

// MinimockListPipelineTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelineTagsInspect() {
	for _, e := range m.ListPipelineTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags with params: %#v", *e.params)
		}
	}

	afterListPipelineTagsCounter := mm_atomic.LoadUint64(&m.afterListPipelineTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelineTagsMock.defaultExpectation != nil && afterListPipelineTagsCounter < 1 {
		if m.ListPipelineTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListPipelineTags")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelineTags with params: %#v", *m.ListPipelineTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelineTags != nil && afterListPipelineTagsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListPipelineTags")
	}

	if !m.ListPipelineTagsMock.invocationsDone() && afterListPipelineTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelineTags but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelineTagsMock.expectedInvocations), afterListPipelineTagsCounter)
	}
}

type mRepositoryMockListPipelines struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelinesExpectation
	expectations       []*RepositoryMockListPipelinesExpectation

	callArgs []*RepositoryMockListPipelinesParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListPipelinesExpectation specifies expectation struct of the Repository.ListPipelines
type RepositoryMockListPipelinesExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListPipelinesParams
	paramPtrs *RepositoryMockListPipelinesParamPtrs
	results   *RepositoryMockListPipelinesResults
	Counter   uint64
}

// RepositoryMockListPipelinesParams contains parameters of the Repository.ListPipelines
type RepositoryMockListPipelinesParams struct {
	ctx           context.Context
	pageSize      int64
	pageToken     string
	isBasicView   bool
	filter        filtering.Filter
	uidAllowList  []uuid.UUID
	showDeleted   bool
	embedReleases bool
	order         ordering.OrderBy
}

// RepositoryMockListPipelinesParamPtrs contains pointers to parameters of the Repository.ListPipelines
type RepositoryMockListPipelinesParamPtrs struct {
	ctx           *context.Context
	pageSize      *int64
	pageToken     *string
	isBasicView   *bool
	filter        *filtering.Filter
	uidAllowList  *[]uuid.UUID
	showDeleted   *bool
	embedReleases *bool
	order         *ordering.OrderBy
}

// RepositoryMockListPipelinesResults contains results of the Repository.ListPipelines
type RepositoryMockListPipelinesResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelines *mRepositoryMockListPipelines) Optional() *mRepositoryMockListPipelines {
	mmListPipelines.optional = true
	return mmListPipelines
}

// Expect sets up expected params for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.paramPtrs != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by ExpectParams functions")
	}

	mmListPipelines.defaultExpectation.params = &RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}
	for _, e := range mmListPipelines.expectations {
		if minimock.Equal(e.params, mmListPipelines.defaultExpectation.params) {
			mmListPipelines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelines.defaultExpectation.params)
		}
	}

	return mmListPipelines
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListPipelines
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListPipelines
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListPipelines
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmListPipelines
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.filter = &filter

	return mmListPipelines
}

// ExpectUidAllowListParam6 sets up expected param uidAllowList for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectUidAllowListParam6(uidAllowList []uuid.UUID) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList

	return mmListPipelines
}

// ExpectShowDeletedParam7 sets up expected param showDeleted for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectShowDeletedParam7(showDeleted bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.showDeleted = &showDeleted

	return mmListPipelines
}

// ExpectEmbedReleasesParam8 sets up expected param embedReleases for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectEmbedReleasesParam8(embedReleases bool) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.embedReleases = &embedReleases

	return mmListPipelines
}

// ExpectOrderParam9 sets up expected param order for Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) ExpectOrderParam9(order ordering.OrderBy) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{}
	}

	if mmListPipelines.defaultExpectation.params != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Expect")
	}

	if mmListPipelines.defaultExpectation.paramPtrs == nil {
		mmListPipelines.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesParamPtrs{}
	}
	mmListPipelines.defaultExpectation.paramPtrs.order = &order

	return mmListPipelines
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy)) *mRepositoryMockListPipelines {
	if mmListPipelines.mock.inspectFuncListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelines")
	}

	mmListPipelines.mock.inspectFuncListPipelines = f

	return mmListPipelines
}

// Return sets up results that will be returned by Repository.ListPipelines
func (mmListPipelines *mRepositoryMockListPipelines) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	if mmListPipelines.defaultExpectation == nil {
		mmListPipelines.defaultExpectation = &RepositoryMockListPipelinesExpectation{mock: mmListPipelines.mock}
	}
	mmListPipelines.defaultExpectation.results = &RepositoryMockListPipelinesResults{ppa1, i1, s1, err}
	return mmListPipelines.mock
}

// Set uses given function f to mock the Repository.ListPipelines method
func (mmListPipelines *mRepositoryMockListPipelines) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPipelines.defaultExpectation != nil {
		mmListPipelines.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelines method")
	}

	if len(mmListPipelines.expectations) > 0 {
		mmListPipelines.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelines method")
	}

	mmListPipelines.mock.funcListPipelines = f
	return mmListPipelines.mock
}

// When sets expectation for the Repository.ListPipelines which will trigger the result defined by the following
// Then helper
func (mmListPipelines *mRepositoryMockListPipelines) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) *RepositoryMockListPipelinesExpectation {
	if mmListPipelines.mock.funcListPipelines != nil {
		mmListPipelines.mock.t.Fatalf("RepositoryMock.ListPipelines mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelinesExpectation{
		mock:   mmListPipelines.mock,
		params: &RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order},
	}
	mmListPipelines.expectations = append(mmListPipelines.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelines return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelinesExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelinesResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelines should be invoked
func (mmListPipelines *mRepositoryMockListPipelines) Times(n uint64) *mRepositoryMockListPipelines {
	if n == 0 {
		mmListPipelines.mock.t.Fatalf("Times of RepositoryMock.ListPipelines mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelines.expectedInvocations, n)
	return mmListPipelines
}

func (mmListPipelines *mRepositoryMockListPipelines) invocationsDone() bool {
	if len(mmListPipelines.expectations) == 0 && mmListPipelines.defaultExpectation == nil && mmListPipelines.mock.funcListPipelines == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelines.mock.afterListPipelinesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelines.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelines implements repository.Repository
func (mmListPipelines *RepositoryMock) ListPipelines(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, embedReleases bool, order ordering.OrderBy) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPipelines.beforeListPipelinesCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelines.afterListPipelinesCounter, 1)

	if mmListPipelines.inspectFuncListPipelines != nil {
		mmListPipelines.inspectFuncListPipelines(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}

	mm_params := RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

	// Record call args
	mmListPipelines.ListPipelinesMock.mutex.Lock()
	mmListPipelines.ListPipelinesMock.callArgs = append(mmListPipelines.ListPipelinesMock.callArgs, &mm_params)
	mmListPipelines.ListPipelinesMock.mutex.Unlock()

	for _, e := range mmListPipelines.ListPipelinesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPipelines.ListPipelinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelines.ListPipelinesMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelines.ListPipelinesMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelines.ListPipelinesMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelinesParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter uidAllowList, want: %#v, got: %#v%s\n", *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter showDeleted, want: %#v, got: %#v%s\n", *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter embedReleases, want: %#v, got: %#v%s\n", *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelines.t.Errorf("RepositoryMock.ListPipelines got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelines.ListPipelinesMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelines.t.Fatal("No results are set for the RepositoryMock.ListPipelines")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPipelines.funcListPipelines != nil {
		return mmListPipelines.funcListPipelines(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	}
	mmListPipelines.t.Fatalf("Unexpected call to RepositoryMock.ListPipelines. %v %v %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, embedReleases, order)
	return
}

// ListPipelinesAfterCounter returns a count of finished RepositoryMock.ListPipelines invocations
func (mmListPipelines *RepositoryMock) ListPipelinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelines.afterListPipelinesCounter)
}

// ListPipelinesBeforeCounter returns a count of RepositoryMock.ListPipelines invocations
func (mmListPipelines *RepositoryMock) ListPipelinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelines.beforeListPipelinesCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelines *mRepositoryMockListPipelines) Calls() []*RepositoryMockListPipelinesParams {
	mmListPipelines.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelinesParams, len(mmListPipelines.callArgs))
	copy(argCopy, mmListPipelines.callArgs)

	mmListPipelines.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelinesDone returns true if the count of the ListPipelines invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelinesDone() bool {
	if m.ListPipelinesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelinesMock.invocationsDone()
}

// MinimockListPipelinesInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelinesInspect() {
	for _, e := range m.ListPipelinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines with params: %#v", *e.params)
		}
	}

	afterListPipelinesCounter := mm_atomic.LoadUint64(&m.afterListPipelinesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelinesMock.defaultExpectation != nil && afterListPipelinesCounter < 1 {
		if m.ListPipelinesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListPipelines")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelines with params: %#v", *m.ListPipelinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelines != nil && afterListPipelinesCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListPipelines")
	}

	if !m.ListPipelinesMock.invocationsDone() && afterListPipelinesCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelines but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelinesMock.expectedInvocations), afterListPipelinesCounter)
	}
}

type mRepositoryMockListPipelinesAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListPipelinesAdminExpectation
	expectations       []*RepositoryMockListPipelinesAdminExpectation

	callArgs []*RepositoryMockListPipelinesAdminParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListPipelinesAdminExpectation specifies expectation struct of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListPipelinesAdminParams
	paramPtrs *RepositoryMockListPipelinesAdminParamPtrs
	results   *RepositoryMockListPipelinesAdminResults
	Counter   uint64
}

// RepositoryMockListPipelinesAdminParams contains parameters of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminParams struct {
	ctx           context.Context
	pageSize      int64
	pageToken     string
	isBasicView   bool
	filter        filtering.Filter
	showDeleted   bool
	embedReleases bool
}

// RepositoryMockListPipelinesAdminParamPtrs contains pointers to parameters of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminParamPtrs struct {
	ctx           *context.Context
	pageSize      *int64
	pageToken     *string
	isBasicView   *bool
	filter        *filtering.Filter
	showDeleted   *bool
	embedReleases *bool
}

// RepositoryMockListPipelinesAdminResults contains results of the Repository.ListPipelinesAdmin
type RepositoryMockListPipelinesAdminResults struct {
	ppa1 []*datamodel.Pipeline
	i1   int64
	s1   string
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Optional() *mRepositoryMockListPipelinesAdmin {
	mmListPipelinesAdmin.optional = true
	return mmListPipelinesAdmin
}

// Expect sets up expected params for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by ExpectParams functions")
	}

	mmListPipelinesAdmin.defaultExpectation.params = &RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}
	for _, e := range mmListPipelinesAdmin.expectations {
		if minimock.Equal(e.params, mmListPipelinesAdmin.defaultExpectation.params) {
			mmListPipelinesAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPipelinesAdmin.defaultExpectation.params)
		}
	}

	return mmListPipelinesAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListPipelinesAdmin
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListPipelinesAdmin
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListPipelinesAdmin
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmListPipelinesAdmin
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.filter = &filter

	return mmListPipelinesAdmin
}

// ExpectShowDeletedParam6 sets up expected param showDeleted for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectShowDeletedParam6(showDeleted bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.showDeleted = &showDeleted

	return mmListPipelinesAdmin
}

// ExpectEmbedReleasesParam7 sets up expected param embedReleases for Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) ExpectEmbedReleasesParam7(embedReleases bool) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{}
	}

	if mmListPipelinesAdmin.defaultExpectation.params != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Expect")
	}

	if mmListPipelinesAdmin.defaultExpectation.paramPtrs == nil {
		mmListPipelinesAdmin.defaultExpectation.paramPtrs = &RepositoryMockListPipelinesAdminParamPtrs{}
	}
	mmListPipelinesAdmin.defaultExpectation.paramPtrs.embedReleases = &embedReleases

	return mmListPipelinesAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool)) *mRepositoryMockListPipelinesAdmin {
	if mmListPipelinesAdmin.mock.inspectFuncListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListPipelinesAdmin")
	}

	mmListPipelinesAdmin.mock.inspectFuncListPipelinesAdmin = f

	return mmListPipelinesAdmin
}

// Return sets up results that will be returned by Repository.ListPipelinesAdmin
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Return(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	if mmListPipelinesAdmin.defaultExpectation == nil {
		mmListPipelinesAdmin.defaultExpectation = &RepositoryMockListPipelinesAdminExpectation{mock: mmListPipelinesAdmin.mock}
	}
	mmListPipelinesAdmin.defaultExpectation.results = &RepositoryMockListPipelinesAdminResults{ppa1, i1, s1, err}
	return mmListPipelinesAdmin.mock
}

// Set uses given function f to mock the Repository.ListPipelinesAdmin method
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListPipelinesAdmin.defaultExpectation != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.ListPipelinesAdmin method")
	}

	if len(mmListPipelinesAdmin.expectations) > 0 {
		mmListPipelinesAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.ListPipelinesAdmin method")
	}

	mmListPipelinesAdmin.mock.funcListPipelinesAdmin = f
	return mmListPipelinesAdmin.mock
}

// When sets expectation for the Repository.ListPipelinesAdmin which will trigger the result defined by the following
// Then helper
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) *RepositoryMockListPipelinesAdminExpectation {
	if mmListPipelinesAdmin.mock.funcListPipelinesAdmin != nil {
		mmListPipelinesAdmin.mock.t.Fatalf("RepositoryMock.ListPipelinesAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockListPipelinesAdminExpectation{
		mock:   mmListPipelinesAdmin.mock,
		params: &RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases},
	}
	mmListPipelinesAdmin.expectations = append(mmListPipelinesAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListPipelinesAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListPipelinesAdminExpectation) Then(ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListPipelinesAdminResults{ppa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListPipelinesAdmin should be invoked
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Times(n uint64) *mRepositoryMockListPipelinesAdmin {
	if n == 0 {
		mmListPipelinesAdmin.mock.t.Fatalf("Times of RepositoryMock.ListPipelinesAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPipelinesAdmin.expectedInvocations, n)
	return mmListPipelinesAdmin
}

func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) invocationsDone() bool {
	if len(mmListPipelinesAdmin.expectations) == 0 && mmListPipelinesAdmin.defaultExpectation == nil && mmListPipelinesAdmin.mock.funcListPipelinesAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPipelinesAdmin.mock.afterListPipelinesAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPipelinesAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPipelinesAdmin implements repository.Repository
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdmin(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool, embedReleases bool) (ppa1 []*datamodel.Pipeline, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListPipelinesAdmin.beforeListPipelinesAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmListPipelinesAdmin.afterListPipelinesAdminCounter, 1)

	if mmListPipelinesAdmin.inspectFuncListPipelinesAdmin != nil {
		mmListPipelinesAdmin.inspectFuncListPipelinesAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	}

	mm_params := RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}

	// Record call args
	mmListPipelinesAdmin.ListPipelinesAdminMock.mutex.Lock()
	mmListPipelinesAdmin.ListPipelinesAdminMock.callArgs = append(mmListPipelinesAdmin.ListPipelinesAdminMock.callArgs, &mm_params)
	mmListPipelinesAdmin.ListPipelinesAdminMock.mutex.Unlock()

	for _, e := range mmListPipelinesAdmin.ListPipelinesAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.params
		mm_want_ptrs := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListPipelinesAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter showDeleted, want: %#v, got: %#v%s\n", *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.embedReleases != nil && !minimock.Equal(*mm_want_ptrs.embedReleases, mm_got.embedReleases) {
				mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameter embedReleases, want: %#v, got: %#v%s\n", *mm_want_ptrs.embedReleases, mm_got.embedReleases, minimock.Diff(*mm_want_ptrs.embedReleases, mm_got.embedReleases))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPipelinesAdmin.t.Errorf("RepositoryMock.ListPipelinesAdmin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPipelinesAdmin.ListPipelinesAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmListPipelinesAdmin.t.Fatal("No results are set for the RepositoryMock.ListPipelinesAdmin")
		}
		return (*mm_results).ppa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListPipelinesAdmin.funcListPipelinesAdmin != nil {
		return mmListPipelinesAdmin.funcListPipelinesAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	}
	mmListPipelinesAdmin.t.Fatalf("Unexpected call to RepositoryMock.ListPipelinesAdmin. %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, showDeleted, embedReleases)
	return
}

// ListPipelinesAdminAfterCounter returns a count of finished RepositoryMock.ListPipelinesAdmin invocations
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelinesAdmin.afterListPipelinesAdminCounter)
}

// ListPipelinesAdminBeforeCounter returns a count of RepositoryMock.ListPipelinesAdmin invocations
func (mmListPipelinesAdmin *RepositoryMock) ListPipelinesAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPipelinesAdmin.beforeListPipelinesAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListPipelinesAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPipelinesAdmin *mRepositoryMockListPipelinesAdmin) Calls() []*RepositoryMockListPipelinesAdminParams {
	mmListPipelinesAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockListPipelinesAdminParams, len(mmListPipelinesAdmin.callArgs))
	copy(argCopy, mmListPipelinesAdmin.callArgs)

	mmListPipelinesAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockListPipelinesAdminDone returns true if the count of the ListPipelinesAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListPipelinesAdminDone() bool {
	if m.ListPipelinesAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPipelinesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPipelinesAdminMock.invocationsDone()
}

// MinimockListPipelinesAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListPipelinesAdminInspect() {
	for _, e := range m.ListPipelinesAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin with params: %#v", *e.params)
		}
	}

	afterListPipelinesAdminCounter := mm_atomic.LoadUint64(&m.afterListPipelinesAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPipelinesAdminMock.defaultExpectation != nil && afterListPipelinesAdminCounter < 1 {
		if m.ListPipelinesAdminMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListPipelinesAdmin")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListPipelinesAdmin with params: %#v", *m.ListPipelinesAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPipelinesAdmin != nil && afterListPipelinesAdminCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListPipelinesAdmin")
	}

	if !m.ListPipelinesAdminMock.invocationsDone() && afterListPipelinesAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListPipelinesAdmin but found %d calls",
			mm_atomic.LoadUint64(&m.ListPipelinesAdminMock.expectedInvocations), afterListPipelinesAdminCounter)
	}
}

type mRepositoryMockTranspileFilter struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockTranspileFilterExpectation
	expectations       []*RepositoryMockTranspileFilterExpectation

	callArgs []*RepositoryMockTranspileFilterParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockTranspileFilterExpectation specifies expectation struct of the Repository.TranspileFilter
type RepositoryMockTranspileFilterExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockTranspileFilterParams
	paramPtrs *RepositoryMockTranspileFilterParamPtrs
	results   *RepositoryMockTranspileFilterResults
	Counter   uint64
}

// RepositoryMockTranspileFilterParams contains parameters of the Repository.TranspileFilter
type RepositoryMockTranspileFilterParams struct {
	f1 filtering.Filter
}

// RepositoryMockTranspileFilterParamPtrs contains pointers to parameters of the Repository.TranspileFilter
type RepositoryMockTranspileFilterParamPtrs struct {
	f1 *filtering.Filter
}

// RepositoryMockTranspileFilterResults contains results of the Repository.TranspileFilter
type RepositoryMockTranspileFilterResults struct {
	ep1 *clause.Expr
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Optional() *mRepositoryMockTranspileFilter {
	mmTranspileFilter.optional = true
	return mmTranspileFilter
}

// Expect sets up expected params for Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Expect(f1 filtering.Filter) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{}
	}

	if mmTranspileFilter.defaultExpectation.paramPtrs != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by ExpectParams functions")
	}

	mmTranspileFilter.defaultExpectation.params = &RepositoryMockTranspileFilterParams{f1}
	for _, e := range mmTranspileFilter.expectations {
		if minimock.Equal(e.params, mmTranspileFilter.defaultExpectation.params) {
			mmTranspileFilter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTranspileFilter.defaultExpectation.params)
		}
	}

	return mmTranspileFilter
}

// ExpectF1Param1 sets up expected param f1 for Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) ExpectF1Param1(f1 filtering.Filter) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{}
	}

	if mmTranspileFilter.defaultExpectation.params != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Expect")
	}

	if mmTranspileFilter.defaultExpectation.paramPtrs == nil {
		mmTranspileFilter.defaultExpectation.paramPtrs = &RepositoryMockTranspileFilterParamPtrs{}
	}
	mmTranspileFilter.defaultExpectation.paramPtrs.f1 = &f1

	return mmTranspileFilter
}

// Inspect accepts an inspector function that has same arguments as the Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Inspect(f func(f1 filtering.Filter)) *mRepositoryMockTranspileFilter {
	if mmTranspileFilter.mock.inspectFuncTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("Inspect function is already set for RepositoryMock.TranspileFilter")
	}

	mmTranspileFilter.mock.inspectFuncTranspileFilter = f

	return mmTranspileFilter
}

// Return sets up results that will be returned by Repository.TranspileFilter
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Return(ep1 *clause.Expr, err error) *RepositoryMock {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	if mmTranspileFilter.defaultExpectation == nil {
		mmTranspileFilter.defaultExpectation = &RepositoryMockTranspileFilterExpectation{mock: mmTranspileFilter.mock}
	}
	mmTranspileFilter.defaultExpectation.results = &RepositoryMockTranspileFilterResults{ep1, err}
	return mmTranspileFilter.mock
}

// Set uses given function f to mock the Repository.TranspileFilter method
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Set(f func(f1 filtering.Filter) (ep1 *clause.Expr, err error)) *RepositoryMock {
	if mmTranspileFilter.defaultExpectation != nil {
		mmTranspileFilter.mock.t.Fatalf("Default expectation is already set for the Repository.TranspileFilter method")
	}

	if len(mmTranspileFilter.expectations) > 0 {
		mmTranspileFilter.mock.t.Fatalf("Some expectations are already set for the Repository.TranspileFilter method")
	}

	mmTranspileFilter.mock.funcTranspileFilter = f
	return mmTranspileFilter.mock
}

// When sets expectation for the Repository.TranspileFilter which will trigger the result defined by the following
// Then helper
func (mmTranspileFilter *mRepositoryMockTranspileFilter) When(f1 filtering.Filter) *RepositoryMockTranspileFilterExpectation {
	if mmTranspileFilter.mock.funcTranspileFilter != nil {
		mmTranspileFilter.mock.t.Fatalf("RepositoryMock.TranspileFilter mock is already set by Set")
	}

	expectation := &RepositoryMockTranspileFilterExpectation{
		mock:   mmTranspileFilter.mock,
		params: &RepositoryMockTranspileFilterParams{f1},
	}
	mmTranspileFilter.expectations = append(mmTranspileFilter.expectations, expectation)
	return expectation
}

// Then sets up Repository.TranspileFilter return parameters for the expectation previously defined by the When method
func (e *RepositoryMockTranspileFilterExpectation) Then(ep1 *clause.Expr, err error) *RepositoryMock {
	e.results = &RepositoryMockTranspileFilterResults{ep1, err}
	return e.mock
}

// Times sets number of times Repository.TranspileFilter should be invoked
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Times(n uint64) *mRepositoryMockTranspileFilter {
	if n == 0 {
		mmTranspileFilter.mock.t.Fatalf("Times of RepositoryMock.TranspileFilter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTranspileFilter.expectedInvocations, n)
	return mmTranspileFilter
}

func (mmTranspileFilter *mRepositoryMockTranspileFilter) invocationsDone() bool {
	if len(mmTranspileFilter.expectations) == 0 && mmTranspileFilter.defaultExpectation == nil && mmTranspileFilter.mock.funcTranspileFilter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTranspileFilter.mock.afterTranspileFilterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTranspileFilter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TranspileFilter implements repository.Repository
func (mmTranspileFilter *RepositoryMock) TranspileFilter(f1 filtering.Filter) (ep1 *clause.Expr, err error) {
	mm_atomic.AddUint64(&mmTranspileFilter.beforeTranspileFilterCounter, 1)
	defer mm_atomic.AddUint64(&mmTranspileFilter.afterTranspileFilterCounter, 1)

	if mmTranspileFilter.inspectFuncTranspileFilter != nil {
		mmTranspileFilter.inspectFuncTranspileFilter(f1)
	}

	mm_params := RepositoryMockTranspileFilterParams{f1}

	// Record call args
	mmTranspileFilter.TranspileFilterMock.mutex.Lock()
	mmTranspileFilter.TranspileFilterMock.callArgs = append(mmTranspileFilter.TranspileFilterMock.callArgs, &mm_params)
	mmTranspileFilter.TranspileFilterMock.mutex.Unlock()

	for _, e := range mmTranspileFilter.TranspileFilterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmTranspileFilter.TranspileFilterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTranspileFilter.TranspileFilterMock.defaultExpectation.Counter, 1)
		mm_want := mmTranspileFilter.TranspileFilterMock.defaultExpectation.params
		mm_want_ptrs := mmTranspileFilter.TranspileFilterMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockTranspileFilterParams{f1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.f1 != nil && !minimock.Equal(*mm_want_ptrs.f1, mm_got.f1) {
				mmTranspileFilter.t.Errorf("RepositoryMock.TranspileFilter got unexpected parameter f1, want: %#v, got: %#v%s\n", *mm_want_ptrs.f1, mm_got.f1, minimock.Diff(*mm_want_ptrs.f1, mm_got.f1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTranspileFilter.t.Errorf("RepositoryMock.TranspileFilter got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTranspileFilter.TranspileFilterMock.defaultExpectation.results
		if mm_results == nil {
			mmTranspileFilter.t.Fatal("No results are set for the RepositoryMock.TranspileFilter")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmTranspileFilter.funcTranspileFilter != nil {
		return mmTranspileFilter.funcTranspileFilter(f1)
	}
	mmTranspileFilter.t.Fatalf("Unexpected call to RepositoryMock.TranspileFilter. %v", f1)
	return
}

// TranspileFilterAfterCounter returns a count of finished RepositoryMock.TranspileFilter invocations
func (mmTranspileFilter *RepositoryMock) TranspileFilterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTranspileFilter.afterTranspileFilterCounter)
}

// TranspileFilterBeforeCounter returns a count of RepositoryMock.TranspileFilter invocations
func (mmTranspileFilter *RepositoryMock) TranspileFilterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTranspileFilter.beforeTranspileFilterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.TranspileFilter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTranspileFilter *mRepositoryMockTranspileFilter) Calls() []*RepositoryMockTranspileFilterParams {
	mmTranspileFilter.mutex.RLock()

	argCopy := make([]*RepositoryMockTranspileFilterParams, len(mmTranspileFilter.callArgs))
	copy(argCopy, mmTranspileFilter.callArgs)

	mmTranspileFilter.mutex.RUnlock()

	return argCopy
}

// MinimockTranspileFilterDone returns true if the count of the TranspileFilter invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockTranspileFilterDone() bool {
	if m.TranspileFilterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TranspileFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TranspileFilterMock.invocationsDone()
}

// MinimockTranspileFilterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockTranspileFilterInspect() {
	for _, e := range m.TranspileFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter with params: %#v", *e.params)
		}
	}

	afterTranspileFilterCounter := mm_atomic.LoadUint64(&m.afterTranspileFilterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TranspileFilterMock.defaultExpectation != nil && afterTranspileFilterCounter < 1 {
		if m.TranspileFilterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.TranspileFilter")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.TranspileFilter with params: %#v", *m.TranspileFilterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTranspileFilter != nil && afterTranspileFilterCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.TranspileFilter")
	}

	if !m.TranspileFilterMock.invocationsDone() && afterTranspileFilterCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.TranspileFilter but found %d calls",
			mm_atomic.LoadUint64(&m.TranspileFilterMock.expectedInvocations), afterTranspileFilterCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineByUIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineByUIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateNamespacePipelineByUIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateNamespacePipelineByUIDParams
	paramPtrs *RepositoryMockUpdateNamespacePipelineByUIDParamPtrs
	results   *RepositoryMockUpdateNamespacePipelineByUIDResults
	Counter   uint64
}

// RepositoryMockUpdateNamespacePipelineByUIDParams contains parameters of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDParams struct {
	ctx      context.Context
	uid      uuid.UUID
	pipeline *datamodel.Pipeline
}

// RepositoryMockUpdateNamespacePipelineByUIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDParamPtrs struct {
	ctx      *context.Context
	uid      *uuid.UUID
	pipeline **datamodel.Pipeline
}

// RepositoryMockUpdateNamespacePipelineByUIDResults contains results of the Repository.UpdateNamespacePipelineByUID
type RepositoryMockUpdateNamespacePipelineByUIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Optional() *mRepositoryMockUpdateNamespacePipelineByUID {
	mmUpdateNamespacePipelineByUID.optional = true
	return mmUpdateNamespacePipelineByUID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Expect(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineByUID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline}
	for _, e := range mmUpdateNamespacePipelineByUID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineByUID.defaultExpectation.params) {
			mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineByUID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineByUIDParamPtrs{}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateNamespacePipelineByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineByUIDParamPtrs{}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs.uid = &uid

	return mmUpdateNamespacePipelineByUID
}

// ExpectPipelineParam3 sets up expected param pipeline for Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) ExpectPipelineParam3(pipeline *datamodel.Pipeline) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{}
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineByUIDParamPtrs{}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.paramPtrs.pipeline = &pipeline

	return mmUpdateNamespacePipelineByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline)) *mRepositoryMockUpdateNamespacePipelineByUID {
	if mmUpdateNamespacePipelineByUID.mock.inspectFuncUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineByUID")
	}

	mmUpdateNamespacePipelineByUID.mock.inspectFuncUpdateNamespacePipelineByUID = f

	return mmUpdateNamespacePipelineByUID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineByUID
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineByUID.defaultExpectation == nil {
		mmUpdateNamespacePipelineByUID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineByUIDExpectation{mock: mmUpdateNamespacePipelineByUID.mock}
	}
	mmUpdateNamespacePipelineByUID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineByUIDResults{err}
	return mmUpdateNamespacePipelineByUID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineByUID method
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Set(f func(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineByUID.defaultExpectation != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineByUID method")
	}

	if len(mmUpdateNamespacePipelineByUID.expectations) > 0 {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineByUID method")
	}

	mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID = f
	return mmUpdateNamespacePipelineByUID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineByUID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) When(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) *RepositoryMockUpdateNamespacePipelineByUIDExpectation {
	if mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineByUID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineByUIDExpectation{
		mock:   mmUpdateNamespacePipelineByUID.mock,
		params: &RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline},
	}
	mmUpdateNamespacePipelineByUID.expectations = append(mmUpdateNamespacePipelineByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineByUIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineByUIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineByUID should be invoked
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineByUID {
	if n == 0 {
		mmUpdateNamespacePipelineByUID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineByUID.expectedInvocations, n)
	return mmUpdateNamespacePipelineByUID
}

func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineByUID.expectations) == 0 && mmUpdateNamespacePipelineByUID.defaultExpectation == nil && mmUpdateNamespacePipelineByUID.mock.funcUpdateNamespacePipelineByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.mock.afterUpdateNamespacePipelineByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineByUID implements repository.Repository
func (mmUpdateNamespacePipelineByUID *RepositoryMock) UpdateNamespacePipelineByUID(ctx context.Context, uid uuid.UUID, pipeline *datamodel.Pipeline) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineByUID.beforeUpdateNamespacePipelineByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineByUID.afterUpdateNamespacePipelineByUIDCounter, 1)

	if mmUpdateNamespacePipelineByUID.inspectFuncUpdateNamespacePipelineByUID != nil {
		mmUpdateNamespacePipelineByUID.inspectFuncUpdateNamespacePipelineByUID(ctx, uid, pipeline)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline}

	// Record call args
	mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.mutex.Lock()
	mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.callArgs = append(mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineByUIDParams{ctx, uid, pipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.pipeline != nil && !minimock.Equal(*mm_want_ptrs.pipeline, mm_got.pipeline) {
				mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameter pipeline, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipeline, mm_got.pipeline, minimock.Diff(*mm_want_ptrs.pipeline, mm_got.pipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineByUID.t.Errorf("RepositoryMock.UpdateNamespacePipelineByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineByUID.UpdateNamespacePipelineByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineByUID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineByUID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineByUID.funcUpdateNamespacePipelineByUID != nil {
		return mmUpdateNamespacePipelineByUID.funcUpdateNamespacePipelineByUID(ctx, uid, pipeline)
	}
	mmUpdateNamespacePipelineByUID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineByUID. %v %v %v", ctx, uid, pipeline)
	return
}

// UpdateNamespacePipelineByUIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineByUID invocations
func (mmUpdateNamespacePipelineByUID *RepositoryMock) UpdateNamespacePipelineByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.afterUpdateNamespacePipelineByUIDCounter)
}

// UpdateNamespacePipelineByUIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineByUID invocations
func (mmUpdateNamespacePipelineByUID *RepositoryMock) UpdateNamespacePipelineByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineByUID.beforeUpdateNamespacePipelineByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineByUID *mRepositoryMockUpdateNamespacePipelineByUID) Calls() []*RepositoryMockUpdateNamespacePipelineByUIDParams {
	mmUpdateNamespacePipelineByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineByUIDParams, len(mmUpdateNamespacePipelineByUID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineByUID.callArgs)

	mmUpdateNamespacePipelineByUID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineByUIDDone returns true if the count of the UpdateNamespacePipelineByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineByUIDDone() bool {
	if m.UpdateNamespacePipelineByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineByUIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineByUIDInspect() {
	for _, e := range m.UpdateNamespacePipelineByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineByUID with params: %#v", *e.params)
		}
	}

	afterUpdateNamespacePipelineByUIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineByUIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineByUIDCounter < 1 {
		if m.UpdateNamespacePipelineByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineByUID with params: %#v", *m.UpdateNamespacePipelineByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineByUID != nil && afterUpdateNamespacePipelineByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineByUID")
	}

	if !m.UpdateNamespacePipelineByUIDMock.invocationsDone() && afterUpdateNamespacePipelineByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineByUID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineByUIDMock.expectedInvocations), afterUpdateNamespacePipelineByUIDCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineIDByIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineIDByIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateNamespacePipelineIDByIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateNamespacePipelineIDByIDParams
	paramPtrs *RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs
	results   *RepositoryMockUpdateNamespacePipelineIDByIDResults
	Counter   uint64
}

// RepositoryMockUpdateNamespacePipelineIDByIDParams contains parameters of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	newID          string
}

// RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	newID          *string
}

// RepositoryMockUpdateNamespacePipelineIDByIDResults contains results of the Repository.UpdateNamespacePipelineIDByID
type RepositoryMockUpdateNamespacePipelineIDByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Optional() *mRepositoryMockUpdateNamespacePipelineIDByID {
	mmUpdateNamespacePipelineIDByID.optional = true
	return mmUpdateNamespacePipelineIDByID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Expect(ctx context.Context, ownerPermalink string, id string, newID string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineIDByID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID}
	for _, e := range mmUpdateNamespacePipelineIDByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineIDByID.defaultExpectation.params) {
			mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineIDByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateNamespacePipelineIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmUpdateNamespacePipelineIDByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.id = &id

	return mmUpdateNamespacePipelineIDByID
}

// ExpectNewIDParam4 sets up expected param newID for Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) ExpectNewIDParam4(newID string) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.paramPtrs.newID = &newID

	return mmUpdateNamespacePipelineIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, newID string)) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if mmUpdateNamespacePipelineIDByID.mock.inspectFuncUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineIDByID")
	}

	mmUpdateNamespacePipelineIDByID.mock.inspectFuncUpdateNamespacePipelineIDByID = f

	return mmUpdateNamespacePipelineIDByID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineIDByID
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{mock: mmUpdateNamespacePipelineIDByID.mock}
	}
	mmUpdateNamespacePipelineIDByID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineIDByIDResults{err}
	return mmUpdateNamespacePipelineIDByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineIDByID method
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Set(f func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineIDByID.defaultExpectation != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineIDByID method")
	}

	if len(mmUpdateNamespacePipelineIDByID.expectations) > 0 {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineIDByID method")
	}

	mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID = f
	return mmUpdateNamespacePipelineIDByID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) When(ctx context.Context, ownerPermalink string, id string, newID string) *RepositoryMockUpdateNamespacePipelineIDByIDExpectation {
	if mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineIDByIDExpectation{
		mock:   mmUpdateNamespacePipelineIDByID.mock,
		params: &RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID},
	}
	mmUpdateNamespacePipelineIDByID.expectations = append(mmUpdateNamespacePipelineIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineIDByID should be invoked
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineIDByID {
	if n == 0 {
		mmUpdateNamespacePipelineIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineIDByID.expectedInvocations, n)
	return mmUpdateNamespacePipelineIDByID
}

func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineIDByID.expectations) == 0 && mmUpdateNamespacePipelineIDByID.defaultExpectation == nil && mmUpdateNamespacePipelineIDByID.mock.funcUpdateNamespacePipelineIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.mock.afterUpdateNamespacePipelineIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineIDByID implements repository.Repository
func (mmUpdateNamespacePipelineIDByID *RepositoryMock) UpdateNamespacePipelineIDByID(ctx context.Context, ownerPermalink string, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineIDByID.beforeUpdateNamespacePipelineIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineIDByID.afterUpdateNamespacePipelineIDByIDCounter, 1)

	if mmUpdateNamespacePipelineIDByID.inspectFuncUpdateNamespacePipelineIDByID != nil {
		mmUpdateNamespacePipelineIDByID.inspectFuncUpdateNamespacePipelineIDByID(ctx, ownerPermalink, id, newID)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID}

	// Record call args
	mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.mutex.Lock()
	mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.callArgs = append(mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineIDByIDParams{ctx, ownerPermalink, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameter newID, want: %#v, got: %#v%s\n", *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineIDByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineIDByID.UpdateNamespacePipelineIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineIDByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineIDByID.funcUpdateNamespacePipelineIDByID != nil {
		return mmUpdateNamespacePipelineIDByID.funcUpdateNamespacePipelineIDByID(ctx, ownerPermalink, id, newID)
	}
	mmUpdateNamespacePipelineIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineIDByID. %v %v %v %v", ctx, ownerPermalink, id, newID)
	return
}

// UpdateNamespacePipelineIDByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineIDByID invocations
func (mmUpdateNamespacePipelineIDByID *RepositoryMock) UpdateNamespacePipelineIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.afterUpdateNamespacePipelineIDByIDCounter)
}

// UpdateNamespacePipelineIDByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineIDByID invocations
func (mmUpdateNamespacePipelineIDByID *RepositoryMock) UpdateNamespacePipelineIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineIDByID.beforeUpdateNamespacePipelineIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineIDByID *mRepositoryMockUpdateNamespacePipelineIDByID) Calls() []*RepositoryMockUpdateNamespacePipelineIDByIDParams {
	mmUpdateNamespacePipelineIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineIDByIDParams, len(mmUpdateNamespacePipelineIDByID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineIDByID.callArgs)

	mmUpdateNamespacePipelineIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineIDByIDDone returns true if the count of the UpdateNamespacePipelineIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineIDByIDDone() bool {
	if m.UpdateNamespacePipelineIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineIDByIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineIDByIDInspect() {
	for _, e := range m.UpdateNamespacePipelineIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID with params: %#v", *e.params)
		}
	}

	afterUpdateNamespacePipelineIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineIDByIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineIDByIDCounter < 1 {
		if m.UpdateNamespacePipelineIDByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID with params: %#v", *m.UpdateNamespacePipelineIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineIDByID != nil && afterUpdateNamespacePipelineIDByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineIDByID")
	}

	if !m.UpdateNamespacePipelineIDByIDMock.invocationsDone() && afterUpdateNamespacePipelineIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineIDByID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineIDByIDMock.expectedInvocations), afterUpdateNamespacePipelineIDByIDCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineReleaseByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineReleaseByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateNamespacePipelineReleaseByIDParams
	paramPtrs *RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs
	results   *RepositoryMockUpdateNamespacePipelineReleaseByIDResults
	Counter   uint64
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDParams contains parameters of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDParams struct {
	ctx             context.Context
	ownerPermalink  string
	pipelineUID     uuid.UUID
	id              string
	pipelineRelease *datamodel.PipelineRelease
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs struct {
	ctx             *context.Context
	ownerPermalink  *string
	pipelineUID     *uuid.UUID
	id              *string
	pipelineRelease **datamodel.PipelineRelease
}

// RepositoryMockUpdateNamespacePipelineReleaseByIDResults contains results of the Repository.UpdateNamespacePipelineReleaseByID
type RepositoryMockUpdateNamespacePipelineReleaseByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Optional() *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	mmUpdateNamespacePipelineReleaseByID.optional = true
	return mmUpdateNamespacePipelineReleaseByID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}
	for _, e := range mmUpdateNamespacePipelineReleaseByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params) {
			mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectIdParam4 sets up expected param id for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectIdParam4(id string) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.id = &id

	return mmUpdateNamespacePipelineReleaseByID
}

// ExpectPipelineReleaseParam5 sets up expected param pipelineRelease for Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) ExpectPipelineReleaseParam5(pipelineRelease *datamodel.PipelineRelease) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.paramPtrs.pipelineRelease = &pipelineRelease

	return mmUpdateNamespacePipelineReleaseByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease)) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if mmUpdateNamespacePipelineReleaseByID.mock.inspectFuncUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineReleaseByID")
	}

	mmUpdateNamespacePipelineReleaseByID.mock.inspectFuncUpdateNamespacePipelineReleaseByID = f

	return mmUpdateNamespacePipelineReleaseByID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineReleaseByID
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{mock: mmUpdateNamespacePipelineReleaseByID.mock}
	}
	mmUpdateNamespacePipelineReleaseByID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineReleaseByIDResults{err}
	return mmUpdateNamespacePipelineReleaseByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineReleaseByID method
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseByID.defaultExpectation != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineReleaseByID method")
	}

	if len(mmUpdateNamespacePipelineReleaseByID.expectations) > 0 {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineReleaseByID method")
	}

	mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID = f
	return mmUpdateNamespacePipelineReleaseByID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineReleaseByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) *RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation {
	if mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation{
		mock:   mmUpdateNamespacePipelineReleaseByID.mock,
		params: &RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease},
	}
	mmUpdateNamespacePipelineReleaseByID.expectations = append(mmUpdateNamespacePipelineReleaseByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineReleaseByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineReleaseByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineReleaseByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineReleaseByID should be invoked
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineReleaseByID {
	if n == 0 {
		mmUpdateNamespacePipelineReleaseByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineReleaseByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineReleaseByID.expectedInvocations, n)
	return mmUpdateNamespacePipelineReleaseByID
}

func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineReleaseByID.expectations) == 0 && mmUpdateNamespacePipelineReleaseByID.defaultExpectation == nil && mmUpdateNamespacePipelineReleaseByID.mock.funcUpdateNamespacePipelineReleaseByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.mock.afterUpdateNamespacePipelineReleaseByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineReleaseByID implements repository.Repository
func (mmUpdateNamespacePipelineReleaseByID *RepositoryMock) UpdateNamespacePipelineReleaseByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, pipelineRelease *datamodel.PipelineRelease) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseByID.beforeUpdateNamespacePipelineReleaseByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseByID.afterUpdateNamespacePipelineReleaseByIDCounter, 1)

	if mmUpdateNamespacePipelineReleaseByID.inspectFuncUpdateNamespacePipelineReleaseByID != nil {
		mmUpdateNamespacePipelineReleaseByID.inspectFuncUpdateNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}

	// Record call args
	mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.mutex.Lock()
	mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.callArgs = append(mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineReleaseByIDParams{ctx, ownerPermalink, pipelineUID, id, pipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.pipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease) {
				mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameter pipelineRelease, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease, minimock.Diff(*mm_want_ptrs.pipelineRelease, mm_got.pipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineReleaseByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineReleaseByID.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineReleaseByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineReleaseByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineReleaseByID.funcUpdateNamespacePipelineReleaseByID != nil {
		return mmUpdateNamespacePipelineReleaseByID.funcUpdateNamespacePipelineReleaseByID(ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	}
	mmUpdateNamespacePipelineReleaseByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineReleaseByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, pipelineRelease)
	return
}

// UpdateNamespacePipelineReleaseByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineReleaseByID invocations
func (mmUpdateNamespacePipelineReleaseByID *RepositoryMock) UpdateNamespacePipelineReleaseByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.afterUpdateNamespacePipelineReleaseByIDCounter)
}

// UpdateNamespacePipelineReleaseByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineReleaseByID invocations
func (mmUpdateNamespacePipelineReleaseByID *RepositoryMock) UpdateNamespacePipelineReleaseByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseByID.beforeUpdateNamespacePipelineReleaseByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineReleaseByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineReleaseByID *mRepositoryMockUpdateNamespacePipelineReleaseByID) Calls() []*RepositoryMockUpdateNamespacePipelineReleaseByIDParams {
	mmUpdateNamespacePipelineReleaseByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineReleaseByIDParams, len(mmUpdateNamespacePipelineReleaseByID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineReleaseByID.callArgs)

	mmUpdateNamespacePipelineReleaseByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineReleaseByIDDone returns true if the count of the UpdateNamespacePipelineReleaseByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseByIDDone() bool {
	if m.UpdateNamespacePipelineReleaseByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineReleaseByIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineReleaseByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseByIDInspect() {
	for _, e := range m.UpdateNamespacePipelineReleaseByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID with params: %#v", *e.params)
		}
	}

	afterUpdateNamespacePipelineReleaseByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineReleaseByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineReleaseByIDCounter < 1 {
		if m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID with params: %#v", *m.UpdateNamespacePipelineReleaseByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineReleaseByID != nil && afterUpdateNamespacePipelineReleaseByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseByID")
	}

	if !m.UpdateNamespacePipelineReleaseByIDMock.invocationsDone() && afterUpdateNamespacePipelineReleaseByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineReleaseByID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineReleaseByIDMock.expectedInvocations), afterUpdateNamespacePipelineReleaseByIDCounter)
	}
}

type mRepositoryMockUpdateNamespacePipelineReleaseIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation
	expectations       []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation

	callArgs []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation specifies expectation struct of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams
	paramPtrs *RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs
	results   *RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults
	Counter   uint64
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams contains parameters of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	pipelineUID    uuid.UUID
	id             string
	newID          string
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pipelineUID    *uuid.UUID
	id             *string
	newID          *string
}

// RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults contains results of the Repository.UpdateNamespacePipelineReleaseIDByID
type RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Optional() *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	mmUpdateNamespacePipelineReleaseIDByID.optional = true
	return mmUpdateNamespacePipelineReleaseIDByID
}

// Expect sets up expected params for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Expect(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}
	for _, e := range mmUpdateNamespacePipelineReleaseIDByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params) {
			mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectPipelineUIDParam3 sets up expected param pipelineUID for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectPipelineUIDParam3(pipelineUID uuid.UUID) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectIdParam4 sets up expected param id for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectIdParam4(id string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.id = &id

	return mmUpdateNamespacePipelineReleaseIDByID
}

// ExpectNewIDParam5 sets up expected param newID for Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) ExpectNewIDParam5(newID string) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.params != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Expect")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParamPtrs{}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.paramPtrs.newID = &newID

	return mmUpdateNamespacePipelineReleaseIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string)) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.inspectFuncUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespacePipelineReleaseIDByID")
	}

	mmUpdateNamespacePipelineReleaseIDByID.mock.inspectFuncUpdateNamespacePipelineReleaseIDByID = f

	return mmUpdateNamespacePipelineReleaseIDByID
}

// Return sets up results that will be returned by Repository.UpdateNamespacePipelineReleaseIDByID
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil {
		mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{mock: mmUpdateNamespacePipelineReleaseIDByID.mock}
	}
	mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation.results = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults{err}
	return mmUpdateNamespacePipelineReleaseIDByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespacePipelineReleaseIDByID method
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Set(f func(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespacePipelineReleaseIDByID method")
	}

	if len(mmUpdateNamespacePipelineReleaseIDByID.expectations) > 0 {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespacePipelineReleaseIDByID method")
	}

	mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID = f
	return mmUpdateNamespacePipelineReleaseIDByID.mock
}

// When sets expectation for the Repository.UpdateNamespacePipelineReleaseIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) When(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) *RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation {
	if mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation{
		mock:   mmUpdateNamespacePipelineReleaseIDByID.mock,
		params: &RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID},
	}
	mmUpdateNamespacePipelineReleaseIDByID.expectations = append(mmUpdateNamespacePipelineReleaseIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespacePipelineReleaseIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespacePipelineReleaseIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespacePipelineReleaseIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespacePipelineReleaseIDByID should be invoked
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Times(n uint64) *mRepositoryMockUpdateNamespacePipelineReleaseIDByID {
	if n == 0 {
		mmUpdateNamespacePipelineReleaseIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespacePipelineReleaseIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespacePipelineReleaseIDByID.expectedInvocations, n)
	return mmUpdateNamespacePipelineReleaseIDByID
}

func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) invocationsDone() bool {
	if len(mmUpdateNamespacePipelineReleaseIDByID.expectations) == 0 && mmUpdateNamespacePipelineReleaseIDByID.defaultExpectation == nil && mmUpdateNamespacePipelineReleaseIDByID.mock.funcUpdateNamespacePipelineReleaseIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.mock.afterUpdateNamespacePipelineReleaseIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespacePipelineReleaseIDByID implements repository.Repository
func (mmUpdateNamespacePipelineReleaseIDByID *RepositoryMock) UpdateNamespacePipelineReleaseIDByID(ctx context.Context, ownerPermalink string, pipelineUID uuid.UUID, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseIDByID.beforeUpdateNamespacePipelineReleaseIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseIDByID.afterUpdateNamespacePipelineReleaseIDByIDCounter, 1)

	if mmUpdateNamespacePipelineReleaseIDByID.inspectFuncUpdateNamespacePipelineReleaseIDByID != nil {
		mmUpdateNamespacePipelineReleaseIDByID.inspectFuncUpdateNamespacePipelineReleaseIDByID(ctx, ownerPermalink, pipelineUID, id, newID)
	}

	mm_params := RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}

	// Record call args
	mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.mutex.Lock()
	mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.callArgs = append(mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.callArgs, &mm_params)
	mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams{ctx, ownerPermalink, pipelineUID, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameter newID, want: %#v, got: %#v%s\n", *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespacePipelineReleaseIDByID.t.Errorf("RepositoryMock.UpdateNamespacePipelineReleaseIDByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespacePipelineReleaseIDByID.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespacePipelineReleaseIDByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespacePipelineReleaseIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespacePipelineReleaseIDByID.funcUpdateNamespacePipelineReleaseIDByID != nil {
		return mmUpdateNamespacePipelineReleaseIDByID.funcUpdateNamespacePipelineReleaseIDByID(ctx, ownerPermalink, pipelineUID, id, newID)
	}
	mmUpdateNamespacePipelineReleaseIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID. %v %v %v %v %v", ctx, ownerPermalink, pipelineUID, id, newID)
	return
}

// UpdateNamespacePipelineReleaseIDByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespacePipelineReleaseIDByID invocations
func (mmUpdateNamespacePipelineReleaseIDByID *RepositoryMock) UpdateNamespacePipelineReleaseIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.afterUpdateNamespacePipelineReleaseIDByIDCounter)
}

// UpdateNamespacePipelineReleaseIDByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespacePipelineReleaseIDByID invocations
func (mmUpdateNamespacePipelineReleaseIDByID *RepositoryMock) UpdateNamespacePipelineReleaseIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespacePipelineReleaseIDByID.beforeUpdateNamespacePipelineReleaseIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespacePipelineReleaseIDByID *mRepositoryMockUpdateNamespacePipelineReleaseIDByID) Calls() []*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams {
	mmUpdateNamespacePipelineReleaseIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespacePipelineReleaseIDByIDParams, len(mmUpdateNamespacePipelineReleaseIDByID.callArgs))
	copy(argCopy, mmUpdateNamespacePipelineReleaseIDByID.callArgs)

	mmUpdateNamespacePipelineReleaseIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespacePipelineReleaseIDByIDDone returns true if the count of the UpdateNamespacePipelineReleaseIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseIDByIDDone() bool {
	if m.UpdateNamespacePipelineReleaseIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespacePipelineReleaseIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespacePipelineReleaseIDByIDMock.invocationsDone()
}

// MinimockUpdateNamespacePipelineReleaseIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespacePipelineReleaseIDByIDInspect() {
	for _, e := range m.UpdateNamespacePipelineReleaseIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID with params: %#v", *e.params)
		}
	}

	afterUpdateNamespacePipelineReleaseIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespacePipelineReleaseIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation != nil && afterUpdateNamespacePipelineReleaseIDByIDCounter < 1 {
		if m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID with params: %#v", *m.UpdateNamespacePipelineReleaseIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespacePipelineReleaseIDByID != nil && afterUpdateNamespacePipelineReleaseIDByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateNamespacePipelineReleaseIDByID")
	}

	if !m.UpdateNamespacePipelineReleaseIDByIDMock.invocationsDone() && afterUpdateNamespacePipelineReleaseIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespacePipelineReleaseIDByID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespacePipelineReleaseIDByIDMock.expectedInvocations), afterUpdateNamespacePipelineReleaseIDByIDCounter)
	}
}

type mRepositoryMockUpdateNamespaceSecretByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceSecretByIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceSecretByIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceSecretByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateNamespaceSecretByIDExpectation specifies expectation struct of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateNamespaceSecretByIDParams
	paramPtrs *RepositoryMockUpdateNamespaceSecretByIDParamPtrs
	results   *RepositoryMockUpdateNamespaceSecretByIDResults
	Counter   uint64
}

// RepositoryMockUpdateNamespaceSecretByIDParams contains parameters of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	secret         *datamodel.Secret
}

// RepositoryMockUpdateNamespaceSecretByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	secret         **datamodel.Secret
}

// RepositoryMockUpdateNamespaceSecretByIDResults contains results of the Repository.UpdateNamespaceSecretByID
type RepositoryMockUpdateNamespaceSecretByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Optional() *mRepositoryMockUpdateNamespaceSecretByID {
	mmUpdateNamespaceSecretByID.optional = true
	return mmUpdateNamespaceSecretByID
}

// Expect sets up expected params for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Expect(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceSecretByID.defaultExpectation.params = &RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}
	for _, e := range mmUpdateNamespaceSecretByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceSecretByID.defaultExpectation.params) {
			mmUpdateNamespaceSecretByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceSecretByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceSecretByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateNamespaceSecretByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmUpdateNamespaceSecretByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.id = &id

	return mmUpdateNamespaceSecretByID
}

// ExpectSecretParam4 sets up expected param secret for Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) ExpectSecretParam4(secret *datamodel.Secret) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{}
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.params != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Expect")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceSecretByIDParamPtrs{}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.paramPtrs.secret = &secret

	return mmUpdateNamespaceSecretByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret)) *mRepositoryMockUpdateNamespaceSecretByID {
	if mmUpdateNamespaceSecretByID.mock.inspectFuncUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceSecretByID")
	}

	mmUpdateNamespaceSecretByID.mock.inspectFuncUpdateNamespaceSecretByID = f

	return mmUpdateNamespaceSecretByID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceSecretByID
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	if mmUpdateNamespaceSecretByID.defaultExpectation == nil {
		mmUpdateNamespaceSecretByID.defaultExpectation = &RepositoryMockUpdateNamespaceSecretByIDExpectation{mock: mmUpdateNamespaceSecretByID.mock}
	}
	mmUpdateNamespaceSecretByID.defaultExpectation.results = &RepositoryMockUpdateNamespaceSecretByIDResults{err}
	return mmUpdateNamespaceSecretByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceSecretByID method
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Set(f func(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error)) *RepositoryMock {
	if mmUpdateNamespaceSecretByID.defaultExpectation != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceSecretByID method")
	}

	if len(mmUpdateNamespaceSecretByID.expectations) > 0 {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceSecretByID method")
	}

	mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID = f
	return mmUpdateNamespaceSecretByID.mock
}

// When sets expectation for the Repository.UpdateNamespaceSecretByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) When(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) *RepositoryMockUpdateNamespaceSecretByIDExpectation {
	if mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceSecretByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceSecretByIDExpectation{
		mock:   mmUpdateNamespaceSecretByID.mock,
		params: &RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret},
	}
	mmUpdateNamespaceSecretByID.expectations = append(mmUpdateNamespaceSecretByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceSecretByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceSecretByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceSecretByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceSecretByID should be invoked
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Times(n uint64) *mRepositoryMockUpdateNamespaceSecretByID {
	if n == 0 {
		mmUpdateNamespaceSecretByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceSecretByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceSecretByID.expectedInvocations, n)
	return mmUpdateNamespaceSecretByID
}

func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) invocationsDone() bool {
	if len(mmUpdateNamespaceSecretByID.expectations) == 0 && mmUpdateNamespaceSecretByID.defaultExpectation == nil && mmUpdateNamespaceSecretByID.mock.funcUpdateNamespaceSecretByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.mock.afterUpdateNamespaceSecretByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceSecretByID implements repository.Repository
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByID(ctx context.Context, ownerPermalink string, id string, secret *datamodel.Secret) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.beforeUpdateNamespaceSecretByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.afterUpdateNamespaceSecretByIDCounter, 1)

	if mmUpdateNamespaceSecretByID.inspectFuncUpdateNamespaceSecretByID != nil {
		mmUpdateNamespaceSecretByID.inspectFuncUpdateNamespaceSecretByID(ctx, ownerPermalink, id, secret)
	}

	mm_params := RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}

	// Record call args
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.mutex.Lock()
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.callArgs = append(mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.callArgs, &mm_params)
	mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceSecretByIDParams{ctx, ownerPermalink, id, secret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.secret != nil && !minimock.Equal(*mm_want_ptrs.secret, mm_got.secret) {
				mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameter secret, want: %#v, got: %#v%s\n", *mm_want_ptrs.secret, mm_got.secret, minimock.Diff(*mm_want_ptrs.secret, mm_got.secret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceSecretByID.t.Errorf("RepositoryMock.UpdateNamespaceSecretByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceSecretByID.UpdateNamespaceSecretByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceSecretByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceSecretByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespaceSecretByID.funcUpdateNamespaceSecretByID != nil {
		return mmUpdateNamespaceSecretByID.funcUpdateNamespaceSecretByID(ctx, ownerPermalink, id, secret)
	}
	mmUpdateNamespaceSecretByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceSecretByID. %v %v %v %v", ctx, ownerPermalink, id, secret)
	return
}

// UpdateNamespaceSecretByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceSecretByID invocations
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.afterUpdateNamespaceSecretByIDCounter)
}

// UpdateNamespaceSecretByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceSecretByID invocations
func (mmUpdateNamespaceSecretByID *RepositoryMock) UpdateNamespaceSecretByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceSecretByID.beforeUpdateNamespaceSecretByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceSecretByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceSecretByID *mRepositoryMockUpdateNamespaceSecretByID) Calls() []*RepositoryMockUpdateNamespaceSecretByIDParams {
	mmUpdateNamespaceSecretByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceSecretByIDParams, len(mmUpdateNamespaceSecretByID.callArgs))
	copy(argCopy, mmUpdateNamespaceSecretByID.callArgs)

	mmUpdateNamespaceSecretByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceSecretByIDDone returns true if the count of the UpdateNamespaceSecretByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceSecretByIDDone() bool {
	if m.UpdateNamespaceSecretByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceSecretByIDMock.invocationsDone()
}

// MinimockUpdateNamespaceSecretByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceSecretByIDInspect() {
	for _, e := range m.UpdateNamespaceSecretByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID with params: %#v", *e.params)
		}
	}

	afterUpdateNamespaceSecretByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceSecretByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceSecretByIDMock.defaultExpectation != nil && afterUpdateNamespaceSecretByIDCounter < 1 {
		if m.UpdateNamespaceSecretByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateNamespaceSecretByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceSecretByID with params: %#v", *m.UpdateNamespaceSecretByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceSecretByID != nil && afterUpdateNamespaceSecretByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateNamespaceSecretByID")
	}

	if !m.UpdateNamespaceSecretByIDMock.invocationsDone() && afterUpdateNamespaceSecretByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceSecretByID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceSecretByIDMock.expectedInvocations), afterUpdateNamespaceSecretByIDCounter)
	}
}

type mRepositoryMockUpdatePipelineRunStats struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdatePipelineRunStatsExpectation
	expectations       []*RepositoryMockUpdatePipelineRunStatsExpectation

	callArgs []*RepositoryMockUpdatePipelineRunStatsParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdatePipelineRunStatsExpectation specifies expectation struct of the Repository.UpdatePipelineRunStats
type RepositoryMockUpdatePipelineRunStatsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdatePipelineRunStatsParams
	results *RepositoryMockUpdatePipelineRunStatsResults
	Counter uint64
}

// RepositoryMockUpdatePipelineRunStatsParams contains parameters of the Repository.UpdatePipelineRunStats
type RepositoryMockUpdatePipelineRunStatsParams struct {
	ctx context.Context
	uid uuid.UUID
}

// RepositoryMockUpdatePipelineRunStatsResults contains results of the Repository.UpdatePipelineRunStats
type RepositoryMockUpdatePipelineRunStatsResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdatePipelineRunStats
func (mmUpdatePipelineRunStats *mRepositoryMockUpdatePipelineRunStats) Expect(ctx context.Context, uid uuid.UUID) *mRepositoryMockUpdatePipelineRunStats {
	if mmUpdatePipelineRunStats.mock.funcUpdatePipelineRunStats != nil {
		mmUpdatePipelineRunStats.mock.t.Fatalf("RepositoryMock.UpdatePipelineRunStats mock is already set by Set")
	}

	if mmUpdatePipelineRunStats.defaultExpectation == nil {
		mmUpdatePipelineRunStats.defaultExpectation = &RepositoryMockUpdatePipelineRunStatsExpectation{}
	}

	mmUpdatePipelineRunStats.defaultExpectation.params = &RepositoryMockUpdatePipelineRunStatsParams{ctx, uid}
	for _, e := range mmUpdatePipelineRunStats.expectations {
		if minimock.Equal(e.params, mmUpdatePipelineRunStats.defaultExpectation.params) {
			mmUpdatePipelineRunStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePipelineRunStats.defaultExpectation.params)
		}
	}

	return mmUpdatePipelineRunStats
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdatePipelineRunStats
func (mmUpdatePipelineRunStats *mRepositoryMockUpdatePipelineRunStats) Inspect(f func(ctx context.Context, uid uuid.UUID)) *mRepositoryMockUpdatePipelineRunStats {
	if mmUpdatePipelineRunStats.mock.inspectFuncUpdatePipelineRunStats != nil {
		mmUpdatePipelineRunStats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdatePipelineRunStats")
	}

	mmUpdatePipelineRunStats.mock.inspectFuncUpdatePipelineRunStats = f

	return mmUpdatePipelineRunStats
}

// Return sets up results that will be returned by Repository.UpdatePipelineRunStats
func (mmUpdatePipelineRunStats *mRepositoryMockUpdatePipelineRunStats) Return(err error) *RepositoryMock {
	if mmUpdatePipelineRunStats.mock.funcUpdatePipelineRunStats != nil {
		mmUpdatePipelineRunStats.mock.t.Fatalf("RepositoryMock.UpdatePipelineRunStats mock is already set by Set")
	}

	if mmUpdatePipelineRunStats.defaultExpectation == nil {
		mmUpdatePipelineRunStats.defaultExpectation = &RepositoryMockUpdatePipelineRunStatsExpectation{mock: mmUpdatePipelineRunStats.mock}
	}
	mmUpdatePipelineRunStats.defaultExpectation.results = &RepositoryMockUpdatePipelineRunStatsResults{err}
	return mmUpdatePipelineRunStats.mock
}

// Set uses given function f to mock the Repository.UpdatePipelineRunStats method
func (mmUpdatePipelineRunStats *mRepositoryMockUpdatePipelineRunStats) Set(f func(ctx context.Context, uid uuid.UUID) (err error)) *RepositoryMock {
	if mmUpdatePipelineRunStats.defaultExpectation != nil {
		mmUpdatePipelineRunStats.mock.t.Fatalf("Default expectation is already set for the Repository.UpdatePipelineRunStats method")
	}

	if len(mmUpdatePipelineRunStats.expectations) > 0 {
		mmUpdatePipelineRunStats.mock.t.Fatalf("Some expectations are already set for the Repository.UpdatePipelineRunStats method")
	}

	mmUpdatePipelineRunStats.mock.funcUpdatePipelineRunStats = f
	return mmUpdatePipelineRunStats.mock
}

// When sets expectation for the Repository.UpdatePipelineRunStats which will trigger the result defined by the following
// Then helper
func (mmUpdatePipelineRunStats *mRepositoryMockUpdatePipelineRunStats) When(ctx context.Context, uid uuid.UUID) *RepositoryMockUpdatePipelineRunStatsExpectation {
	if mmUpdatePipelineRunStats.mock.funcUpdatePipelineRunStats != nil {
		mmUpdatePipelineRunStats.mock.t.Fatalf("RepositoryMock.UpdatePipelineRunStats mock is already set by Set")
	}

	expectation := &RepositoryMockUpdatePipelineRunStatsExpectation{
		mock:   mmUpdatePipelineRunStats.mock,
		params: &RepositoryMockUpdatePipelineRunStatsParams{ctx, uid},
	}
	mmUpdatePipelineRunStats.expectations = append(mmUpdatePipelineRunStats.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdatePipelineRunStats return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdatePipelineRunStatsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdatePipelineRunStatsResults{err}
	return e.mock
}

// UpdatePipelineRunStats implements repository.Repository
func (mmUpdatePipelineRunStats *RepositoryMock) UpdatePipelineRunStats(ctx context.Context, uid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmUpdatePipelineRunStats.beforeUpdatePipelineRunStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePipelineRunStats.afterUpdatePipelineRunStatsCounter, 1)

	if mmUpdatePipelineRunStats.inspectFuncUpdatePipelineRunStats != nil {
		mmUpdatePipelineRunStats.inspectFuncUpdatePipelineRunStats(ctx, uid)
	}

	mm_params := RepositoryMockUpdatePipelineRunStatsParams{ctx, uid}

	// Record call args
	mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.mutex.Lock()
	mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.callArgs = append(mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.callArgs, &mm_params)
	mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.mutex.Unlock()

	for _, e := range mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.defaultExpectation.params
		mm_got := RepositoryMockUpdatePipelineRunStatsParams{ctx, uid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePipelineRunStats.t.Errorf("RepositoryMock.UpdatePipelineRunStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePipelineRunStats.UpdatePipelineRunStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePipelineRunStats.t.Fatal("No results are set for the RepositoryMock.UpdatePipelineRunStats")
		}
		return (*mm_results).err
	}
	if mmUpdatePipelineRunStats.funcUpdatePipelineRunStats != nil {
		return mmUpdatePipelineRunStats.funcUpdatePipelineRunStats(ctx, uid)
	}
	mmUpdatePipelineRunStats.t.Fatalf("Unexpected call to RepositoryMock.UpdatePipelineRunStats. %v %v", ctx, uid)
	return
}

// UpdatePipelineRunStatsAfterCounter returns a count of finished RepositoryMock.UpdatePipelineRunStats invocations
func (mmUpdatePipelineRunStats *RepositoryMock) UpdatePipelineRunStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineRunStats.afterUpdatePipelineRunStatsCounter)
}

// UpdatePipelineRunStatsBeforeCounter returns a count of RepositoryMock.UpdatePipelineRunStats invocations
func (mmUpdatePipelineRunStats *RepositoryMock) UpdatePipelineRunStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePipelineRunStats.beforeUpdatePipelineRunStatsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdatePipelineRunStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePipelineRunStats *mRepositoryMockUpdatePipelineRunStats) Calls() []*RepositoryMockUpdatePipelineRunStatsParams {
	mmUpdatePipelineRunStats.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdatePipelineRunStatsParams, len(mmUpdatePipelineRunStats.callArgs))
	copy(argCopy, mmUpdatePipelineRunStats.callArgs)

	mmUpdatePipelineRunStats.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePipelineRunStatsDone returns true if the count of the UpdatePipelineRunStats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdatePipelineRunStatsDone() bool {
	for _, e := range m.UpdatePipelineRunStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineRunStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePipelineRunStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineRunStats != nil && mm_atomic.LoadUint64(&m.afterUpdatePipelineRunStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdatePipelineRunStatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdatePipelineRunStatsInspect() {
	for _, e := range m.UpdatePipelineRunStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRunStats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePipelineRunStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePipelineRunStatsCounter) < 1 {
		if m.UpdatePipelineRunStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdatePipelineRunStats")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdatePipelineRunStats with params: %#v", *m.UpdatePipelineRunStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePipelineRunStats != nil && mm_atomic.LoadUint64(&m.afterUpdatePipelineRunStatsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdatePipelineRunStats")
	}
}

type mRepositoryMockUpsertComponentDefinition struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertComponentDefinitionExpectation
	expectations       []*RepositoryMockUpsertComponentDefinitionExpectation

	callArgs []*RepositoryMockUpsertComponentDefinitionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpsertComponentDefinitionExpectation specifies expectation struct of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpsertComponentDefinitionParams
	paramPtrs *RepositoryMockUpsertComponentDefinitionParamPtrs
	results   *RepositoryMockUpsertComponentDefinitionResults
	Counter   uint64
}

// RepositoryMockUpsertComponentDefinitionParams contains parameters of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionParams struct {
	ctx context.Context
	cp1 *pb.ComponentDefinition
}

// RepositoryMockUpsertComponentDefinitionParamPtrs contains pointers to parameters of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionParamPtrs struct {
	ctx *context.Context
	cp1 **pb.ComponentDefinition
}

// RepositoryMockUpsertComponentDefinitionResults contains results of the Repository.UpsertComponentDefinition
type RepositoryMockUpsertComponentDefinitionResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Optional() *mRepositoryMockUpsertComponentDefinition {
	mmUpsertComponentDefinition.optional = true
	return mmUpsertComponentDefinition
}

// Expect sets up expected params for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Expect(ctx context.Context, cp1 *pb.ComponentDefinition) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by ExpectParams functions")
	}

	mmUpsertComponentDefinition.defaultExpectation.params = &RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}
	for _, e := range mmUpsertComponentDefinition.expectations {
		if minimock.Equal(e.params, mmUpsertComponentDefinition.defaultExpectation.params) {
			mmUpsertComponentDefinition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertComponentDefinition.defaultExpectation.params)
		}
	}

	return mmUpsertComponentDefinition
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.params != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Expect")
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentDefinitionParamPtrs{}
	}
	mmUpsertComponentDefinition.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpsertComponentDefinition
}

// ExpectCp1Param2 sets up expected param cp1 for Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) ExpectCp1Param2(cp1 *pb.ComponentDefinition) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{}
	}

	if mmUpsertComponentDefinition.defaultExpectation.params != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Expect")
	}

	if mmUpsertComponentDefinition.defaultExpectation.paramPtrs == nil {
		mmUpsertComponentDefinition.defaultExpectation.paramPtrs = &RepositoryMockUpsertComponentDefinitionParamPtrs{}
	}
	mmUpsertComponentDefinition.defaultExpectation.paramPtrs.cp1 = &cp1

	return mmUpsertComponentDefinition
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Inspect(f func(ctx context.Context, cp1 *pb.ComponentDefinition)) *mRepositoryMockUpsertComponentDefinition {
	if mmUpsertComponentDefinition.mock.inspectFuncUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertComponentDefinition")
	}

	mmUpsertComponentDefinition.mock.inspectFuncUpsertComponentDefinition = f

	return mmUpsertComponentDefinition
}

// Return sets up results that will be returned by Repository.UpsertComponentDefinition
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Return(err error) *RepositoryMock {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	if mmUpsertComponentDefinition.defaultExpectation == nil {
		mmUpsertComponentDefinition.defaultExpectation = &RepositoryMockUpsertComponentDefinitionExpectation{mock: mmUpsertComponentDefinition.mock}
	}
	mmUpsertComponentDefinition.defaultExpectation.results = &RepositoryMockUpsertComponentDefinitionResults{err}
	return mmUpsertComponentDefinition.mock
}

// Set uses given function f to mock the Repository.UpsertComponentDefinition method
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Set(f func(ctx context.Context, cp1 *pb.ComponentDefinition) (err error)) *RepositoryMock {
	if mmUpsertComponentDefinition.defaultExpectation != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertComponentDefinition method")
	}

	if len(mmUpsertComponentDefinition.expectations) > 0 {
		mmUpsertComponentDefinition.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertComponentDefinition method")
	}

	mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition = f
	return mmUpsertComponentDefinition.mock
}

// When sets expectation for the Repository.UpsertComponentDefinition which will trigger the result defined by the following
// Then helper
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) When(ctx context.Context, cp1 *pb.ComponentDefinition) *RepositoryMockUpsertComponentDefinitionExpectation {
	if mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.mock.t.Fatalf("RepositoryMock.UpsertComponentDefinition mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertComponentDefinitionExpectation{
		mock:   mmUpsertComponentDefinition.mock,
		params: &RepositoryMockUpsertComponentDefinitionParams{ctx, cp1},
	}
	mmUpsertComponentDefinition.expectations = append(mmUpsertComponentDefinition.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertComponentDefinition return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertComponentDefinitionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertComponentDefinitionResults{err}
	return e.mock
}

// Times sets number of times Repository.UpsertComponentDefinition should be invoked
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Times(n uint64) *mRepositoryMockUpsertComponentDefinition {
	if n == 0 {
		mmUpsertComponentDefinition.mock.t.Fatalf("Times of RepositoryMock.UpsertComponentDefinition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertComponentDefinition.expectedInvocations, n)
	return mmUpsertComponentDefinition
}

func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) invocationsDone() bool {
	if len(mmUpsertComponentDefinition.expectations) == 0 && mmUpsertComponentDefinition.defaultExpectation == nil && mmUpsertComponentDefinition.mock.funcUpsertComponentDefinition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertComponentDefinition.mock.afterUpsertComponentDefinitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertComponentDefinition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertComponentDefinition implements repository.Repository
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinition(ctx context.Context, cp1 *pb.ComponentDefinition) (err error) {
	mm_atomic.AddUint64(&mmUpsertComponentDefinition.beforeUpsertComponentDefinitionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertComponentDefinition.afterUpsertComponentDefinitionCounter, 1)

	if mmUpsertComponentDefinition.inspectFuncUpsertComponentDefinition != nil {
		mmUpsertComponentDefinition.inspectFuncUpsertComponentDefinition(ctx, cp1)
	}

	mm_params := RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}

	// Record call args
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.mutex.Lock()
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.callArgs = append(mmUpsertComponentDefinition.UpsertComponentDefinitionMock.callArgs, &mm_params)
	mmUpsertComponentDefinition.UpsertComponentDefinitionMock.mutex.Unlock()

	for _, e := range mmUpsertComponentDefinition.UpsertComponentDefinitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertComponentDefinitionParams{ctx, cp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cp1 != nil && !minimock.Equal(*mm_want_ptrs.cp1, mm_got.cp1) {
				mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameter cp1, want: %#v, got: %#v%s\n", *mm_want_ptrs.cp1, mm_got.cp1, minimock.Diff(*mm_want_ptrs.cp1, mm_got.cp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertComponentDefinition.t.Errorf("RepositoryMock.UpsertComponentDefinition got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertComponentDefinition.UpsertComponentDefinitionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertComponentDefinition.t.Fatal("No results are set for the RepositoryMock.UpsertComponentDefinition")
		}
		return (*mm_results).err
	}
	if mmUpsertComponentDefinition.funcUpsertComponentDefinition != nil {
		return mmUpsertComponentDefinition.funcUpsertComponentDefinition(ctx, cp1)
	}
	mmUpsertComponentDefinition.t.Fatalf("Unexpected call to RepositoryMock.UpsertComponentDefinition. %v %v", ctx, cp1)
	return
}

// UpsertComponentDefinitionAfterCounter returns a count of finished RepositoryMock.UpsertComponentDefinition invocations
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentDefinition.afterUpsertComponentDefinitionCounter)
}

// UpsertComponentDefinitionBeforeCounter returns a count of RepositoryMock.UpsertComponentDefinition invocations
func (mmUpsertComponentDefinition *RepositoryMock) UpsertComponentDefinitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertComponentDefinition.beforeUpsertComponentDefinitionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertComponentDefinition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertComponentDefinition *mRepositoryMockUpsertComponentDefinition) Calls() []*RepositoryMockUpsertComponentDefinitionParams {
	mmUpsertComponentDefinition.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertComponentDefinitionParams, len(mmUpsertComponentDefinition.callArgs))
	copy(argCopy, mmUpsertComponentDefinition.callArgs)

	mmUpsertComponentDefinition.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertComponentDefinitionDone returns true if the count of the UpsertComponentDefinition invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertComponentDefinitionDone() bool {
	if m.UpsertComponentDefinitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertComponentDefinitionMock.invocationsDone()
}

// MinimockUpsertComponentDefinitionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertComponentDefinitionInspect() {
	for _, e := range m.UpsertComponentDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition with params: %#v", *e.params)
		}
	}

	afterUpsertComponentDefinitionCounter := mm_atomic.LoadUint64(&m.afterUpsertComponentDefinitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertComponentDefinitionMock.defaultExpectation != nil && afterUpsertComponentDefinitionCounter < 1 {
		if m.UpsertComponentDefinitionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpsertComponentDefinition")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertComponentDefinition with params: %#v", *m.UpsertComponentDefinitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertComponentDefinition != nil && afterUpsertComponentDefinitionCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpsertComponentDefinition")
	}

	if !m.UpsertComponentDefinitionMock.invocationsDone() && afterUpsertComponentDefinitionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertComponentDefinition but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertComponentDefinitionMock.expectedInvocations), afterUpsertComponentDefinitionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddPipelineClonesInspect()

			m.MinimockAddPipelineRunsInspect()

			m.MinimockCreateNamespacePipelineInspect()

			m.MinimockCreateNamespacePipelineReleaseInspect()

			m.MinimockCreateNamespaceSecretInspect()

			m.MinimockCreatePipelineTagsInspect()

			m.MinimockDeleteNamespacePipelineByIDInspect()

			m.MinimockDeleteNamespacePipelineReleaseByIDInspect()

			m.MinimockDeleteNamespaceSecretByIDInspect()

			m.MinimockDeletePipelineTagsInspect()

			m.MinimockGetDefinitionByUIDInspect()

			m.MinimockGetHubStatsInspect()

			m.MinimockGetLatestNamespacePipelineReleaseInspect()

			m.MinimockGetNamespacePipelineByIDInspect()

			m.MinimockGetNamespacePipelineReleaseByIDInspect()

			m.MinimockGetNamespaceSecretByIDInspect()

			m.MinimockGetPipelineByIDAdminInspect()

			m.MinimockGetPipelineByUIDInspect()

			m.MinimockGetPipelineByUIDAdminInspect()

			m.MinimockListComponentDefinitionUIDsInspect()

			m.MinimockListNamespacePipelineReleasesInspect()

			m.MinimockListNamespacePipelinesInspect()

			m.MinimockListNamespaceSecretsInspect()

			m.MinimockListPipelineTagsInspect()

			m.MinimockListPipelinesInspect()

			m.MinimockListPipelinesAdminInspect()

			m.MinimockTranspileFilterInspect()

			m.MinimockUpdateNamespacePipelineByUIDInspect()

			m.MinimockUpdateNamespacePipelineIDByIDInspect()

			m.MinimockUpdateNamespacePipelineReleaseByIDInspect()

			m.MinimockUpdateNamespacePipelineReleaseIDByIDInspect()

			m.MinimockUpdateNamespaceSecretByIDInspect()

			m.MinimockUpdatePipelineRunStatsInspect()

			m.MinimockUpsertComponentDefinitionInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddPipelineClonesDone() &&
		m.MinimockAddPipelineRunsDone() &&
		m.MinimockCreateNamespacePipelineDone() &&
		m.MinimockCreateNamespacePipelineReleaseDone() &&
		m.MinimockCreateNamespaceSecretDone() &&
		m.MinimockCreatePipelineTagsDone() &&
		m.MinimockDeleteNamespacePipelineByIDDone() &&
		m.MinimockDeleteNamespacePipelineReleaseByIDDone() &&
		m.MinimockDeleteNamespaceSecretByIDDone() &&
		m.MinimockDeletePipelineTagsDone() &&
		m.MinimockGetDefinitionByUIDDone() &&
		m.MinimockGetHubStatsDone() &&
		m.MinimockGetLatestNamespacePipelineReleaseDone() &&
		m.MinimockGetNamespacePipelineByIDDone() &&
		m.MinimockGetNamespacePipelineReleaseByIDDone() &&
		m.MinimockGetNamespaceSecretByIDDone() &&
		m.MinimockGetPipelineByIDAdminDone() &&
		m.MinimockGetPipelineByUIDDone() &&
		m.MinimockGetPipelineByUIDAdminDone() &&
		m.MinimockListComponentDefinitionUIDsDone() &&
		m.MinimockListNamespacePipelineReleasesDone() &&
		m.MinimockListNamespacePipelinesDone() &&
		m.MinimockListNamespaceSecretsDone() &&
		m.MinimockListPipelineTagsDone() &&
		m.MinimockListPipelinesDone() &&
		m.MinimockListPipelinesAdminDone() &&
		m.MinimockTranspileFilterDone() &&
		m.MinimockUpdateNamespacePipelineByUIDDone() &&
		m.MinimockUpdateNamespacePipelineIDByIDDone() &&
		m.MinimockUpdateNamespacePipelineReleaseByIDDone() &&
		m.MinimockUpdateNamespacePipelineReleaseIDByIDDone() &&
		m.MinimockUpdateNamespaceSecretByIDDone() &&
		m.MinimockUpdatePipelineRunStatsDone() &&
		m.MinimockUpsertComponentDefinitionDone()
}
