// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"context"
	"sync"

	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"

	minio "github.com/minio/minio-go/v7"

	mm_minio "github.com/instill-ai/pipeline-backend/pkg/minio"
)

// MinioIMock implements mm_minio.MinioI
type MinioIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteFile          func(ctx context.Context, filePath string) (err error)
	funcDeleteFileOrigin    string
	inspectFuncDeleteFile   func(ctx context.Context, filePath string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mMinioIMockDeleteFile

	funcGetFile          func(ctx context.Context, filePath string) (ba1 []byte, err error)
	funcGetFileOrigin    string
	inspectFuncGetFile   func(ctx context.Context, filePath string)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mMinioIMockGetFile

	funcGetFilesByPaths          func(ctx context.Context, filePaths []string) (fa1 []mm_minio.FileContent, err error)
	funcGetFilesByPathsOrigin    string
	inspectFuncGetFilesByPaths   func(ctx context.Context, filePaths []string)
	afterGetFilesByPathsCounter  uint64
	beforeGetFilesByPathsCounter uint64
	GetFilesByPathsMock          mMinioIMockGetFilesByPaths

	funcUploadFile          func(ctx context.Context, filePath string, fileContent any, fileMimeType string) (url string, objectInfo *minio.ObjectInfo, err error)
	funcUploadFileOrigin    string
	inspectFuncUploadFile   func(ctx context.Context, filePath string, fileContent any, fileMimeType string)
	afterUploadFileCounter  uint64
	beforeUploadFileCounter uint64
	UploadFileMock          mMinioIMockUploadFile

	funcUploadFileBytes          func(ctx context.Context, filePath string, fileBytes []byte, fileMimeType string) (url string, objectInfo *minio.ObjectInfo, err error)
	funcUploadFileBytesOrigin    string
	inspectFuncUploadFileBytes   func(ctx context.Context, filePath string, fileBytes []byte, fileMimeType string)
	afterUploadFileBytesCounter  uint64
	beforeUploadFileBytesCounter uint64
	UploadFileBytesMock          mMinioIMockUploadFileBytes
}

// NewMinioIMock returns a mock for mm_minio.MinioI
func NewMinioIMock(t minimock.Tester) *MinioIMock {
	m := &MinioIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteFileMock = mMinioIMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*MinioIMockDeleteFileParams{}

	m.GetFileMock = mMinioIMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*MinioIMockGetFileParams{}

	m.GetFilesByPathsMock = mMinioIMockGetFilesByPaths{mock: m}
	m.GetFilesByPathsMock.callArgs = []*MinioIMockGetFilesByPathsParams{}

	m.UploadFileMock = mMinioIMockUploadFile{mock: m}
	m.UploadFileMock.callArgs = []*MinioIMockUploadFileParams{}

	m.UploadFileBytesMock = mMinioIMockUploadFileBytes{mock: m}
	m.UploadFileBytesMock.callArgs = []*MinioIMockUploadFileBytesParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMinioIMockDeleteFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockDeleteFileExpectation
	expectations       []*MinioIMockDeleteFileExpectation

	callArgs []*MinioIMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockDeleteFileExpectation specifies expectation struct of the MinioI.DeleteFile
type MinioIMockDeleteFileExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockDeleteFileParams
	paramPtrs          *MinioIMockDeleteFileParamPtrs
	expectationOrigins MinioIMockDeleteFileExpectationOrigins
	results            *MinioIMockDeleteFileResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockDeleteFileParams contains parameters of the MinioI.DeleteFile
type MinioIMockDeleteFileParams struct {
	ctx      context.Context
	filePath string
}

// MinioIMockDeleteFileParamPtrs contains pointers to parameters of the MinioI.DeleteFile
type MinioIMockDeleteFileParamPtrs struct {
	ctx      *context.Context
	filePath *string
}

// MinioIMockDeleteFileResults contains results of the MinioI.DeleteFile
type MinioIMockDeleteFileResults struct {
	err error
}

// MinioIMockDeleteFileOrigins contains origins of expectations of the MinioI.DeleteFile
type MinioIMockDeleteFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mMinioIMockDeleteFile) Optional() *mMinioIMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Expect(ctx context.Context, filePath string) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &MinioIMockDeleteFileParams{ctx, filePath}
	mmDeleteFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &MinioIMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFile
}

// ExpectFilePathParam2 sets up expected param filePath for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) ExpectFilePathParam2(filePath string) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &MinioIMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmDeleteFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Inspect(f func(ctx context.Context, filePath string)) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Return(err error) *MinioIMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &MinioIMockDeleteFileResults{err}
	mmDeleteFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// Set uses given function f to mock the MinioI.DeleteFile method
func (mmDeleteFile *mMinioIMockDeleteFile) Set(f func(ctx context.Context, filePath string) (err error)) *MinioIMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the MinioI.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the MinioI.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	mmDeleteFile.mock.funcDeleteFileOrigin = minimock.CallerInfo(1)
	return mmDeleteFile.mock
}

// When sets expectation for the MinioI.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mMinioIMockDeleteFile) When(ctx context.Context, filePath string) *MinioIMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	expectation := &MinioIMockDeleteFileExpectation{
		mock:               mmDeleteFile.mock,
		params:             &MinioIMockDeleteFileParams{ctx, filePath},
		expectationOrigins: MinioIMockDeleteFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.DeleteFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockDeleteFileExpectation) Then(err error) *MinioIMock {
	e.results = &MinioIMockDeleteFileResults{err}
	return e.mock
}

// Times sets number of times MinioI.DeleteFile should be invoked
func (mmDeleteFile *mMinioIMockDeleteFile) Times(n uint64) *mMinioIMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of MinioIMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	mmDeleteFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFile
}

func (mmDeleteFile *mMinioIMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements mm_minio.MinioI
func (mmDeleteFile *MinioIMock) DeleteFile(ctx context.Context, filePath string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	mmDeleteFile.t.Helper()

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, filePath)
	}

	mm_params := MinioIMockDeleteFileParams{ctx, filePath}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockDeleteFileParams{ctx, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFile.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the MinioIMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, filePath)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to MinioIMock.DeleteFile. %v %v", ctx, filePath)
	return
}

// DeleteFileAfterCounter returns a count of finished MinioIMock.DeleteFile invocations
func (mmDeleteFile *MinioIMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of MinioIMock.DeleteFile invocations
func (mmDeleteFile *MinioIMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mMinioIMockDeleteFile) Calls() []*MinioIMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*MinioIMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s", m.DeleteFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s with params: %#v", m.DeleteFileMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.DeleteFile at\n%s", m.funcDeleteFileOrigin)
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.DeleteFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), m.DeleteFileMock.expectedInvocationsOrigin, afterDeleteFileCounter)
	}
}

type mMinioIMockGetFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetFileExpectation
	expectations       []*MinioIMockGetFileExpectation

	callArgs []*MinioIMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockGetFileExpectation specifies expectation struct of the MinioI.GetFile
type MinioIMockGetFileExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockGetFileParams
	paramPtrs          *MinioIMockGetFileParamPtrs
	expectationOrigins MinioIMockGetFileExpectationOrigins
	results            *MinioIMockGetFileResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockGetFileParams contains parameters of the MinioI.GetFile
type MinioIMockGetFileParams struct {
	ctx      context.Context
	filePath string
}

// MinioIMockGetFileParamPtrs contains pointers to parameters of the MinioI.GetFile
type MinioIMockGetFileParamPtrs struct {
	ctx      *context.Context
	filePath *string
}

// MinioIMockGetFileResults contains results of the MinioI.GetFile
type MinioIMockGetFileResults struct {
	ba1 []byte
	err error
}

// MinioIMockGetFileOrigins contains origins of expectations of the MinioI.GetFile
type MinioIMockGetFileExpectationOrigins struct {
	origin         string
	originCtx      string
	originFilePath string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mMinioIMockGetFile) Optional() *mMinioIMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Expect(ctx context.Context, filePath string) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &MinioIMockGetFileParams{ctx, filePath}
	mmGetFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &MinioIMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFile
}

// ExpectFilePathParam2 sets up expected param filePath for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) ExpectFilePathParam2(filePath string) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &MinioIMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmGetFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Inspect(f func(ctx context.Context, filePath string)) *mMinioIMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Return(ba1 []byte, err error) *MinioIMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &MinioIMockGetFileResults{ba1, err}
	mmGetFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// Set uses given function f to mock the MinioI.GetFile method
func (mmGetFile *mMinioIMockGetFile) Set(f func(ctx context.Context, filePath string) (ba1 []byte, err error)) *MinioIMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the MinioI.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the MinioI.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	mmGetFile.mock.funcGetFileOrigin = minimock.CallerInfo(1)
	return mmGetFile.mock
}

// When sets expectation for the MinioI.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mMinioIMockGetFile) When(ctx context.Context, filePath string) *MinioIMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	expectation := &MinioIMockGetFileExpectation{
		mock:               mmGetFile.mock,
		params:             &MinioIMockGetFileParams{ctx, filePath},
		expectationOrigins: MinioIMockGetFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetFileExpectation) Then(ba1 []byte, err error) *MinioIMock {
	e.results = &MinioIMockGetFileResults{ba1, err}
	return e.mock
}

// Times sets number of times MinioI.GetFile should be invoked
func (mmGetFile *mMinioIMockGetFile) Times(n uint64) *mMinioIMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of MinioIMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	mmGetFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFile
}

func (mmGetFile *mMinioIMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements mm_minio.MinioI
func (mmGetFile *MinioIMock) GetFile(ctx context.Context, filePath string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	mmGetFile.t.Helper()

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, filePath)
	}

	mm_params := MinioIMockGetFileParams{ctx, filePath}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetFileParams{ctx, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFile.GetFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the MinioIMock.GetFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, filePath)
	}
	mmGetFile.t.Fatalf("Unexpected call to MinioIMock.GetFile. %v %v", ctx, filePath)
	return
}

// GetFileAfterCounter returns a count of finished MinioIMock.GetFile invocations
func (mmGetFile *MinioIMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of MinioIMock.GetFile invocations
func (mmGetFile *MinioIMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mMinioIMockGetFile) Calls() []*MinioIMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*MinioIMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s", m.GetFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s with params: %#v", m.GetFileMock.defaultExpectation.expectationOrigins.origin, *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.GetFile at\n%s", m.funcGetFileOrigin)
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), m.GetFileMock.expectedInvocationsOrigin, afterGetFileCounter)
	}
}

type mMinioIMockGetFilesByPaths struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetFilesByPathsExpectation
	expectations       []*MinioIMockGetFilesByPathsExpectation

	callArgs []*MinioIMockGetFilesByPathsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockGetFilesByPathsExpectation specifies expectation struct of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockGetFilesByPathsParams
	paramPtrs          *MinioIMockGetFilesByPathsParamPtrs
	expectationOrigins MinioIMockGetFilesByPathsExpectationOrigins
	results            *MinioIMockGetFilesByPathsResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockGetFilesByPathsParams contains parameters of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsParams struct {
	ctx       context.Context
	filePaths []string
}

// MinioIMockGetFilesByPathsParamPtrs contains pointers to parameters of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsParamPtrs struct {
	ctx       *context.Context
	filePaths *[]string
}

// MinioIMockGetFilesByPathsResults contains results of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsResults struct {
	fa1 []mm_minio.FileContent
	err error
}

// MinioIMockGetFilesByPathsOrigins contains origins of expectations of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsExpectationOrigins struct {
	origin          string
	originCtx       string
	originFilePaths string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Optional() *mMinioIMockGetFilesByPaths {
	mmGetFilesByPaths.optional = true
	return mmGetFilesByPaths
}

// Expect sets up expected params for MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Expect(ctx context.Context, filePaths []string) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by ExpectParams functions")
	}

	mmGetFilesByPaths.defaultExpectation.params = &MinioIMockGetFilesByPathsParams{ctx, filePaths}
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFilesByPaths.expectations {
		if minimock.Equal(e.params, mmGetFilesByPaths.defaultExpectation.params) {
			mmGetFilesByPaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesByPaths.defaultExpectation.params)
		}
	}

	return mmGetFilesByPaths
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &MinioIMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// ExpectFilePathsParam2 sets up expected param filePaths for MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) ExpectFilePathsParam2(filePaths []string) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &MinioIMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.filePaths = &filePaths
	mmGetFilesByPaths.defaultExpectation.expectationOrigins.originFilePaths = minimock.CallerInfo(1)

	return mmGetFilesByPaths
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Inspect(f func(ctx context.Context, filePaths []string)) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetFilesByPaths")
	}

	mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths = f

	return mmGetFilesByPaths
}

// Return sets up results that will be returned by MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Return(fa1 []mm_minio.FileContent, err error) *MinioIMock {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{mock: mmGetFilesByPaths.mock}
	}
	mmGetFilesByPaths.defaultExpectation.results = &MinioIMockGetFilesByPathsResults{fa1, err}
	mmGetFilesByPaths.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// Set uses given function f to mock the MinioI.GetFilesByPaths method
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Set(f func(ctx context.Context, filePaths []string) (fa1 []mm_minio.FileContent, err error)) *MinioIMock {
	if mmGetFilesByPaths.defaultExpectation != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Default expectation is already set for the MinioI.GetFilesByPaths method")
	}

	if len(mmGetFilesByPaths.expectations) > 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Some expectations are already set for the MinioI.GetFilesByPaths method")
	}

	mmGetFilesByPaths.mock.funcGetFilesByPaths = f
	mmGetFilesByPaths.mock.funcGetFilesByPathsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths.mock
}

// When sets expectation for the MinioI.GetFilesByPaths which will trigger the result defined by the following
// Then helper
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) When(ctx context.Context, filePaths []string) *MinioIMockGetFilesByPathsExpectation {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	expectation := &MinioIMockGetFilesByPathsExpectation{
		mock:               mmGetFilesByPaths.mock,
		params:             &MinioIMockGetFilesByPathsParams{ctx, filePaths},
		expectationOrigins: MinioIMockGetFilesByPathsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFilesByPaths.expectations = append(mmGetFilesByPaths.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetFilesByPaths return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetFilesByPathsExpectation) Then(fa1 []mm_minio.FileContent, err error) *MinioIMock {
	e.results = &MinioIMockGetFilesByPathsResults{fa1, err}
	return e.mock
}

// Times sets number of times MinioI.GetFilesByPaths should be invoked
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Times(n uint64) *mMinioIMockGetFilesByPaths {
	if n == 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Times of MinioIMock.GetFilesByPaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesByPaths.expectedInvocations, n)
	mmGetFilesByPaths.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFilesByPaths
}

func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) invocationsDone() bool {
	if len(mmGetFilesByPaths.expectations) == 0 && mmGetFilesByPaths.defaultExpectation == nil && mmGetFilesByPaths.mock.funcGetFilesByPaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.mock.afterGetFilesByPathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesByPaths implements mm_minio.MinioI
func (mmGetFilesByPaths *MinioIMock) GetFilesByPaths(ctx context.Context, filePaths []string) (fa1 []mm_minio.FileContent, err error) {
	mm_atomic.AddUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter, 1)

	mmGetFilesByPaths.t.Helper()

	if mmGetFilesByPaths.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.inspectFuncGetFilesByPaths(ctx, filePaths)
	}

	mm_params := MinioIMockGetFilesByPathsParams{ctx, filePaths}

	// Record call args
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Lock()
	mmGetFilesByPaths.GetFilesByPathsMock.callArgs = append(mmGetFilesByPaths.GetFilesByPathsMock.callArgs, &mm_params)
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Unlock()

	for _, e := range mmGetFilesByPaths.GetFilesByPathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetFilesByPathsParams{ctx, filePaths}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesByPaths.t.Errorf("MinioIMock.GetFilesByPaths got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePaths != nil && !minimock.Equal(*mm_want_ptrs.filePaths, mm_got.filePaths) {
				mmGetFilesByPaths.t.Errorf("MinioIMock.GetFilesByPaths got unexpected parameter filePaths, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.originFilePaths, *mm_want_ptrs.filePaths, mm_got.filePaths, minimock.Diff(*mm_want_ptrs.filePaths, mm_got.filePaths))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesByPaths.t.Errorf("MinioIMock.GetFilesByPaths got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesByPaths.t.Fatal("No results are set for the MinioIMock.GetFilesByPaths")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetFilesByPaths.funcGetFilesByPaths != nil {
		return mmGetFilesByPaths.funcGetFilesByPaths(ctx, filePaths)
	}
	mmGetFilesByPaths.t.Fatalf("Unexpected call to MinioIMock.GetFilesByPaths. %v %v", ctx, filePaths)
	return
}

// GetFilesByPathsAfterCounter returns a count of finished MinioIMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *MinioIMock) GetFilesByPathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter)
}

// GetFilesByPathsBeforeCounter returns a count of MinioIMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *MinioIMock) GetFilesByPathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetFilesByPaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Calls() []*MinioIMockGetFilesByPathsParams {
	mmGetFilesByPaths.mutex.RLock()

	argCopy := make([]*MinioIMockGetFilesByPathsParams, len(mmGetFilesByPaths.callArgs))
	copy(argCopy, mmGetFilesByPaths.callArgs)

	mmGetFilesByPaths.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesByPathsDone returns true if the count of the GetFilesByPaths invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetFilesByPathsDone() bool {
	if m.GetFilesByPathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesByPathsMock.invocationsDone()
}

// MinimockGetFilesByPathsInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetFilesByPathsInspect() {
	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetFilesByPaths at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFilesByPathsCounter := mm_atomic.LoadUint64(&m.afterGetFilesByPathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesByPathsMock.defaultExpectation != nil && afterGetFilesByPathsCounter < 1 {
		if m.GetFilesByPathsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.GetFilesByPaths at\n%s", m.GetFilesByPathsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetFilesByPaths at\n%s with params: %#v", m.GetFilesByPathsMock.defaultExpectation.expectationOrigins.origin, *m.GetFilesByPathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesByPaths != nil && afterGetFilesByPathsCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.GetFilesByPaths at\n%s", m.funcGetFilesByPathsOrigin)
	}

	if !m.GetFilesByPathsMock.invocationsDone() && afterGetFilesByPathsCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetFilesByPaths at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesByPathsMock.expectedInvocations), m.GetFilesByPathsMock.expectedInvocationsOrigin, afterGetFilesByPathsCounter)
	}
}

type mMinioIMockUploadFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockUploadFileExpectation
	expectations       []*MinioIMockUploadFileExpectation

	callArgs []*MinioIMockUploadFileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockUploadFileExpectation specifies expectation struct of the MinioI.UploadFile
type MinioIMockUploadFileExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockUploadFileParams
	paramPtrs          *MinioIMockUploadFileParamPtrs
	expectationOrigins MinioIMockUploadFileExpectationOrigins
	results            *MinioIMockUploadFileResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockUploadFileParams contains parameters of the MinioI.UploadFile
type MinioIMockUploadFileParams struct {
	ctx          context.Context
	filePath     string
	fileContent  any
	fileMimeType string
}

// MinioIMockUploadFileParamPtrs contains pointers to parameters of the MinioI.UploadFile
type MinioIMockUploadFileParamPtrs struct {
	ctx          *context.Context
	filePath     *string
	fileContent  *any
	fileMimeType *string
}

// MinioIMockUploadFileResults contains results of the MinioI.UploadFile
type MinioIMockUploadFileResults struct {
	url        string
	objectInfo *minio.ObjectInfo
	err        error
}

// MinioIMockUploadFileOrigins contains origins of expectations of the MinioI.UploadFile
type MinioIMockUploadFileExpectationOrigins struct {
	origin             string
	originCtx          string
	originFilePath     string
	originFileContent  string
	originFileMimeType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadFile *mMinioIMockUploadFile) Optional() *mMinioIMockUploadFile {
	mmUploadFile.optional = true
	return mmUploadFile
}

// Expect sets up expected params for MinioI.UploadFile
func (mmUploadFile *mMinioIMockUploadFile) Expect(ctx context.Context, filePath string, fileContent any, fileMimeType string) *mMinioIMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &MinioIMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.paramPtrs != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by ExpectParams functions")
	}

	mmUploadFile.defaultExpectation.params = &MinioIMockUploadFileParams{ctx, filePath, fileContent, fileMimeType}
	mmUploadFile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadFile.expectations {
		if minimock.Equal(e.params, mmUploadFile.defaultExpectation.params) {
			mmUploadFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadFile.defaultExpectation.params)
		}
	}

	return mmUploadFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.UploadFile
func (mmUploadFile *mMinioIMockUploadFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &MinioIMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.params != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Expect")
	}

	if mmUploadFile.defaultExpectation.paramPtrs == nil {
		mmUploadFile.defaultExpectation.paramPtrs = &MinioIMockUploadFileParamPtrs{}
	}
	mmUploadFile.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadFile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadFile
}

// ExpectFilePathParam2 sets up expected param filePath for MinioI.UploadFile
func (mmUploadFile *mMinioIMockUploadFile) ExpectFilePathParam2(filePath string) *mMinioIMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &MinioIMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.params != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Expect")
	}

	if mmUploadFile.defaultExpectation.paramPtrs == nil {
		mmUploadFile.defaultExpectation.paramPtrs = &MinioIMockUploadFileParamPtrs{}
	}
	mmUploadFile.defaultExpectation.paramPtrs.filePath = &filePath
	mmUploadFile.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmUploadFile
}

// ExpectFileContentParam3 sets up expected param fileContent for MinioI.UploadFile
func (mmUploadFile *mMinioIMockUploadFile) ExpectFileContentParam3(fileContent any) *mMinioIMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &MinioIMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.params != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Expect")
	}

	if mmUploadFile.defaultExpectation.paramPtrs == nil {
		mmUploadFile.defaultExpectation.paramPtrs = &MinioIMockUploadFileParamPtrs{}
	}
	mmUploadFile.defaultExpectation.paramPtrs.fileContent = &fileContent
	mmUploadFile.defaultExpectation.expectationOrigins.originFileContent = minimock.CallerInfo(1)

	return mmUploadFile
}

// ExpectFileMimeTypeParam4 sets up expected param fileMimeType for MinioI.UploadFile
func (mmUploadFile *mMinioIMockUploadFile) ExpectFileMimeTypeParam4(fileMimeType string) *mMinioIMockUploadFile {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &MinioIMockUploadFileExpectation{}
	}

	if mmUploadFile.defaultExpectation.params != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Expect")
	}

	if mmUploadFile.defaultExpectation.paramPtrs == nil {
		mmUploadFile.defaultExpectation.paramPtrs = &MinioIMockUploadFileParamPtrs{}
	}
	mmUploadFile.defaultExpectation.paramPtrs.fileMimeType = &fileMimeType
	mmUploadFile.defaultExpectation.expectationOrigins.originFileMimeType = minimock.CallerInfo(1)

	return mmUploadFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.UploadFile
func (mmUploadFile *mMinioIMockUploadFile) Inspect(f func(ctx context.Context, filePath string, fileContent any, fileMimeType string)) *mMinioIMockUploadFile {
	if mmUploadFile.mock.inspectFuncUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.UploadFile")
	}

	mmUploadFile.mock.inspectFuncUploadFile = f

	return mmUploadFile
}

// Return sets up results that will be returned by MinioI.UploadFile
func (mmUploadFile *mMinioIMockUploadFile) Return(url string, objectInfo *minio.ObjectInfo, err error) *MinioIMock {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Set")
	}

	if mmUploadFile.defaultExpectation == nil {
		mmUploadFile.defaultExpectation = &MinioIMockUploadFileExpectation{mock: mmUploadFile.mock}
	}
	mmUploadFile.defaultExpectation.results = &MinioIMockUploadFileResults{url, objectInfo, err}
	mmUploadFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadFile.mock
}

// Set uses given function f to mock the MinioI.UploadFile method
func (mmUploadFile *mMinioIMockUploadFile) Set(f func(ctx context.Context, filePath string, fileContent any, fileMimeType string) (url string, objectInfo *minio.ObjectInfo, err error)) *MinioIMock {
	if mmUploadFile.defaultExpectation != nil {
		mmUploadFile.mock.t.Fatalf("Default expectation is already set for the MinioI.UploadFile method")
	}

	if len(mmUploadFile.expectations) > 0 {
		mmUploadFile.mock.t.Fatalf("Some expectations are already set for the MinioI.UploadFile method")
	}

	mmUploadFile.mock.funcUploadFile = f
	mmUploadFile.mock.funcUploadFileOrigin = minimock.CallerInfo(1)
	return mmUploadFile.mock
}

// When sets expectation for the MinioI.UploadFile which will trigger the result defined by the following
// Then helper
func (mmUploadFile *mMinioIMockUploadFile) When(ctx context.Context, filePath string, fileContent any, fileMimeType string) *MinioIMockUploadFileExpectation {
	if mmUploadFile.mock.funcUploadFile != nil {
		mmUploadFile.mock.t.Fatalf("MinioIMock.UploadFile mock is already set by Set")
	}

	expectation := &MinioIMockUploadFileExpectation{
		mock:               mmUploadFile.mock,
		params:             &MinioIMockUploadFileParams{ctx, filePath, fileContent, fileMimeType},
		expectationOrigins: MinioIMockUploadFileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadFile.expectations = append(mmUploadFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.UploadFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockUploadFileExpectation) Then(url string, objectInfo *minio.ObjectInfo, err error) *MinioIMock {
	e.results = &MinioIMockUploadFileResults{url, objectInfo, err}
	return e.mock
}

// Times sets number of times MinioI.UploadFile should be invoked
func (mmUploadFile *mMinioIMockUploadFile) Times(n uint64) *mMinioIMockUploadFile {
	if n == 0 {
		mmUploadFile.mock.t.Fatalf("Times of MinioIMock.UploadFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadFile.expectedInvocations, n)
	mmUploadFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadFile
}

func (mmUploadFile *mMinioIMockUploadFile) invocationsDone() bool {
	if len(mmUploadFile.expectations) == 0 && mmUploadFile.defaultExpectation == nil && mmUploadFile.mock.funcUploadFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadFile.mock.afterUploadFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadFile implements mm_minio.MinioI
func (mmUploadFile *MinioIMock) UploadFile(ctx context.Context, filePath string, fileContent any, fileMimeType string) (url string, objectInfo *minio.ObjectInfo, err error) {
	mm_atomic.AddUint64(&mmUploadFile.beforeUploadFileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadFile.afterUploadFileCounter, 1)

	mmUploadFile.t.Helper()

	if mmUploadFile.inspectFuncUploadFile != nil {
		mmUploadFile.inspectFuncUploadFile(ctx, filePath, fileContent, fileMimeType)
	}

	mm_params := MinioIMockUploadFileParams{ctx, filePath, fileContent, fileMimeType}

	// Record call args
	mmUploadFile.UploadFileMock.mutex.Lock()
	mmUploadFile.UploadFileMock.callArgs = append(mmUploadFile.UploadFileMock.callArgs, &mm_params)
	mmUploadFile.UploadFileMock.mutex.Unlock()

	for _, e := range mmUploadFile.UploadFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.url, e.results.objectInfo, e.results.err
		}
	}

	if mmUploadFile.UploadFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadFile.UploadFileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadFile.UploadFileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadFile.UploadFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockUploadFileParams{ctx, filePath, fileContent, fileMimeType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadFile.t.Errorf("MinioIMock.UploadFile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmUploadFile.t.Errorf("MinioIMock.UploadFile got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

			if mm_want_ptrs.fileContent != nil && !minimock.Equal(*mm_want_ptrs.fileContent, mm_got.fileContent) {
				mmUploadFile.t.Errorf("MinioIMock.UploadFile got unexpected parameter fileContent, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.originFileContent, *mm_want_ptrs.fileContent, mm_got.fileContent, minimock.Diff(*mm_want_ptrs.fileContent, mm_got.fileContent))
			}

			if mm_want_ptrs.fileMimeType != nil && !minimock.Equal(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType) {
				mmUploadFile.t.Errorf("MinioIMock.UploadFile got unexpected parameter fileMimeType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.originFileMimeType, *mm_want_ptrs.fileMimeType, mm_got.fileMimeType, minimock.Diff(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadFile.t.Errorf("MinioIMock.UploadFile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadFile.UploadFileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadFile.UploadFileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadFile.t.Fatal("No results are set for the MinioIMock.UploadFile")
		}
		return (*mm_results).url, (*mm_results).objectInfo, (*mm_results).err
	}
	if mmUploadFile.funcUploadFile != nil {
		return mmUploadFile.funcUploadFile(ctx, filePath, fileContent, fileMimeType)
	}
	mmUploadFile.t.Fatalf("Unexpected call to MinioIMock.UploadFile. %v %v %v %v", ctx, filePath, fileContent, fileMimeType)
	return
}

// UploadFileAfterCounter returns a count of finished MinioIMock.UploadFile invocations
func (mmUploadFile *MinioIMock) UploadFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFile.afterUploadFileCounter)
}

// UploadFileBeforeCounter returns a count of MinioIMock.UploadFile invocations
func (mmUploadFile *MinioIMock) UploadFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFile.beforeUploadFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.UploadFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadFile *mMinioIMockUploadFile) Calls() []*MinioIMockUploadFileParams {
	mmUploadFile.mutex.RLock()

	argCopy := make([]*MinioIMockUploadFileParams, len(mmUploadFile.callArgs))
	copy(argCopy, mmUploadFile.callArgs)

	mmUploadFile.mutex.RUnlock()

	return argCopy
}

// MinimockUploadFileDone returns true if the count of the UploadFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockUploadFileDone() bool {
	if m.UploadFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadFileMock.invocationsDone()
}

// MinimockUploadFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockUploadFileInspect() {
	for _, e := range m.UploadFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.UploadFile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadFileCounter := mm_atomic.LoadUint64(&m.afterUploadFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadFileMock.defaultExpectation != nil && afterUploadFileCounter < 1 {
		if m.UploadFileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.UploadFile at\n%s", m.UploadFileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.UploadFile at\n%s with params: %#v", m.UploadFileMock.defaultExpectation.expectationOrigins.origin, *m.UploadFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadFile != nil && afterUploadFileCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.UploadFile at\n%s", m.funcUploadFileOrigin)
	}

	if !m.UploadFileMock.invocationsDone() && afterUploadFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.UploadFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadFileMock.expectedInvocations), m.UploadFileMock.expectedInvocationsOrigin, afterUploadFileCounter)
	}
}

type mMinioIMockUploadFileBytes struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockUploadFileBytesExpectation
	expectations       []*MinioIMockUploadFileBytesExpectation

	callArgs []*MinioIMockUploadFileBytesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MinioIMockUploadFileBytesExpectation specifies expectation struct of the MinioI.UploadFileBytes
type MinioIMockUploadFileBytesExpectation struct {
	mock               *MinioIMock
	params             *MinioIMockUploadFileBytesParams
	paramPtrs          *MinioIMockUploadFileBytesParamPtrs
	expectationOrigins MinioIMockUploadFileBytesExpectationOrigins
	results            *MinioIMockUploadFileBytesResults
	returnOrigin       string
	Counter            uint64
}

// MinioIMockUploadFileBytesParams contains parameters of the MinioI.UploadFileBytes
type MinioIMockUploadFileBytesParams struct {
	ctx          context.Context
	filePath     string
	fileBytes    []byte
	fileMimeType string
}

// MinioIMockUploadFileBytesParamPtrs contains pointers to parameters of the MinioI.UploadFileBytes
type MinioIMockUploadFileBytesParamPtrs struct {
	ctx          *context.Context
	filePath     *string
	fileBytes    *[]byte
	fileMimeType *string
}

// MinioIMockUploadFileBytesResults contains results of the MinioI.UploadFileBytes
type MinioIMockUploadFileBytesResults struct {
	url        string
	objectInfo *minio.ObjectInfo
	err        error
}

// MinioIMockUploadFileBytesOrigins contains origins of expectations of the MinioI.UploadFileBytes
type MinioIMockUploadFileBytesExpectationOrigins struct {
	origin             string
	originCtx          string
	originFilePath     string
	originFileBytes    string
	originFileMimeType string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) Optional() *mMinioIMockUploadFileBytes {
	mmUploadFileBytes.optional = true
	return mmUploadFileBytes
}

// Expect sets up expected params for MinioI.UploadFileBytes
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) Expect(ctx context.Context, filePath string, fileBytes []byte, fileMimeType string) *mMinioIMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &MinioIMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by ExpectParams functions")
	}

	mmUploadFileBytes.defaultExpectation.params = &MinioIMockUploadFileBytesParams{ctx, filePath, fileBytes, fileMimeType}
	mmUploadFileBytes.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadFileBytes.expectations {
		if minimock.Equal(e.params, mmUploadFileBytes.defaultExpectation.params) {
			mmUploadFileBytes.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadFileBytes.defaultExpectation.params)
		}
	}

	return mmUploadFileBytes
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.UploadFileBytes
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) ExpectCtxParam1(ctx context.Context) *mMinioIMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &MinioIMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.params != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Expect")
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadFileBytes.defaultExpectation.paramPtrs = &MinioIMockUploadFileBytesParamPtrs{}
	}
	mmUploadFileBytes.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadFileBytes.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadFileBytes
}

// ExpectFilePathParam2 sets up expected param filePath for MinioI.UploadFileBytes
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) ExpectFilePathParam2(filePath string) *mMinioIMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &MinioIMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.params != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Expect")
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadFileBytes.defaultExpectation.paramPtrs = &MinioIMockUploadFileBytesParamPtrs{}
	}
	mmUploadFileBytes.defaultExpectation.paramPtrs.filePath = &filePath
	mmUploadFileBytes.defaultExpectation.expectationOrigins.originFilePath = minimock.CallerInfo(1)

	return mmUploadFileBytes
}

// ExpectFileBytesParam3 sets up expected param fileBytes for MinioI.UploadFileBytes
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) ExpectFileBytesParam3(fileBytes []byte) *mMinioIMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &MinioIMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.params != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Expect")
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadFileBytes.defaultExpectation.paramPtrs = &MinioIMockUploadFileBytesParamPtrs{}
	}
	mmUploadFileBytes.defaultExpectation.paramPtrs.fileBytes = &fileBytes
	mmUploadFileBytes.defaultExpectation.expectationOrigins.originFileBytes = minimock.CallerInfo(1)

	return mmUploadFileBytes
}

// ExpectFileMimeTypeParam4 sets up expected param fileMimeType for MinioI.UploadFileBytes
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) ExpectFileMimeTypeParam4(fileMimeType string) *mMinioIMockUploadFileBytes {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &MinioIMockUploadFileBytesExpectation{}
	}

	if mmUploadFileBytes.defaultExpectation.params != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Expect")
	}

	if mmUploadFileBytes.defaultExpectation.paramPtrs == nil {
		mmUploadFileBytes.defaultExpectation.paramPtrs = &MinioIMockUploadFileBytesParamPtrs{}
	}
	mmUploadFileBytes.defaultExpectation.paramPtrs.fileMimeType = &fileMimeType
	mmUploadFileBytes.defaultExpectation.expectationOrigins.originFileMimeType = minimock.CallerInfo(1)

	return mmUploadFileBytes
}

// Inspect accepts an inspector function that has same arguments as the MinioI.UploadFileBytes
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) Inspect(f func(ctx context.Context, filePath string, fileBytes []byte, fileMimeType string)) *mMinioIMockUploadFileBytes {
	if mmUploadFileBytes.mock.inspectFuncUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("Inspect function is already set for MinioIMock.UploadFileBytes")
	}

	mmUploadFileBytes.mock.inspectFuncUploadFileBytes = f

	return mmUploadFileBytes
}

// Return sets up results that will be returned by MinioI.UploadFileBytes
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) Return(url string, objectInfo *minio.ObjectInfo, err error) *MinioIMock {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Set")
	}

	if mmUploadFileBytes.defaultExpectation == nil {
		mmUploadFileBytes.defaultExpectation = &MinioIMockUploadFileBytesExpectation{mock: mmUploadFileBytes.mock}
	}
	mmUploadFileBytes.defaultExpectation.results = &MinioIMockUploadFileBytesResults{url, objectInfo, err}
	mmUploadFileBytes.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadFileBytes.mock
}

// Set uses given function f to mock the MinioI.UploadFileBytes method
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) Set(f func(ctx context.Context, filePath string, fileBytes []byte, fileMimeType string) (url string, objectInfo *minio.ObjectInfo, err error)) *MinioIMock {
	if mmUploadFileBytes.defaultExpectation != nil {
		mmUploadFileBytes.mock.t.Fatalf("Default expectation is already set for the MinioI.UploadFileBytes method")
	}

	if len(mmUploadFileBytes.expectations) > 0 {
		mmUploadFileBytes.mock.t.Fatalf("Some expectations are already set for the MinioI.UploadFileBytes method")
	}

	mmUploadFileBytes.mock.funcUploadFileBytes = f
	mmUploadFileBytes.mock.funcUploadFileBytesOrigin = minimock.CallerInfo(1)
	return mmUploadFileBytes.mock
}

// When sets expectation for the MinioI.UploadFileBytes which will trigger the result defined by the following
// Then helper
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) When(ctx context.Context, filePath string, fileBytes []byte, fileMimeType string) *MinioIMockUploadFileBytesExpectation {
	if mmUploadFileBytes.mock.funcUploadFileBytes != nil {
		mmUploadFileBytes.mock.t.Fatalf("MinioIMock.UploadFileBytes mock is already set by Set")
	}

	expectation := &MinioIMockUploadFileBytesExpectation{
		mock:               mmUploadFileBytes.mock,
		params:             &MinioIMockUploadFileBytesParams{ctx, filePath, fileBytes, fileMimeType},
		expectationOrigins: MinioIMockUploadFileBytesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadFileBytes.expectations = append(mmUploadFileBytes.expectations, expectation)
	return expectation
}

// Then sets up MinioI.UploadFileBytes return parameters for the expectation previously defined by the When method
func (e *MinioIMockUploadFileBytesExpectation) Then(url string, objectInfo *minio.ObjectInfo, err error) *MinioIMock {
	e.results = &MinioIMockUploadFileBytesResults{url, objectInfo, err}
	return e.mock
}

// Times sets number of times MinioI.UploadFileBytes should be invoked
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) Times(n uint64) *mMinioIMockUploadFileBytes {
	if n == 0 {
		mmUploadFileBytes.mock.t.Fatalf("Times of MinioIMock.UploadFileBytes mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadFileBytes.expectedInvocations, n)
	mmUploadFileBytes.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadFileBytes
}

func (mmUploadFileBytes *mMinioIMockUploadFileBytes) invocationsDone() bool {
	if len(mmUploadFileBytes.expectations) == 0 && mmUploadFileBytes.defaultExpectation == nil && mmUploadFileBytes.mock.funcUploadFileBytes == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadFileBytes.mock.afterUploadFileBytesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadFileBytes.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadFileBytes implements mm_minio.MinioI
func (mmUploadFileBytes *MinioIMock) UploadFileBytes(ctx context.Context, filePath string, fileBytes []byte, fileMimeType string) (url string, objectInfo *minio.ObjectInfo, err error) {
	mm_atomic.AddUint64(&mmUploadFileBytes.beforeUploadFileBytesCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadFileBytes.afterUploadFileBytesCounter, 1)

	mmUploadFileBytes.t.Helper()

	if mmUploadFileBytes.inspectFuncUploadFileBytes != nil {
		mmUploadFileBytes.inspectFuncUploadFileBytes(ctx, filePath, fileBytes, fileMimeType)
	}

	mm_params := MinioIMockUploadFileBytesParams{ctx, filePath, fileBytes, fileMimeType}

	// Record call args
	mmUploadFileBytes.UploadFileBytesMock.mutex.Lock()
	mmUploadFileBytes.UploadFileBytesMock.callArgs = append(mmUploadFileBytes.UploadFileBytesMock.callArgs, &mm_params)
	mmUploadFileBytes.UploadFileBytesMock.mutex.Unlock()

	for _, e := range mmUploadFileBytes.UploadFileBytesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.url, e.results.objectInfo, e.results.err
		}
	}

	if mmUploadFileBytes.UploadFileBytesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.params
		mm_want_ptrs := mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockUploadFileBytesParams{ctx, filePath, fileBytes, fileMimeType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadFileBytes.t.Errorf("MinioIMock.UploadFileBytes got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmUploadFileBytes.t.Errorf("MinioIMock.UploadFileBytes got unexpected parameter filePath, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.originFilePath, *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

			if mm_want_ptrs.fileBytes != nil && !minimock.Equal(*mm_want_ptrs.fileBytes, mm_got.fileBytes) {
				mmUploadFileBytes.t.Errorf("MinioIMock.UploadFileBytes got unexpected parameter fileBytes, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.originFileBytes, *mm_want_ptrs.fileBytes, mm_got.fileBytes, minimock.Diff(*mm_want_ptrs.fileBytes, mm_got.fileBytes))
			}

			if mm_want_ptrs.fileMimeType != nil && !minimock.Equal(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType) {
				mmUploadFileBytes.t.Errorf("MinioIMock.UploadFileBytes got unexpected parameter fileMimeType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.originFileMimeType, *mm_want_ptrs.fileMimeType, mm_got.fileMimeType, minimock.Diff(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadFileBytes.t.Errorf("MinioIMock.UploadFileBytes got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadFileBytes.UploadFileBytesMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadFileBytes.t.Fatal("No results are set for the MinioIMock.UploadFileBytes")
		}
		return (*mm_results).url, (*mm_results).objectInfo, (*mm_results).err
	}
	if mmUploadFileBytes.funcUploadFileBytes != nil {
		return mmUploadFileBytes.funcUploadFileBytes(ctx, filePath, fileBytes, fileMimeType)
	}
	mmUploadFileBytes.t.Fatalf("Unexpected call to MinioIMock.UploadFileBytes. %v %v %v %v", ctx, filePath, fileBytes, fileMimeType)
	return
}

// UploadFileBytesAfterCounter returns a count of finished MinioIMock.UploadFileBytes invocations
func (mmUploadFileBytes *MinioIMock) UploadFileBytesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFileBytes.afterUploadFileBytesCounter)
}

// UploadFileBytesBeforeCounter returns a count of MinioIMock.UploadFileBytes invocations
func (mmUploadFileBytes *MinioIMock) UploadFileBytesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadFileBytes.beforeUploadFileBytesCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.UploadFileBytes.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadFileBytes *mMinioIMockUploadFileBytes) Calls() []*MinioIMockUploadFileBytesParams {
	mmUploadFileBytes.mutex.RLock()

	argCopy := make([]*MinioIMockUploadFileBytesParams, len(mmUploadFileBytes.callArgs))
	copy(argCopy, mmUploadFileBytes.callArgs)

	mmUploadFileBytes.mutex.RUnlock()

	return argCopy
}

// MinimockUploadFileBytesDone returns true if the count of the UploadFileBytes invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockUploadFileBytesDone() bool {
	if m.UploadFileBytesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadFileBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadFileBytesMock.invocationsDone()
}

// MinimockUploadFileBytesInspect logs each unmet expectation
func (m *MinioIMock) MinimockUploadFileBytesInspect() {
	for _, e := range m.UploadFileBytesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.UploadFileBytes at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadFileBytesCounter := mm_atomic.LoadUint64(&m.afterUploadFileBytesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadFileBytesMock.defaultExpectation != nil && afterUploadFileBytesCounter < 1 {
		if m.UploadFileBytesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MinioIMock.UploadFileBytes at\n%s", m.UploadFileBytesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MinioIMock.UploadFileBytes at\n%s with params: %#v", m.UploadFileBytesMock.defaultExpectation.expectationOrigins.origin, *m.UploadFileBytesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadFileBytes != nil && afterUploadFileBytesCounter < 1 {
		m.t.Errorf("Expected call to MinioIMock.UploadFileBytes at\n%s", m.funcUploadFileBytesOrigin)
	}

	if !m.UploadFileBytesMock.invocationsDone() && afterUploadFileBytesCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.UploadFileBytes at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadFileBytesMock.expectedInvocations), m.UploadFileBytesMock.expectedInvocationsOrigin, afterUploadFileBytesCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MinioIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteFileInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetFilesByPathsInspect()

			m.MinimockUploadFileInspect()

			m.MinimockUploadFileBytesInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MinioIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MinioIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteFileDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetFilesByPathsDone() &&
		m.MinimockUploadFileDone() &&
		m.MinimockUploadFileBytesDone()
}
