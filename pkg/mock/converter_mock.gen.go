// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/pipeline-backend/pkg/datamodel"
	"github.com/instill-ai/pipeline-backend/pkg/resource"
	pb "github.com/instill-ai/protogen-go/vdp/pipeline/v1beta"
)

// ConverterMock implements service.Converter
type ConverterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConvertOwnerNameToPermalink          func(ctx context.Context, name string) (s1 string, err error)
	inspectFuncConvertOwnerNameToPermalink   func(ctx context.Context, name string)
	afterConvertOwnerNameToPermalinkCounter  uint64
	beforeConvertOwnerNameToPermalinkCounter uint64
	ConvertOwnerNameToPermalinkMock          mConverterMockConvertOwnerNameToPermalink

	funcConvertOwnerPermalinkToName          func(ctx context.Context, permalink string) (s1 string, err error)
	inspectFuncConvertOwnerPermalinkToName   func(ctx context.Context, permalink string)
	afterConvertOwnerPermalinkToNameCounter  uint64
	beforeConvertOwnerPermalinkToNameCounter uint64
	ConvertOwnerPermalinkToNameMock          mConverterMockConvertOwnerPermalinkToName

	funcConvertPipelineReleaseToDB          func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) (pp1 *datamodel.PipelineRelease, err error)
	inspectFuncConvertPipelineReleaseToDB   func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease)
	afterConvertPipelineReleaseToDBCounter  uint64
	beforeConvertPipelineReleaseToDBCounter uint64
	ConvertPipelineReleaseToDBMock          mConverterMockConvertPipelineReleaseToDB

	funcConvertPipelineReleaseToPB          func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) (pp1 *pb.PipelineRelease, err error)
	inspectFuncConvertPipelineReleaseToPB   func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View)
	afterConvertPipelineReleaseToPBCounter  uint64
	beforeConvertPipelineReleaseToPBCounter uint64
	ConvertPipelineReleaseToPBMock          mConverterMockConvertPipelineReleaseToPB

	funcConvertPipelineReleasesToPB          func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) (ppa1 []*pb.PipelineRelease, err error)
	inspectFuncConvertPipelineReleasesToPB   func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View)
	afterConvertPipelineReleasesToPBCounter  uint64
	beforeConvertPipelineReleasesToPBCounter uint64
	ConvertPipelineReleasesToPBMock          mConverterMockConvertPipelineReleasesToPB

	funcConvertPipelineToDB          func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) (pp1 *datamodel.Pipeline, err error)
	inspectFuncConvertPipelineToDB   func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline)
	afterConvertPipelineToDBCounter  uint64
	beforeConvertPipelineToDBCounter uint64
	ConvertPipelineToDBMock          mConverterMockConvertPipelineToDB

	funcConvertPipelineToPB          func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) (pp1 *pb.Pipeline, err error)
	inspectFuncConvertPipelineToPB   func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool)
	afterConvertPipelineToPBCounter  uint64
	beforeConvertPipelineToPBCounter uint64
	ConvertPipelineToPBMock          mConverterMockConvertPipelineToPB

	funcConvertPipelinesToPB          func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) (ppa1 []*pb.Pipeline, err error)
	inspectFuncConvertPipelinesToPB   func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool)
	afterConvertPipelinesToPBCounter  uint64
	beforeConvertPipelinesToPBCounter uint64
	ConvertPipelinesToPBMock          mConverterMockConvertPipelinesToPB

	funcConvertSecretToDB          func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) (sp1 *datamodel.Secret, err error)
	inspectFuncConvertSecretToDB   func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret)
	afterConvertSecretToDBCounter  uint64
	beforeConvertSecretToDBCounter uint64
	ConvertSecretToDBMock          mConverterMockConvertSecretToDB

	funcConvertSecretToPB          func(ctx context.Context, dbSecret *datamodel.Secret) (sp1 *pb.Secret, err error)
	inspectFuncConvertSecretToPB   func(ctx context.Context, dbSecret *datamodel.Secret)
	afterConvertSecretToPBCounter  uint64
	beforeConvertSecretToPBCounter uint64
	ConvertSecretToPBMock          mConverterMockConvertSecretToPB

	funcConvertSecretsToPB          func(ctx context.Context, dbSecrets []*datamodel.Secret) (spa1 []*pb.Secret, err error)
	inspectFuncConvertSecretsToPB   func(ctx context.Context, dbSecrets []*datamodel.Secret)
	afterConvertSecretsToPBCounter  uint64
	beforeConvertSecretsToPBCounter uint64
	ConvertSecretsToPBMock          mConverterMockConvertSecretsToPB
}

// NewConverterMock returns a mock for service.Converter
func NewConverterMock(t minimock.Tester) *ConverterMock {
	m := &ConverterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConvertOwnerNameToPermalinkMock = mConverterMockConvertOwnerNameToPermalink{mock: m}
	m.ConvertOwnerNameToPermalinkMock.callArgs = []*ConverterMockConvertOwnerNameToPermalinkParams{}

	m.ConvertOwnerPermalinkToNameMock = mConverterMockConvertOwnerPermalinkToName{mock: m}
	m.ConvertOwnerPermalinkToNameMock.callArgs = []*ConverterMockConvertOwnerPermalinkToNameParams{}

	m.ConvertPipelineReleaseToDBMock = mConverterMockConvertPipelineReleaseToDB{mock: m}
	m.ConvertPipelineReleaseToDBMock.callArgs = []*ConverterMockConvertPipelineReleaseToDBParams{}

	m.ConvertPipelineReleaseToPBMock = mConverterMockConvertPipelineReleaseToPB{mock: m}
	m.ConvertPipelineReleaseToPBMock.callArgs = []*ConverterMockConvertPipelineReleaseToPBParams{}

	m.ConvertPipelineReleasesToPBMock = mConverterMockConvertPipelineReleasesToPB{mock: m}
	m.ConvertPipelineReleasesToPBMock.callArgs = []*ConverterMockConvertPipelineReleasesToPBParams{}

	m.ConvertPipelineToDBMock = mConverterMockConvertPipelineToDB{mock: m}
	m.ConvertPipelineToDBMock.callArgs = []*ConverterMockConvertPipelineToDBParams{}

	m.ConvertPipelineToPBMock = mConverterMockConvertPipelineToPB{mock: m}
	m.ConvertPipelineToPBMock.callArgs = []*ConverterMockConvertPipelineToPBParams{}

	m.ConvertPipelinesToPBMock = mConverterMockConvertPipelinesToPB{mock: m}
	m.ConvertPipelinesToPBMock.callArgs = []*ConverterMockConvertPipelinesToPBParams{}

	m.ConvertSecretToDBMock = mConverterMockConvertSecretToDB{mock: m}
	m.ConvertSecretToDBMock.callArgs = []*ConverterMockConvertSecretToDBParams{}

	m.ConvertSecretToPBMock = mConverterMockConvertSecretToPB{mock: m}
	m.ConvertSecretToPBMock.callArgs = []*ConverterMockConvertSecretToPBParams{}

	m.ConvertSecretsToPBMock = mConverterMockConvertSecretsToPB{mock: m}
	m.ConvertSecretsToPBMock.callArgs = []*ConverterMockConvertSecretsToPBParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConverterMockConvertOwnerNameToPermalink struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertOwnerNameToPermalinkExpectation
	expectations       []*ConverterMockConvertOwnerNameToPermalinkExpectation

	callArgs []*ConverterMockConvertOwnerNameToPermalinkParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertOwnerNameToPermalinkExpectation specifies expectation struct of the Converter.ConvertOwnerNameToPermalink
type ConverterMockConvertOwnerNameToPermalinkExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertOwnerNameToPermalinkParams
	paramPtrs *ConverterMockConvertOwnerNameToPermalinkParamPtrs
	results   *ConverterMockConvertOwnerNameToPermalinkResults
	Counter   uint64
}

// ConverterMockConvertOwnerNameToPermalinkParams contains parameters of the Converter.ConvertOwnerNameToPermalink
type ConverterMockConvertOwnerNameToPermalinkParams struct {
	ctx  context.Context
	name string
}

// ConverterMockConvertOwnerNameToPermalinkParamPtrs contains pointers to parameters of the Converter.ConvertOwnerNameToPermalink
type ConverterMockConvertOwnerNameToPermalinkParamPtrs struct {
	ctx  *context.Context
	name *string
}

// ConverterMockConvertOwnerNameToPermalinkResults contains results of the Converter.ConvertOwnerNameToPermalink
type ConverterMockConvertOwnerNameToPermalinkResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) Optional() *mConverterMockConvertOwnerNameToPermalink {
	mmConvertOwnerNameToPermalink.optional = true
	return mmConvertOwnerNameToPermalink
}

// Expect sets up expected params for Converter.ConvertOwnerNameToPermalink
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) Expect(ctx context.Context, name string) *mConverterMockConvertOwnerNameToPermalink {
	if mmConvertOwnerNameToPermalink.mock.funcConvertOwnerNameToPermalink != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by Set")
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation == nil {
		mmConvertOwnerNameToPermalink.defaultExpectation = &ConverterMockConvertOwnerNameToPermalinkExpectation{}
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation.paramPtrs != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by ExpectParams functions")
	}

	mmConvertOwnerNameToPermalink.defaultExpectation.params = &ConverterMockConvertOwnerNameToPermalinkParams{ctx, name}
	for _, e := range mmConvertOwnerNameToPermalink.expectations {
		if minimock.Equal(e.params, mmConvertOwnerNameToPermalink.defaultExpectation.params) {
			mmConvertOwnerNameToPermalink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertOwnerNameToPermalink.defaultExpectation.params)
		}
	}

	return mmConvertOwnerNameToPermalink
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertOwnerNameToPermalink
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertOwnerNameToPermalink {
	if mmConvertOwnerNameToPermalink.mock.funcConvertOwnerNameToPermalink != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by Set")
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation == nil {
		mmConvertOwnerNameToPermalink.defaultExpectation = &ConverterMockConvertOwnerNameToPermalinkExpectation{}
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation.params != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by Expect")
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation.paramPtrs == nil {
		mmConvertOwnerNameToPermalink.defaultExpectation.paramPtrs = &ConverterMockConvertOwnerNameToPermalinkParamPtrs{}
	}
	mmConvertOwnerNameToPermalink.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertOwnerNameToPermalink
}

// ExpectNameParam2 sets up expected param name for Converter.ConvertOwnerNameToPermalink
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) ExpectNameParam2(name string) *mConverterMockConvertOwnerNameToPermalink {
	if mmConvertOwnerNameToPermalink.mock.funcConvertOwnerNameToPermalink != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by Set")
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation == nil {
		mmConvertOwnerNameToPermalink.defaultExpectation = &ConverterMockConvertOwnerNameToPermalinkExpectation{}
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation.params != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by Expect")
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation.paramPtrs == nil {
		mmConvertOwnerNameToPermalink.defaultExpectation.paramPtrs = &ConverterMockConvertOwnerNameToPermalinkParamPtrs{}
	}
	mmConvertOwnerNameToPermalink.defaultExpectation.paramPtrs.name = &name

	return mmConvertOwnerNameToPermalink
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertOwnerNameToPermalink
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) Inspect(f func(ctx context.Context, name string)) *mConverterMockConvertOwnerNameToPermalink {
	if mmConvertOwnerNameToPermalink.mock.inspectFuncConvertOwnerNameToPermalink != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertOwnerNameToPermalink")
	}

	mmConvertOwnerNameToPermalink.mock.inspectFuncConvertOwnerNameToPermalink = f

	return mmConvertOwnerNameToPermalink
}

// Return sets up results that will be returned by Converter.ConvertOwnerNameToPermalink
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) Return(s1 string, err error) *ConverterMock {
	if mmConvertOwnerNameToPermalink.mock.funcConvertOwnerNameToPermalink != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by Set")
	}

	if mmConvertOwnerNameToPermalink.defaultExpectation == nil {
		mmConvertOwnerNameToPermalink.defaultExpectation = &ConverterMockConvertOwnerNameToPermalinkExpectation{mock: mmConvertOwnerNameToPermalink.mock}
	}
	mmConvertOwnerNameToPermalink.defaultExpectation.results = &ConverterMockConvertOwnerNameToPermalinkResults{s1, err}
	return mmConvertOwnerNameToPermalink.mock
}

// Set uses given function f to mock the Converter.ConvertOwnerNameToPermalink method
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) Set(f func(ctx context.Context, name string) (s1 string, err error)) *ConverterMock {
	if mmConvertOwnerNameToPermalink.defaultExpectation != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertOwnerNameToPermalink method")
	}

	if len(mmConvertOwnerNameToPermalink.expectations) > 0 {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertOwnerNameToPermalink method")
	}

	mmConvertOwnerNameToPermalink.mock.funcConvertOwnerNameToPermalink = f
	return mmConvertOwnerNameToPermalink.mock
}

// When sets expectation for the Converter.ConvertOwnerNameToPermalink which will trigger the result defined by the following
// Then helper
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) When(ctx context.Context, name string) *ConverterMockConvertOwnerNameToPermalinkExpectation {
	if mmConvertOwnerNameToPermalink.mock.funcConvertOwnerNameToPermalink != nil {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("ConverterMock.ConvertOwnerNameToPermalink mock is already set by Set")
	}

	expectation := &ConverterMockConvertOwnerNameToPermalinkExpectation{
		mock:   mmConvertOwnerNameToPermalink.mock,
		params: &ConverterMockConvertOwnerNameToPermalinkParams{ctx, name},
	}
	mmConvertOwnerNameToPermalink.expectations = append(mmConvertOwnerNameToPermalink.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertOwnerNameToPermalink return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertOwnerNameToPermalinkExpectation) Then(s1 string, err error) *ConverterMock {
	e.results = &ConverterMockConvertOwnerNameToPermalinkResults{s1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertOwnerNameToPermalink should be invoked
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) Times(n uint64) *mConverterMockConvertOwnerNameToPermalink {
	if n == 0 {
		mmConvertOwnerNameToPermalink.mock.t.Fatalf("Times of ConverterMock.ConvertOwnerNameToPermalink mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertOwnerNameToPermalink.expectedInvocations, n)
	return mmConvertOwnerNameToPermalink
}

func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) invocationsDone() bool {
	if len(mmConvertOwnerNameToPermalink.expectations) == 0 && mmConvertOwnerNameToPermalink.defaultExpectation == nil && mmConvertOwnerNameToPermalink.mock.funcConvertOwnerNameToPermalink == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertOwnerNameToPermalink.mock.afterConvertOwnerNameToPermalinkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertOwnerNameToPermalink.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertOwnerNameToPermalink implements service.Converter
func (mmConvertOwnerNameToPermalink *ConverterMock) ConvertOwnerNameToPermalink(ctx context.Context, name string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmConvertOwnerNameToPermalink.beforeConvertOwnerNameToPermalinkCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertOwnerNameToPermalink.afterConvertOwnerNameToPermalinkCounter, 1)

	if mmConvertOwnerNameToPermalink.inspectFuncConvertOwnerNameToPermalink != nil {
		mmConvertOwnerNameToPermalink.inspectFuncConvertOwnerNameToPermalink(ctx, name)
	}

	mm_params := ConverterMockConvertOwnerNameToPermalinkParams{ctx, name}

	// Record call args
	mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.mutex.Lock()
	mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.callArgs = append(mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.callArgs, &mm_params)
	mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.mutex.Unlock()

	for _, e := range mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.defaultExpectation.params
		mm_want_ptrs := mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertOwnerNameToPermalinkParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertOwnerNameToPermalink.t.Errorf("ConverterMock.ConvertOwnerNameToPermalink got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmConvertOwnerNameToPermalink.t.Errorf("ConverterMock.ConvertOwnerNameToPermalink got unexpected parameter name, want: %#v, got: %#v%s\n", *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertOwnerNameToPermalink.t.Errorf("ConverterMock.ConvertOwnerNameToPermalink got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertOwnerNameToPermalink.ConvertOwnerNameToPermalinkMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertOwnerNameToPermalink.t.Fatal("No results are set for the ConverterMock.ConvertOwnerNameToPermalink")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmConvertOwnerNameToPermalink.funcConvertOwnerNameToPermalink != nil {
		return mmConvertOwnerNameToPermalink.funcConvertOwnerNameToPermalink(ctx, name)
	}
	mmConvertOwnerNameToPermalink.t.Fatalf("Unexpected call to ConverterMock.ConvertOwnerNameToPermalink. %v %v", ctx, name)
	return
}

// ConvertOwnerNameToPermalinkAfterCounter returns a count of finished ConverterMock.ConvertOwnerNameToPermalink invocations
func (mmConvertOwnerNameToPermalink *ConverterMock) ConvertOwnerNameToPermalinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertOwnerNameToPermalink.afterConvertOwnerNameToPermalinkCounter)
}

// ConvertOwnerNameToPermalinkBeforeCounter returns a count of ConverterMock.ConvertOwnerNameToPermalink invocations
func (mmConvertOwnerNameToPermalink *ConverterMock) ConvertOwnerNameToPermalinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertOwnerNameToPermalink.beforeConvertOwnerNameToPermalinkCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertOwnerNameToPermalink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertOwnerNameToPermalink *mConverterMockConvertOwnerNameToPermalink) Calls() []*ConverterMockConvertOwnerNameToPermalinkParams {
	mmConvertOwnerNameToPermalink.mutex.RLock()

	argCopy := make([]*ConverterMockConvertOwnerNameToPermalinkParams, len(mmConvertOwnerNameToPermalink.callArgs))
	copy(argCopy, mmConvertOwnerNameToPermalink.callArgs)

	mmConvertOwnerNameToPermalink.mutex.RUnlock()

	return argCopy
}

// MinimockConvertOwnerNameToPermalinkDone returns true if the count of the ConvertOwnerNameToPermalink invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertOwnerNameToPermalinkDone() bool {
	if m.ConvertOwnerNameToPermalinkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertOwnerNameToPermalinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertOwnerNameToPermalinkMock.invocationsDone()
}

// MinimockConvertOwnerNameToPermalinkInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertOwnerNameToPermalinkInspect() {
	for _, e := range m.ConvertOwnerNameToPermalinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertOwnerNameToPermalink with params: %#v", *e.params)
		}
	}

	afterConvertOwnerNameToPermalinkCounter := mm_atomic.LoadUint64(&m.afterConvertOwnerNameToPermalinkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertOwnerNameToPermalinkMock.defaultExpectation != nil && afterConvertOwnerNameToPermalinkCounter < 1 {
		if m.ConvertOwnerNameToPermalinkMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertOwnerNameToPermalink")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertOwnerNameToPermalink with params: %#v", *m.ConvertOwnerNameToPermalinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertOwnerNameToPermalink != nil && afterConvertOwnerNameToPermalinkCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertOwnerNameToPermalink")
	}

	if !m.ConvertOwnerNameToPermalinkMock.invocationsDone() && afterConvertOwnerNameToPermalinkCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertOwnerNameToPermalink but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertOwnerNameToPermalinkMock.expectedInvocations), afterConvertOwnerNameToPermalinkCounter)
	}
}

type mConverterMockConvertOwnerPermalinkToName struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertOwnerPermalinkToNameExpectation
	expectations       []*ConverterMockConvertOwnerPermalinkToNameExpectation

	callArgs []*ConverterMockConvertOwnerPermalinkToNameParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertOwnerPermalinkToNameExpectation specifies expectation struct of the Converter.ConvertOwnerPermalinkToName
type ConverterMockConvertOwnerPermalinkToNameExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertOwnerPermalinkToNameParams
	paramPtrs *ConverterMockConvertOwnerPermalinkToNameParamPtrs
	results   *ConverterMockConvertOwnerPermalinkToNameResults
	Counter   uint64
}

// ConverterMockConvertOwnerPermalinkToNameParams contains parameters of the Converter.ConvertOwnerPermalinkToName
type ConverterMockConvertOwnerPermalinkToNameParams struct {
	ctx       context.Context
	permalink string
}

// ConverterMockConvertOwnerPermalinkToNameParamPtrs contains pointers to parameters of the Converter.ConvertOwnerPermalinkToName
type ConverterMockConvertOwnerPermalinkToNameParamPtrs struct {
	ctx       *context.Context
	permalink *string
}

// ConverterMockConvertOwnerPermalinkToNameResults contains results of the Converter.ConvertOwnerPermalinkToName
type ConverterMockConvertOwnerPermalinkToNameResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) Optional() *mConverterMockConvertOwnerPermalinkToName {
	mmConvertOwnerPermalinkToName.optional = true
	return mmConvertOwnerPermalinkToName
}

// Expect sets up expected params for Converter.ConvertOwnerPermalinkToName
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) Expect(ctx context.Context, permalink string) *mConverterMockConvertOwnerPermalinkToName {
	if mmConvertOwnerPermalinkToName.mock.funcConvertOwnerPermalinkToName != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by Set")
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation == nil {
		mmConvertOwnerPermalinkToName.defaultExpectation = &ConverterMockConvertOwnerPermalinkToNameExpectation{}
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation.paramPtrs != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by ExpectParams functions")
	}

	mmConvertOwnerPermalinkToName.defaultExpectation.params = &ConverterMockConvertOwnerPermalinkToNameParams{ctx, permalink}
	for _, e := range mmConvertOwnerPermalinkToName.expectations {
		if minimock.Equal(e.params, mmConvertOwnerPermalinkToName.defaultExpectation.params) {
			mmConvertOwnerPermalinkToName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertOwnerPermalinkToName.defaultExpectation.params)
		}
	}

	return mmConvertOwnerPermalinkToName
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertOwnerPermalinkToName
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertOwnerPermalinkToName {
	if mmConvertOwnerPermalinkToName.mock.funcConvertOwnerPermalinkToName != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by Set")
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation == nil {
		mmConvertOwnerPermalinkToName.defaultExpectation = &ConverterMockConvertOwnerPermalinkToNameExpectation{}
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation.params != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by Expect")
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation.paramPtrs == nil {
		mmConvertOwnerPermalinkToName.defaultExpectation.paramPtrs = &ConverterMockConvertOwnerPermalinkToNameParamPtrs{}
	}
	mmConvertOwnerPermalinkToName.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertOwnerPermalinkToName
}

// ExpectPermalinkParam2 sets up expected param permalink for Converter.ConvertOwnerPermalinkToName
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) ExpectPermalinkParam2(permalink string) *mConverterMockConvertOwnerPermalinkToName {
	if mmConvertOwnerPermalinkToName.mock.funcConvertOwnerPermalinkToName != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by Set")
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation == nil {
		mmConvertOwnerPermalinkToName.defaultExpectation = &ConverterMockConvertOwnerPermalinkToNameExpectation{}
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation.params != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by Expect")
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation.paramPtrs == nil {
		mmConvertOwnerPermalinkToName.defaultExpectation.paramPtrs = &ConverterMockConvertOwnerPermalinkToNameParamPtrs{}
	}
	mmConvertOwnerPermalinkToName.defaultExpectation.paramPtrs.permalink = &permalink

	return mmConvertOwnerPermalinkToName
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertOwnerPermalinkToName
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) Inspect(f func(ctx context.Context, permalink string)) *mConverterMockConvertOwnerPermalinkToName {
	if mmConvertOwnerPermalinkToName.mock.inspectFuncConvertOwnerPermalinkToName != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertOwnerPermalinkToName")
	}

	mmConvertOwnerPermalinkToName.mock.inspectFuncConvertOwnerPermalinkToName = f

	return mmConvertOwnerPermalinkToName
}

// Return sets up results that will be returned by Converter.ConvertOwnerPermalinkToName
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) Return(s1 string, err error) *ConverterMock {
	if mmConvertOwnerPermalinkToName.mock.funcConvertOwnerPermalinkToName != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by Set")
	}

	if mmConvertOwnerPermalinkToName.defaultExpectation == nil {
		mmConvertOwnerPermalinkToName.defaultExpectation = &ConverterMockConvertOwnerPermalinkToNameExpectation{mock: mmConvertOwnerPermalinkToName.mock}
	}
	mmConvertOwnerPermalinkToName.defaultExpectation.results = &ConverterMockConvertOwnerPermalinkToNameResults{s1, err}
	return mmConvertOwnerPermalinkToName.mock
}

// Set uses given function f to mock the Converter.ConvertOwnerPermalinkToName method
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) Set(f func(ctx context.Context, permalink string) (s1 string, err error)) *ConverterMock {
	if mmConvertOwnerPermalinkToName.defaultExpectation != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertOwnerPermalinkToName method")
	}

	if len(mmConvertOwnerPermalinkToName.expectations) > 0 {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertOwnerPermalinkToName method")
	}

	mmConvertOwnerPermalinkToName.mock.funcConvertOwnerPermalinkToName = f
	return mmConvertOwnerPermalinkToName.mock
}

// When sets expectation for the Converter.ConvertOwnerPermalinkToName which will trigger the result defined by the following
// Then helper
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) When(ctx context.Context, permalink string) *ConverterMockConvertOwnerPermalinkToNameExpectation {
	if mmConvertOwnerPermalinkToName.mock.funcConvertOwnerPermalinkToName != nil {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("ConverterMock.ConvertOwnerPermalinkToName mock is already set by Set")
	}

	expectation := &ConverterMockConvertOwnerPermalinkToNameExpectation{
		mock:   mmConvertOwnerPermalinkToName.mock,
		params: &ConverterMockConvertOwnerPermalinkToNameParams{ctx, permalink},
	}
	mmConvertOwnerPermalinkToName.expectations = append(mmConvertOwnerPermalinkToName.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertOwnerPermalinkToName return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertOwnerPermalinkToNameExpectation) Then(s1 string, err error) *ConverterMock {
	e.results = &ConverterMockConvertOwnerPermalinkToNameResults{s1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertOwnerPermalinkToName should be invoked
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) Times(n uint64) *mConverterMockConvertOwnerPermalinkToName {
	if n == 0 {
		mmConvertOwnerPermalinkToName.mock.t.Fatalf("Times of ConverterMock.ConvertOwnerPermalinkToName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertOwnerPermalinkToName.expectedInvocations, n)
	return mmConvertOwnerPermalinkToName
}

func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) invocationsDone() bool {
	if len(mmConvertOwnerPermalinkToName.expectations) == 0 && mmConvertOwnerPermalinkToName.defaultExpectation == nil && mmConvertOwnerPermalinkToName.mock.funcConvertOwnerPermalinkToName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertOwnerPermalinkToName.mock.afterConvertOwnerPermalinkToNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertOwnerPermalinkToName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertOwnerPermalinkToName implements service.Converter
func (mmConvertOwnerPermalinkToName *ConverterMock) ConvertOwnerPermalinkToName(ctx context.Context, permalink string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmConvertOwnerPermalinkToName.beforeConvertOwnerPermalinkToNameCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertOwnerPermalinkToName.afterConvertOwnerPermalinkToNameCounter, 1)

	if mmConvertOwnerPermalinkToName.inspectFuncConvertOwnerPermalinkToName != nil {
		mmConvertOwnerPermalinkToName.inspectFuncConvertOwnerPermalinkToName(ctx, permalink)
	}

	mm_params := ConverterMockConvertOwnerPermalinkToNameParams{ctx, permalink}

	// Record call args
	mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.mutex.Lock()
	mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.callArgs = append(mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.callArgs, &mm_params)
	mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.mutex.Unlock()

	for _, e := range mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.defaultExpectation.params
		mm_want_ptrs := mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertOwnerPermalinkToNameParams{ctx, permalink}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertOwnerPermalinkToName.t.Errorf("ConverterMock.ConvertOwnerPermalinkToName got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.permalink != nil && !minimock.Equal(*mm_want_ptrs.permalink, mm_got.permalink) {
				mmConvertOwnerPermalinkToName.t.Errorf("ConverterMock.ConvertOwnerPermalinkToName got unexpected parameter permalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.permalink, mm_got.permalink, minimock.Diff(*mm_want_ptrs.permalink, mm_got.permalink))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertOwnerPermalinkToName.t.Errorf("ConverterMock.ConvertOwnerPermalinkToName got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertOwnerPermalinkToName.ConvertOwnerPermalinkToNameMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertOwnerPermalinkToName.t.Fatal("No results are set for the ConverterMock.ConvertOwnerPermalinkToName")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmConvertOwnerPermalinkToName.funcConvertOwnerPermalinkToName != nil {
		return mmConvertOwnerPermalinkToName.funcConvertOwnerPermalinkToName(ctx, permalink)
	}
	mmConvertOwnerPermalinkToName.t.Fatalf("Unexpected call to ConverterMock.ConvertOwnerPermalinkToName. %v %v", ctx, permalink)
	return
}

// ConvertOwnerPermalinkToNameAfterCounter returns a count of finished ConverterMock.ConvertOwnerPermalinkToName invocations
func (mmConvertOwnerPermalinkToName *ConverterMock) ConvertOwnerPermalinkToNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertOwnerPermalinkToName.afterConvertOwnerPermalinkToNameCounter)
}

// ConvertOwnerPermalinkToNameBeforeCounter returns a count of ConverterMock.ConvertOwnerPermalinkToName invocations
func (mmConvertOwnerPermalinkToName *ConverterMock) ConvertOwnerPermalinkToNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertOwnerPermalinkToName.beforeConvertOwnerPermalinkToNameCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertOwnerPermalinkToName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertOwnerPermalinkToName *mConverterMockConvertOwnerPermalinkToName) Calls() []*ConverterMockConvertOwnerPermalinkToNameParams {
	mmConvertOwnerPermalinkToName.mutex.RLock()

	argCopy := make([]*ConverterMockConvertOwnerPermalinkToNameParams, len(mmConvertOwnerPermalinkToName.callArgs))
	copy(argCopy, mmConvertOwnerPermalinkToName.callArgs)

	mmConvertOwnerPermalinkToName.mutex.RUnlock()

	return argCopy
}

// MinimockConvertOwnerPermalinkToNameDone returns true if the count of the ConvertOwnerPermalinkToName invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertOwnerPermalinkToNameDone() bool {
	if m.ConvertOwnerPermalinkToNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertOwnerPermalinkToNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertOwnerPermalinkToNameMock.invocationsDone()
}

// MinimockConvertOwnerPermalinkToNameInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertOwnerPermalinkToNameInspect() {
	for _, e := range m.ConvertOwnerPermalinkToNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertOwnerPermalinkToName with params: %#v", *e.params)
		}
	}

	afterConvertOwnerPermalinkToNameCounter := mm_atomic.LoadUint64(&m.afterConvertOwnerPermalinkToNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertOwnerPermalinkToNameMock.defaultExpectation != nil && afterConvertOwnerPermalinkToNameCounter < 1 {
		if m.ConvertOwnerPermalinkToNameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertOwnerPermalinkToName")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertOwnerPermalinkToName with params: %#v", *m.ConvertOwnerPermalinkToNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertOwnerPermalinkToName != nil && afterConvertOwnerPermalinkToNameCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertOwnerPermalinkToName")
	}

	if !m.ConvertOwnerPermalinkToNameMock.invocationsDone() && afterConvertOwnerPermalinkToNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertOwnerPermalinkToName but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertOwnerPermalinkToNameMock.expectedInvocations), afterConvertOwnerPermalinkToNameCounter)
	}
}

type mConverterMockConvertPipelineReleaseToDB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineReleaseToDBExpectation
	expectations       []*ConverterMockConvertPipelineReleaseToDBExpectation

	callArgs []*ConverterMockConvertPipelineReleaseToDBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertPipelineReleaseToDBExpectation specifies expectation struct of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertPipelineReleaseToDBParams
	paramPtrs *ConverterMockConvertPipelineReleaseToDBParamPtrs
	results   *ConverterMockConvertPipelineReleaseToDBResults
	Counter   uint64
}

// ConverterMockConvertPipelineReleaseToDBParams contains parameters of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBParams struct {
	ctx               context.Context
	pipelineUID       uuid.UUID
	pbPipelineRelease *pb.PipelineRelease
}

// ConverterMockConvertPipelineReleaseToDBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBParamPtrs struct {
	ctx               *context.Context
	pipelineUID       *uuid.UUID
	pbPipelineRelease **pb.PipelineRelease
}

// ConverterMockConvertPipelineReleaseToDBResults contains results of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Optional() *mConverterMockConvertPipelineReleaseToDB {
	mmConvertPipelineReleaseToDB.optional = true
	return mmConvertPipelineReleaseToDB
}

// Expect sets up expected params for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Expect(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineReleaseToDB.defaultExpectation.params = &ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease}
	for _, e := range mmConvertPipelineReleaseToDB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineReleaseToDB.defaultExpectation.params) {
			mmConvertPipelineReleaseToDB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineReleaseToDB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineReleaseToDB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToDBParamPtrs{}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertPipelineReleaseToDB
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToDBParamPtrs{}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID

	return mmConvertPipelineReleaseToDB
}

// ExpectPbPipelineReleaseParam3 sets up expected param pbPipelineRelease for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) ExpectPbPipelineReleaseParam3(pbPipelineRelease *pb.PipelineRelease) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToDBParamPtrs{}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs.pbPipelineRelease = &pbPipelineRelease

	return mmConvertPipelineReleaseToDB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease)) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.inspectFuncConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineReleaseToDB")
	}

	mmConvertPipelineReleaseToDB.mock.inspectFuncConvertPipelineReleaseToDB = f

	return mmConvertPipelineReleaseToDB
}

// Return sets up results that will be returned by Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Return(pp1 *datamodel.PipelineRelease, err error) *ConverterMock {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{mock: mmConvertPipelineReleaseToDB.mock}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.results = &ConverterMockConvertPipelineReleaseToDBResults{pp1, err}
	return mmConvertPipelineReleaseToDB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineReleaseToDB method
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Set(f func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) (pp1 *datamodel.PipelineRelease, err error)) *ConverterMock {
	if mmConvertPipelineReleaseToDB.defaultExpectation != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineReleaseToDB method")
	}

	if len(mmConvertPipelineReleaseToDB.expectations) > 0 {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineReleaseToDB method")
	}

	mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB = f
	return mmConvertPipelineReleaseToDB.mock
}

// When sets expectation for the Converter.ConvertPipelineReleaseToDB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) When(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) *ConverterMockConvertPipelineReleaseToDBExpectation {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineReleaseToDBExpectation{
		mock:   mmConvertPipelineReleaseToDB.mock,
		params: &ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease},
	}
	mmConvertPipelineReleaseToDB.expectations = append(mmConvertPipelineReleaseToDB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineReleaseToDB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineReleaseToDBExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineReleaseToDBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineReleaseToDB should be invoked
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Times(n uint64) *mConverterMockConvertPipelineReleaseToDB {
	if n == 0 {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineReleaseToDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineReleaseToDB.expectedInvocations, n)
	return mmConvertPipelineReleaseToDB
}

func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) invocationsDone() bool {
	if len(mmConvertPipelineReleaseToDB.expectations) == 0 && mmConvertPipelineReleaseToDB.defaultExpectation == nil && mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.mock.afterConvertPipelineReleaseToDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineReleaseToDB implements service.Converter
func (mmConvertPipelineReleaseToDB *ConverterMock) ConvertPipelineReleaseToDB(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineReleaseToDB.beforeConvertPipelineReleaseToDBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineReleaseToDB.afterConvertPipelineReleaseToDBCounter, 1)

	if mmConvertPipelineReleaseToDB.inspectFuncConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.inspectFuncConvertPipelineReleaseToDB(ctx, pipelineUID, pbPipelineRelease)
	}

	mm_params := ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease}

	// Record call args
	mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.mutex.Lock()
	mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.callArgs = append(mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.callArgs, &mm_params)
	mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameter pipelineUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pbPipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pbPipelineRelease, mm_got.pbPipelineRelease) {
				mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameter pbPipelineRelease, want: %#v, got: %#v%s\n", *mm_want_ptrs.pbPipelineRelease, mm_got.pbPipelineRelease, minimock.Diff(*mm_want_ptrs.pbPipelineRelease, mm_got.pbPipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineReleaseToDB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineReleaseToDB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineReleaseToDB.funcConvertPipelineReleaseToDB != nil {
		return mmConvertPipelineReleaseToDB.funcConvertPipelineReleaseToDB(ctx, pipelineUID, pbPipelineRelease)
	}
	mmConvertPipelineReleaseToDB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineReleaseToDB. %v %v %v", ctx, pipelineUID, pbPipelineRelease)
	return
}

// ConvertPipelineReleaseToDBAfterCounter returns a count of finished ConverterMock.ConvertPipelineReleaseToDB invocations
func (mmConvertPipelineReleaseToDB *ConverterMock) ConvertPipelineReleaseToDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.afterConvertPipelineReleaseToDBCounter)
}

// ConvertPipelineReleaseToDBBeforeCounter returns a count of ConverterMock.ConvertPipelineReleaseToDB invocations
func (mmConvertPipelineReleaseToDB *ConverterMock) ConvertPipelineReleaseToDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.beforeConvertPipelineReleaseToDBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineReleaseToDB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Calls() []*ConverterMockConvertPipelineReleaseToDBParams {
	mmConvertPipelineReleaseToDB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineReleaseToDBParams, len(mmConvertPipelineReleaseToDB.callArgs))
	copy(argCopy, mmConvertPipelineReleaseToDB.callArgs)

	mmConvertPipelineReleaseToDB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineReleaseToDBDone returns true if the count of the ConvertPipelineReleaseToDB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineReleaseToDBDone() bool {
	if m.ConvertPipelineReleaseToDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineReleaseToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineReleaseToDBMock.invocationsDone()
}

// MinimockConvertPipelineReleaseToDBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineReleaseToDBInspect() {
	for _, e := range m.ConvertPipelineReleaseToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToDB with params: %#v", *e.params)
		}
	}

	afterConvertPipelineReleaseToDBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineReleaseToDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineReleaseToDBMock.defaultExpectation != nil && afterConvertPipelineReleaseToDBCounter < 1 {
		if m.ConvertPipelineReleaseToDBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertPipelineReleaseToDB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToDB with params: %#v", *m.ConvertPipelineReleaseToDBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineReleaseToDB != nil && afterConvertPipelineReleaseToDBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertPipelineReleaseToDB")
	}

	if !m.ConvertPipelineReleaseToDBMock.invocationsDone() && afterConvertPipelineReleaseToDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineReleaseToDB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineReleaseToDBMock.expectedInvocations), afterConvertPipelineReleaseToDBCounter)
	}
}

type mConverterMockConvertPipelineReleaseToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineReleaseToPBExpectation
	expectations       []*ConverterMockConvertPipelineReleaseToPBExpectation

	callArgs []*ConverterMockConvertPipelineReleaseToPBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertPipelineReleaseToPBExpectation specifies expectation struct of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertPipelineReleaseToPBParams
	paramPtrs *ConverterMockConvertPipelineReleaseToPBParamPtrs
	results   *ConverterMockConvertPipelineReleaseToPBResults
	Counter   uint64
}

// ConverterMockConvertPipelineReleaseToPBParams contains parameters of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBParams struct {
	ctx               context.Context
	dbPipeline        *datamodel.Pipeline
	dbPipelineRelease *datamodel.PipelineRelease
	view              pb.Pipeline_View
}

// ConverterMockConvertPipelineReleaseToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBParamPtrs struct {
	ctx               *context.Context
	dbPipeline        **datamodel.Pipeline
	dbPipelineRelease **datamodel.PipelineRelease
	view              *pb.Pipeline_View
}

// ConverterMockConvertPipelineReleaseToPBResults contains results of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBResults struct {
	pp1 *pb.PipelineRelease
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Optional() *mConverterMockConvertPipelineReleaseToPB {
	mmConvertPipelineReleaseToPB.optional = true
	return mmConvertPipelineReleaseToPB
}

// Expect sets up expected params for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Expect(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineReleaseToPB.defaultExpectation.params = &ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view}
	for _, e := range mmConvertPipelineReleaseToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineReleaseToPB.defaultExpectation.params) {
			mmConvertPipelineReleaseToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineReleaseToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineReleaseToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertPipelineReleaseToPB
}

// ExpectDbPipelineParam2 sets up expected param dbPipeline for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectDbPipelineParam2(dbPipeline *datamodel.Pipeline) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.dbPipeline = &dbPipeline

	return mmConvertPipelineReleaseToPB
}

// ExpectDbPipelineReleaseParam3 sets up expected param dbPipelineRelease for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectDbPipelineReleaseParam3(dbPipelineRelease *datamodel.PipelineRelease) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.dbPipelineRelease = &dbPipelineRelease

	return mmConvertPipelineReleaseToPB
}

// ExpectViewParam4 sets up expected param view for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectViewParam4(view pb.Pipeline_View) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.view = &view

	return mmConvertPipelineReleaseToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Inspect(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View)) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.inspectFuncConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineReleaseToPB")
	}

	mmConvertPipelineReleaseToPB.mock.inspectFuncConvertPipelineReleaseToPB = f

	return mmConvertPipelineReleaseToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Return(pp1 *pb.PipelineRelease, err error) *ConverterMock {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{mock: mmConvertPipelineReleaseToPB.mock}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.results = &ConverterMockConvertPipelineReleaseToPBResults{pp1, err}
	return mmConvertPipelineReleaseToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineReleaseToPB method
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Set(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) (pp1 *pb.PipelineRelease, err error)) *ConverterMock {
	if mmConvertPipelineReleaseToPB.defaultExpectation != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineReleaseToPB method")
	}

	if len(mmConvertPipelineReleaseToPB.expectations) > 0 {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineReleaseToPB method")
	}

	mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB = f
	return mmConvertPipelineReleaseToPB.mock
}

// When sets expectation for the Converter.ConvertPipelineReleaseToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) When(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) *ConverterMockConvertPipelineReleaseToPBExpectation {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineReleaseToPBExpectation{
		mock:   mmConvertPipelineReleaseToPB.mock,
		params: &ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view},
	}
	mmConvertPipelineReleaseToPB.expectations = append(mmConvertPipelineReleaseToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineReleaseToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineReleaseToPBExpectation) Then(pp1 *pb.PipelineRelease, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineReleaseToPBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineReleaseToPB should be invoked
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Times(n uint64) *mConverterMockConvertPipelineReleaseToPB {
	if n == 0 {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineReleaseToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineReleaseToPB.expectedInvocations, n)
	return mmConvertPipelineReleaseToPB
}

func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) invocationsDone() bool {
	if len(mmConvertPipelineReleaseToPB.expectations) == 0 && mmConvertPipelineReleaseToPB.defaultExpectation == nil && mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.mock.afterConvertPipelineReleaseToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineReleaseToPB implements service.Converter
func (mmConvertPipelineReleaseToPB *ConverterMock) ConvertPipelineReleaseToPB(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) (pp1 *pb.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineReleaseToPB.beforeConvertPipelineReleaseToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineReleaseToPB.afterConvertPipelineReleaseToPBCounter, 1)

	if mmConvertPipelineReleaseToPB.inspectFuncConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.inspectFuncConvertPipelineReleaseToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}

	mm_params := ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

	// Record call args
	mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.mutex.Lock()
	mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.callArgs = append(mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.callArgs, &mm_params)
	mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipeline != nil && !minimock.Equal(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter dbPipeline, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbPipeline, mm_got.dbPipeline, minimock.Diff(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline))
			}

			if mm_want_ptrs.dbPipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter dbPipelineRelease, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease, minimock.Diff(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter view, want: %#v, got: %#v%s\n", *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineReleaseToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineReleaseToPB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineReleaseToPB.funcConvertPipelineReleaseToPB != nil {
		return mmConvertPipelineReleaseToPB.funcConvertPipelineReleaseToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}
	mmConvertPipelineReleaseToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineReleaseToPB. %v %v %v %v", ctx, dbPipeline, dbPipelineRelease, view)
	return
}

// ConvertPipelineReleaseToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelineReleaseToPB invocations
func (mmConvertPipelineReleaseToPB *ConverterMock) ConvertPipelineReleaseToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.afterConvertPipelineReleaseToPBCounter)
}

// ConvertPipelineReleaseToPBBeforeCounter returns a count of ConverterMock.ConvertPipelineReleaseToPB invocations
func (mmConvertPipelineReleaseToPB *ConverterMock) ConvertPipelineReleaseToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.beforeConvertPipelineReleaseToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineReleaseToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Calls() []*ConverterMockConvertPipelineReleaseToPBParams {
	mmConvertPipelineReleaseToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineReleaseToPBParams, len(mmConvertPipelineReleaseToPB.callArgs))
	copy(argCopy, mmConvertPipelineReleaseToPB.callArgs)

	mmConvertPipelineReleaseToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineReleaseToPBDone returns true if the count of the ConvertPipelineReleaseToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineReleaseToPBDone() bool {
	if m.ConvertPipelineReleaseToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineReleaseToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineReleaseToPBMock.invocationsDone()
}

// MinimockConvertPipelineReleaseToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineReleaseToPBInspect() {
	for _, e := range m.ConvertPipelineReleaseToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToPB with params: %#v", *e.params)
		}
	}

	afterConvertPipelineReleaseToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineReleaseToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineReleaseToPBMock.defaultExpectation != nil && afterConvertPipelineReleaseToPBCounter < 1 {
		if m.ConvertPipelineReleaseToPBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertPipelineReleaseToPB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToPB with params: %#v", *m.ConvertPipelineReleaseToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineReleaseToPB != nil && afterConvertPipelineReleaseToPBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertPipelineReleaseToPB")
	}

	if !m.ConvertPipelineReleaseToPBMock.invocationsDone() && afterConvertPipelineReleaseToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineReleaseToPB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineReleaseToPBMock.expectedInvocations), afterConvertPipelineReleaseToPBCounter)
	}
}

type mConverterMockConvertPipelineReleasesToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineReleasesToPBExpectation
	expectations       []*ConverterMockConvertPipelineReleasesToPBExpectation

	callArgs []*ConverterMockConvertPipelineReleasesToPBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertPipelineReleasesToPBExpectation specifies expectation struct of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertPipelineReleasesToPBParams
	paramPtrs *ConverterMockConvertPipelineReleasesToPBParamPtrs
	results   *ConverterMockConvertPipelineReleasesToPBResults
	Counter   uint64
}

// ConverterMockConvertPipelineReleasesToPBParams contains parameters of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBParams struct {
	ctx               context.Context
	dbPipeline        *datamodel.Pipeline
	dbPipelineRelease []*datamodel.PipelineRelease
	view              pb.Pipeline_View
}

// ConverterMockConvertPipelineReleasesToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBParamPtrs struct {
	ctx               *context.Context
	dbPipeline        **datamodel.Pipeline
	dbPipelineRelease *[]*datamodel.PipelineRelease
	view              *pb.Pipeline_View
}

// ConverterMockConvertPipelineReleasesToPBResults contains results of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBResults struct {
	ppa1 []*pb.PipelineRelease
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Optional() *mConverterMockConvertPipelineReleasesToPB {
	mmConvertPipelineReleasesToPB.optional = true
	return mmConvertPipelineReleasesToPB
}

// Expect sets up expected params for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Expect(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineReleasesToPB.defaultExpectation.params = &ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view}
	for _, e := range mmConvertPipelineReleasesToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineReleasesToPB.defaultExpectation.params) {
			mmConvertPipelineReleasesToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineReleasesToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineReleasesToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertPipelineReleasesToPB
}

// ExpectDbPipelineParam2 sets up expected param dbPipeline for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectDbPipelineParam2(dbPipeline *datamodel.Pipeline) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.dbPipeline = &dbPipeline

	return mmConvertPipelineReleasesToPB
}

// ExpectDbPipelineReleaseParam3 sets up expected param dbPipelineRelease for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectDbPipelineReleaseParam3(dbPipelineRelease []*datamodel.PipelineRelease) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.dbPipelineRelease = &dbPipelineRelease

	return mmConvertPipelineReleasesToPB
}

// ExpectViewParam4 sets up expected param view for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectViewParam4(view pb.Pipeline_View) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.view = &view

	return mmConvertPipelineReleasesToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Inspect(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View)) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.inspectFuncConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineReleasesToPB")
	}

	mmConvertPipelineReleasesToPB.mock.inspectFuncConvertPipelineReleasesToPB = f

	return mmConvertPipelineReleasesToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Return(ppa1 []*pb.PipelineRelease, err error) *ConverterMock {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{mock: mmConvertPipelineReleasesToPB.mock}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.results = &ConverterMockConvertPipelineReleasesToPBResults{ppa1, err}
	return mmConvertPipelineReleasesToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineReleasesToPB method
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Set(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) (ppa1 []*pb.PipelineRelease, err error)) *ConverterMock {
	if mmConvertPipelineReleasesToPB.defaultExpectation != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineReleasesToPB method")
	}

	if len(mmConvertPipelineReleasesToPB.expectations) > 0 {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineReleasesToPB method")
	}

	mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB = f
	return mmConvertPipelineReleasesToPB.mock
}

// When sets expectation for the Converter.ConvertPipelineReleasesToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) When(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) *ConverterMockConvertPipelineReleasesToPBExpectation {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineReleasesToPBExpectation{
		mock:   mmConvertPipelineReleasesToPB.mock,
		params: &ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view},
	}
	mmConvertPipelineReleasesToPB.expectations = append(mmConvertPipelineReleasesToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineReleasesToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineReleasesToPBExpectation) Then(ppa1 []*pb.PipelineRelease, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineReleasesToPBResults{ppa1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineReleasesToPB should be invoked
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Times(n uint64) *mConverterMockConvertPipelineReleasesToPB {
	if n == 0 {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineReleasesToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineReleasesToPB.expectedInvocations, n)
	return mmConvertPipelineReleasesToPB
}

func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) invocationsDone() bool {
	if len(mmConvertPipelineReleasesToPB.expectations) == 0 && mmConvertPipelineReleasesToPB.defaultExpectation == nil && mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.mock.afterConvertPipelineReleasesToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineReleasesToPB implements service.Converter
func (mmConvertPipelineReleasesToPB *ConverterMock) ConvertPipelineReleasesToPB(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) (ppa1 []*pb.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineReleasesToPB.beforeConvertPipelineReleasesToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineReleasesToPB.afterConvertPipelineReleasesToPBCounter, 1)

	if mmConvertPipelineReleasesToPB.inspectFuncConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.inspectFuncConvertPipelineReleasesToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}

	mm_params := ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

	// Record call args
	mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.mutex.Lock()
	mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.callArgs = append(mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.callArgs, &mm_params)
	mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipeline != nil && !minimock.Equal(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter dbPipeline, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbPipeline, mm_got.dbPipeline, minimock.Diff(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline))
			}

			if mm_want_ptrs.dbPipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter dbPipelineRelease, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease, minimock.Diff(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter view, want: %#v, got: %#v%s\n", *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineReleasesToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineReleasesToPB")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmConvertPipelineReleasesToPB.funcConvertPipelineReleasesToPB != nil {
		return mmConvertPipelineReleasesToPB.funcConvertPipelineReleasesToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}
	mmConvertPipelineReleasesToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineReleasesToPB. %v %v %v %v", ctx, dbPipeline, dbPipelineRelease, view)
	return
}

// ConvertPipelineReleasesToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelineReleasesToPB invocations
func (mmConvertPipelineReleasesToPB *ConverterMock) ConvertPipelineReleasesToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.afterConvertPipelineReleasesToPBCounter)
}

// ConvertPipelineReleasesToPBBeforeCounter returns a count of ConverterMock.ConvertPipelineReleasesToPB invocations
func (mmConvertPipelineReleasesToPB *ConverterMock) ConvertPipelineReleasesToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.beforeConvertPipelineReleasesToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineReleasesToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Calls() []*ConverterMockConvertPipelineReleasesToPBParams {
	mmConvertPipelineReleasesToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineReleasesToPBParams, len(mmConvertPipelineReleasesToPB.callArgs))
	copy(argCopy, mmConvertPipelineReleasesToPB.callArgs)

	mmConvertPipelineReleasesToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineReleasesToPBDone returns true if the count of the ConvertPipelineReleasesToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineReleasesToPBDone() bool {
	if m.ConvertPipelineReleasesToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineReleasesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineReleasesToPBMock.invocationsDone()
}

// MinimockConvertPipelineReleasesToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineReleasesToPBInspect() {
	for _, e := range m.ConvertPipelineReleasesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleasesToPB with params: %#v", *e.params)
		}
	}

	afterConvertPipelineReleasesToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineReleasesToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineReleasesToPBMock.defaultExpectation != nil && afterConvertPipelineReleasesToPBCounter < 1 {
		if m.ConvertPipelineReleasesToPBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertPipelineReleasesToPB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleasesToPB with params: %#v", *m.ConvertPipelineReleasesToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineReleasesToPB != nil && afterConvertPipelineReleasesToPBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertPipelineReleasesToPB")
	}

	if !m.ConvertPipelineReleasesToPBMock.invocationsDone() && afterConvertPipelineReleasesToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineReleasesToPB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineReleasesToPBMock.expectedInvocations), afterConvertPipelineReleasesToPBCounter)
	}
}

type mConverterMockConvertPipelineToDB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineToDBExpectation
	expectations       []*ConverterMockConvertPipelineToDBExpectation

	callArgs []*ConverterMockConvertPipelineToDBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertPipelineToDBExpectation specifies expectation struct of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertPipelineToDBParams
	paramPtrs *ConverterMockConvertPipelineToDBParamPtrs
	results   *ConverterMockConvertPipelineToDBResults
	Counter   uint64
}

// ConverterMockConvertPipelineToDBParams contains parameters of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBParams struct {
	ctx        context.Context
	ns         resource.Namespace
	pbPipeline *pb.Pipeline
}

// ConverterMockConvertPipelineToDBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBParamPtrs struct {
	ctx        *context.Context
	ns         *resource.Namespace
	pbPipeline **pb.Pipeline
}

// ConverterMockConvertPipelineToDBResults contains results of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Optional() *mConverterMockConvertPipelineToDB {
	mmConvertPipelineToDB.optional = true
	return mmConvertPipelineToDB
}

// Expect sets up expected params for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Expect(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineToDB.defaultExpectation.params = &ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline}
	for _, e := range mmConvertPipelineToDB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineToDB.defaultExpectation.params) {
			mmConvertPipelineToDB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineToDB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineToDB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.params != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Expect")
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToDBParamPtrs{}
	}
	mmConvertPipelineToDB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertPipelineToDB
}

// ExpectNsParam2 sets up expected param ns for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) ExpectNsParam2(ns resource.Namespace) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.params != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Expect")
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToDBParamPtrs{}
	}
	mmConvertPipelineToDB.defaultExpectation.paramPtrs.ns = &ns

	return mmConvertPipelineToDB
}

// ExpectPbPipelineParam3 sets up expected param pbPipeline for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) ExpectPbPipelineParam3(pbPipeline *pb.Pipeline) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.params != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Expect")
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToDBParamPtrs{}
	}
	mmConvertPipelineToDB.defaultExpectation.paramPtrs.pbPipeline = &pbPipeline

	return mmConvertPipelineToDB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Inspect(f func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline)) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.inspectFuncConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineToDB")
	}

	mmConvertPipelineToDB.mock.inspectFuncConvertPipelineToDB = f

	return mmConvertPipelineToDB
}

// Return sets up results that will be returned by Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Return(pp1 *datamodel.Pipeline, err error) *ConverterMock {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{mock: mmConvertPipelineToDB.mock}
	}
	mmConvertPipelineToDB.defaultExpectation.results = &ConverterMockConvertPipelineToDBResults{pp1, err}
	return mmConvertPipelineToDB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineToDB method
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Set(f func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) (pp1 *datamodel.Pipeline, err error)) *ConverterMock {
	if mmConvertPipelineToDB.defaultExpectation != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineToDB method")
	}

	if len(mmConvertPipelineToDB.expectations) > 0 {
		mmConvertPipelineToDB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineToDB method")
	}

	mmConvertPipelineToDB.mock.funcConvertPipelineToDB = f
	return mmConvertPipelineToDB.mock
}

// When sets expectation for the Converter.ConvertPipelineToDB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) When(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) *ConverterMockConvertPipelineToDBExpectation {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineToDBExpectation{
		mock:   mmConvertPipelineToDB.mock,
		params: &ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline},
	}
	mmConvertPipelineToDB.expectations = append(mmConvertPipelineToDB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineToDB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineToDBExpectation) Then(pp1 *datamodel.Pipeline, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineToDBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineToDB should be invoked
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Times(n uint64) *mConverterMockConvertPipelineToDB {
	if n == 0 {
		mmConvertPipelineToDB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineToDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineToDB.expectedInvocations, n)
	return mmConvertPipelineToDB
}

func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) invocationsDone() bool {
	if len(mmConvertPipelineToDB.expectations) == 0 && mmConvertPipelineToDB.defaultExpectation == nil && mmConvertPipelineToDB.mock.funcConvertPipelineToDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToDB.mock.afterConvertPipelineToDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineToDB implements service.Converter
func (mmConvertPipelineToDB *ConverterMock) ConvertPipelineToDB(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineToDB.beforeConvertPipelineToDBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineToDB.afterConvertPipelineToDBCounter, 1)

	if mmConvertPipelineToDB.inspectFuncConvertPipelineToDB != nil {
		mmConvertPipelineToDB.inspectFuncConvertPipelineToDB(ctx, ns, pbPipeline)
	}

	mm_params := ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline}

	// Record call args
	mmConvertPipelineToDB.ConvertPipelineToDBMock.mutex.Lock()
	mmConvertPipelineToDB.ConvertPipelineToDBMock.callArgs = append(mmConvertPipelineToDB.ConvertPipelineToDBMock.callArgs, &mm_params)
	mmConvertPipelineToDB.ConvertPipelineToDBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineToDB.ConvertPipelineToDBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ns != nil && !minimock.Equal(*mm_want_ptrs.ns, mm_got.ns) {
				mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameter ns, want: %#v, got: %#v%s\n", *mm_want_ptrs.ns, mm_got.ns, minimock.Diff(*mm_want_ptrs.ns, mm_got.ns))
			}

			if mm_want_ptrs.pbPipeline != nil && !minimock.Equal(*mm_want_ptrs.pbPipeline, mm_got.pbPipeline) {
				mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameter pbPipeline, want: %#v, got: %#v%s\n", *mm_want_ptrs.pbPipeline, mm_got.pbPipeline, minimock.Diff(*mm_want_ptrs.pbPipeline, mm_got.pbPipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineToDB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineToDB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineToDB.funcConvertPipelineToDB != nil {
		return mmConvertPipelineToDB.funcConvertPipelineToDB(ctx, ns, pbPipeline)
	}
	mmConvertPipelineToDB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineToDB. %v %v %v", ctx, ns, pbPipeline)
	return
}

// ConvertPipelineToDBAfterCounter returns a count of finished ConverterMock.ConvertPipelineToDB invocations
func (mmConvertPipelineToDB *ConverterMock) ConvertPipelineToDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToDB.afterConvertPipelineToDBCounter)
}

// ConvertPipelineToDBBeforeCounter returns a count of ConverterMock.ConvertPipelineToDB invocations
func (mmConvertPipelineToDB *ConverterMock) ConvertPipelineToDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToDB.beforeConvertPipelineToDBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineToDB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Calls() []*ConverterMockConvertPipelineToDBParams {
	mmConvertPipelineToDB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineToDBParams, len(mmConvertPipelineToDB.callArgs))
	copy(argCopy, mmConvertPipelineToDB.callArgs)

	mmConvertPipelineToDB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineToDBDone returns true if the count of the ConvertPipelineToDB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineToDBDone() bool {
	if m.ConvertPipelineToDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineToDBMock.invocationsDone()
}

// MinimockConvertPipelineToDBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineToDBInspect() {
	for _, e := range m.ConvertPipelineToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToDB with params: %#v", *e.params)
		}
	}

	afterConvertPipelineToDBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineToDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineToDBMock.defaultExpectation != nil && afterConvertPipelineToDBCounter < 1 {
		if m.ConvertPipelineToDBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertPipelineToDB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToDB with params: %#v", *m.ConvertPipelineToDBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineToDB != nil && afterConvertPipelineToDBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertPipelineToDB")
	}

	if !m.ConvertPipelineToDBMock.invocationsDone() && afterConvertPipelineToDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineToDB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineToDBMock.expectedInvocations), afterConvertPipelineToDBCounter)
	}
}

type mConverterMockConvertPipelineToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineToPBExpectation
	expectations       []*ConverterMockConvertPipelineToPBExpectation

	callArgs []*ConverterMockConvertPipelineToPBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertPipelineToPBExpectation specifies expectation struct of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertPipelineToPBParams
	paramPtrs *ConverterMockConvertPipelineToPBParamPtrs
	results   *ConverterMockConvertPipelineToPBResults
	Counter   uint64
}

// ConverterMockConvertPipelineToPBParams contains parameters of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBParams struct {
	ctx             context.Context
	dbPipeline      *datamodel.Pipeline
	view            pb.Pipeline_View
	checkPermission bool
	useDynamicDef   bool
}

// ConverterMockConvertPipelineToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBParamPtrs struct {
	ctx             *context.Context
	dbPipeline      **datamodel.Pipeline
	view            *pb.Pipeline_View
	checkPermission *bool
	useDynamicDef   *bool
}

// ConverterMockConvertPipelineToPBResults contains results of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBResults struct {
	pp1 *pb.Pipeline
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Optional() *mConverterMockConvertPipelineToPB {
	mmConvertPipelineToPB.optional = true
	return mmConvertPipelineToPB
}

// Expect sets up expected params for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Expect(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineToPB.defaultExpectation.params = &ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef}
	for _, e := range mmConvertPipelineToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineToPB.defaultExpectation.params) {
			mmConvertPipelineToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertPipelineToPB
}

// ExpectDbPipelineParam2 sets up expected param dbPipeline for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectDbPipelineParam2(dbPipeline *datamodel.Pipeline) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.dbPipeline = &dbPipeline

	return mmConvertPipelineToPB
}

// ExpectViewParam3 sets up expected param view for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectViewParam3(view pb.Pipeline_View) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.view = &view

	return mmConvertPipelineToPB
}

// ExpectCheckPermissionParam4 sets up expected param checkPermission for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectCheckPermissionParam4(checkPermission bool) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.checkPermission = &checkPermission

	return mmConvertPipelineToPB
}

// ExpectUseDynamicDefParam5 sets up expected param useDynamicDef for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectUseDynamicDefParam5(useDynamicDef bool) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.useDynamicDef = &useDynamicDef

	return mmConvertPipelineToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Inspect(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool)) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.inspectFuncConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineToPB")
	}

	mmConvertPipelineToPB.mock.inspectFuncConvertPipelineToPB = f

	return mmConvertPipelineToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Return(pp1 *pb.Pipeline, err error) *ConverterMock {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{mock: mmConvertPipelineToPB.mock}
	}
	mmConvertPipelineToPB.defaultExpectation.results = &ConverterMockConvertPipelineToPBResults{pp1, err}
	return mmConvertPipelineToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineToPB method
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Set(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) (pp1 *pb.Pipeline, err error)) *ConverterMock {
	if mmConvertPipelineToPB.defaultExpectation != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineToPB method")
	}

	if len(mmConvertPipelineToPB.expectations) > 0 {
		mmConvertPipelineToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineToPB method")
	}

	mmConvertPipelineToPB.mock.funcConvertPipelineToPB = f
	return mmConvertPipelineToPB.mock
}

// When sets expectation for the Converter.ConvertPipelineToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) When(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) *ConverterMockConvertPipelineToPBExpectation {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineToPBExpectation{
		mock:   mmConvertPipelineToPB.mock,
		params: &ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef},
	}
	mmConvertPipelineToPB.expectations = append(mmConvertPipelineToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineToPBExpectation) Then(pp1 *pb.Pipeline, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineToPBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineToPB should be invoked
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Times(n uint64) *mConverterMockConvertPipelineToPB {
	if n == 0 {
		mmConvertPipelineToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineToPB.expectedInvocations, n)
	return mmConvertPipelineToPB
}

func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) invocationsDone() bool {
	if len(mmConvertPipelineToPB.expectations) == 0 && mmConvertPipelineToPB.defaultExpectation == nil && mmConvertPipelineToPB.mock.funcConvertPipelineToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToPB.mock.afterConvertPipelineToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineToPB implements service.Converter
func (mmConvertPipelineToPB *ConverterMock) ConvertPipelineToPB(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) (pp1 *pb.Pipeline, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineToPB.beforeConvertPipelineToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineToPB.afterConvertPipelineToPBCounter, 1)

	if mmConvertPipelineToPB.inspectFuncConvertPipelineToPB != nil {
		mmConvertPipelineToPB.inspectFuncConvertPipelineToPB(ctx, dbPipeline, view, checkPermission, useDynamicDef)
	}

	mm_params := ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef}

	// Record call args
	mmConvertPipelineToPB.ConvertPipelineToPBMock.mutex.Lock()
	mmConvertPipelineToPB.ConvertPipelineToPBMock.callArgs = append(mmConvertPipelineToPB.ConvertPipelineToPBMock.callArgs, &mm_params)
	mmConvertPipelineToPB.ConvertPipelineToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineToPB.ConvertPipelineToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipeline != nil && !minimock.Equal(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter dbPipeline, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbPipeline, mm_got.dbPipeline, minimock.Diff(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter view, want: %#v, got: %#v%s\n", *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

			if mm_want_ptrs.checkPermission != nil && !minimock.Equal(*mm_want_ptrs.checkPermission, mm_got.checkPermission) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter checkPermission, want: %#v, got: %#v%s\n", *mm_want_ptrs.checkPermission, mm_got.checkPermission, minimock.Diff(*mm_want_ptrs.checkPermission, mm_got.checkPermission))
			}

			if mm_want_ptrs.useDynamicDef != nil && !minimock.Equal(*mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter useDynamicDef, want: %#v, got: %#v%s\n", *mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef, minimock.Diff(*mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineToPB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineToPB.funcConvertPipelineToPB != nil {
		return mmConvertPipelineToPB.funcConvertPipelineToPB(ctx, dbPipeline, view, checkPermission, useDynamicDef)
	}
	mmConvertPipelineToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineToPB. %v %v %v %v %v", ctx, dbPipeline, view, checkPermission, useDynamicDef)
	return
}

// ConvertPipelineToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelineToPB invocations
func (mmConvertPipelineToPB *ConverterMock) ConvertPipelineToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToPB.afterConvertPipelineToPBCounter)
}

// ConvertPipelineToPBBeforeCounter returns a count of ConverterMock.ConvertPipelineToPB invocations
func (mmConvertPipelineToPB *ConverterMock) ConvertPipelineToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToPB.beforeConvertPipelineToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Calls() []*ConverterMockConvertPipelineToPBParams {
	mmConvertPipelineToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineToPBParams, len(mmConvertPipelineToPB.callArgs))
	copy(argCopy, mmConvertPipelineToPB.callArgs)

	mmConvertPipelineToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineToPBDone returns true if the count of the ConvertPipelineToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineToPBDone() bool {
	if m.ConvertPipelineToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineToPBMock.invocationsDone()
}

// MinimockConvertPipelineToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineToPBInspect() {
	for _, e := range m.ConvertPipelineToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToPB with params: %#v", *e.params)
		}
	}

	afterConvertPipelineToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineToPBMock.defaultExpectation != nil && afterConvertPipelineToPBCounter < 1 {
		if m.ConvertPipelineToPBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertPipelineToPB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToPB with params: %#v", *m.ConvertPipelineToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineToPB != nil && afterConvertPipelineToPBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertPipelineToPB")
	}

	if !m.ConvertPipelineToPBMock.invocationsDone() && afterConvertPipelineToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineToPB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineToPBMock.expectedInvocations), afterConvertPipelineToPBCounter)
	}
}

type mConverterMockConvertPipelinesToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelinesToPBExpectation
	expectations       []*ConverterMockConvertPipelinesToPBExpectation

	callArgs []*ConverterMockConvertPipelinesToPBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertPipelinesToPBExpectation specifies expectation struct of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertPipelinesToPBParams
	paramPtrs *ConverterMockConvertPipelinesToPBParamPtrs
	results   *ConverterMockConvertPipelinesToPBResults
	Counter   uint64
}

// ConverterMockConvertPipelinesToPBParams contains parameters of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBParams struct {
	ctx             context.Context
	dbPipelines     []*datamodel.Pipeline
	view            pb.Pipeline_View
	checkPermission bool
}

// ConverterMockConvertPipelinesToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBParamPtrs struct {
	ctx             *context.Context
	dbPipelines     *[]*datamodel.Pipeline
	view            *pb.Pipeline_View
	checkPermission *bool
}

// ConverterMockConvertPipelinesToPBResults contains results of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBResults struct {
	ppa1 []*pb.Pipeline
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Optional() *mConverterMockConvertPipelinesToPB {
	mmConvertPipelinesToPB.optional = true
	return mmConvertPipelinesToPB
}

// Expect sets up expected params for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Expect(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelinesToPB.defaultExpectation.params = &ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission}
	for _, e := range mmConvertPipelinesToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelinesToPB.defaultExpectation.params) {
			mmConvertPipelinesToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelinesToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelinesToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertPipelinesToPB
}

// ExpectDbPipelinesParam2 sets up expected param dbPipelines for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectDbPipelinesParam2(dbPipelines []*datamodel.Pipeline) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.dbPipelines = &dbPipelines

	return mmConvertPipelinesToPB
}

// ExpectViewParam3 sets up expected param view for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectViewParam3(view pb.Pipeline_View) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.view = &view

	return mmConvertPipelinesToPB
}

// ExpectCheckPermissionParam4 sets up expected param checkPermission for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectCheckPermissionParam4(checkPermission bool) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.checkPermission = &checkPermission

	return mmConvertPipelinesToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Inspect(f func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool)) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.inspectFuncConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelinesToPB")
	}

	mmConvertPipelinesToPB.mock.inspectFuncConvertPipelinesToPB = f

	return mmConvertPipelinesToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Return(ppa1 []*pb.Pipeline, err error) *ConverterMock {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{mock: mmConvertPipelinesToPB.mock}
	}
	mmConvertPipelinesToPB.defaultExpectation.results = &ConverterMockConvertPipelinesToPBResults{ppa1, err}
	return mmConvertPipelinesToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelinesToPB method
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Set(f func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) (ppa1 []*pb.Pipeline, err error)) *ConverterMock {
	if mmConvertPipelinesToPB.defaultExpectation != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelinesToPB method")
	}

	if len(mmConvertPipelinesToPB.expectations) > 0 {
		mmConvertPipelinesToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelinesToPB method")
	}

	mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB = f
	return mmConvertPipelinesToPB.mock
}

// When sets expectation for the Converter.ConvertPipelinesToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) When(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) *ConverterMockConvertPipelinesToPBExpectation {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelinesToPBExpectation{
		mock:   mmConvertPipelinesToPB.mock,
		params: &ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission},
	}
	mmConvertPipelinesToPB.expectations = append(mmConvertPipelinesToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelinesToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelinesToPBExpectation) Then(ppa1 []*pb.Pipeline, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelinesToPBResults{ppa1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelinesToPB should be invoked
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Times(n uint64) *mConverterMockConvertPipelinesToPB {
	if n == 0 {
		mmConvertPipelinesToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelinesToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelinesToPB.expectedInvocations, n)
	return mmConvertPipelinesToPB
}

func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) invocationsDone() bool {
	if len(mmConvertPipelinesToPB.expectations) == 0 && mmConvertPipelinesToPB.defaultExpectation == nil && mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelinesToPB.mock.afterConvertPipelinesToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelinesToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelinesToPB implements service.Converter
func (mmConvertPipelinesToPB *ConverterMock) ConvertPipelinesToPB(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) (ppa1 []*pb.Pipeline, err error) {
	mm_atomic.AddUint64(&mmConvertPipelinesToPB.beforeConvertPipelinesToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelinesToPB.afterConvertPipelinesToPBCounter, 1)

	if mmConvertPipelinesToPB.inspectFuncConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.inspectFuncConvertPipelinesToPB(ctx, dbPipelines, view, checkPermission)
	}

	mm_params := ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission}

	// Record call args
	mmConvertPipelinesToPB.ConvertPipelinesToPBMock.mutex.Lock()
	mmConvertPipelinesToPB.ConvertPipelinesToPBMock.callArgs = append(mmConvertPipelinesToPB.ConvertPipelinesToPBMock.callArgs, &mm_params)
	mmConvertPipelinesToPB.ConvertPipelinesToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelinesToPB.ConvertPipelinesToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipelines != nil && !minimock.Equal(*mm_want_ptrs.dbPipelines, mm_got.dbPipelines) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter dbPipelines, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbPipelines, mm_got.dbPipelines, minimock.Diff(*mm_want_ptrs.dbPipelines, mm_got.dbPipelines))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter view, want: %#v, got: %#v%s\n", *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

			if mm_want_ptrs.checkPermission != nil && !minimock.Equal(*mm_want_ptrs.checkPermission, mm_got.checkPermission) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter checkPermission, want: %#v, got: %#v%s\n", *mm_want_ptrs.checkPermission, mm_got.checkPermission, minimock.Diff(*mm_want_ptrs.checkPermission, mm_got.checkPermission))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelinesToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelinesToPB")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmConvertPipelinesToPB.funcConvertPipelinesToPB != nil {
		return mmConvertPipelinesToPB.funcConvertPipelinesToPB(ctx, dbPipelines, view, checkPermission)
	}
	mmConvertPipelinesToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelinesToPB. %v %v %v %v", ctx, dbPipelines, view, checkPermission)
	return
}

// ConvertPipelinesToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelinesToPB invocations
func (mmConvertPipelinesToPB *ConverterMock) ConvertPipelinesToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelinesToPB.afterConvertPipelinesToPBCounter)
}

// ConvertPipelinesToPBBeforeCounter returns a count of ConverterMock.ConvertPipelinesToPB invocations
func (mmConvertPipelinesToPB *ConverterMock) ConvertPipelinesToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelinesToPB.beforeConvertPipelinesToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelinesToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Calls() []*ConverterMockConvertPipelinesToPBParams {
	mmConvertPipelinesToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelinesToPBParams, len(mmConvertPipelinesToPB.callArgs))
	copy(argCopy, mmConvertPipelinesToPB.callArgs)

	mmConvertPipelinesToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelinesToPBDone returns true if the count of the ConvertPipelinesToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelinesToPBDone() bool {
	if m.ConvertPipelinesToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelinesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelinesToPBMock.invocationsDone()
}

// MinimockConvertPipelinesToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelinesToPBInspect() {
	for _, e := range m.ConvertPipelinesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelinesToPB with params: %#v", *e.params)
		}
	}

	afterConvertPipelinesToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelinesToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelinesToPBMock.defaultExpectation != nil && afterConvertPipelinesToPBCounter < 1 {
		if m.ConvertPipelinesToPBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertPipelinesToPB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelinesToPB with params: %#v", *m.ConvertPipelinesToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelinesToPB != nil && afterConvertPipelinesToPBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertPipelinesToPB")
	}

	if !m.ConvertPipelinesToPBMock.invocationsDone() && afterConvertPipelinesToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelinesToPB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelinesToPBMock.expectedInvocations), afterConvertPipelinesToPBCounter)
	}
}

type mConverterMockConvertSecretToDB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertSecretToDBExpectation
	expectations       []*ConverterMockConvertSecretToDBExpectation

	callArgs []*ConverterMockConvertSecretToDBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertSecretToDBExpectation specifies expectation struct of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertSecretToDBParams
	paramPtrs *ConverterMockConvertSecretToDBParamPtrs
	results   *ConverterMockConvertSecretToDBResults
	Counter   uint64
}

// ConverterMockConvertSecretToDBParams contains parameters of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBParams struct {
	ctx      context.Context
	ns       resource.Namespace
	pbSecret *pb.Secret
}

// ConverterMockConvertSecretToDBParamPtrs contains pointers to parameters of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBParamPtrs struct {
	ctx      *context.Context
	ns       *resource.Namespace
	pbSecret **pb.Secret
}

// ConverterMockConvertSecretToDBResults contains results of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBResults struct {
	sp1 *datamodel.Secret
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Optional() *mConverterMockConvertSecretToDB {
	mmConvertSecretToDB.optional = true
	return mmConvertSecretToDB
}

// Expect sets up expected params for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Expect(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by ExpectParams functions")
	}

	mmConvertSecretToDB.defaultExpectation.params = &ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret}
	for _, e := range mmConvertSecretToDB.expectations {
		if minimock.Equal(e.params, mmConvertSecretToDB.defaultExpectation.params) {
			mmConvertSecretToDB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertSecretToDB.defaultExpectation.params)
		}
	}

	return mmConvertSecretToDB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.params != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Expect")
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToDB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToDBParamPtrs{}
	}
	mmConvertSecretToDB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertSecretToDB
}

// ExpectNsParam2 sets up expected param ns for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) ExpectNsParam2(ns resource.Namespace) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.params != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Expect")
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToDB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToDBParamPtrs{}
	}
	mmConvertSecretToDB.defaultExpectation.paramPtrs.ns = &ns

	return mmConvertSecretToDB
}

// ExpectPbSecretParam3 sets up expected param pbSecret for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) ExpectPbSecretParam3(pbSecret *pb.Secret) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.params != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Expect")
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToDB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToDBParamPtrs{}
	}
	mmConvertSecretToDB.defaultExpectation.paramPtrs.pbSecret = &pbSecret

	return mmConvertSecretToDB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Inspect(f func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret)) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.inspectFuncConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertSecretToDB")
	}

	mmConvertSecretToDB.mock.inspectFuncConvertSecretToDB = f

	return mmConvertSecretToDB
}

// Return sets up results that will be returned by Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Return(sp1 *datamodel.Secret, err error) *ConverterMock {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{mock: mmConvertSecretToDB.mock}
	}
	mmConvertSecretToDB.defaultExpectation.results = &ConverterMockConvertSecretToDBResults{sp1, err}
	return mmConvertSecretToDB.mock
}

// Set uses given function f to mock the Converter.ConvertSecretToDB method
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Set(f func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) (sp1 *datamodel.Secret, err error)) *ConverterMock {
	if mmConvertSecretToDB.defaultExpectation != nil {
		mmConvertSecretToDB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertSecretToDB method")
	}

	if len(mmConvertSecretToDB.expectations) > 0 {
		mmConvertSecretToDB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertSecretToDB method")
	}

	mmConvertSecretToDB.mock.funcConvertSecretToDB = f
	return mmConvertSecretToDB.mock
}

// When sets expectation for the Converter.ConvertSecretToDB which will trigger the result defined by the following
// Then helper
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) When(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) *ConverterMockConvertSecretToDBExpectation {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	expectation := &ConverterMockConvertSecretToDBExpectation{
		mock:   mmConvertSecretToDB.mock,
		params: &ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret},
	}
	mmConvertSecretToDB.expectations = append(mmConvertSecretToDB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertSecretToDB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertSecretToDBExpectation) Then(sp1 *datamodel.Secret, err error) *ConverterMock {
	e.results = &ConverterMockConvertSecretToDBResults{sp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertSecretToDB should be invoked
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Times(n uint64) *mConverterMockConvertSecretToDB {
	if n == 0 {
		mmConvertSecretToDB.mock.t.Fatalf("Times of ConverterMock.ConvertSecretToDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertSecretToDB.expectedInvocations, n)
	return mmConvertSecretToDB
}

func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) invocationsDone() bool {
	if len(mmConvertSecretToDB.expectations) == 0 && mmConvertSecretToDB.defaultExpectation == nil && mmConvertSecretToDB.mock.funcConvertSecretToDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertSecretToDB.mock.afterConvertSecretToDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertSecretToDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertSecretToDB implements service.Converter
func (mmConvertSecretToDB *ConverterMock) ConvertSecretToDB(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) (sp1 *datamodel.Secret, err error) {
	mm_atomic.AddUint64(&mmConvertSecretToDB.beforeConvertSecretToDBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertSecretToDB.afterConvertSecretToDBCounter, 1)

	if mmConvertSecretToDB.inspectFuncConvertSecretToDB != nil {
		mmConvertSecretToDB.inspectFuncConvertSecretToDB(ctx, ns, pbSecret)
	}

	mm_params := ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret}

	// Record call args
	mmConvertSecretToDB.ConvertSecretToDBMock.mutex.Lock()
	mmConvertSecretToDB.ConvertSecretToDBMock.callArgs = append(mmConvertSecretToDB.ConvertSecretToDBMock.callArgs, &mm_params)
	mmConvertSecretToDB.ConvertSecretToDBMock.mutex.Unlock()

	for _, e := range mmConvertSecretToDB.ConvertSecretToDBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ns != nil && !minimock.Equal(*mm_want_ptrs.ns, mm_got.ns) {
				mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameter ns, want: %#v, got: %#v%s\n", *mm_want_ptrs.ns, mm_got.ns, minimock.Diff(*mm_want_ptrs.ns, mm_got.ns))
			}

			if mm_want_ptrs.pbSecret != nil && !minimock.Equal(*mm_want_ptrs.pbSecret, mm_got.pbSecret) {
				mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameter pbSecret, want: %#v, got: %#v%s\n", *mm_want_ptrs.pbSecret, mm_got.pbSecret, minimock.Diff(*mm_want_ptrs.pbSecret, mm_got.pbSecret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertSecretToDB.t.Fatal("No results are set for the ConverterMock.ConvertSecretToDB")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmConvertSecretToDB.funcConvertSecretToDB != nil {
		return mmConvertSecretToDB.funcConvertSecretToDB(ctx, ns, pbSecret)
	}
	mmConvertSecretToDB.t.Fatalf("Unexpected call to ConverterMock.ConvertSecretToDB. %v %v %v", ctx, ns, pbSecret)
	return
}

// ConvertSecretToDBAfterCounter returns a count of finished ConverterMock.ConvertSecretToDB invocations
func (mmConvertSecretToDB *ConverterMock) ConvertSecretToDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToDB.afterConvertSecretToDBCounter)
}

// ConvertSecretToDBBeforeCounter returns a count of ConverterMock.ConvertSecretToDB invocations
func (mmConvertSecretToDB *ConverterMock) ConvertSecretToDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToDB.beforeConvertSecretToDBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertSecretToDB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Calls() []*ConverterMockConvertSecretToDBParams {
	mmConvertSecretToDB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertSecretToDBParams, len(mmConvertSecretToDB.callArgs))
	copy(argCopy, mmConvertSecretToDB.callArgs)

	mmConvertSecretToDB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertSecretToDBDone returns true if the count of the ConvertSecretToDB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertSecretToDBDone() bool {
	if m.ConvertSecretToDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertSecretToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertSecretToDBMock.invocationsDone()
}

// MinimockConvertSecretToDBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertSecretToDBInspect() {
	for _, e := range m.ConvertSecretToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToDB with params: %#v", *e.params)
		}
	}

	afterConvertSecretToDBCounter := mm_atomic.LoadUint64(&m.afterConvertSecretToDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSecretToDBMock.defaultExpectation != nil && afterConvertSecretToDBCounter < 1 {
		if m.ConvertSecretToDBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertSecretToDB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToDB with params: %#v", *m.ConvertSecretToDBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSecretToDB != nil && afterConvertSecretToDBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertSecretToDB")
	}

	if !m.ConvertSecretToDBMock.invocationsDone() && afterConvertSecretToDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertSecretToDB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertSecretToDBMock.expectedInvocations), afterConvertSecretToDBCounter)
	}
}

type mConverterMockConvertSecretToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertSecretToPBExpectation
	expectations       []*ConverterMockConvertSecretToPBExpectation

	callArgs []*ConverterMockConvertSecretToPBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertSecretToPBExpectation specifies expectation struct of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertSecretToPBParams
	paramPtrs *ConverterMockConvertSecretToPBParamPtrs
	results   *ConverterMockConvertSecretToPBResults
	Counter   uint64
}

// ConverterMockConvertSecretToPBParams contains parameters of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBParams struct {
	ctx      context.Context
	dbSecret *datamodel.Secret
}

// ConverterMockConvertSecretToPBParamPtrs contains pointers to parameters of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBParamPtrs struct {
	ctx      *context.Context
	dbSecret **datamodel.Secret
}

// ConverterMockConvertSecretToPBResults contains results of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBResults struct {
	sp1 *pb.Secret
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Optional() *mConverterMockConvertSecretToPB {
	mmConvertSecretToPB.optional = true
	return mmConvertSecretToPB
}

// Expect sets up expected params for Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Expect(ctx context.Context, dbSecret *datamodel.Secret) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{}
	}

	if mmConvertSecretToPB.defaultExpectation.paramPtrs != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by ExpectParams functions")
	}

	mmConvertSecretToPB.defaultExpectation.params = &ConverterMockConvertSecretToPBParams{ctx, dbSecret}
	for _, e := range mmConvertSecretToPB.expectations {
		if minimock.Equal(e.params, mmConvertSecretToPB.defaultExpectation.params) {
			mmConvertSecretToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertSecretToPB.defaultExpectation.params)
		}
	}

	return mmConvertSecretToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{}
	}

	if mmConvertSecretToPB.defaultExpectation.params != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Expect")
	}

	if mmConvertSecretToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToPBParamPtrs{}
	}
	mmConvertSecretToPB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertSecretToPB
}

// ExpectDbSecretParam2 sets up expected param dbSecret for Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) ExpectDbSecretParam2(dbSecret *datamodel.Secret) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{}
	}

	if mmConvertSecretToPB.defaultExpectation.params != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Expect")
	}

	if mmConvertSecretToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToPBParamPtrs{}
	}
	mmConvertSecretToPB.defaultExpectation.paramPtrs.dbSecret = &dbSecret

	return mmConvertSecretToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Inspect(f func(ctx context.Context, dbSecret *datamodel.Secret)) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.inspectFuncConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertSecretToPB")
	}

	mmConvertSecretToPB.mock.inspectFuncConvertSecretToPB = f

	return mmConvertSecretToPB
}

// Return sets up results that will be returned by Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Return(sp1 *pb.Secret, err error) *ConverterMock {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{mock: mmConvertSecretToPB.mock}
	}
	mmConvertSecretToPB.defaultExpectation.results = &ConverterMockConvertSecretToPBResults{sp1, err}
	return mmConvertSecretToPB.mock
}

// Set uses given function f to mock the Converter.ConvertSecretToPB method
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Set(f func(ctx context.Context, dbSecret *datamodel.Secret) (sp1 *pb.Secret, err error)) *ConverterMock {
	if mmConvertSecretToPB.defaultExpectation != nil {
		mmConvertSecretToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertSecretToPB method")
	}

	if len(mmConvertSecretToPB.expectations) > 0 {
		mmConvertSecretToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertSecretToPB method")
	}

	mmConvertSecretToPB.mock.funcConvertSecretToPB = f
	return mmConvertSecretToPB.mock
}

// When sets expectation for the Converter.ConvertSecretToPB which will trigger the result defined by the following
// Then helper
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) When(ctx context.Context, dbSecret *datamodel.Secret) *ConverterMockConvertSecretToPBExpectation {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertSecretToPBExpectation{
		mock:   mmConvertSecretToPB.mock,
		params: &ConverterMockConvertSecretToPBParams{ctx, dbSecret},
	}
	mmConvertSecretToPB.expectations = append(mmConvertSecretToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertSecretToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertSecretToPBExpectation) Then(sp1 *pb.Secret, err error) *ConverterMock {
	e.results = &ConverterMockConvertSecretToPBResults{sp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertSecretToPB should be invoked
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Times(n uint64) *mConverterMockConvertSecretToPB {
	if n == 0 {
		mmConvertSecretToPB.mock.t.Fatalf("Times of ConverterMock.ConvertSecretToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertSecretToPB.expectedInvocations, n)
	return mmConvertSecretToPB
}

func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) invocationsDone() bool {
	if len(mmConvertSecretToPB.expectations) == 0 && mmConvertSecretToPB.defaultExpectation == nil && mmConvertSecretToPB.mock.funcConvertSecretToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertSecretToPB.mock.afterConvertSecretToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertSecretToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertSecretToPB implements service.Converter
func (mmConvertSecretToPB *ConverterMock) ConvertSecretToPB(ctx context.Context, dbSecret *datamodel.Secret) (sp1 *pb.Secret, err error) {
	mm_atomic.AddUint64(&mmConvertSecretToPB.beforeConvertSecretToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertSecretToPB.afterConvertSecretToPBCounter, 1)

	if mmConvertSecretToPB.inspectFuncConvertSecretToPB != nil {
		mmConvertSecretToPB.inspectFuncConvertSecretToPB(ctx, dbSecret)
	}

	mm_params := ConverterMockConvertSecretToPBParams{ctx, dbSecret}

	// Record call args
	mmConvertSecretToPB.ConvertSecretToPBMock.mutex.Lock()
	mmConvertSecretToPB.ConvertSecretToPBMock.callArgs = append(mmConvertSecretToPB.ConvertSecretToPBMock.callArgs, &mm_params)
	mmConvertSecretToPB.ConvertSecretToPBMock.mutex.Unlock()

	for _, e := range mmConvertSecretToPB.ConvertSecretToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertSecretToPBParams{ctx, dbSecret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertSecretToPB.t.Errorf("ConverterMock.ConvertSecretToPB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbSecret != nil && !minimock.Equal(*mm_want_ptrs.dbSecret, mm_got.dbSecret) {
				mmConvertSecretToPB.t.Errorf("ConverterMock.ConvertSecretToPB got unexpected parameter dbSecret, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbSecret, mm_got.dbSecret, minimock.Diff(*mm_want_ptrs.dbSecret, mm_got.dbSecret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertSecretToPB.t.Errorf("ConverterMock.ConvertSecretToPB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertSecretToPB.t.Fatal("No results are set for the ConverterMock.ConvertSecretToPB")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmConvertSecretToPB.funcConvertSecretToPB != nil {
		return mmConvertSecretToPB.funcConvertSecretToPB(ctx, dbSecret)
	}
	mmConvertSecretToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertSecretToPB. %v %v", ctx, dbSecret)
	return
}

// ConvertSecretToPBAfterCounter returns a count of finished ConverterMock.ConvertSecretToPB invocations
func (mmConvertSecretToPB *ConverterMock) ConvertSecretToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToPB.afterConvertSecretToPBCounter)
}

// ConvertSecretToPBBeforeCounter returns a count of ConverterMock.ConvertSecretToPB invocations
func (mmConvertSecretToPB *ConverterMock) ConvertSecretToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToPB.beforeConvertSecretToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertSecretToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Calls() []*ConverterMockConvertSecretToPBParams {
	mmConvertSecretToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertSecretToPBParams, len(mmConvertSecretToPB.callArgs))
	copy(argCopy, mmConvertSecretToPB.callArgs)

	mmConvertSecretToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertSecretToPBDone returns true if the count of the ConvertSecretToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertSecretToPBDone() bool {
	if m.ConvertSecretToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertSecretToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertSecretToPBMock.invocationsDone()
}

// MinimockConvertSecretToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertSecretToPBInspect() {
	for _, e := range m.ConvertSecretToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToPB with params: %#v", *e.params)
		}
	}

	afterConvertSecretToPBCounter := mm_atomic.LoadUint64(&m.afterConvertSecretToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSecretToPBMock.defaultExpectation != nil && afterConvertSecretToPBCounter < 1 {
		if m.ConvertSecretToPBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertSecretToPB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToPB with params: %#v", *m.ConvertSecretToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSecretToPB != nil && afterConvertSecretToPBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertSecretToPB")
	}

	if !m.ConvertSecretToPBMock.invocationsDone() && afterConvertSecretToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertSecretToPB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertSecretToPBMock.expectedInvocations), afterConvertSecretToPBCounter)
	}
}

type mConverterMockConvertSecretsToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertSecretsToPBExpectation
	expectations       []*ConverterMockConvertSecretsToPBExpectation

	callArgs []*ConverterMockConvertSecretsToPBParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ConverterMockConvertSecretsToPBExpectation specifies expectation struct of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBExpectation struct {
	mock      *ConverterMock
	params    *ConverterMockConvertSecretsToPBParams
	paramPtrs *ConverterMockConvertSecretsToPBParamPtrs
	results   *ConverterMockConvertSecretsToPBResults
	Counter   uint64
}

// ConverterMockConvertSecretsToPBParams contains parameters of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBParams struct {
	ctx       context.Context
	dbSecrets []*datamodel.Secret
}

// ConverterMockConvertSecretsToPBParamPtrs contains pointers to parameters of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBParamPtrs struct {
	ctx       *context.Context
	dbSecrets *[]*datamodel.Secret
}

// ConverterMockConvertSecretsToPBResults contains results of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBResults struct {
	spa1 []*pb.Secret
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Optional() *mConverterMockConvertSecretsToPB {
	mmConvertSecretsToPB.optional = true
	return mmConvertSecretsToPB
}

// Expect sets up expected params for Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Expect(ctx context.Context, dbSecrets []*datamodel.Secret) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{}
	}

	if mmConvertSecretsToPB.defaultExpectation.paramPtrs != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by ExpectParams functions")
	}

	mmConvertSecretsToPB.defaultExpectation.params = &ConverterMockConvertSecretsToPBParams{ctx, dbSecrets}
	for _, e := range mmConvertSecretsToPB.expectations {
		if minimock.Equal(e.params, mmConvertSecretsToPB.defaultExpectation.params) {
			mmConvertSecretsToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertSecretsToPB.defaultExpectation.params)
		}
	}

	return mmConvertSecretsToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{}
	}

	if mmConvertSecretsToPB.defaultExpectation.params != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Expect")
	}

	if mmConvertSecretsToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretsToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretsToPBParamPtrs{}
	}
	mmConvertSecretsToPB.defaultExpectation.paramPtrs.ctx = &ctx

	return mmConvertSecretsToPB
}

// ExpectDbSecretsParam2 sets up expected param dbSecrets for Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) ExpectDbSecretsParam2(dbSecrets []*datamodel.Secret) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{}
	}

	if mmConvertSecretsToPB.defaultExpectation.params != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Expect")
	}

	if mmConvertSecretsToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretsToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretsToPBParamPtrs{}
	}
	mmConvertSecretsToPB.defaultExpectation.paramPtrs.dbSecrets = &dbSecrets

	return mmConvertSecretsToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Inspect(f func(ctx context.Context, dbSecrets []*datamodel.Secret)) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.inspectFuncConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertSecretsToPB")
	}

	mmConvertSecretsToPB.mock.inspectFuncConvertSecretsToPB = f

	return mmConvertSecretsToPB
}

// Return sets up results that will be returned by Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Return(spa1 []*pb.Secret, err error) *ConverterMock {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{mock: mmConvertSecretsToPB.mock}
	}
	mmConvertSecretsToPB.defaultExpectation.results = &ConverterMockConvertSecretsToPBResults{spa1, err}
	return mmConvertSecretsToPB.mock
}

// Set uses given function f to mock the Converter.ConvertSecretsToPB method
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Set(f func(ctx context.Context, dbSecrets []*datamodel.Secret) (spa1 []*pb.Secret, err error)) *ConverterMock {
	if mmConvertSecretsToPB.defaultExpectation != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertSecretsToPB method")
	}

	if len(mmConvertSecretsToPB.expectations) > 0 {
		mmConvertSecretsToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertSecretsToPB method")
	}

	mmConvertSecretsToPB.mock.funcConvertSecretsToPB = f
	return mmConvertSecretsToPB.mock
}

// When sets expectation for the Converter.ConvertSecretsToPB which will trigger the result defined by the following
// Then helper
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) When(ctx context.Context, dbSecrets []*datamodel.Secret) *ConverterMockConvertSecretsToPBExpectation {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertSecretsToPBExpectation{
		mock:   mmConvertSecretsToPB.mock,
		params: &ConverterMockConvertSecretsToPBParams{ctx, dbSecrets},
	}
	mmConvertSecretsToPB.expectations = append(mmConvertSecretsToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertSecretsToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertSecretsToPBExpectation) Then(spa1 []*pb.Secret, err error) *ConverterMock {
	e.results = &ConverterMockConvertSecretsToPBResults{spa1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertSecretsToPB should be invoked
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Times(n uint64) *mConverterMockConvertSecretsToPB {
	if n == 0 {
		mmConvertSecretsToPB.mock.t.Fatalf("Times of ConverterMock.ConvertSecretsToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertSecretsToPB.expectedInvocations, n)
	return mmConvertSecretsToPB
}

func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) invocationsDone() bool {
	if len(mmConvertSecretsToPB.expectations) == 0 && mmConvertSecretsToPB.defaultExpectation == nil && mmConvertSecretsToPB.mock.funcConvertSecretsToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertSecretsToPB.mock.afterConvertSecretsToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertSecretsToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertSecretsToPB implements service.Converter
func (mmConvertSecretsToPB *ConverterMock) ConvertSecretsToPB(ctx context.Context, dbSecrets []*datamodel.Secret) (spa1 []*pb.Secret, err error) {
	mm_atomic.AddUint64(&mmConvertSecretsToPB.beforeConvertSecretsToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertSecretsToPB.afterConvertSecretsToPBCounter, 1)

	if mmConvertSecretsToPB.inspectFuncConvertSecretsToPB != nil {
		mmConvertSecretsToPB.inspectFuncConvertSecretsToPB(ctx, dbSecrets)
	}

	mm_params := ConverterMockConvertSecretsToPBParams{ctx, dbSecrets}

	// Record call args
	mmConvertSecretsToPB.ConvertSecretsToPBMock.mutex.Lock()
	mmConvertSecretsToPB.ConvertSecretsToPBMock.callArgs = append(mmConvertSecretsToPB.ConvertSecretsToPBMock.callArgs, &mm_params)
	mmConvertSecretsToPB.ConvertSecretsToPBMock.mutex.Unlock()

	for _, e := range mmConvertSecretsToPB.ConvertSecretsToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.err
		}
	}

	if mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertSecretsToPBParams{ctx, dbSecrets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertSecretsToPB.t.Errorf("ConverterMock.ConvertSecretsToPB got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbSecrets != nil && !minimock.Equal(*mm_want_ptrs.dbSecrets, mm_got.dbSecrets) {
				mmConvertSecretsToPB.t.Errorf("ConverterMock.ConvertSecretsToPB got unexpected parameter dbSecrets, want: %#v, got: %#v%s\n", *mm_want_ptrs.dbSecrets, mm_got.dbSecrets, minimock.Diff(*mm_want_ptrs.dbSecrets, mm_got.dbSecrets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertSecretsToPB.t.Errorf("ConverterMock.ConvertSecretsToPB got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertSecretsToPB.t.Fatal("No results are set for the ConverterMock.ConvertSecretsToPB")
		}
		return (*mm_results).spa1, (*mm_results).err
	}
	if mmConvertSecretsToPB.funcConvertSecretsToPB != nil {
		return mmConvertSecretsToPB.funcConvertSecretsToPB(ctx, dbSecrets)
	}
	mmConvertSecretsToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertSecretsToPB. %v %v", ctx, dbSecrets)
	return
}

// ConvertSecretsToPBAfterCounter returns a count of finished ConverterMock.ConvertSecretsToPB invocations
func (mmConvertSecretsToPB *ConverterMock) ConvertSecretsToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretsToPB.afterConvertSecretsToPBCounter)
}

// ConvertSecretsToPBBeforeCounter returns a count of ConverterMock.ConvertSecretsToPB invocations
func (mmConvertSecretsToPB *ConverterMock) ConvertSecretsToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretsToPB.beforeConvertSecretsToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertSecretsToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Calls() []*ConverterMockConvertSecretsToPBParams {
	mmConvertSecretsToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertSecretsToPBParams, len(mmConvertSecretsToPB.callArgs))
	copy(argCopy, mmConvertSecretsToPB.callArgs)

	mmConvertSecretsToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertSecretsToPBDone returns true if the count of the ConvertSecretsToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertSecretsToPBDone() bool {
	if m.ConvertSecretsToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertSecretsToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertSecretsToPBMock.invocationsDone()
}

// MinimockConvertSecretsToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertSecretsToPBInspect() {
	for _, e := range m.ConvertSecretsToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretsToPB with params: %#v", *e.params)
		}
	}

	afterConvertSecretsToPBCounter := mm_atomic.LoadUint64(&m.afterConvertSecretsToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSecretsToPBMock.defaultExpectation != nil && afterConvertSecretsToPBCounter < 1 {
		if m.ConvertSecretsToPBMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ConverterMock.ConvertSecretsToPB")
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretsToPB with params: %#v", *m.ConvertSecretsToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSecretsToPB != nil && afterConvertSecretsToPBCounter < 1 {
		m.t.Error("Expected call to ConverterMock.ConvertSecretsToPB")
	}

	if !m.ConvertSecretsToPBMock.invocationsDone() && afterConvertSecretsToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertSecretsToPB but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertSecretsToPBMock.expectedInvocations), afterConvertSecretsToPBCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConverterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConvertOwnerNameToPermalinkInspect()

			m.MinimockConvertOwnerPermalinkToNameInspect()

			m.MinimockConvertPipelineReleaseToDBInspect()

			m.MinimockConvertPipelineReleaseToPBInspect()

			m.MinimockConvertPipelineReleasesToPBInspect()

			m.MinimockConvertPipelineToDBInspect()

			m.MinimockConvertPipelineToPBInspect()

			m.MinimockConvertPipelinesToPBInspect()

			m.MinimockConvertSecretToDBInspect()

			m.MinimockConvertSecretToPBInspect()

			m.MinimockConvertSecretsToPBInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConverterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConverterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConvertOwnerNameToPermalinkDone() &&
		m.MinimockConvertOwnerPermalinkToNameDone() &&
		m.MinimockConvertPipelineReleaseToDBDone() &&
		m.MinimockConvertPipelineReleaseToPBDone() &&
		m.MinimockConvertPipelineReleasesToPBDone() &&
		m.MinimockConvertPipelineToDBDone() &&
		m.MinimockConvertPipelineToPBDone() &&
		m.MinimockConvertPipelinesToPBDone() &&
		m.MinimockConvertSecretToDBDone() &&
		m.MinimockConvertSecretToPBDone() &&
		m.MinimockConvertSecretsToPBDone()
}
