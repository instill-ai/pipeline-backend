// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"context"
	"sync"

	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"

	"github.com/instill-ai/pipeline-backend/pkg/datamodel"
	"github.com/instill-ai/pipeline-backend/pkg/resource"

	pb "github.com/instill-ai/protogen-go/vdp/pipeline/v1beta"
)

// ConverterMock implements mm_service.Converter
type ConverterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConvertPipelineReleaseToDB          func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) (pp1 *datamodel.PipelineRelease, err error)
	funcConvertPipelineReleaseToDBOrigin    string
	inspectFuncConvertPipelineReleaseToDB   func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease)
	afterConvertPipelineReleaseToDBCounter  uint64
	beforeConvertPipelineReleaseToDBCounter uint64
	ConvertPipelineReleaseToDBMock          mConverterMockConvertPipelineReleaseToDB

	funcConvertPipelineReleaseToPB          func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) (pp1 *pb.PipelineRelease, err error)
	funcConvertPipelineReleaseToPBOrigin    string
	inspectFuncConvertPipelineReleaseToPB   func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View)
	afterConvertPipelineReleaseToPBCounter  uint64
	beforeConvertPipelineReleaseToPBCounter uint64
	ConvertPipelineReleaseToPBMock          mConverterMockConvertPipelineReleaseToPB

	funcConvertPipelineReleasesToPB          func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) (ppa1 []*pb.PipelineRelease, err error)
	funcConvertPipelineReleasesToPBOrigin    string
	inspectFuncConvertPipelineReleasesToPB   func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View)
	afterConvertPipelineReleasesToPBCounter  uint64
	beforeConvertPipelineReleasesToPBCounter uint64
	ConvertPipelineReleasesToPBMock          mConverterMockConvertPipelineReleasesToPB

	funcConvertPipelineToDB          func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) (pp1 *datamodel.Pipeline, err error)
	funcConvertPipelineToDBOrigin    string
	inspectFuncConvertPipelineToDB   func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline)
	afterConvertPipelineToDBCounter  uint64
	beforeConvertPipelineToDBCounter uint64
	ConvertPipelineToDBMock          mConverterMockConvertPipelineToDB

	funcConvertPipelineToPB          func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) (pp1 *pb.Pipeline, err error)
	funcConvertPipelineToPBOrigin    string
	inspectFuncConvertPipelineToPB   func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool)
	afterConvertPipelineToPBCounter  uint64
	beforeConvertPipelineToPBCounter uint64
	ConvertPipelineToPBMock          mConverterMockConvertPipelineToPB

	funcConvertPipelinesToPB          func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) (ppa1 []*pb.Pipeline, err error)
	funcConvertPipelinesToPBOrigin    string
	inspectFuncConvertPipelinesToPB   func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool)
	afterConvertPipelinesToPBCounter  uint64
	beforeConvertPipelinesToPBCounter uint64
	ConvertPipelinesToPBMock          mConverterMockConvertPipelinesToPB

	funcConvertSecretToDB          func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) (sp1 *datamodel.Secret, err error)
	funcConvertSecretToDBOrigin    string
	inspectFuncConvertSecretToDB   func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret)
	afterConvertSecretToDBCounter  uint64
	beforeConvertSecretToDBCounter uint64
	ConvertSecretToDBMock          mConverterMockConvertSecretToDB

	funcConvertSecretToPB          func(ctx context.Context, dbSecret *datamodel.Secret) (sp1 *pb.Secret, err error)
	funcConvertSecretToPBOrigin    string
	inspectFuncConvertSecretToPB   func(ctx context.Context, dbSecret *datamodel.Secret)
	afterConvertSecretToPBCounter  uint64
	beforeConvertSecretToPBCounter uint64
	ConvertSecretToPBMock          mConverterMockConvertSecretToPB

	funcConvertSecretsToPB          func(ctx context.Context, dbSecrets []*datamodel.Secret) (spa1 []*pb.Secret, err error)
	funcConvertSecretsToPBOrigin    string
	inspectFuncConvertSecretsToPB   func(ctx context.Context, dbSecrets []*datamodel.Secret)
	afterConvertSecretsToPBCounter  uint64
	beforeConvertSecretsToPBCounter uint64
	ConvertSecretsToPBMock          mConverterMockConvertSecretsToPB

	funcGeneratePipelineDataSpec          func(variables map[string]*datamodel.Variable, outputs map[string]*datamodel.Output, compsOrigin datamodel.ComponentMap) (dp1 *pb.DataSpecification, err error)
	funcGeneratePipelineDataSpecOrigin    string
	inspectFuncGeneratePipelineDataSpec   func(variables map[string]*datamodel.Variable, outputs map[string]*datamodel.Output, compsOrigin datamodel.ComponentMap)
	afterGeneratePipelineDataSpecCounter  uint64
	beforeGeneratePipelineDataSpecCounter uint64
	GeneratePipelineDataSpecMock          mConverterMockGeneratePipelineDataSpec

	funcIncludeDetailInRecipe          func(ctx context.Context, ownerPermalink string, recipe *datamodel.Recipe, useDynamicDef bool) (err error)
	funcIncludeDetailInRecipeOrigin    string
	inspectFuncIncludeDetailInRecipe   func(ctx context.Context, ownerPermalink string, recipe *datamodel.Recipe, useDynamicDef bool)
	afterIncludeDetailInRecipeCounter  uint64
	beforeIncludeDetailInRecipeCounter uint64
	IncludeDetailInRecipeMock          mConverterMockIncludeDetailInRecipe
}

// NewConverterMock returns a mock for mm_service.Converter
func NewConverterMock(t minimock.Tester) *ConverterMock {
	m := &ConverterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConvertPipelineReleaseToDBMock = mConverterMockConvertPipelineReleaseToDB{mock: m}
	m.ConvertPipelineReleaseToDBMock.callArgs = []*ConverterMockConvertPipelineReleaseToDBParams{}

	m.ConvertPipelineReleaseToPBMock = mConverterMockConvertPipelineReleaseToPB{mock: m}
	m.ConvertPipelineReleaseToPBMock.callArgs = []*ConverterMockConvertPipelineReleaseToPBParams{}

	m.ConvertPipelineReleasesToPBMock = mConverterMockConvertPipelineReleasesToPB{mock: m}
	m.ConvertPipelineReleasesToPBMock.callArgs = []*ConverterMockConvertPipelineReleasesToPBParams{}

	m.ConvertPipelineToDBMock = mConverterMockConvertPipelineToDB{mock: m}
	m.ConvertPipelineToDBMock.callArgs = []*ConverterMockConvertPipelineToDBParams{}

	m.ConvertPipelineToPBMock = mConverterMockConvertPipelineToPB{mock: m}
	m.ConvertPipelineToPBMock.callArgs = []*ConverterMockConvertPipelineToPBParams{}

	m.ConvertPipelinesToPBMock = mConverterMockConvertPipelinesToPB{mock: m}
	m.ConvertPipelinesToPBMock.callArgs = []*ConverterMockConvertPipelinesToPBParams{}

	m.ConvertSecretToDBMock = mConverterMockConvertSecretToDB{mock: m}
	m.ConvertSecretToDBMock.callArgs = []*ConverterMockConvertSecretToDBParams{}

	m.ConvertSecretToPBMock = mConverterMockConvertSecretToPB{mock: m}
	m.ConvertSecretToPBMock.callArgs = []*ConverterMockConvertSecretToPBParams{}

	m.ConvertSecretsToPBMock = mConverterMockConvertSecretsToPB{mock: m}
	m.ConvertSecretsToPBMock.callArgs = []*ConverterMockConvertSecretsToPBParams{}

	m.GeneratePipelineDataSpecMock = mConverterMockGeneratePipelineDataSpec{mock: m}
	m.GeneratePipelineDataSpecMock.callArgs = []*ConverterMockGeneratePipelineDataSpecParams{}

	m.IncludeDetailInRecipeMock = mConverterMockIncludeDetailInRecipe{mock: m}
	m.IncludeDetailInRecipeMock.callArgs = []*ConverterMockIncludeDetailInRecipeParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConverterMockConvertPipelineReleaseToDB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineReleaseToDBExpectation
	expectations       []*ConverterMockConvertPipelineReleaseToDBExpectation

	callArgs []*ConverterMockConvertPipelineReleaseToDBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertPipelineReleaseToDBExpectation specifies expectation struct of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertPipelineReleaseToDBParams
	paramPtrs          *ConverterMockConvertPipelineReleaseToDBParamPtrs
	expectationOrigins ConverterMockConvertPipelineReleaseToDBExpectationOrigins
	results            *ConverterMockConvertPipelineReleaseToDBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertPipelineReleaseToDBParams contains parameters of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBParams struct {
	ctx               context.Context
	pipelineUID       uuid.UUID
	pbPipelineRelease *pb.PipelineRelease
}

// ConverterMockConvertPipelineReleaseToDBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBParamPtrs struct {
	ctx               *context.Context
	pipelineUID       *uuid.UUID
	pbPipelineRelease **pb.PipelineRelease
}

// ConverterMockConvertPipelineReleaseToDBResults contains results of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBResults struct {
	pp1 *datamodel.PipelineRelease
	err error
}

// ConverterMockConvertPipelineReleaseToDBOrigins contains origins of expectations of the Converter.ConvertPipelineReleaseToDB
type ConverterMockConvertPipelineReleaseToDBExpectationOrigins struct {
	origin                  string
	originCtx               string
	originPipelineUID       string
	originPbPipelineRelease string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Optional() *mConverterMockConvertPipelineReleaseToDB {
	mmConvertPipelineReleaseToDB.optional = true
	return mmConvertPipelineReleaseToDB
}

// Expect sets up expected params for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Expect(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineReleaseToDB.defaultExpectation.params = &ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease}
	mmConvertPipelineReleaseToDB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertPipelineReleaseToDB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineReleaseToDB.defaultExpectation.params) {
			mmConvertPipelineReleaseToDB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineReleaseToDB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineReleaseToDB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToDBParamPtrs{}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertPipelineReleaseToDB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertPipelineReleaseToDB
}

// ExpectPipelineUIDParam2 sets up expected param pipelineUID for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) ExpectPipelineUIDParam2(pipelineUID uuid.UUID) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToDBParamPtrs{}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs.pipelineUID = &pipelineUID
	mmConvertPipelineReleaseToDB.defaultExpectation.expectationOrigins.originPipelineUID = minimock.CallerInfo(1)

	return mmConvertPipelineReleaseToDB
}

// ExpectPbPipelineReleaseParam3 sets up expected param pbPipelineRelease for Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) ExpectPbPipelineReleaseParam3(pbPipelineRelease *pb.PipelineRelease) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{}
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToDBParamPtrs{}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.paramPtrs.pbPipelineRelease = &pbPipelineRelease
	mmConvertPipelineReleaseToDB.defaultExpectation.expectationOrigins.originPbPipelineRelease = minimock.CallerInfo(1)

	return mmConvertPipelineReleaseToDB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Inspect(f func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease)) *mConverterMockConvertPipelineReleaseToDB {
	if mmConvertPipelineReleaseToDB.mock.inspectFuncConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineReleaseToDB")
	}

	mmConvertPipelineReleaseToDB.mock.inspectFuncConvertPipelineReleaseToDB = f

	return mmConvertPipelineReleaseToDB
}

// Return sets up results that will be returned by Converter.ConvertPipelineReleaseToDB
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Return(pp1 *datamodel.PipelineRelease, err error) *ConverterMock {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToDB.defaultExpectation == nil {
		mmConvertPipelineReleaseToDB.defaultExpectation = &ConverterMockConvertPipelineReleaseToDBExpectation{mock: mmConvertPipelineReleaseToDB.mock}
	}
	mmConvertPipelineReleaseToDB.defaultExpectation.results = &ConverterMockConvertPipelineReleaseToDBResults{pp1, err}
	mmConvertPipelineReleaseToDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleaseToDB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineReleaseToDB method
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Set(f func(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) (pp1 *datamodel.PipelineRelease, err error)) *ConverterMock {
	if mmConvertPipelineReleaseToDB.defaultExpectation != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineReleaseToDB method")
	}

	if len(mmConvertPipelineReleaseToDB.expectations) > 0 {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineReleaseToDB method")
	}

	mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB = f
	mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDBOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleaseToDB.mock
}

// When sets expectation for the Converter.ConvertPipelineReleaseToDB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) When(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) *ConverterMockConvertPipelineReleaseToDBExpectation {
	if mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToDB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineReleaseToDBExpectation{
		mock:               mmConvertPipelineReleaseToDB.mock,
		params:             &ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease},
		expectationOrigins: ConverterMockConvertPipelineReleaseToDBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertPipelineReleaseToDB.expectations = append(mmConvertPipelineReleaseToDB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineReleaseToDB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineReleaseToDBExpectation) Then(pp1 *datamodel.PipelineRelease, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineReleaseToDBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineReleaseToDB should be invoked
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Times(n uint64) *mConverterMockConvertPipelineReleaseToDB {
	if n == 0 {
		mmConvertPipelineReleaseToDB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineReleaseToDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineReleaseToDB.expectedInvocations, n)
	mmConvertPipelineReleaseToDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleaseToDB
}

func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) invocationsDone() bool {
	if len(mmConvertPipelineReleaseToDB.expectations) == 0 && mmConvertPipelineReleaseToDB.defaultExpectation == nil && mmConvertPipelineReleaseToDB.mock.funcConvertPipelineReleaseToDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.mock.afterConvertPipelineReleaseToDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineReleaseToDB implements mm_service.Converter
func (mmConvertPipelineReleaseToDB *ConverterMock) ConvertPipelineReleaseToDB(ctx context.Context, pipelineUID uuid.UUID, pbPipelineRelease *pb.PipelineRelease) (pp1 *datamodel.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineReleaseToDB.beforeConvertPipelineReleaseToDBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineReleaseToDB.afterConvertPipelineReleaseToDBCounter, 1)

	mmConvertPipelineReleaseToDB.t.Helper()

	if mmConvertPipelineReleaseToDB.inspectFuncConvertPipelineReleaseToDB != nil {
		mmConvertPipelineReleaseToDB.inspectFuncConvertPipelineReleaseToDB(ctx, pipelineUID, pbPipelineRelease)
	}

	mm_params := ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease}

	// Record call args
	mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.mutex.Lock()
	mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.callArgs = append(mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.callArgs, &mm_params)
	mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineReleaseToDBParams{ctx, pipelineUID, pbPipelineRelease}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pipelineUID != nil && !minimock.Equal(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID) {
				mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameter pipelineUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.expectationOrigins.originPipelineUID, *mm_want_ptrs.pipelineUID, mm_got.pipelineUID, minimock.Diff(*mm_want_ptrs.pipelineUID, mm_got.pipelineUID))
			}

			if mm_want_ptrs.pbPipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.pbPipelineRelease, mm_got.pbPipelineRelease) {
				mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameter pbPipelineRelease, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.expectationOrigins.originPbPipelineRelease, *mm_want_ptrs.pbPipelineRelease, mm_got.pbPipelineRelease, minimock.Diff(*mm_want_ptrs.pbPipelineRelease, mm_got.pbPipelineRelease))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineReleaseToDB.t.Errorf("ConverterMock.ConvertPipelineReleaseToDB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineReleaseToDB.ConvertPipelineReleaseToDBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineReleaseToDB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineReleaseToDB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineReleaseToDB.funcConvertPipelineReleaseToDB != nil {
		return mmConvertPipelineReleaseToDB.funcConvertPipelineReleaseToDB(ctx, pipelineUID, pbPipelineRelease)
	}
	mmConvertPipelineReleaseToDB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineReleaseToDB. %v %v %v", ctx, pipelineUID, pbPipelineRelease)
	return
}

// ConvertPipelineReleaseToDBAfterCounter returns a count of finished ConverterMock.ConvertPipelineReleaseToDB invocations
func (mmConvertPipelineReleaseToDB *ConverterMock) ConvertPipelineReleaseToDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.afterConvertPipelineReleaseToDBCounter)
}

// ConvertPipelineReleaseToDBBeforeCounter returns a count of ConverterMock.ConvertPipelineReleaseToDB invocations
func (mmConvertPipelineReleaseToDB *ConverterMock) ConvertPipelineReleaseToDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToDB.beforeConvertPipelineReleaseToDBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineReleaseToDB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineReleaseToDB *mConverterMockConvertPipelineReleaseToDB) Calls() []*ConverterMockConvertPipelineReleaseToDBParams {
	mmConvertPipelineReleaseToDB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineReleaseToDBParams, len(mmConvertPipelineReleaseToDB.callArgs))
	copy(argCopy, mmConvertPipelineReleaseToDB.callArgs)

	mmConvertPipelineReleaseToDB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineReleaseToDBDone returns true if the count of the ConvertPipelineReleaseToDB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineReleaseToDBDone() bool {
	if m.ConvertPipelineReleaseToDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineReleaseToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineReleaseToDBMock.invocationsDone()
}

// MinimockConvertPipelineReleaseToDBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineReleaseToDBInspect() {
	for _, e := range m.ConvertPipelineReleaseToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToDB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertPipelineReleaseToDBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineReleaseToDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineReleaseToDBMock.defaultExpectation != nil && afterConvertPipelineReleaseToDBCounter < 1 {
		if m.ConvertPipelineReleaseToDBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToDB at\n%s", m.ConvertPipelineReleaseToDBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToDB at\n%s with params: %#v", m.ConvertPipelineReleaseToDBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertPipelineReleaseToDBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineReleaseToDB != nil && afterConvertPipelineReleaseToDBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToDB at\n%s", m.funcConvertPipelineReleaseToDBOrigin)
	}

	if !m.ConvertPipelineReleaseToDBMock.invocationsDone() && afterConvertPipelineReleaseToDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineReleaseToDB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineReleaseToDBMock.expectedInvocations), m.ConvertPipelineReleaseToDBMock.expectedInvocationsOrigin, afterConvertPipelineReleaseToDBCounter)
	}
}

type mConverterMockConvertPipelineReleaseToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineReleaseToPBExpectation
	expectations       []*ConverterMockConvertPipelineReleaseToPBExpectation

	callArgs []*ConverterMockConvertPipelineReleaseToPBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertPipelineReleaseToPBExpectation specifies expectation struct of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertPipelineReleaseToPBParams
	paramPtrs          *ConverterMockConvertPipelineReleaseToPBParamPtrs
	expectationOrigins ConverterMockConvertPipelineReleaseToPBExpectationOrigins
	results            *ConverterMockConvertPipelineReleaseToPBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertPipelineReleaseToPBParams contains parameters of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBParams struct {
	ctx               context.Context
	dbPipeline        *datamodel.Pipeline
	dbPipelineRelease *datamodel.PipelineRelease
	view              pb.Pipeline_View
}

// ConverterMockConvertPipelineReleaseToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBParamPtrs struct {
	ctx               *context.Context
	dbPipeline        **datamodel.Pipeline
	dbPipelineRelease **datamodel.PipelineRelease
	view              *pb.Pipeline_View
}

// ConverterMockConvertPipelineReleaseToPBResults contains results of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBResults struct {
	pp1 *pb.PipelineRelease
	err error
}

// ConverterMockConvertPipelineReleaseToPBOrigins contains origins of expectations of the Converter.ConvertPipelineReleaseToPB
type ConverterMockConvertPipelineReleaseToPBExpectationOrigins struct {
	origin                  string
	originCtx               string
	originDbPipeline        string
	originDbPipelineRelease string
	originView              string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Optional() *mConverterMockConvertPipelineReleaseToPB {
	mmConvertPipelineReleaseToPB.optional = true
	return mmConvertPipelineReleaseToPB
}

// Expect sets up expected params for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Expect(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineReleaseToPB.defaultExpectation.params = &ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view}
	mmConvertPipelineReleaseToPB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertPipelineReleaseToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineReleaseToPB.defaultExpectation.params) {
			mmConvertPipelineReleaseToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineReleaseToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineReleaseToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertPipelineReleaseToPB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertPipelineReleaseToPB
}

// ExpectDbPipelineParam2 sets up expected param dbPipeline for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectDbPipelineParam2(dbPipeline *datamodel.Pipeline) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.dbPipeline = &dbPipeline
	mmConvertPipelineReleaseToPB.defaultExpectation.expectationOrigins.originDbPipeline = minimock.CallerInfo(1)

	return mmConvertPipelineReleaseToPB
}

// ExpectDbPipelineReleaseParam3 sets up expected param dbPipelineRelease for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectDbPipelineReleaseParam3(dbPipelineRelease *datamodel.PipelineRelease) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.dbPipelineRelease = &dbPipelineRelease
	mmConvertPipelineReleaseToPB.defaultExpectation.expectationOrigins.originDbPipelineRelease = minimock.CallerInfo(1)

	return mmConvertPipelineReleaseToPB
}

// ExpectViewParam4 sets up expected param view for Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) ExpectViewParam4(view pb.Pipeline_View) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{}
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleaseToPBParamPtrs{}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.paramPtrs.view = &view
	mmConvertPipelineReleaseToPB.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmConvertPipelineReleaseToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Inspect(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View)) *mConverterMockConvertPipelineReleaseToPB {
	if mmConvertPipelineReleaseToPB.mock.inspectFuncConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineReleaseToPB")
	}

	mmConvertPipelineReleaseToPB.mock.inspectFuncConvertPipelineReleaseToPB = f

	return mmConvertPipelineReleaseToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelineReleaseToPB
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Return(pp1 *pb.PipelineRelease, err error) *ConverterMock {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	if mmConvertPipelineReleaseToPB.defaultExpectation == nil {
		mmConvertPipelineReleaseToPB.defaultExpectation = &ConverterMockConvertPipelineReleaseToPBExpectation{mock: mmConvertPipelineReleaseToPB.mock}
	}
	mmConvertPipelineReleaseToPB.defaultExpectation.results = &ConverterMockConvertPipelineReleaseToPBResults{pp1, err}
	mmConvertPipelineReleaseToPB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleaseToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineReleaseToPB method
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Set(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) (pp1 *pb.PipelineRelease, err error)) *ConverterMock {
	if mmConvertPipelineReleaseToPB.defaultExpectation != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineReleaseToPB method")
	}

	if len(mmConvertPipelineReleaseToPB.expectations) > 0 {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineReleaseToPB method")
	}

	mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB = f
	mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPBOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleaseToPB.mock
}

// When sets expectation for the Converter.ConvertPipelineReleaseToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) When(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) *ConverterMockConvertPipelineReleaseToPBExpectation {
	if mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleaseToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineReleaseToPBExpectation{
		mock:               mmConvertPipelineReleaseToPB.mock,
		params:             &ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view},
		expectationOrigins: ConverterMockConvertPipelineReleaseToPBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertPipelineReleaseToPB.expectations = append(mmConvertPipelineReleaseToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineReleaseToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineReleaseToPBExpectation) Then(pp1 *pb.PipelineRelease, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineReleaseToPBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineReleaseToPB should be invoked
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Times(n uint64) *mConverterMockConvertPipelineReleaseToPB {
	if n == 0 {
		mmConvertPipelineReleaseToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineReleaseToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineReleaseToPB.expectedInvocations, n)
	mmConvertPipelineReleaseToPB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleaseToPB
}

func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) invocationsDone() bool {
	if len(mmConvertPipelineReleaseToPB.expectations) == 0 && mmConvertPipelineReleaseToPB.defaultExpectation == nil && mmConvertPipelineReleaseToPB.mock.funcConvertPipelineReleaseToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.mock.afterConvertPipelineReleaseToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineReleaseToPB implements mm_service.Converter
func (mmConvertPipelineReleaseToPB *ConverterMock) ConvertPipelineReleaseToPB(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease *datamodel.PipelineRelease, view pb.Pipeline_View) (pp1 *pb.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineReleaseToPB.beforeConvertPipelineReleaseToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineReleaseToPB.afterConvertPipelineReleaseToPBCounter, 1)

	mmConvertPipelineReleaseToPB.t.Helper()

	if mmConvertPipelineReleaseToPB.inspectFuncConvertPipelineReleaseToPB != nil {
		mmConvertPipelineReleaseToPB.inspectFuncConvertPipelineReleaseToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}

	mm_params := ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

	// Record call args
	mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.mutex.Lock()
	mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.callArgs = append(mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.callArgs, &mm_params)
	mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineReleaseToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipeline != nil && !minimock.Equal(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter dbPipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.expectationOrigins.originDbPipeline, *mm_want_ptrs.dbPipeline, mm_got.dbPipeline, minimock.Diff(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline))
			}

			if mm_want_ptrs.dbPipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter dbPipelineRelease, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.expectationOrigins.originDbPipelineRelease, *mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease, minimock.Diff(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineReleaseToPB.t.Errorf("ConverterMock.ConvertPipelineReleaseToPB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineReleaseToPB.ConvertPipelineReleaseToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineReleaseToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineReleaseToPB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineReleaseToPB.funcConvertPipelineReleaseToPB != nil {
		return mmConvertPipelineReleaseToPB.funcConvertPipelineReleaseToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}
	mmConvertPipelineReleaseToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineReleaseToPB. %v %v %v %v", ctx, dbPipeline, dbPipelineRelease, view)
	return
}

// ConvertPipelineReleaseToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelineReleaseToPB invocations
func (mmConvertPipelineReleaseToPB *ConverterMock) ConvertPipelineReleaseToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.afterConvertPipelineReleaseToPBCounter)
}

// ConvertPipelineReleaseToPBBeforeCounter returns a count of ConverterMock.ConvertPipelineReleaseToPB invocations
func (mmConvertPipelineReleaseToPB *ConverterMock) ConvertPipelineReleaseToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleaseToPB.beforeConvertPipelineReleaseToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineReleaseToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineReleaseToPB *mConverterMockConvertPipelineReleaseToPB) Calls() []*ConverterMockConvertPipelineReleaseToPBParams {
	mmConvertPipelineReleaseToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineReleaseToPBParams, len(mmConvertPipelineReleaseToPB.callArgs))
	copy(argCopy, mmConvertPipelineReleaseToPB.callArgs)

	mmConvertPipelineReleaseToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineReleaseToPBDone returns true if the count of the ConvertPipelineReleaseToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineReleaseToPBDone() bool {
	if m.ConvertPipelineReleaseToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineReleaseToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineReleaseToPBMock.invocationsDone()
}

// MinimockConvertPipelineReleaseToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineReleaseToPBInspect() {
	for _, e := range m.ConvertPipelineReleaseToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToPB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertPipelineReleaseToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineReleaseToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineReleaseToPBMock.defaultExpectation != nil && afterConvertPipelineReleaseToPBCounter < 1 {
		if m.ConvertPipelineReleaseToPBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToPB at\n%s", m.ConvertPipelineReleaseToPBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToPB at\n%s with params: %#v", m.ConvertPipelineReleaseToPBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertPipelineReleaseToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineReleaseToPB != nil && afterConvertPipelineReleaseToPBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleaseToPB at\n%s", m.funcConvertPipelineReleaseToPBOrigin)
	}

	if !m.ConvertPipelineReleaseToPBMock.invocationsDone() && afterConvertPipelineReleaseToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineReleaseToPB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineReleaseToPBMock.expectedInvocations), m.ConvertPipelineReleaseToPBMock.expectedInvocationsOrigin, afterConvertPipelineReleaseToPBCounter)
	}
}

type mConverterMockConvertPipelineReleasesToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineReleasesToPBExpectation
	expectations       []*ConverterMockConvertPipelineReleasesToPBExpectation

	callArgs []*ConverterMockConvertPipelineReleasesToPBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertPipelineReleasesToPBExpectation specifies expectation struct of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertPipelineReleasesToPBParams
	paramPtrs          *ConverterMockConvertPipelineReleasesToPBParamPtrs
	expectationOrigins ConverterMockConvertPipelineReleasesToPBExpectationOrigins
	results            *ConverterMockConvertPipelineReleasesToPBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertPipelineReleasesToPBParams contains parameters of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBParams struct {
	ctx               context.Context
	dbPipeline        *datamodel.Pipeline
	dbPipelineRelease []*datamodel.PipelineRelease
	view              pb.Pipeline_View
}

// ConverterMockConvertPipelineReleasesToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBParamPtrs struct {
	ctx               *context.Context
	dbPipeline        **datamodel.Pipeline
	dbPipelineRelease *[]*datamodel.PipelineRelease
	view              *pb.Pipeline_View
}

// ConverterMockConvertPipelineReleasesToPBResults contains results of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBResults struct {
	ppa1 []*pb.PipelineRelease
	err  error
}

// ConverterMockConvertPipelineReleasesToPBOrigins contains origins of expectations of the Converter.ConvertPipelineReleasesToPB
type ConverterMockConvertPipelineReleasesToPBExpectationOrigins struct {
	origin                  string
	originCtx               string
	originDbPipeline        string
	originDbPipelineRelease string
	originView              string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Optional() *mConverterMockConvertPipelineReleasesToPB {
	mmConvertPipelineReleasesToPB.optional = true
	return mmConvertPipelineReleasesToPB
}

// Expect sets up expected params for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Expect(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineReleasesToPB.defaultExpectation.params = &ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view}
	mmConvertPipelineReleasesToPB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertPipelineReleasesToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineReleasesToPB.defaultExpectation.params) {
			mmConvertPipelineReleasesToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineReleasesToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineReleasesToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertPipelineReleasesToPB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertPipelineReleasesToPB
}

// ExpectDbPipelineParam2 sets up expected param dbPipeline for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectDbPipelineParam2(dbPipeline *datamodel.Pipeline) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.dbPipeline = &dbPipeline
	mmConvertPipelineReleasesToPB.defaultExpectation.expectationOrigins.originDbPipeline = minimock.CallerInfo(1)

	return mmConvertPipelineReleasesToPB
}

// ExpectDbPipelineReleaseParam3 sets up expected param dbPipelineRelease for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectDbPipelineReleaseParam3(dbPipelineRelease []*datamodel.PipelineRelease) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.dbPipelineRelease = &dbPipelineRelease
	mmConvertPipelineReleasesToPB.defaultExpectation.expectationOrigins.originDbPipelineRelease = minimock.CallerInfo(1)

	return mmConvertPipelineReleasesToPB
}

// ExpectViewParam4 sets up expected param view for Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) ExpectViewParam4(view pb.Pipeline_View) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{}
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.params != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Expect")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineReleasesToPBParamPtrs{}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.paramPtrs.view = &view
	mmConvertPipelineReleasesToPB.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmConvertPipelineReleasesToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Inspect(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View)) *mConverterMockConvertPipelineReleasesToPB {
	if mmConvertPipelineReleasesToPB.mock.inspectFuncConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineReleasesToPB")
	}

	mmConvertPipelineReleasesToPB.mock.inspectFuncConvertPipelineReleasesToPB = f

	return mmConvertPipelineReleasesToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelineReleasesToPB
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Return(ppa1 []*pb.PipelineRelease, err error) *ConverterMock {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	if mmConvertPipelineReleasesToPB.defaultExpectation == nil {
		mmConvertPipelineReleasesToPB.defaultExpectation = &ConverterMockConvertPipelineReleasesToPBExpectation{mock: mmConvertPipelineReleasesToPB.mock}
	}
	mmConvertPipelineReleasesToPB.defaultExpectation.results = &ConverterMockConvertPipelineReleasesToPBResults{ppa1, err}
	mmConvertPipelineReleasesToPB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleasesToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineReleasesToPB method
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Set(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) (ppa1 []*pb.PipelineRelease, err error)) *ConverterMock {
	if mmConvertPipelineReleasesToPB.defaultExpectation != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineReleasesToPB method")
	}

	if len(mmConvertPipelineReleasesToPB.expectations) > 0 {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineReleasesToPB method")
	}

	mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB = f
	mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPBOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleasesToPB.mock
}

// When sets expectation for the Converter.ConvertPipelineReleasesToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) When(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) *ConverterMockConvertPipelineReleasesToPBExpectation {
	if mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineReleasesToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineReleasesToPBExpectation{
		mock:               mmConvertPipelineReleasesToPB.mock,
		params:             &ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view},
		expectationOrigins: ConverterMockConvertPipelineReleasesToPBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertPipelineReleasesToPB.expectations = append(mmConvertPipelineReleasesToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineReleasesToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineReleasesToPBExpectation) Then(ppa1 []*pb.PipelineRelease, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineReleasesToPBResults{ppa1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineReleasesToPB should be invoked
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Times(n uint64) *mConverterMockConvertPipelineReleasesToPB {
	if n == 0 {
		mmConvertPipelineReleasesToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineReleasesToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineReleasesToPB.expectedInvocations, n)
	mmConvertPipelineReleasesToPB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineReleasesToPB
}

func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) invocationsDone() bool {
	if len(mmConvertPipelineReleasesToPB.expectations) == 0 && mmConvertPipelineReleasesToPB.defaultExpectation == nil && mmConvertPipelineReleasesToPB.mock.funcConvertPipelineReleasesToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.mock.afterConvertPipelineReleasesToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineReleasesToPB implements mm_service.Converter
func (mmConvertPipelineReleasesToPB *ConverterMock) ConvertPipelineReleasesToPB(ctx context.Context, dbPipeline *datamodel.Pipeline, dbPipelineRelease []*datamodel.PipelineRelease, view pb.Pipeline_View) (ppa1 []*pb.PipelineRelease, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineReleasesToPB.beforeConvertPipelineReleasesToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineReleasesToPB.afterConvertPipelineReleasesToPBCounter, 1)

	mmConvertPipelineReleasesToPB.t.Helper()

	if mmConvertPipelineReleasesToPB.inspectFuncConvertPipelineReleasesToPB != nil {
		mmConvertPipelineReleasesToPB.inspectFuncConvertPipelineReleasesToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}

	mm_params := ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

	// Record call args
	mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.mutex.Lock()
	mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.callArgs = append(mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.callArgs, &mm_params)
	mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineReleasesToPBParams{ctx, dbPipeline, dbPipelineRelease, view}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipeline != nil && !minimock.Equal(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter dbPipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.expectationOrigins.originDbPipeline, *mm_want_ptrs.dbPipeline, mm_got.dbPipeline, minimock.Diff(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline))
			}

			if mm_want_ptrs.dbPipelineRelease != nil && !minimock.Equal(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter dbPipelineRelease, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.expectationOrigins.originDbPipelineRelease, *mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease, minimock.Diff(*mm_want_ptrs.dbPipelineRelease, mm_got.dbPipelineRelease))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineReleasesToPB.t.Errorf("ConverterMock.ConvertPipelineReleasesToPB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineReleasesToPB.ConvertPipelineReleasesToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineReleasesToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineReleasesToPB")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmConvertPipelineReleasesToPB.funcConvertPipelineReleasesToPB != nil {
		return mmConvertPipelineReleasesToPB.funcConvertPipelineReleasesToPB(ctx, dbPipeline, dbPipelineRelease, view)
	}
	mmConvertPipelineReleasesToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineReleasesToPB. %v %v %v %v", ctx, dbPipeline, dbPipelineRelease, view)
	return
}

// ConvertPipelineReleasesToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelineReleasesToPB invocations
func (mmConvertPipelineReleasesToPB *ConverterMock) ConvertPipelineReleasesToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.afterConvertPipelineReleasesToPBCounter)
}

// ConvertPipelineReleasesToPBBeforeCounter returns a count of ConverterMock.ConvertPipelineReleasesToPB invocations
func (mmConvertPipelineReleasesToPB *ConverterMock) ConvertPipelineReleasesToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineReleasesToPB.beforeConvertPipelineReleasesToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineReleasesToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineReleasesToPB *mConverterMockConvertPipelineReleasesToPB) Calls() []*ConverterMockConvertPipelineReleasesToPBParams {
	mmConvertPipelineReleasesToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineReleasesToPBParams, len(mmConvertPipelineReleasesToPB.callArgs))
	copy(argCopy, mmConvertPipelineReleasesToPB.callArgs)

	mmConvertPipelineReleasesToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineReleasesToPBDone returns true if the count of the ConvertPipelineReleasesToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineReleasesToPBDone() bool {
	if m.ConvertPipelineReleasesToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineReleasesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineReleasesToPBMock.invocationsDone()
}

// MinimockConvertPipelineReleasesToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineReleasesToPBInspect() {
	for _, e := range m.ConvertPipelineReleasesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleasesToPB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertPipelineReleasesToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineReleasesToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineReleasesToPBMock.defaultExpectation != nil && afterConvertPipelineReleasesToPBCounter < 1 {
		if m.ConvertPipelineReleasesToPBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleasesToPB at\n%s", m.ConvertPipelineReleasesToPBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleasesToPB at\n%s with params: %#v", m.ConvertPipelineReleasesToPBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertPipelineReleasesToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineReleasesToPB != nil && afterConvertPipelineReleasesToPBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertPipelineReleasesToPB at\n%s", m.funcConvertPipelineReleasesToPBOrigin)
	}

	if !m.ConvertPipelineReleasesToPBMock.invocationsDone() && afterConvertPipelineReleasesToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineReleasesToPB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineReleasesToPBMock.expectedInvocations), m.ConvertPipelineReleasesToPBMock.expectedInvocationsOrigin, afterConvertPipelineReleasesToPBCounter)
	}
}

type mConverterMockConvertPipelineToDB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineToDBExpectation
	expectations       []*ConverterMockConvertPipelineToDBExpectation

	callArgs []*ConverterMockConvertPipelineToDBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertPipelineToDBExpectation specifies expectation struct of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertPipelineToDBParams
	paramPtrs          *ConverterMockConvertPipelineToDBParamPtrs
	expectationOrigins ConverterMockConvertPipelineToDBExpectationOrigins
	results            *ConverterMockConvertPipelineToDBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertPipelineToDBParams contains parameters of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBParams struct {
	ctx        context.Context
	ns         resource.Namespace
	pbPipeline *pb.Pipeline
}

// ConverterMockConvertPipelineToDBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBParamPtrs struct {
	ctx        *context.Context
	ns         *resource.Namespace
	pbPipeline **pb.Pipeline
}

// ConverterMockConvertPipelineToDBResults contains results of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBResults struct {
	pp1 *datamodel.Pipeline
	err error
}

// ConverterMockConvertPipelineToDBOrigins contains origins of expectations of the Converter.ConvertPipelineToDB
type ConverterMockConvertPipelineToDBExpectationOrigins struct {
	origin           string
	originCtx        string
	originNs         string
	originPbPipeline string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Optional() *mConverterMockConvertPipelineToDB {
	mmConvertPipelineToDB.optional = true
	return mmConvertPipelineToDB
}

// Expect sets up expected params for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Expect(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineToDB.defaultExpectation.params = &ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline}
	mmConvertPipelineToDB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertPipelineToDB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineToDB.defaultExpectation.params) {
			mmConvertPipelineToDB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineToDB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineToDB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.params != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Expect")
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToDBParamPtrs{}
	}
	mmConvertPipelineToDB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertPipelineToDB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertPipelineToDB
}

// ExpectNsParam2 sets up expected param ns for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) ExpectNsParam2(ns resource.Namespace) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.params != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Expect")
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToDBParamPtrs{}
	}
	mmConvertPipelineToDB.defaultExpectation.paramPtrs.ns = &ns
	mmConvertPipelineToDB.defaultExpectation.expectationOrigins.originNs = minimock.CallerInfo(1)

	return mmConvertPipelineToDB
}

// ExpectPbPipelineParam3 sets up expected param pbPipeline for Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) ExpectPbPipelineParam3(pbPipeline *pb.Pipeline) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{}
	}

	if mmConvertPipelineToDB.defaultExpectation.params != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Expect")
	}

	if mmConvertPipelineToDB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToDB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToDBParamPtrs{}
	}
	mmConvertPipelineToDB.defaultExpectation.paramPtrs.pbPipeline = &pbPipeline
	mmConvertPipelineToDB.defaultExpectation.expectationOrigins.originPbPipeline = minimock.CallerInfo(1)

	return mmConvertPipelineToDB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Inspect(f func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline)) *mConverterMockConvertPipelineToDB {
	if mmConvertPipelineToDB.mock.inspectFuncConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineToDB")
	}

	mmConvertPipelineToDB.mock.inspectFuncConvertPipelineToDB = f

	return mmConvertPipelineToDB
}

// Return sets up results that will be returned by Converter.ConvertPipelineToDB
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Return(pp1 *datamodel.Pipeline, err error) *ConverterMock {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	if mmConvertPipelineToDB.defaultExpectation == nil {
		mmConvertPipelineToDB.defaultExpectation = &ConverterMockConvertPipelineToDBExpectation{mock: mmConvertPipelineToDB.mock}
	}
	mmConvertPipelineToDB.defaultExpectation.results = &ConverterMockConvertPipelineToDBResults{pp1, err}
	mmConvertPipelineToDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineToDB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineToDB method
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Set(f func(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) (pp1 *datamodel.Pipeline, err error)) *ConverterMock {
	if mmConvertPipelineToDB.defaultExpectation != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineToDB method")
	}

	if len(mmConvertPipelineToDB.expectations) > 0 {
		mmConvertPipelineToDB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineToDB method")
	}

	mmConvertPipelineToDB.mock.funcConvertPipelineToDB = f
	mmConvertPipelineToDB.mock.funcConvertPipelineToDBOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineToDB.mock
}

// When sets expectation for the Converter.ConvertPipelineToDB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) When(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) *ConverterMockConvertPipelineToDBExpectation {
	if mmConvertPipelineToDB.mock.funcConvertPipelineToDB != nil {
		mmConvertPipelineToDB.mock.t.Fatalf("ConverterMock.ConvertPipelineToDB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineToDBExpectation{
		mock:               mmConvertPipelineToDB.mock,
		params:             &ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline},
		expectationOrigins: ConverterMockConvertPipelineToDBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertPipelineToDB.expectations = append(mmConvertPipelineToDB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineToDB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineToDBExpectation) Then(pp1 *datamodel.Pipeline, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineToDBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineToDB should be invoked
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Times(n uint64) *mConverterMockConvertPipelineToDB {
	if n == 0 {
		mmConvertPipelineToDB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineToDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineToDB.expectedInvocations, n)
	mmConvertPipelineToDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineToDB
}

func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) invocationsDone() bool {
	if len(mmConvertPipelineToDB.expectations) == 0 && mmConvertPipelineToDB.defaultExpectation == nil && mmConvertPipelineToDB.mock.funcConvertPipelineToDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToDB.mock.afterConvertPipelineToDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineToDB implements mm_service.Converter
func (mmConvertPipelineToDB *ConverterMock) ConvertPipelineToDB(ctx context.Context, ns resource.Namespace, pbPipeline *pb.Pipeline) (pp1 *datamodel.Pipeline, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineToDB.beforeConvertPipelineToDBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineToDB.afterConvertPipelineToDBCounter, 1)

	mmConvertPipelineToDB.t.Helper()

	if mmConvertPipelineToDB.inspectFuncConvertPipelineToDB != nil {
		mmConvertPipelineToDB.inspectFuncConvertPipelineToDB(ctx, ns, pbPipeline)
	}

	mm_params := ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline}

	// Record call args
	mmConvertPipelineToDB.ConvertPipelineToDBMock.mutex.Lock()
	mmConvertPipelineToDB.ConvertPipelineToDBMock.callArgs = append(mmConvertPipelineToDB.ConvertPipelineToDBMock.callArgs, &mm_params)
	mmConvertPipelineToDB.ConvertPipelineToDBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineToDB.ConvertPipelineToDBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineToDBParams{ctx, ns, pbPipeline}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ns != nil && !minimock.Equal(*mm_want_ptrs.ns, mm_got.ns) {
				mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameter ns, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.expectationOrigins.originNs, *mm_want_ptrs.ns, mm_got.ns, minimock.Diff(*mm_want_ptrs.ns, mm_got.ns))
			}

			if mm_want_ptrs.pbPipeline != nil && !minimock.Equal(*mm_want_ptrs.pbPipeline, mm_got.pbPipeline) {
				mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameter pbPipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.expectationOrigins.originPbPipeline, *mm_want_ptrs.pbPipeline, mm_got.pbPipeline, minimock.Diff(*mm_want_ptrs.pbPipeline, mm_got.pbPipeline))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineToDB.t.Errorf("ConverterMock.ConvertPipelineToDB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineToDB.ConvertPipelineToDBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineToDB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineToDB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineToDB.funcConvertPipelineToDB != nil {
		return mmConvertPipelineToDB.funcConvertPipelineToDB(ctx, ns, pbPipeline)
	}
	mmConvertPipelineToDB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineToDB. %v %v %v", ctx, ns, pbPipeline)
	return
}

// ConvertPipelineToDBAfterCounter returns a count of finished ConverterMock.ConvertPipelineToDB invocations
func (mmConvertPipelineToDB *ConverterMock) ConvertPipelineToDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToDB.afterConvertPipelineToDBCounter)
}

// ConvertPipelineToDBBeforeCounter returns a count of ConverterMock.ConvertPipelineToDB invocations
func (mmConvertPipelineToDB *ConverterMock) ConvertPipelineToDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToDB.beforeConvertPipelineToDBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineToDB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineToDB *mConverterMockConvertPipelineToDB) Calls() []*ConverterMockConvertPipelineToDBParams {
	mmConvertPipelineToDB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineToDBParams, len(mmConvertPipelineToDB.callArgs))
	copy(argCopy, mmConvertPipelineToDB.callArgs)

	mmConvertPipelineToDB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineToDBDone returns true if the count of the ConvertPipelineToDB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineToDBDone() bool {
	if m.ConvertPipelineToDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineToDBMock.invocationsDone()
}

// MinimockConvertPipelineToDBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineToDBInspect() {
	for _, e := range m.ConvertPipelineToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToDB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertPipelineToDBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineToDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineToDBMock.defaultExpectation != nil && afterConvertPipelineToDBCounter < 1 {
		if m.ConvertPipelineToDBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToDB at\n%s", m.ConvertPipelineToDBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToDB at\n%s with params: %#v", m.ConvertPipelineToDBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertPipelineToDBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineToDB != nil && afterConvertPipelineToDBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToDB at\n%s", m.funcConvertPipelineToDBOrigin)
	}

	if !m.ConvertPipelineToDBMock.invocationsDone() && afterConvertPipelineToDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineToDB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineToDBMock.expectedInvocations), m.ConvertPipelineToDBMock.expectedInvocationsOrigin, afterConvertPipelineToDBCounter)
	}
}

type mConverterMockConvertPipelineToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelineToPBExpectation
	expectations       []*ConverterMockConvertPipelineToPBExpectation

	callArgs []*ConverterMockConvertPipelineToPBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertPipelineToPBExpectation specifies expectation struct of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertPipelineToPBParams
	paramPtrs          *ConverterMockConvertPipelineToPBParamPtrs
	expectationOrigins ConverterMockConvertPipelineToPBExpectationOrigins
	results            *ConverterMockConvertPipelineToPBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertPipelineToPBParams contains parameters of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBParams struct {
	ctx             context.Context
	dbPipeline      *datamodel.Pipeline
	view            pb.Pipeline_View
	checkPermission bool
	useDynamicDef   bool
}

// ConverterMockConvertPipelineToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBParamPtrs struct {
	ctx             *context.Context
	dbPipeline      **datamodel.Pipeline
	view            *pb.Pipeline_View
	checkPermission *bool
	useDynamicDef   *bool
}

// ConverterMockConvertPipelineToPBResults contains results of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBResults struct {
	pp1 *pb.Pipeline
	err error
}

// ConverterMockConvertPipelineToPBOrigins contains origins of expectations of the Converter.ConvertPipelineToPB
type ConverterMockConvertPipelineToPBExpectationOrigins struct {
	origin                string
	originCtx             string
	originDbPipeline      string
	originView            string
	originCheckPermission string
	originUseDynamicDef   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Optional() *mConverterMockConvertPipelineToPB {
	mmConvertPipelineToPB.optional = true
	return mmConvertPipelineToPB
}

// Expect sets up expected params for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Expect(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelineToPB.defaultExpectation.params = &ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef}
	mmConvertPipelineToPB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertPipelineToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelineToPB.defaultExpectation.params) {
			mmConvertPipelineToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelineToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelineToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertPipelineToPB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertPipelineToPB
}

// ExpectDbPipelineParam2 sets up expected param dbPipeline for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectDbPipelineParam2(dbPipeline *datamodel.Pipeline) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.dbPipeline = &dbPipeline
	mmConvertPipelineToPB.defaultExpectation.expectationOrigins.originDbPipeline = minimock.CallerInfo(1)

	return mmConvertPipelineToPB
}

// ExpectViewParam3 sets up expected param view for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectViewParam3(view pb.Pipeline_View) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.view = &view
	mmConvertPipelineToPB.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmConvertPipelineToPB
}

// ExpectCheckPermissionParam4 sets up expected param checkPermission for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectCheckPermissionParam4(checkPermission bool) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.checkPermission = &checkPermission
	mmConvertPipelineToPB.defaultExpectation.expectationOrigins.originCheckPermission = minimock.CallerInfo(1)

	return mmConvertPipelineToPB
}

// ExpectUseDynamicDefParam5 sets up expected param useDynamicDef for Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) ExpectUseDynamicDefParam5(useDynamicDef bool) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{}
	}

	if mmConvertPipelineToPB.defaultExpectation.params != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Expect")
	}

	if mmConvertPipelineToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelineToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelineToPBParamPtrs{}
	}
	mmConvertPipelineToPB.defaultExpectation.paramPtrs.useDynamicDef = &useDynamicDef
	mmConvertPipelineToPB.defaultExpectation.expectationOrigins.originUseDynamicDef = minimock.CallerInfo(1)

	return mmConvertPipelineToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Inspect(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool)) *mConverterMockConvertPipelineToPB {
	if mmConvertPipelineToPB.mock.inspectFuncConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelineToPB")
	}

	mmConvertPipelineToPB.mock.inspectFuncConvertPipelineToPB = f

	return mmConvertPipelineToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelineToPB
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Return(pp1 *pb.Pipeline, err error) *ConverterMock {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	if mmConvertPipelineToPB.defaultExpectation == nil {
		mmConvertPipelineToPB.defaultExpectation = &ConverterMockConvertPipelineToPBExpectation{mock: mmConvertPipelineToPB.mock}
	}
	mmConvertPipelineToPB.defaultExpectation.results = &ConverterMockConvertPipelineToPBResults{pp1, err}
	mmConvertPipelineToPB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelineToPB method
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Set(f func(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) (pp1 *pb.Pipeline, err error)) *ConverterMock {
	if mmConvertPipelineToPB.defaultExpectation != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelineToPB method")
	}

	if len(mmConvertPipelineToPB.expectations) > 0 {
		mmConvertPipelineToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelineToPB method")
	}

	mmConvertPipelineToPB.mock.funcConvertPipelineToPB = f
	mmConvertPipelineToPB.mock.funcConvertPipelineToPBOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineToPB.mock
}

// When sets expectation for the Converter.ConvertPipelineToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) When(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) *ConverterMockConvertPipelineToPBExpectation {
	if mmConvertPipelineToPB.mock.funcConvertPipelineToPB != nil {
		mmConvertPipelineToPB.mock.t.Fatalf("ConverterMock.ConvertPipelineToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelineToPBExpectation{
		mock:               mmConvertPipelineToPB.mock,
		params:             &ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef},
		expectationOrigins: ConverterMockConvertPipelineToPBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertPipelineToPB.expectations = append(mmConvertPipelineToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelineToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelineToPBExpectation) Then(pp1 *pb.Pipeline, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelineToPBResults{pp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelineToPB should be invoked
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Times(n uint64) *mConverterMockConvertPipelineToPB {
	if n == 0 {
		mmConvertPipelineToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelineToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelineToPB.expectedInvocations, n)
	mmConvertPipelineToPB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertPipelineToPB
}

func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) invocationsDone() bool {
	if len(mmConvertPipelineToPB.expectations) == 0 && mmConvertPipelineToPB.defaultExpectation == nil && mmConvertPipelineToPB.mock.funcConvertPipelineToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToPB.mock.afterConvertPipelineToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelineToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelineToPB implements mm_service.Converter
func (mmConvertPipelineToPB *ConverterMock) ConvertPipelineToPB(ctx context.Context, dbPipeline *datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool, useDynamicDef bool) (pp1 *pb.Pipeline, err error) {
	mm_atomic.AddUint64(&mmConvertPipelineToPB.beforeConvertPipelineToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelineToPB.afterConvertPipelineToPBCounter, 1)

	mmConvertPipelineToPB.t.Helper()

	if mmConvertPipelineToPB.inspectFuncConvertPipelineToPB != nil {
		mmConvertPipelineToPB.inspectFuncConvertPipelineToPB(ctx, dbPipeline, view, checkPermission, useDynamicDef)
	}

	mm_params := ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef}

	// Record call args
	mmConvertPipelineToPB.ConvertPipelineToPBMock.mutex.Lock()
	mmConvertPipelineToPB.ConvertPipelineToPBMock.callArgs = append(mmConvertPipelineToPB.ConvertPipelineToPBMock.callArgs, &mm_params)
	mmConvertPipelineToPB.ConvertPipelineToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelineToPB.ConvertPipelineToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelineToPBParams{ctx, dbPipeline, view, checkPermission, useDynamicDef}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipeline != nil && !minimock.Equal(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter dbPipeline, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.expectationOrigins.originDbPipeline, *mm_want_ptrs.dbPipeline, mm_got.dbPipeline, minimock.Diff(*mm_want_ptrs.dbPipeline, mm_got.dbPipeline))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

			if mm_want_ptrs.checkPermission != nil && !minimock.Equal(*mm_want_ptrs.checkPermission, mm_got.checkPermission) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter checkPermission, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.expectationOrigins.originCheckPermission, *mm_want_ptrs.checkPermission, mm_got.checkPermission, minimock.Diff(*mm_want_ptrs.checkPermission, mm_got.checkPermission))
			}

			if mm_want_ptrs.useDynamicDef != nil && !minimock.Equal(*mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef) {
				mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameter useDynamicDef, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.expectationOrigins.originUseDynamicDef, *mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef, minimock.Diff(*mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelineToPB.t.Errorf("ConverterMock.ConvertPipelineToPB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelineToPB.ConvertPipelineToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelineToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelineToPB")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmConvertPipelineToPB.funcConvertPipelineToPB != nil {
		return mmConvertPipelineToPB.funcConvertPipelineToPB(ctx, dbPipeline, view, checkPermission, useDynamicDef)
	}
	mmConvertPipelineToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelineToPB. %v %v %v %v %v", ctx, dbPipeline, view, checkPermission, useDynamicDef)
	return
}

// ConvertPipelineToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelineToPB invocations
func (mmConvertPipelineToPB *ConverterMock) ConvertPipelineToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToPB.afterConvertPipelineToPBCounter)
}

// ConvertPipelineToPBBeforeCounter returns a count of ConverterMock.ConvertPipelineToPB invocations
func (mmConvertPipelineToPB *ConverterMock) ConvertPipelineToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelineToPB.beforeConvertPipelineToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelineToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelineToPB *mConverterMockConvertPipelineToPB) Calls() []*ConverterMockConvertPipelineToPBParams {
	mmConvertPipelineToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelineToPBParams, len(mmConvertPipelineToPB.callArgs))
	copy(argCopy, mmConvertPipelineToPB.callArgs)

	mmConvertPipelineToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelineToPBDone returns true if the count of the ConvertPipelineToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelineToPBDone() bool {
	if m.ConvertPipelineToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelineToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelineToPBMock.invocationsDone()
}

// MinimockConvertPipelineToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelineToPBInspect() {
	for _, e := range m.ConvertPipelineToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToPB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertPipelineToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelineToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelineToPBMock.defaultExpectation != nil && afterConvertPipelineToPBCounter < 1 {
		if m.ConvertPipelineToPBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToPB at\n%s", m.ConvertPipelineToPBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToPB at\n%s with params: %#v", m.ConvertPipelineToPBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertPipelineToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelineToPB != nil && afterConvertPipelineToPBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertPipelineToPB at\n%s", m.funcConvertPipelineToPBOrigin)
	}

	if !m.ConvertPipelineToPBMock.invocationsDone() && afterConvertPipelineToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelineToPB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelineToPBMock.expectedInvocations), m.ConvertPipelineToPBMock.expectedInvocationsOrigin, afterConvertPipelineToPBCounter)
	}
}

type mConverterMockConvertPipelinesToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertPipelinesToPBExpectation
	expectations       []*ConverterMockConvertPipelinesToPBExpectation

	callArgs []*ConverterMockConvertPipelinesToPBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertPipelinesToPBExpectation specifies expectation struct of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertPipelinesToPBParams
	paramPtrs          *ConverterMockConvertPipelinesToPBParamPtrs
	expectationOrigins ConverterMockConvertPipelinesToPBExpectationOrigins
	results            *ConverterMockConvertPipelinesToPBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertPipelinesToPBParams contains parameters of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBParams struct {
	ctx             context.Context
	dbPipelines     []*datamodel.Pipeline
	view            pb.Pipeline_View
	checkPermission bool
}

// ConverterMockConvertPipelinesToPBParamPtrs contains pointers to parameters of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBParamPtrs struct {
	ctx             *context.Context
	dbPipelines     *[]*datamodel.Pipeline
	view            *pb.Pipeline_View
	checkPermission *bool
}

// ConverterMockConvertPipelinesToPBResults contains results of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBResults struct {
	ppa1 []*pb.Pipeline
	err  error
}

// ConverterMockConvertPipelinesToPBOrigins contains origins of expectations of the Converter.ConvertPipelinesToPB
type ConverterMockConvertPipelinesToPBExpectationOrigins struct {
	origin                string
	originCtx             string
	originDbPipelines     string
	originView            string
	originCheckPermission string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Optional() *mConverterMockConvertPipelinesToPB {
	mmConvertPipelinesToPB.optional = true
	return mmConvertPipelinesToPB
}

// Expect sets up expected params for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Expect(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by ExpectParams functions")
	}

	mmConvertPipelinesToPB.defaultExpectation.params = &ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission}
	mmConvertPipelinesToPB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertPipelinesToPB.expectations {
		if minimock.Equal(e.params, mmConvertPipelinesToPB.defaultExpectation.params) {
			mmConvertPipelinesToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertPipelinesToPB.defaultExpectation.params)
		}
	}

	return mmConvertPipelinesToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertPipelinesToPB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertPipelinesToPB
}

// ExpectDbPipelinesParam2 sets up expected param dbPipelines for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectDbPipelinesParam2(dbPipelines []*datamodel.Pipeline) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.dbPipelines = &dbPipelines
	mmConvertPipelinesToPB.defaultExpectation.expectationOrigins.originDbPipelines = minimock.CallerInfo(1)

	return mmConvertPipelinesToPB
}

// ExpectViewParam3 sets up expected param view for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectViewParam3(view pb.Pipeline_View) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.view = &view
	mmConvertPipelinesToPB.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmConvertPipelinesToPB
}

// ExpectCheckPermissionParam4 sets up expected param checkPermission for Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) ExpectCheckPermissionParam4(checkPermission bool) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{}
	}

	if mmConvertPipelinesToPB.defaultExpectation.params != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Expect")
	}

	if mmConvertPipelinesToPB.defaultExpectation.paramPtrs == nil {
		mmConvertPipelinesToPB.defaultExpectation.paramPtrs = &ConverterMockConvertPipelinesToPBParamPtrs{}
	}
	mmConvertPipelinesToPB.defaultExpectation.paramPtrs.checkPermission = &checkPermission
	mmConvertPipelinesToPB.defaultExpectation.expectationOrigins.originCheckPermission = minimock.CallerInfo(1)

	return mmConvertPipelinesToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Inspect(f func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool)) *mConverterMockConvertPipelinesToPB {
	if mmConvertPipelinesToPB.mock.inspectFuncConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertPipelinesToPB")
	}

	mmConvertPipelinesToPB.mock.inspectFuncConvertPipelinesToPB = f

	return mmConvertPipelinesToPB
}

// Return sets up results that will be returned by Converter.ConvertPipelinesToPB
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Return(ppa1 []*pb.Pipeline, err error) *ConverterMock {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	if mmConvertPipelinesToPB.defaultExpectation == nil {
		mmConvertPipelinesToPB.defaultExpectation = &ConverterMockConvertPipelinesToPBExpectation{mock: mmConvertPipelinesToPB.mock}
	}
	mmConvertPipelinesToPB.defaultExpectation.results = &ConverterMockConvertPipelinesToPBResults{ppa1, err}
	mmConvertPipelinesToPB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertPipelinesToPB.mock
}

// Set uses given function f to mock the Converter.ConvertPipelinesToPB method
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Set(f func(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) (ppa1 []*pb.Pipeline, err error)) *ConverterMock {
	if mmConvertPipelinesToPB.defaultExpectation != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertPipelinesToPB method")
	}

	if len(mmConvertPipelinesToPB.expectations) > 0 {
		mmConvertPipelinesToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertPipelinesToPB method")
	}

	mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB = f
	mmConvertPipelinesToPB.mock.funcConvertPipelinesToPBOrigin = minimock.CallerInfo(1)
	return mmConvertPipelinesToPB.mock
}

// When sets expectation for the Converter.ConvertPipelinesToPB which will trigger the result defined by the following
// Then helper
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) When(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) *ConverterMockConvertPipelinesToPBExpectation {
	if mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.mock.t.Fatalf("ConverterMock.ConvertPipelinesToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertPipelinesToPBExpectation{
		mock:               mmConvertPipelinesToPB.mock,
		params:             &ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission},
		expectationOrigins: ConverterMockConvertPipelinesToPBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertPipelinesToPB.expectations = append(mmConvertPipelinesToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertPipelinesToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertPipelinesToPBExpectation) Then(ppa1 []*pb.Pipeline, err error) *ConverterMock {
	e.results = &ConverterMockConvertPipelinesToPBResults{ppa1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertPipelinesToPB should be invoked
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Times(n uint64) *mConverterMockConvertPipelinesToPB {
	if n == 0 {
		mmConvertPipelinesToPB.mock.t.Fatalf("Times of ConverterMock.ConvertPipelinesToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertPipelinesToPB.expectedInvocations, n)
	mmConvertPipelinesToPB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertPipelinesToPB
}

func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) invocationsDone() bool {
	if len(mmConvertPipelinesToPB.expectations) == 0 && mmConvertPipelinesToPB.defaultExpectation == nil && mmConvertPipelinesToPB.mock.funcConvertPipelinesToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertPipelinesToPB.mock.afterConvertPipelinesToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertPipelinesToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertPipelinesToPB implements mm_service.Converter
func (mmConvertPipelinesToPB *ConverterMock) ConvertPipelinesToPB(ctx context.Context, dbPipelines []*datamodel.Pipeline, view pb.Pipeline_View, checkPermission bool) (ppa1 []*pb.Pipeline, err error) {
	mm_atomic.AddUint64(&mmConvertPipelinesToPB.beforeConvertPipelinesToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertPipelinesToPB.afterConvertPipelinesToPBCounter, 1)

	mmConvertPipelinesToPB.t.Helper()

	if mmConvertPipelinesToPB.inspectFuncConvertPipelinesToPB != nil {
		mmConvertPipelinesToPB.inspectFuncConvertPipelinesToPB(ctx, dbPipelines, view, checkPermission)
	}

	mm_params := ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission}

	// Record call args
	mmConvertPipelinesToPB.ConvertPipelinesToPBMock.mutex.Lock()
	mmConvertPipelinesToPB.ConvertPipelinesToPBMock.callArgs = append(mmConvertPipelinesToPB.ConvertPipelinesToPBMock.callArgs, &mm_params)
	mmConvertPipelinesToPB.ConvertPipelinesToPBMock.mutex.Unlock()

	for _, e := range mmConvertPipelinesToPB.ConvertPipelinesToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertPipelinesToPBParams{ctx, dbPipelines, view, checkPermission}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbPipelines != nil && !minimock.Equal(*mm_want_ptrs.dbPipelines, mm_got.dbPipelines) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter dbPipelines, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.expectationOrigins.originDbPipelines, *mm_want_ptrs.dbPipelines, mm_got.dbPipelines, minimock.Diff(*mm_want_ptrs.dbPipelines, mm_got.dbPipelines))
			}

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

			if mm_want_ptrs.checkPermission != nil && !minimock.Equal(*mm_want_ptrs.checkPermission, mm_got.checkPermission) {
				mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameter checkPermission, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.expectationOrigins.originCheckPermission, *mm_want_ptrs.checkPermission, mm_got.checkPermission, minimock.Diff(*mm_want_ptrs.checkPermission, mm_got.checkPermission))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertPipelinesToPB.t.Errorf("ConverterMock.ConvertPipelinesToPB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertPipelinesToPB.ConvertPipelinesToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertPipelinesToPB.t.Fatal("No results are set for the ConverterMock.ConvertPipelinesToPB")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmConvertPipelinesToPB.funcConvertPipelinesToPB != nil {
		return mmConvertPipelinesToPB.funcConvertPipelinesToPB(ctx, dbPipelines, view, checkPermission)
	}
	mmConvertPipelinesToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertPipelinesToPB. %v %v %v %v", ctx, dbPipelines, view, checkPermission)
	return
}

// ConvertPipelinesToPBAfterCounter returns a count of finished ConverterMock.ConvertPipelinesToPB invocations
func (mmConvertPipelinesToPB *ConverterMock) ConvertPipelinesToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelinesToPB.afterConvertPipelinesToPBCounter)
}

// ConvertPipelinesToPBBeforeCounter returns a count of ConverterMock.ConvertPipelinesToPB invocations
func (mmConvertPipelinesToPB *ConverterMock) ConvertPipelinesToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertPipelinesToPB.beforeConvertPipelinesToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertPipelinesToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertPipelinesToPB *mConverterMockConvertPipelinesToPB) Calls() []*ConverterMockConvertPipelinesToPBParams {
	mmConvertPipelinesToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertPipelinesToPBParams, len(mmConvertPipelinesToPB.callArgs))
	copy(argCopy, mmConvertPipelinesToPB.callArgs)

	mmConvertPipelinesToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertPipelinesToPBDone returns true if the count of the ConvertPipelinesToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertPipelinesToPBDone() bool {
	if m.ConvertPipelinesToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertPipelinesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertPipelinesToPBMock.invocationsDone()
}

// MinimockConvertPipelinesToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertPipelinesToPBInspect() {
	for _, e := range m.ConvertPipelinesToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelinesToPB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertPipelinesToPBCounter := mm_atomic.LoadUint64(&m.afterConvertPipelinesToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertPipelinesToPBMock.defaultExpectation != nil && afterConvertPipelinesToPBCounter < 1 {
		if m.ConvertPipelinesToPBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelinesToPB at\n%s", m.ConvertPipelinesToPBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertPipelinesToPB at\n%s with params: %#v", m.ConvertPipelinesToPBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertPipelinesToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertPipelinesToPB != nil && afterConvertPipelinesToPBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertPipelinesToPB at\n%s", m.funcConvertPipelinesToPBOrigin)
	}

	if !m.ConvertPipelinesToPBMock.invocationsDone() && afterConvertPipelinesToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertPipelinesToPB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertPipelinesToPBMock.expectedInvocations), m.ConvertPipelinesToPBMock.expectedInvocationsOrigin, afterConvertPipelinesToPBCounter)
	}
}

type mConverterMockConvertSecretToDB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertSecretToDBExpectation
	expectations       []*ConverterMockConvertSecretToDBExpectation

	callArgs []*ConverterMockConvertSecretToDBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertSecretToDBExpectation specifies expectation struct of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertSecretToDBParams
	paramPtrs          *ConverterMockConvertSecretToDBParamPtrs
	expectationOrigins ConverterMockConvertSecretToDBExpectationOrigins
	results            *ConverterMockConvertSecretToDBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertSecretToDBParams contains parameters of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBParams struct {
	ctx      context.Context
	ns       resource.Namespace
	pbSecret *pb.Secret
}

// ConverterMockConvertSecretToDBParamPtrs contains pointers to parameters of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBParamPtrs struct {
	ctx      *context.Context
	ns       *resource.Namespace
	pbSecret **pb.Secret
}

// ConverterMockConvertSecretToDBResults contains results of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBResults struct {
	sp1 *datamodel.Secret
	err error
}

// ConverterMockConvertSecretToDBOrigins contains origins of expectations of the Converter.ConvertSecretToDB
type ConverterMockConvertSecretToDBExpectationOrigins struct {
	origin         string
	originCtx      string
	originNs       string
	originPbSecret string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Optional() *mConverterMockConvertSecretToDB {
	mmConvertSecretToDB.optional = true
	return mmConvertSecretToDB
}

// Expect sets up expected params for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Expect(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by ExpectParams functions")
	}

	mmConvertSecretToDB.defaultExpectation.params = &ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret}
	mmConvertSecretToDB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertSecretToDB.expectations {
		if minimock.Equal(e.params, mmConvertSecretToDB.defaultExpectation.params) {
			mmConvertSecretToDB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertSecretToDB.defaultExpectation.params)
		}
	}

	return mmConvertSecretToDB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.params != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Expect")
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToDB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToDBParamPtrs{}
	}
	mmConvertSecretToDB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertSecretToDB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertSecretToDB
}

// ExpectNsParam2 sets up expected param ns for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) ExpectNsParam2(ns resource.Namespace) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.params != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Expect")
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToDB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToDBParamPtrs{}
	}
	mmConvertSecretToDB.defaultExpectation.paramPtrs.ns = &ns
	mmConvertSecretToDB.defaultExpectation.expectationOrigins.originNs = minimock.CallerInfo(1)

	return mmConvertSecretToDB
}

// ExpectPbSecretParam3 sets up expected param pbSecret for Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) ExpectPbSecretParam3(pbSecret *pb.Secret) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{}
	}

	if mmConvertSecretToDB.defaultExpectation.params != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Expect")
	}

	if mmConvertSecretToDB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToDB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToDBParamPtrs{}
	}
	mmConvertSecretToDB.defaultExpectation.paramPtrs.pbSecret = &pbSecret
	mmConvertSecretToDB.defaultExpectation.expectationOrigins.originPbSecret = minimock.CallerInfo(1)

	return mmConvertSecretToDB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Inspect(f func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret)) *mConverterMockConvertSecretToDB {
	if mmConvertSecretToDB.mock.inspectFuncConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertSecretToDB")
	}

	mmConvertSecretToDB.mock.inspectFuncConvertSecretToDB = f

	return mmConvertSecretToDB
}

// Return sets up results that will be returned by Converter.ConvertSecretToDB
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Return(sp1 *datamodel.Secret, err error) *ConverterMock {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	if mmConvertSecretToDB.defaultExpectation == nil {
		mmConvertSecretToDB.defaultExpectation = &ConverterMockConvertSecretToDBExpectation{mock: mmConvertSecretToDB.mock}
	}
	mmConvertSecretToDB.defaultExpectation.results = &ConverterMockConvertSecretToDBResults{sp1, err}
	mmConvertSecretToDB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertSecretToDB.mock
}

// Set uses given function f to mock the Converter.ConvertSecretToDB method
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Set(f func(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) (sp1 *datamodel.Secret, err error)) *ConverterMock {
	if mmConvertSecretToDB.defaultExpectation != nil {
		mmConvertSecretToDB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertSecretToDB method")
	}

	if len(mmConvertSecretToDB.expectations) > 0 {
		mmConvertSecretToDB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertSecretToDB method")
	}

	mmConvertSecretToDB.mock.funcConvertSecretToDB = f
	mmConvertSecretToDB.mock.funcConvertSecretToDBOrigin = minimock.CallerInfo(1)
	return mmConvertSecretToDB.mock
}

// When sets expectation for the Converter.ConvertSecretToDB which will trigger the result defined by the following
// Then helper
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) When(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) *ConverterMockConvertSecretToDBExpectation {
	if mmConvertSecretToDB.mock.funcConvertSecretToDB != nil {
		mmConvertSecretToDB.mock.t.Fatalf("ConverterMock.ConvertSecretToDB mock is already set by Set")
	}

	expectation := &ConverterMockConvertSecretToDBExpectation{
		mock:               mmConvertSecretToDB.mock,
		params:             &ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret},
		expectationOrigins: ConverterMockConvertSecretToDBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertSecretToDB.expectations = append(mmConvertSecretToDB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertSecretToDB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertSecretToDBExpectation) Then(sp1 *datamodel.Secret, err error) *ConverterMock {
	e.results = &ConverterMockConvertSecretToDBResults{sp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertSecretToDB should be invoked
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Times(n uint64) *mConverterMockConvertSecretToDB {
	if n == 0 {
		mmConvertSecretToDB.mock.t.Fatalf("Times of ConverterMock.ConvertSecretToDB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertSecretToDB.expectedInvocations, n)
	mmConvertSecretToDB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertSecretToDB
}

func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) invocationsDone() bool {
	if len(mmConvertSecretToDB.expectations) == 0 && mmConvertSecretToDB.defaultExpectation == nil && mmConvertSecretToDB.mock.funcConvertSecretToDB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertSecretToDB.mock.afterConvertSecretToDBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertSecretToDB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertSecretToDB implements mm_service.Converter
func (mmConvertSecretToDB *ConverterMock) ConvertSecretToDB(ctx context.Context, ns resource.Namespace, pbSecret *pb.Secret) (sp1 *datamodel.Secret, err error) {
	mm_atomic.AddUint64(&mmConvertSecretToDB.beforeConvertSecretToDBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertSecretToDB.afterConvertSecretToDBCounter, 1)

	mmConvertSecretToDB.t.Helper()

	if mmConvertSecretToDB.inspectFuncConvertSecretToDB != nil {
		mmConvertSecretToDB.inspectFuncConvertSecretToDB(ctx, ns, pbSecret)
	}

	mm_params := ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret}

	// Record call args
	mmConvertSecretToDB.ConvertSecretToDBMock.mutex.Lock()
	mmConvertSecretToDB.ConvertSecretToDBMock.callArgs = append(mmConvertSecretToDB.ConvertSecretToDBMock.callArgs, &mm_params)
	mmConvertSecretToDB.ConvertSecretToDBMock.mutex.Unlock()

	for _, e := range mmConvertSecretToDB.ConvertSecretToDBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertSecretToDBParams{ctx, ns, pbSecret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ns != nil && !minimock.Equal(*mm_want_ptrs.ns, mm_got.ns) {
				mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameter ns, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.expectationOrigins.originNs, *mm_want_ptrs.ns, mm_got.ns, minimock.Diff(*mm_want_ptrs.ns, mm_got.ns))
			}

			if mm_want_ptrs.pbSecret != nil && !minimock.Equal(*mm_want_ptrs.pbSecret, mm_got.pbSecret) {
				mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameter pbSecret, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.expectationOrigins.originPbSecret, *mm_want_ptrs.pbSecret, mm_got.pbSecret, minimock.Diff(*mm_want_ptrs.pbSecret, mm_got.pbSecret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertSecretToDB.t.Errorf("ConverterMock.ConvertSecretToDB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertSecretToDB.ConvertSecretToDBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertSecretToDB.t.Fatal("No results are set for the ConverterMock.ConvertSecretToDB")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmConvertSecretToDB.funcConvertSecretToDB != nil {
		return mmConvertSecretToDB.funcConvertSecretToDB(ctx, ns, pbSecret)
	}
	mmConvertSecretToDB.t.Fatalf("Unexpected call to ConverterMock.ConvertSecretToDB. %v %v %v", ctx, ns, pbSecret)
	return
}

// ConvertSecretToDBAfterCounter returns a count of finished ConverterMock.ConvertSecretToDB invocations
func (mmConvertSecretToDB *ConverterMock) ConvertSecretToDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToDB.afterConvertSecretToDBCounter)
}

// ConvertSecretToDBBeforeCounter returns a count of ConverterMock.ConvertSecretToDB invocations
func (mmConvertSecretToDB *ConverterMock) ConvertSecretToDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToDB.beforeConvertSecretToDBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertSecretToDB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertSecretToDB *mConverterMockConvertSecretToDB) Calls() []*ConverterMockConvertSecretToDBParams {
	mmConvertSecretToDB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertSecretToDBParams, len(mmConvertSecretToDB.callArgs))
	copy(argCopy, mmConvertSecretToDB.callArgs)

	mmConvertSecretToDB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertSecretToDBDone returns true if the count of the ConvertSecretToDB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertSecretToDBDone() bool {
	if m.ConvertSecretToDBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertSecretToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertSecretToDBMock.invocationsDone()
}

// MinimockConvertSecretToDBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertSecretToDBInspect() {
	for _, e := range m.ConvertSecretToDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToDB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertSecretToDBCounter := mm_atomic.LoadUint64(&m.afterConvertSecretToDBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSecretToDBMock.defaultExpectation != nil && afterConvertSecretToDBCounter < 1 {
		if m.ConvertSecretToDBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToDB at\n%s", m.ConvertSecretToDBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToDB at\n%s with params: %#v", m.ConvertSecretToDBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertSecretToDBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSecretToDB != nil && afterConvertSecretToDBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertSecretToDB at\n%s", m.funcConvertSecretToDBOrigin)
	}

	if !m.ConvertSecretToDBMock.invocationsDone() && afterConvertSecretToDBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertSecretToDB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertSecretToDBMock.expectedInvocations), m.ConvertSecretToDBMock.expectedInvocationsOrigin, afterConvertSecretToDBCounter)
	}
}

type mConverterMockConvertSecretToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertSecretToPBExpectation
	expectations       []*ConverterMockConvertSecretToPBExpectation

	callArgs []*ConverterMockConvertSecretToPBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertSecretToPBExpectation specifies expectation struct of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertSecretToPBParams
	paramPtrs          *ConverterMockConvertSecretToPBParamPtrs
	expectationOrigins ConverterMockConvertSecretToPBExpectationOrigins
	results            *ConverterMockConvertSecretToPBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertSecretToPBParams contains parameters of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBParams struct {
	ctx      context.Context
	dbSecret *datamodel.Secret
}

// ConverterMockConvertSecretToPBParamPtrs contains pointers to parameters of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBParamPtrs struct {
	ctx      *context.Context
	dbSecret **datamodel.Secret
}

// ConverterMockConvertSecretToPBResults contains results of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBResults struct {
	sp1 *pb.Secret
	err error
}

// ConverterMockConvertSecretToPBOrigins contains origins of expectations of the Converter.ConvertSecretToPB
type ConverterMockConvertSecretToPBExpectationOrigins struct {
	origin         string
	originCtx      string
	originDbSecret string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Optional() *mConverterMockConvertSecretToPB {
	mmConvertSecretToPB.optional = true
	return mmConvertSecretToPB
}

// Expect sets up expected params for Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Expect(ctx context.Context, dbSecret *datamodel.Secret) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{}
	}

	if mmConvertSecretToPB.defaultExpectation.paramPtrs != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by ExpectParams functions")
	}

	mmConvertSecretToPB.defaultExpectation.params = &ConverterMockConvertSecretToPBParams{ctx, dbSecret}
	mmConvertSecretToPB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertSecretToPB.expectations {
		if minimock.Equal(e.params, mmConvertSecretToPB.defaultExpectation.params) {
			mmConvertSecretToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertSecretToPB.defaultExpectation.params)
		}
	}

	return mmConvertSecretToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{}
	}

	if mmConvertSecretToPB.defaultExpectation.params != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Expect")
	}

	if mmConvertSecretToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToPBParamPtrs{}
	}
	mmConvertSecretToPB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertSecretToPB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertSecretToPB
}

// ExpectDbSecretParam2 sets up expected param dbSecret for Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) ExpectDbSecretParam2(dbSecret *datamodel.Secret) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{}
	}

	if mmConvertSecretToPB.defaultExpectation.params != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Expect")
	}

	if mmConvertSecretToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretToPBParamPtrs{}
	}
	mmConvertSecretToPB.defaultExpectation.paramPtrs.dbSecret = &dbSecret
	mmConvertSecretToPB.defaultExpectation.expectationOrigins.originDbSecret = minimock.CallerInfo(1)

	return mmConvertSecretToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Inspect(f func(ctx context.Context, dbSecret *datamodel.Secret)) *mConverterMockConvertSecretToPB {
	if mmConvertSecretToPB.mock.inspectFuncConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertSecretToPB")
	}

	mmConvertSecretToPB.mock.inspectFuncConvertSecretToPB = f

	return mmConvertSecretToPB
}

// Return sets up results that will be returned by Converter.ConvertSecretToPB
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Return(sp1 *pb.Secret, err error) *ConverterMock {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	if mmConvertSecretToPB.defaultExpectation == nil {
		mmConvertSecretToPB.defaultExpectation = &ConverterMockConvertSecretToPBExpectation{mock: mmConvertSecretToPB.mock}
	}
	mmConvertSecretToPB.defaultExpectation.results = &ConverterMockConvertSecretToPBResults{sp1, err}
	mmConvertSecretToPB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertSecretToPB.mock
}

// Set uses given function f to mock the Converter.ConvertSecretToPB method
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Set(f func(ctx context.Context, dbSecret *datamodel.Secret) (sp1 *pb.Secret, err error)) *ConverterMock {
	if mmConvertSecretToPB.defaultExpectation != nil {
		mmConvertSecretToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertSecretToPB method")
	}

	if len(mmConvertSecretToPB.expectations) > 0 {
		mmConvertSecretToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertSecretToPB method")
	}

	mmConvertSecretToPB.mock.funcConvertSecretToPB = f
	mmConvertSecretToPB.mock.funcConvertSecretToPBOrigin = minimock.CallerInfo(1)
	return mmConvertSecretToPB.mock
}

// When sets expectation for the Converter.ConvertSecretToPB which will trigger the result defined by the following
// Then helper
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) When(ctx context.Context, dbSecret *datamodel.Secret) *ConverterMockConvertSecretToPBExpectation {
	if mmConvertSecretToPB.mock.funcConvertSecretToPB != nil {
		mmConvertSecretToPB.mock.t.Fatalf("ConverterMock.ConvertSecretToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertSecretToPBExpectation{
		mock:               mmConvertSecretToPB.mock,
		params:             &ConverterMockConvertSecretToPBParams{ctx, dbSecret},
		expectationOrigins: ConverterMockConvertSecretToPBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertSecretToPB.expectations = append(mmConvertSecretToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertSecretToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertSecretToPBExpectation) Then(sp1 *pb.Secret, err error) *ConverterMock {
	e.results = &ConverterMockConvertSecretToPBResults{sp1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertSecretToPB should be invoked
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Times(n uint64) *mConverterMockConvertSecretToPB {
	if n == 0 {
		mmConvertSecretToPB.mock.t.Fatalf("Times of ConverterMock.ConvertSecretToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertSecretToPB.expectedInvocations, n)
	mmConvertSecretToPB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertSecretToPB
}

func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) invocationsDone() bool {
	if len(mmConvertSecretToPB.expectations) == 0 && mmConvertSecretToPB.defaultExpectation == nil && mmConvertSecretToPB.mock.funcConvertSecretToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertSecretToPB.mock.afterConvertSecretToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertSecretToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertSecretToPB implements mm_service.Converter
func (mmConvertSecretToPB *ConverterMock) ConvertSecretToPB(ctx context.Context, dbSecret *datamodel.Secret) (sp1 *pb.Secret, err error) {
	mm_atomic.AddUint64(&mmConvertSecretToPB.beforeConvertSecretToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertSecretToPB.afterConvertSecretToPBCounter, 1)

	mmConvertSecretToPB.t.Helper()

	if mmConvertSecretToPB.inspectFuncConvertSecretToPB != nil {
		mmConvertSecretToPB.inspectFuncConvertSecretToPB(ctx, dbSecret)
	}

	mm_params := ConverterMockConvertSecretToPBParams{ctx, dbSecret}

	// Record call args
	mmConvertSecretToPB.ConvertSecretToPBMock.mutex.Lock()
	mmConvertSecretToPB.ConvertSecretToPBMock.callArgs = append(mmConvertSecretToPB.ConvertSecretToPBMock.callArgs, &mm_params)
	mmConvertSecretToPB.ConvertSecretToPBMock.mutex.Unlock()

	for _, e := range mmConvertSecretToPB.ConvertSecretToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertSecretToPBParams{ctx, dbSecret}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertSecretToPB.t.Errorf("ConverterMock.ConvertSecretToPB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbSecret != nil && !minimock.Equal(*mm_want_ptrs.dbSecret, mm_got.dbSecret) {
				mmConvertSecretToPB.t.Errorf("ConverterMock.ConvertSecretToPB got unexpected parameter dbSecret, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.expectationOrigins.originDbSecret, *mm_want_ptrs.dbSecret, mm_got.dbSecret, minimock.Diff(*mm_want_ptrs.dbSecret, mm_got.dbSecret))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertSecretToPB.t.Errorf("ConverterMock.ConvertSecretToPB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertSecretToPB.ConvertSecretToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertSecretToPB.t.Fatal("No results are set for the ConverterMock.ConvertSecretToPB")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmConvertSecretToPB.funcConvertSecretToPB != nil {
		return mmConvertSecretToPB.funcConvertSecretToPB(ctx, dbSecret)
	}
	mmConvertSecretToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertSecretToPB. %v %v", ctx, dbSecret)
	return
}

// ConvertSecretToPBAfterCounter returns a count of finished ConverterMock.ConvertSecretToPB invocations
func (mmConvertSecretToPB *ConverterMock) ConvertSecretToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToPB.afterConvertSecretToPBCounter)
}

// ConvertSecretToPBBeforeCounter returns a count of ConverterMock.ConvertSecretToPB invocations
func (mmConvertSecretToPB *ConverterMock) ConvertSecretToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretToPB.beforeConvertSecretToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertSecretToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertSecretToPB *mConverterMockConvertSecretToPB) Calls() []*ConverterMockConvertSecretToPBParams {
	mmConvertSecretToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertSecretToPBParams, len(mmConvertSecretToPB.callArgs))
	copy(argCopy, mmConvertSecretToPB.callArgs)

	mmConvertSecretToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertSecretToPBDone returns true if the count of the ConvertSecretToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertSecretToPBDone() bool {
	if m.ConvertSecretToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertSecretToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertSecretToPBMock.invocationsDone()
}

// MinimockConvertSecretToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertSecretToPBInspect() {
	for _, e := range m.ConvertSecretToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToPB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertSecretToPBCounter := mm_atomic.LoadUint64(&m.afterConvertSecretToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSecretToPBMock.defaultExpectation != nil && afterConvertSecretToPBCounter < 1 {
		if m.ConvertSecretToPBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToPB at\n%s", m.ConvertSecretToPBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretToPB at\n%s with params: %#v", m.ConvertSecretToPBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertSecretToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSecretToPB != nil && afterConvertSecretToPBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertSecretToPB at\n%s", m.funcConvertSecretToPBOrigin)
	}

	if !m.ConvertSecretToPBMock.invocationsDone() && afterConvertSecretToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertSecretToPB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertSecretToPBMock.expectedInvocations), m.ConvertSecretToPBMock.expectedInvocationsOrigin, afterConvertSecretToPBCounter)
	}
}

type mConverterMockConvertSecretsToPB struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockConvertSecretsToPBExpectation
	expectations       []*ConverterMockConvertSecretsToPBExpectation

	callArgs []*ConverterMockConvertSecretsToPBParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockConvertSecretsToPBExpectation specifies expectation struct of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockConvertSecretsToPBParams
	paramPtrs          *ConverterMockConvertSecretsToPBParamPtrs
	expectationOrigins ConverterMockConvertSecretsToPBExpectationOrigins
	results            *ConverterMockConvertSecretsToPBResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockConvertSecretsToPBParams contains parameters of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBParams struct {
	ctx       context.Context
	dbSecrets []*datamodel.Secret
}

// ConverterMockConvertSecretsToPBParamPtrs contains pointers to parameters of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBParamPtrs struct {
	ctx       *context.Context
	dbSecrets *[]*datamodel.Secret
}

// ConverterMockConvertSecretsToPBResults contains results of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBResults struct {
	spa1 []*pb.Secret
	err  error
}

// ConverterMockConvertSecretsToPBOrigins contains origins of expectations of the Converter.ConvertSecretsToPB
type ConverterMockConvertSecretsToPBExpectationOrigins struct {
	origin          string
	originCtx       string
	originDbSecrets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Optional() *mConverterMockConvertSecretsToPB {
	mmConvertSecretsToPB.optional = true
	return mmConvertSecretsToPB
}

// Expect sets up expected params for Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Expect(ctx context.Context, dbSecrets []*datamodel.Secret) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{}
	}

	if mmConvertSecretsToPB.defaultExpectation.paramPtrs != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by ExpectParams functions")
	}

	mmConvertSecretsToPB.defaultExpectation.params = &ConverterMockConvertSecretsToPBParams{ctx, dbSecrets}
	mmConvertSecretsToPB.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmConvertSecretsToPB.expectations {
		if minimock.Equal(e.params, mmConvertSecretsToPB.defaultExpectation.params) {
			mmConvertSecretsToPB.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConvertSecretsToPB.defaultExpectation.params)
		}
	}

	return mmConvertSecretsToPB
}

// ExpectCtxParam1 sets up expected param ctx for Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) ExpectCtxParam1(ctx context.Context) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{}
	}

	if mmConvertSecretsToPB.defaultExpectation.params != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Expect")
	}

	if mmConvertSecretsToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretsToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretsToPBParamPtrs{}
	}
	mmConvertSecretsToPB.defaultExpectation.paramPtrs.ctx = &ctx
	mmConvertSecretsToPB.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmConvertSecretsToPB
}

// ExpectDbSecretsParam2 sets up expected param dbSecrets for Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) ExpectDbSecretsParam2(dbSecrets []*datamodel.Secret) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{}
	}

	if mmConvertSecretsToPB.defaultExpectation.params != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Expect")
	}

	if mmConvertSecretsToPB.defaultExpectation.paramPtrs == nil {
		mmConvertSecretsToPB.defaultExpectation.paramPtrs = &ConverterMockConvertSecretsToPBParamPtrs{}
	}
	mmConvertSecretsToPB.defaultExpectation.paramPtrs.dbSecrets = &dbSecrets
	mmConvertSecretsToPB.defaultExpectation.expectationOrigins.originDbSecrets = minimock.CallerInfo(1)

	return mmConvertSecretsToPB
}

// Inspect accepts an inspector function that has same arguments as the Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Inspect(f func(ctx context.Context, dbSecrets []*datamodel.Secret)) *mConverterMockConvertSecretsToPB {
	if mmConvertSecretsToPB.mock.inspectFuncConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("Inspect function is already set for ConverterMock.ConvertSecretsToPB")
	}

	mmConvertSecretsToPB.mock.inspectFuncConvertSecretsToPB = f

	return mmConvertSecretsToPB
}

// Return sets up results that will be returned by Converter.ConvertSecretsToPB
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Return(spa1 []*pb.Secret, err error) *ConverterMock {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	if mmConvertSecretsToPB.defaultExpectation == nil {
		mmConvertSecretsToPB.defaultExpectation = &ConverterMockConvertSecretsToPBExpectation{mock: mmConvertSecretsToPB.mock}
	}
	mmConvertSecretsToPB.defaultExpectation.results = &ConverterMockConvertSecretsToPBResults{spa1, err}
	mmConvertSecretsToPB.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConvertSecretsToPB.mock
}

// Set uses given function f to mock the Converter.ConvertSecretsToPB method
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Set(f func(ctx context.Context, dbSecrets []*datamodel.Secret) (spa1 []*pb.Secret, err error)) *ConverterMock {
	if mmConvertSecretsToPB.defaultExpectation != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("Default expectation is already set for the Converter.ConvertSecretsToPB method")
	}

	if len(mmConvertSecretsToPB.expectations) > 0 {
		mmConvertSecretsToPB.mock.t.Fatalf("Some expectations are already set for the Converter.ConvertSecretsToPB method")
	}

	mmConvertSecretsToPB.mock.funcConvertSecretsToPB = f
	mmConvertSecretsToPB.mock.funcConvertSecretsToPBOrigin = minimock.CallerInfo(1)
	return mmConvertSecretsToPB.mock
}

// When sets expectation for the Converter.ConvertSecretsToPB which will trigger the result defined by the following
// Then helper
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) When(ctx context.Context, dbSecrets []*datamodel.Secret) *ConverterMockConvertSecretsToPBExpectation {
	if mmConvertSecretsToPB.mock.funcConvertSecretsToPB != nil {
		mmConvertSecretsToPB.mock.t.Fatalf("ConverterMock.ConvertSecretsToPB mock is already set by Set")
	}

	expectation := &ConverterMockConvertSecretsToPBExpectation{
		mock:               mmConvertSecretsToPB.mock,
		params:             &ConverterMockConvertSecretsToPBParams{ctx, dbSecrets},
		expectationOrigins: ConverterMockConvertSecretsToPBExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmConvertSecretsToPB.expectations = append(mmConvertSecretsToPB.expectations, expectation)
	return expectation
}

// Then sets up Converter.ConvertSecretsToPB return parameters for the expectation previously defined by the When method
func (e *ConverterMockConvertSecretsToPBExpectation) Then(spa1 []*pb.Secret, err error) *ConverterMock {
	e.results = &ConverterMockConvertSecretsToPBResults{spa1, err}
	return e.mock
}

// Times sets number of times Converter.ConvertSecretsToPB should be invoked
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Times(n uint64) *mConverterMockConvertSecretsToPB {
	if n == 0 {
		mmConvertSecretsToPB.mock.t.Fatalf("Times of ConverterMock.ConvertSecretsToPB mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConvertSecretsToPB.expectedInvocations, n)
	mmConvertSecretsToPB.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConvertSecretsToPB
}

func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) invocationsDone() bool {
	if len(mmConvertSecretsToPB.expectations) == 0 && mmConvertSecretsToPB.defaultExpectation == nil && mmConvertSecretsToPB.mock.funcConvertSecretsToPB == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConvertSecretsToPB.mock.afterConvertSecretsToPBCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConvertSecretsToPB.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ConvertSecretsToPB implements mm_service.Converter
func (mmConvertSecretsToPB *ConverterMock) ConvertSecretsToPB(ctx context.Context, dbSecrets []*datamodel.Secret) (spa1 []*pb.Secret, err error) {
	mm_atomic.AddUint64(&mmConvertSecretsToPB.beforeConvertSecretsToPBCounter, 1)
	defer mm_atomic.AddUint64(&mmConvertSecretsToPB.afterConvertSecretsToPBCounter, 1)

	mmConvertSecretsToPB.t.Helper()

	if mmConvertSecretsToPB.inspectFuncConvertSecretsToPB != nil {
		mmConvertSecretsToPB.inspectFuncConvertSecretsToPB(ctx, dbSecrets)
	}

	mm_params := ConverterMockConvertSecretsToPBParams{ctx, dbSecrets}

	// Record call args
	mmConvertSecretsToPB.ConvertSecretsToPBMock.mutex.Lock()
	mmConvertSecretsToPB.ConvertSecretsToPBMock.callArgs = append(mmConvertSecretsToPB.ConvertSecretsToPBMock.callArgs, &mm_params)
	mmConvertSecretsToPB.ConvertSecretsToPBMock.mutex.Unlock()

	for _, e := range mmConvertSecretsToPB.ConvertSecretsToPBMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.err
		}
	}

	if mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.Counter, 1)
		mm_want := mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.params
		mm_want_ptrs := mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockConvertSecretsToPBParams{ctx, dbSecrets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmConvertSecretsToPB.t.Errorf("ConverterMock.ConvertSecretsToPB got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.dbSecrets != nil && !minimock.Equal(*mm_want_ptrs.dbSecrets, mm_got.dbSecrets) {
				mmConvertSecretsToPB.t.Errorf("ConverterMock.ConvertSecretsToPB got unexpected parameter dbSecrets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.expectationOrigins.originDbSecrets, *mm_want_ptrs.dbSecrets, mm_got.dbSecrets, minimock.Diff(*mm_want_ptrs.dbSecrets, mm_got.dbSecrets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConvertSecretsToPB.t.Errorf("ConverterMock.ConvertSecretsToPB got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConvertSecretsToPB.ConvertSecretsToPBMock.defaultExpectation.results
		if mm_results == nil {
			mmConvertSecretsToPB.t.Fatal("No results are set for the ConverterMock.ConvertSecretsToPB")
		}
		return (*mm_results).spa1, (*mm_results).err
	}
	if mmConvertSecretsToPB.funcConvertSecretsToPB != nil {
		return mmConvertSecretsToPB.funcConvertSecretsToPB(ctx, dbSecrets)
	}
	mmConvertSecretsToPB.t.Fatalf("Unexpected call to ConverterMock.ConvertSecretsToPB. %v %v", ctx, dbSecrets)
	return
}

// ConvertSecretsToPBAfterCounter returns a count of finished ConverterMock.ConvertSecretsToPB invocations
func (mmConvertSecretsToPB *ConverterMock) ConvertSecretsToPBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretsToPB.afterConvertSecretsToPBCounter)
}

// ConvertSecretsToPBBeforeCounter returns a count of ConverterMock.ConvertSecretsToPB invocations
func (mmConvertSecretsToPB *ConverterMock) ConvertSecretsToPBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConvertSecretsToPB.beforeConvertSecretsToPBCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.ConvertSecretsToPB.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConvertSecretsToPB *mConverterMockConvertSecretsToPB) Calls() []*ConverterMockConvertSecretsToPBParams {
	mmConvertSecretsToPB.mutex.RLock()

	argCopy := make([]*ConverterMockConvertSecretsToPBParams, len(mmConvertSecretsToPB.callArgs))
	copy(argCopy, mmConvertSecretsToPB.callArgs)

	mmConvertSecretsToPB.mutex.RUnlock()

	return argCopy
}

// MinimockConvertSecretsToPBDone returns true if the count of the ConvertSecretsToPB invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockConvertSecretsToPBDone() bool {
	if m.ConvertSecretsToPBMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConvertSecretsToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConvertSecretsToPBMock.invocationsDone()
}

// MinimockConvertSecretsToPBInspect logs each unmet expectation
func (m *ConverterMock) MinimockConvertSecretsToPBInspect() {
	for _, e := range m.ConvertSecretsToPBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretsToPB at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterConvertSecretsToPBCounter := mm_atomic.LoadUint64(&m.afterConvertSecretsToPBCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConvertSecretsToPBMock.defaultExpectation != nil && afterConvertSecretsToPBCounter < 1 {
		if m.ConvertSecretsToPBMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretsToPB at\n%s", m.ConvertSecretsToPBMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.ConvertSecretsToPB at\n%s with params: %#v", m.ConvertSecretsToPBMock.defaultExpectation.expectationOrigins.origin, *m.ConvertSecretsToPBMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConvertSecretsToPB != nil && afterConvertSecretsToPBCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.ConvertSecretsToPB at\n%s", m.funcConvertSecretsToPBOrigin)
	}

	if !m.ConvertSecretsToPBMock.invocationsDone() && afterConvertSecretsToPBCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.ConvertSecretsToPB at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConvertSecretsToPBMock.expectedInvocations), m.ConvertSecretsToPBMock.expectedInvocationsOrigin, afterConvertSecretsToPBCounter)
	}
}

type mConverterMockGeneratePipelineDataSpec struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockGeneratePipelineDataSpecExpectation
	expectations       []*ConverterMockGeneratePipelineDataSpecExpectation

	callArgs []*ConverterMockGeneratePipelineDataSpecParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockGeneratePipelineDataSpecExpectation specifies expectation struct of the Converter.GeneratePipelineDataSpec
type ConverterMockGeneratePipelineDataSpecExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockGeneratePipelineDataSpecParams
	paramPtrs          *ConverterMockGeneratePipelineDataSpecParamPtrs
	expectationOrigins ConverterMockGeneratePipelineDataSpecExpectationOrigins
	results            *ConverterMockGeneratePipelineDataSpecResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockGeneratePipelineDataSpecParams contains parameters of the Converter.GeneratePipelineDataSpec
type ConverterMockGeneratePipelineDataSpecParams struct {
	variables   map[string]*datamodel.Variable
	outputs     map[string]*datamodel.Output
	compsOrigin datamodel.ComponentMap
}

// ConverterMockGeneratePipelineDataSpecParamPtrs contains pointers to parameters of the Converter.GeneratePipelineDataSpec
type ConverterMockGeneratePipelineDataSpecParamPtrs struct {
	variables   *map[string]*datamodel.Variable
	outputs     *map[string]*datamodel.Output
	compsOrigin *datamodel.ComponentMap
}

// ConverterMockGeneratePipelineDataSpecResults contains results of the Converter.GeneratePipelineDataSpec
type ConverterMockGeneratePipelineDataSpecResults struct {
	dp1 *pb.DataSpecification
	err error
}

// ConverterMockGeneratePipelineDataSpecOrigins contains origins of expectations of the Converter.GeneratePipelineDataSpec
type ConverterMockGeneratePipelineDataSpecExpectationOrigins struct {
	origin            string
	originVariables   string
	originOutputs     string
	originCompsOrigin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) Optional() *mConverterMockGeneratePipelineDataSpec {
	mmGeneratePipelineDataSpec.optional = true
	return mmGeneratePipelineDataSpec
}

// Expect sets up expected params for Converter.GeneratePipelineDataSpec
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) Expect(variables map[string]*datamodel.Variable, outputs map[string]*datamodel.Output, compsOrigin datamodel.ComponentMap) *mConverterMockGeneratePipelineDataSpec {
	if mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Set")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation == nil {
		mmGeneratePipelineDataSpec.defaultExpectation = &ConverterMockGeneratePipelineDataSpecExpectation{}
	}

	if mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by ExpectParams functions")
	}

	mmGeneratePipelineDataSpec.defaultExpectation.params = &ConverterMockGeneratePipelineDataSpecParams{variables, outputs, compsOrigin}
	mmGeneratePipelineDataSpec.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGeneratePipelineDataSpec.expectations {
		if minimock.Equal(e.params, mmGeneratePipelineDataSpec.defaultExpectation.params) {
			mmGeneratePipelineDataSpec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGeneratePipelineDataSpec.defaultExpectation.params)
		}
	}

	return mmGeneratePipelineDataSpec
}

// ExpectVariablesParam1 sets up expected param variables for Converter.GeneratePipelineDataSpec
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) ExpectVariablesParam1(variables map[string]*datamodel.Variable) *mConverterMockGeneratePipelineDataSpec {
	if mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Set")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation == nil {
		mmGeneratePipelineDataSpec.defaultExpectation = &ConverterMockGeneratePipelineDataSpecExpectation{}
	}

	if mmGeneratePipelineDataSpec.defaultExpectation.params != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Expect")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs == nil {
		mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs = &ConverterMockGeneratePipelineDataSpecParamPtrs{}
	}
	mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs.variables = &variables
	mmGeneratePipelineDataSpec.defaultExpectation.expectationOrigins.originVariables = minimock.CallerInfo(1)

	return mmGeneratePipelineDataSpec
}

// ExpectOutputsParam2 sets up expected param outputs for Converter.GeneratePipelineDataSpec
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) ExpectOutputsParam2(outputs map[string]*datamodel.Output) *mConverterMockGeneratePipelineDataSpec {
	if mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Set")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation == nil {
		mmGeneratePipelineDataSpec.defaultExpectation = &ConverterMockGeneratePipelineDataSpecExpectation{}
	}

	if mmGeneratePipelineDataSpec.defaultExpectation.params != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Expect")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs == nil {
		mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs = &ConverterMockGeneratePipelineDataSpecParamPtrs{}
	}
	mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs.outputs = &outputs
	mmGeneratePipelineDataSpec.defaultExpectation.expectationOrigins.originOutputs = minimock.CallerInfo(1)

	return mmGeneratePipelineDataSpec
}

// ExpectCompsOriginParam3 sets up expected param compsOrigin for Converter.GeneratePipelineDataSpec
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) ExpectCompsOriginParam3(compsOrigin datamodel.ComponentMap) *mConverterMockGeneratePipelineDataSpec {
	if mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Set")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation == nil {
		mmGeneratePipelineDataSpec.defaultExpectation = &ConverterMockGeneratePipelineDataSpecExpectation{}
	}

	if mmGeneratePipelineDataSpec.defaultExpectation.params != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Expect")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs == nil {
		mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs = &ConverterMockGeneratePipelineDataSpecParamPtrs{}
	}
	mmGeneratePipelineDataSpec.defaultExpectation.paramPtrs.compsOrigin = &compsOrigin
	mmGeneratePipelineDataSpec.defaultExpectation.expectationOrigins.originCompsOrigin = minimock.CallerInfo(1)

	return mmGeneratePipelineDataSpec
}

// Inspect accepts an inspector function that has same arguments as the Converter.GeneratePipelineDataSpec
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) Inspect(f func(variables map[string]*datamodel.Variable, outputs map[string]*datamodel.Output, compsOrigin datamodel.ComponentMap)) *mConverterMockGeneratePipelineDataSpec {
	if mmGeneratePipelineDataSpec.mock.inspectFuncGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("Inspect function is already set for ConverterMock.GeneratePipelineDataSpec")
	}

	mmGeneratePipelineDataSpec.mock.inspectFuncGeneratePipelineDataSpec = f

	return mmGeneratePipelineDataSpec
}

// Return sets up results that will be returned by Converter.GeneratePipelineDataSpec
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) Return(dp1 *pb.DataSpecification, err error) *ConverterMock {
	if mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Set")
	}

	if mmGeneratePipelineDataSpec.defaultExpectation == nil {
		mmGeneratePipelineDataSpec.defaultExpectation = &ConverterMockGeneratePipelineDataSpecExpectation{mock: mmGeneratePipelineDataSpec.mock}
	}
	mmGeneratePipelineDataSpec.defaultExpectation.results = &ConverterMockGeneratePipelineDataSpecResults{dp1, err}
	mmGeneratePipelineDataSpec.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGeneratePipelineDataSpec.mock
}

// Set uses given function f to mock the Converter.GeneratePipelineDataSpec method
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) Set(f func(variables map[string]*datamodel.Variable, outputs map[string]*datamodel.Output, compsOrigin datamodel.ComponentMap) (dp1 *pb.DataSpecification, err error)) *ConverterMock {
	if mmGeneratePipelineDataSpec.defaultExpectation != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("Default expectation is already set for the Converter.GeneratePipelineDataSpec method")
	}

	if len(mmGeneratePipelineDataSpec.expectations) > 0 {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("Some expectations are already set for the Converter.GeneratePipelineDataSpec method")
	}

	mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec = f
	mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpecOrigin = minimock.CallerInfo(1)
	return mmGeneratePipelineDataSpec.mock
}

// When sets expectation for the Converter.GeneratePipelineDataSpec which will trigger the result defined by the following
// Then helper
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) When(variables map[string]*datamodel.Variable, outputs map[string]*datamodel.Output, compsOrigin datamodel.ComponentMap) *ConverterMockGeneratePipelineDataSpecExpectation {
	if mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("ConverterMock.GeneratePipelineDataSpec mock is already set by Set")
	}

	expectation := &ConverterMockGeneratePipelineDataSpecExpectation{
		mock:               mmGeneratePipelineDataSpec.mock,
		params:             &ConverterMockGeneratePipelineDataSpecParams{variables, outputs, compsOrigin},
		expectationOrigins: ConverterMockGeneratePipelineDataSpecExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGeneratePipelineDataSpec.expectations = append(mmGeneratePipelineDataSpec.expectations, expectation)
	return expectation
}

// Then sets up Converter.GeneratePipelineDataSpec return parameters for the expectation previously defined by the When method
func (e *ConverterMockGeneratePipelineDataSpecExpectation) Then(dp1 *pb.DataSpecification, err error) *ConverterMock {
	e.results = &ConverterMockGeneratePipelineDataSpecResults{dp1, err}
	return e.mock
}

// Times sets number of times Converter.GeneratePipelineDataSpec should be invoked
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) Times(n uint64) *mConverterMockGeneratePipelineDataSpec {
	if n == 0 {
		mmGeneratePipelineDataSpec.mock.t.Fatalf("Times of ConverterMock.GeneratePipelineDataSpec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGeneratePipelineDataSpec.expectedInvocations, n)
	mmGeneratePipelineDataSpec.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGeneratePipelineDataSpec
}

func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) invocationsDone() bool {
	if len(mmGeneratePipelineDataSpec.expectations) == 0 && mmGeneratePipelineDataSpec.defaultExpectation == nil && mmGeneratePipelineDataSpec.mock.funcGeneratePipelineDataSpec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGeneratePipelineDataSpec.mock.afterGeneratePipelineDataSpecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGeneratePipelineDataSpec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GeneratePipelineDataSpec implements mm_service.Converter
func (mmGeneratePipelineDataSpec *ConverterMock) GeneratePipelineDataSpec(variables map[string]*datamodel.Variable, outputs map[string]*datamodel.Output, compsOrigin datamodel.ComponentMap) (dp1 *pb.DataSpecification, err error) {
	mm_atomic.AddUint64(&mmGeneratePipelineDataSpec.beforeGeneratePipelineDataSpecCounter, 1)
	defer mm_atomic.AddUint64(&mmGeneratePipelineDataSpec.afterGeneratePipelineDataSpecCounter, 1)

	mmGeneratePipelineDataSpec.t.Helper()

	if mmGeneratePipelineDataSpec.inspectFuncGeneratePipelineDataSpec != nil {
		mmGeneratePipelineDataSpec.inspectFuncGeneratePipelineDataSpec(variables, outputs, compsOrigin)
	}

	mm_params := ConverterMockGeneratePipelineDataSpecParams{variables, outputs, compsOrigin}

	// Record call args
	mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.mutex.Lock()
	mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.callArgs = append(mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.callArgs, &mm_params)
	mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.mutex.Unlock()

	for _, e := range mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.Counter, 1)
		mm_want := mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.params
		mm_want_ptrs := mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockGeneratePipelineDataSpecParams{variables, outputs, compsOrigin}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.variables != nil && !minimock.Equal(*mm_want_ptrs.variables, mm_got.variables) {
				mmGeneratePipelineDataSpec.t.Errorf("ConverterMock.GeneratePipelineDataSpec got unexpected parameter variables, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.expectationOrigins.originVariables, *mm_want_ptrs.variables, mm_got.variables, minimock.Diff(*mm_want_ptrs.variables, mm_got.variables))
			}

			if mm_want_ptrs.outputs != nil && !minimock.Equal(*mm_want_ptrs.outputs, mm_got.outputs) {
				mmGeneratePipelineDataSpec.t.Errorf("ConverterMock.GeneratePipelineDataSpec got unexpected parameter outputs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.expectationOrigins.originOutputs, *mm_want_ptrs.outputs, mm_got.outputs, minimock.Diff(*mm_want_ptrs.outputs, mm_got.outputs))
			}

			if mm_want_ptrs.compsOrigin != nil && !minimock.Equal(*mm_want_ptrs.compsOrigin, mm_got.compsOrigin) {
				mmGeneratePipelineDataSpec.t.Errorf("ConverterMock.GeneratePipelineDataSpec got unexpected parameter compsOrigin, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.expectationOrigins.originCompsOrigin, *mm_want_ptrs.compsOrigin, mm_got.compsOrigin, minimock.Diff(*mm_want_ptrs.compsOrigin, mm_got.compsOrigin))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGeneratePipelineDataSpec.t.Errorf("ConverterMock.GeneratePipelineDataSpec got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGeneratePipelineDataSpec.GeneratePipelineDataSpecMock.defaultExpectation.results
		if mm_results == nil {
			mmGeneratePipelineDataSpec.t.Fatal("No results are set for the ConverterMock.GeneratePipelineDataSpec")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGeneratePipelineDataSpec.funcGeneratePipelineDataSpec != nil {
		return mmGeneratePipelineDataSpec.funcGeneratePipelineDataSpec(variables, outputs, compsOrigin)
	}
	mmGeneratePipelineDataSpec.t.Fatalf("Unexpected call to ConverterMock.GeneratePipelineDataSpec. %v %v %v", variables, outputs, compsOrigin)
	return
}

// GeneratePipelineDataSpecAfterCounter returns a count of finished ConverterMock.GeneratePipelineDataSpec invocations
func (mmGeneratePipelineDataSpec *ConverterMock) GeneratePipelineDataSpecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGeneratePipelineDataSpec.afterGeneratePipelineDataSpecCounter)
}

// GeneratePipelineDataSpecBeforeCounter returns a count of ConverterMock.GeneratePipelineDataSpec invocations
func (mmGeneratePipelineDataSpec *ConverterMock) GeneratePipelineDataSpecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGeneratePipelineDataSpec.beforeGeneratePipelineDataSpecCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.GeneratePipelineDataSpec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGeneratePipelineDataSpec *mConverterMockGeneratePipelineDataSpec) Calls() []*ConverterMockGeneratePipelineDataSpecParams {
	mmGeneratePipelineDataSpec.mutex.RLock()

	argCopy := make([]*ConverterMockGeneratePipelineDataSpecParams, len(mmGeneratePipelineDataSpec.callArgs))
	copy(argCopy, mmGeneratePipelineDataSpec.callArgs)

	mmGeneratePipelineDataSpec.mutex.RUnlock()

	return argCopy
}

// MinimockGeneratePipelineDataSpecDone returns true if the count of the GeneratePipelineDataSpec invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockGeneratePipelineDataSpecDone() bool {
	if m.GeneratePipelineDataSpecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GeneratePipelineDataSpecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GeneratePipelineDataSpecMock.invocationsDone()
}

// MinimockGeneratePipelineDataSpecInspect logs each unmet expectation
func (m *ConverterMock) MinimockGeneratePipelineDataSpecInspect() {
	for _, e := range m.GeneratePipelineDataSpecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.GeneratePipelineDataSpec at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGeneratePipelineDataSpecCounter := mm_atomic.LoadUint64(&m.afterGeneratePipelineDataSpecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GeneratePipelineDataSpecMock.defaultExpectation != nil && afterGeneratePipelineDataSpecCounter < 1 {
		if m.GeneratePipelineDataSpecMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.GeneratePipelineDataSpec at\n%s", m.GeneratePipelineDataSpecMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.GeneratePipelineDataSpec at\n%s with params: %#v", m.GeneratePipelineDataSpecMock.defaultExpectation.expectationOrigins.origin, *m.GeneratePipelineDataSpecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGeneratePipelineDataSpec != nil && afterGeneratePipelineDataSpecCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.GeneratePipelineDataSpec at\n%s", m.funcGeneratePipelineDataSpecOrigin)
	}

	if !m.GeneratePipelineDataSpecMock.invocationsDone() && afterGeneratePipelineDataSpecCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.GeneratePipelineDataSpec at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GeneratePipelineDataSpecMock.expectedInvocations), m.GeneratePipelineDataSpecMock.expectedInvocationsOrigin, afterGeneratePipelineDataSpecCounter)
	}
}

type mConverterMockIncludeDetailInRecipe struct {
	optional           bool
	mock               *ConverterMock
	defaultExpectation *ConverterMockIncludeDetailInRecipeExpectation
	expectations       []*ConverterMockIncludeDetailInRecipeExpectation

	callArgs []*ConverterMockIncludeDetailInRecipeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConverterMockIncludeDetailInRecipeExpectation specifies expectation struct of the Converter.IncludeDetailInRecipe
type ConverterMockIncludeDetailInRecipeExpectation struct {
	mock               *ConverterMock
	params             *ConverterMockIncludeDetailInRecipeParams
	paramPtrs          *ConverterMockIncludeDetailInRecipeParamPtrs
	expectationOrigins ConverterMockIncludeDetailInRecipeExpectationOrigins
	results            *ConverterMockIncludeDetailInRecipeResults
	returnOrigin       string
	Counter            uint64
}

// ConverterMockIncludeDetailInRecipeParams contains parameters of the Converter.IncludeDetailInRecipe
type ConverterMockIncludeDetailInRecipeParams struct {
	ctx            context.Context
	ownerPermalink string
	recipe         *datamodel.Recipe
	useDynamicDef  bool
}

// ConverterMockIncludeDetailInRecipeParamPtrs contains pointers to parameters of the Converter.IncludeDetailInRecipe
type ConverterMockIncludeDetailInRecipeParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	recipe         **datamodel.Recipe
	useDynamicDef  *bool
}

// ConverterMockIncludeDetailInRecipeResults contains results of the Converter.IncludeDetailInRecipe
type ConverterMockIncludeDetailInRecipeResults struct {
	err error
}

// ConverterMockIncludeDetailInRecipeOrigins contains origins of expectations of the Converter.IncludeDetailInRecipe
type ConverterMockIncludeDetailInRecipeExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originRecipe         string
	originUseDynamicDef  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) Optional() *mConverterMockIncludeDetailInRecipe {
	mmIncludeDetailInRecipe.optional = true
	return mmIncludeDetailInRecipe
}

// Expect sets up expected params for Converter.IncludeDetailInRecipe
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) Expect(ctx context.Context, ownerPermalink string, recipe *datamodel.Recipe, useDynamicDef bool) *mConverterMockIncludeDetailInRecipe {
	if mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Set")
	}

	if mmIncludeDetailInRecipe.defaultExpectation == nil {
		mmIncludeDetailInRecipe.defaultExpectation = &ConverterMockIncludeDetailInRecipeExpectation{}
	}

	if mmIncludeDetailInRecipe.defaultExpectation.paramPtrs != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by ExpectParams functions")
	}

	mmIncludeDetailInRecipe.defaultExpectation.params = &ConverterMockIncludeDetailInRecipeParams{ctx, ownerPermalink, recipe, useDynamicDef}
	mmIncludeDetailInRecipe.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIncludeDetailInRecipe.expectations {
		if minimock.Equal(e.params, mmIncludeDetailInRecipe.defaultExpectation.params) {
			mmIncludeDetailInRecipe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIncludeDetailInRecipe.defaultExpectation.params)
		}
	}

	return mmIncludeDetailInRecipe
}

// ExpectCtxParam1 sets up expected param ctx for Converter.IncludeDetailInRecipe
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) ExpectCtxParam1(ctx context.Context) *mConverterMockIncludeDetailInRecipe {
	if mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Set")
	}

	if mmIncludeDetailInRecipe.defaultExpectation == nil {
		mmIncludeDetailInRecipe.defaultExpectation = &ConverterMockIncludeDetailInRecipeExpectation{}
	}

	if mmIncludeDetailInRecipe.defaultExpectation.params != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Expect")
	}

	if mmIncludeDetailInRecipe.defaultExpectation.paramPtrs == nil {
		mmIncludeDetailInRecipe.defaultExpectation.paramPtrs = &ConverterMockIncludeDetailInRecipeParamPtrs{}
	}
	mmIncludeDetailInRecipe.defaultExpectation.paramPtrs.ctx = &ctx
	mmIncludeDetailInRecipe.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIncludeDetailInRecipe
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Converter.IncludeDetailInRecipe
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) ExpectOwnerPermalinkParam2(ownerPermalink string) *mConverterMockIncludeDetailInRecipe {
	if mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Set")
	}

	if mmIncludeDetailInRecipe.defaultExpectation == nil {
		mmIncludeDetailInRecipe.defaultExpectation = &ConverterMockIncludeDetailInRecipeExpectation{}
	}

	if mmIncludeDetailInRecipe.defaultExpectation.params != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Expect")
	}

	if mmIncludeDetailInRecipe.defaultExpectation.paramPtrs == nil {
		mmIncludeDetailInRecipe.defaultExpectation.paramPtrs = &ConverterMockIncludeDetailInRecipeParamPtrs{}
	}
	mmIncludeDetailInRecipe.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmIncludeDetailInRecipe.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmIncludeDetailInRecipe
}

// ExpectRecipeParam3 sets up expected param recipe for Converter.IncludeDetailInRecipe
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) ExpectRecipeParam3(recipe *datamodel.Recipe) *mConverterMockIncludeDetailInRecipe {
	if mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Set")
	}

	if mmIncludeDetailInRecipe.defaultExpectation == nil {
		mmIncludeDetailInRecipe.defaultExpectation = &ConverterMockIncludeDetailInRecipeExpectation{}
	}

	if mmIncludeDetailInRecipe.defaultExpectation.params != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Expect")
	}

	if mmIncludeDetailInRecipe.defaultExpectation.paramPtrs == nil {
		mmIncludeDetailInRecipe.defaultExpectation.paramPtrs = &ConverterMockIncludeDetailInRecipeParamPtrs{}
	}
	mmIncludeDetailInRecipe.defaultExpectation.paramPtrs.recipe = &recipe
	mmIncludeDetailInRecipe.defaultExpectation.expectationOrigins.originRecipe = minimock.CallerInfo(1)

	return mmIncludeDetailInRecipe
}

// ExpectUseDynamicDefParam4 sets up expected param useDynamicDef for Converter.IncludeDetailInRecipe
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) ExpectUseDynamicDefParam4(useDynamicDef bool) *mConverterMockIncludeDetailInRecipe {
	if mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Set")
	}

	if mmIncludeDetailInRecipe.defaultExpectation == nil {
		mmIncludeDetailInRecipe.defaultExpectation = &ConverterMockIncludeDetailInRecipeExpectation{}
	}

	if mmIncludeDetailInRecipe.defaultExpectation.params != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Expect")
	}

	if mmIncludeDetailInRecipe.defaultExpectation.paramPtrs == nil {
		mmIncludeDetailInRecipe.defaultExpectation.paramPtrs = &ConverterMockIncludeDetailInRecipeParamPtrs{}
	}
	mmIncludeDetailInRecipe.defaultExpectation.paramPtrs.useDynamicDef = &useDynamicDef
	mmIncludeDetailInRecipe.defaultExpectation.expectationOrigins.originUseDynamicDef = minimock.CallerInfo(1)

	return mmIncludeDetailInRecipe
}

// Inspect accepts an inspector function that has same arguments as the Converter.IncludeDetailInRecipe
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) Inspect(f func(ctx context.Context, ownerPermalink string, recipe *datamodel.Recipe, useDynamicDef bool)) *mConverterMockIncludeDetailInRecipe {
	if mmIncludeDetailInRecipe.mock.inspectFuncIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("Inspect function is already set for ConverterMock.IncludeDetailInRecipe")
	}

	mmIncludeDetailInRecipe.mock.inspectFuncIncludeDetailInRecipe = f

	return mmIncludeDetailInRecipe
}

// Return sets up results that will be returned by Converter.IncludeDetailInRecipe
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) Return(err error) *ConverterMock {
	if mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Set")
	}

	if mmIncludeDetailInRecipe.defaultExpectation == nil {
		mmIncludeDetailInRecipe.defaultExpectation = &ConverterMockIncludeDetailInRecipeExpectation{mock: mmIncludeDetailInRecipe.mock}
	}
	mmIncludeDetailInRecipe.defaultExpectation.results = &ConverterMockIncludeDetailInRecipeResults{err}
	mmIncludeDetailInRecipe.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIncludeDetailInRecipe.mock
}

// Set uses given function f to mock the Converter.IncludeDetailInRecipe method
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) Set(f func(ctx context.Context, ownerPermalink string, recipe *datamodel.Recipe, useDynamicDef bool) (err error)) *ConverterMock {
	if mmIncludeDetailInRecipe.defaultExpectation != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("Default expectation is already set for the Converter.IncludeDetailInRecipe method")
	}

	if len(mmIncludeDetailInRecipe.expectations) > 0 {
		mmIncludeDetailInRecipe.mock.t.Fatalf("Some expectations are already set for the Converter.IncludeDetailInRecipe method")
	}

	mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe = f
	mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipeOrigin = minimock.CallerInfo(1)
	return mmIncludeDetailInRecipe.mock
}

// When sets expectation for the Converter.IncludeDetailInRecipe which will trigger the result defined by the following
// Then helper
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) When(ctx context.Context, ownerPermalink string, recipe *datamodel.Recipe, useDynamicDef bool) *ConverterMockIncludeDetailInRecipeExpectation {
	if mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.mock.t.Fatalf("ConverterMock.IncludeDetailInRecipe mock is already set by Set")
	}

	expectation := &ConverterMockIncludeDetailInRecipeExpectation{
		mock:               mmIncludeDetailInRecipe.mock,
		params:             &ConverterMockIncludeDetailInRecipeParams{ctx, ownerPermalink, recipe, useDynamicDef},
		expectationOrigins: ConverterMockIncludeDetailInRecipeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIncludeDetailInRecipe.expectations = append(mmIncludeDetailInRecipe.expectations, expectation)
	return expectation
}

// Then sets up Converter.IncludeDetailInRecipe return parameters for the expectation previously defined by the When method
func (e *ConverterMockIncludeDetailInRecipeExpectation) Then(err error) *ConverterMock {
	e.results = &ConverterMockIncludeDetailInRecipeResults{err}
	return e.mock
}

// Times sets number of times Converter.IncludeDetailInRecipe should be invoked
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) Times(n uint64) *mConverterMockIncludeDetailInRecipe {
	if n == 0 {
		mmIncludeDetailInRecipe.mock.t.Fatalf("Times of ConverterMock.IncludeDetailInRecipe mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIncludeDetailInRecipe.expectedInvocations, n)
	mmIncludeDetailInRecipe.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIncludeDetailInRecipe
}

func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) invocationsDone() bool {
	if len(mmIncludeDetailInRecipe.expectations) == 0 && mmIncludeDetailInRecipe.defaultExpectation == nil && mmIncludeDetailInRecipe.mock.funcIncludeDetailInRecipe == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIncludeDetailInRecipe.mock.afterIncludeDetailInRecipeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIncludeDetailInRecipe.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IncludeDetailInRecipe implements mm_service.Converter
func (mmIncludeDetailInRecipe *ConverterMock) IncludeDetailInRecipe(ctx context.Context, ownerPermalink string, recipe *datamodel.Recipe, useDynamicDef bool) (err error) {
	mm_atomic.AddUint64(&mmIncludeDetailInRecipe.beforeIncludeDetailInRecipeCounter, 1)
	defer mm_atomic.AddUint64(&mmIncludeDetailInRecipe.afterIncludeDetailInRecipeCounter, 1)

	mmIncludeDetailInRecipe.t.Helper()

	if mmIncludeDetailInRecipe.inspectFuncIncludeDetailInRecipe != nil {
		mmIncludeDetailInRecipe.inspectFuncIncludeDetailInRecipe(ctx, ownerPermalink, recipe, useDynamicDef)
	}

	mm_params := ConverterMockIncludeDetailInRecipeParams{ctx, ownerPermalink, recipe, useDynamicDef}

	// Record call args
	mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.mutex.Lock()
	mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.callArgs = append(mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.callArgs, &mm_params)
	mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.mutex.Unlock()

	for _, e := range mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.Counter, 1)
		mm_want := mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.params
		mm_want_ptrs := mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.paramPtrs

		mm_got := ConverterMockIncludeDetailInRecipeParams{ctx, ownerPermalink, recipe, useDynamicDef}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIncludeDetailInRecipe.t.Errorf("ConverterMock.IncludeDetailInRecipe got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmIncludeDetailInRecipe.t.Errorf("ConverterMock.IncludeDetailInRecipe got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.recipe != nil && !minimock.Equal(*mm_want_ptrs.recipe, mm_got.recipe) {
				mmIncludeDetailInRecipe.t.Errorf("ConverterMock.IncludeDetailInRecipe got unexpected parameter recipe, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.expectationOrigins.originRecipe, *mm_want_ptrs.recipe, mm_got.recipe, minimock.Diff(*mm_want_ptrs.recipe, mm_got.recipe))
			}

			if mm_want_ptrs.useDynamicDef != nil && !minimock.Equal(*mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef) {
				mmIncludeDetailInRecipe.t.Errorf("ConverterMock.IncludeDetailInRecipe got unexpected parameter useDynamicDef, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.expectationOrigins.originUseDynamicDef, *mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef, minimock.Diff(*mm_want_ptrs.useDynamicDef, mm_got.useDynamicDef))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIncludeDetailInRecipe.t.Errorf("ConverterMock.IncludeDetailInRecipe got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIncludeDetailInRecipe.IncludeDetailInRecipeMock.defaultExpectation.results
		if mm_results == nil {
			mmIncludeDetailInRecipe.t.Fatal("No results are set for the ConverterMock.IncludeDetailInRecipe")
		}
		return (*mm_results).err
	}
	if mmIncludeDetailInRecipe.funcIncludeDetailInRecipe != nil {
		return mmIncludeDetailInRecipe.funcIncludeDetailInRecipe(ctx, ownerPermalink, recipe, useDynamicDef)
	}
	mmIncludeDetailInRecipe.t.Fatalf("Unexpected call to ConverterMock.IncludeDetailInRecipe. %v %v %v %v", ctx, ownerPermalink, recipe, useDynamicDef)
	return
}

// IncludeDetailInRecipeAfterCounter returns a count of finished ConverterMock.IncludeDetailInRecipe invocations
func (mmIncludeDetailInRecipe *ConverterMock) IncludeDetailInRecipeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncludeDetailInRecipe.afterIncludeDetailInRecipeCounter)
}

// IncludeDetailInRecipeBeforeCounter returns a count of ConverterMock.IncludeDetailInRecipe invocations
func (mmIncludeDetailInRecipe *ConverterMock) IncludeDetailInRecipeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIncludeDetailInRecipe.beforeIncludeDetailInRecipeCounter)
}

// Calls returns a list of arguments used in each call to ConverterMock.IncludeDetailInRecipe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIncludeDetailInRecipe *mConverterMockIncludeDetailInRecipe) Calls() []*ConverterMockIncludeDetailInRecipeParams {
	mmIncludeDetailInRecipe.mutex.RLock()

	argCopy := make([]*ConverterMockIncludeDetailInRecipeParams, len(mmIncludeDetailInRecipe.callArgs))
	copy(argCopy, mmIncludeDetailInRecipe.callArgs)

	mmIncludeDetailInRecipe.mutex.RUnlock()

	return argCopy
}

// MinimockIncludeDetailInRecipeDone returns true if the count of the IncludeDetailInRecipe invocations corresponds
// the number of defined expectations
func (m *ConverterMock) MinimockIncludeDetailInRecipeDone() bool {
	if m.IncludeDetailInRecipeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IncludeDetailInRecipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IncludeDetailInRecipeMock.invocationsDone()
}

// MinimockIncludeDetailInRecipeInspect logs each unmet expectation
func (m *ConverterMock) MinimockIncludeDetailInRecipeInspect() {
	for _, e := range m.IncludeDetailInRecipeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConverterMock.IncludeDetailInRecipe at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIncludeDetailInRecipeCounter := mm_atomic.LoadUint64(&m.afterIncludeDetailInRecipeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IncludeDetailInRecipeMock.defaultExpectation != nil && afterIncludeDetailInRecipeCounter < 1 {
		if m.IncludeDetailInRecipeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConverterMock.IncludeDetailInRecipe at\n%s", m.IncludeDetailInRecipeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConverterMock.IncludeDetailInRecipe at\n%s with params: %#v", m.IncludeDetailInRecipeMock.defaultExpectation.expectationOrigins.origin, *m.IncludeDetailInRecipeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIncludeDetailInRecipe != nil && afterIncludeDetailInRecipeCounter < 1 {
		m.t.Errorf("Expected call to ConverterMock.IncludeDetailInRecipe at\n%s", m.funcIncludeDetailInRecipeOrigin)
	}

	if !m.IncludeDetailInRecipeMock.invocationsDone() && afterIncludeDetailInRecipeCounter > 0 {
		m.t.Errorf("Expected %d calls to ConverterMock.IncludeDetailInRecipe at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IncludeDetailInRecipeMock.expectedInvocations), m.IncludeDetailInRecipeMock.expectedInvocationsOrigin, afterIncludeDetailInRecipeCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConverterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConvertPipelineReleaseToDBInspect()

			m.MinimockConvertPipelineReleaseToPBInspect()

			m.MinimockConvertPipelineReleasesToPBInspect()

			m.MinimockConvertPipelineToDBInspect()

			m.MinimockConvertPipelineToPBInspect()

			m.MinimockConvertPipelinesToPBInspect()

			m.MinimockConvertSecretToDBInspect()

			m.MinimockConvertSecretToPBInspect()

			m.MinimockConvertSecretsToPBInspect()

			m.MinimockGeneratePipelineDataSpecInspect()

			m.MinimockIncludeDetailInRecipeInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConverterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConverterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConvertPipelineReleaseToDBDone() &&
		m.MinimockConvertPipelineReleaseToPBDone() &&
		m.MinimockConvertPipelineReleasesToPBDone() &&
		m.MinimockConvertPipelineToDBDone() &&
		m.MinimockConvertPipelineToPBDone() &&
		m.MinimockConvertPipelinesToPBDone() &&
		m.MinimockConvertSecretToDBDone() &&
		m.MinimockConvertSecretToPBDone() &&
		m.MinimockConvertSecretsToPBDone() &&
		m.MinimockGeneratePipelineDataSpecDone() &&
		m.MinimockIncludeDetailInRecipeDone()
}
